/**
 * \file
 * \brief Generated by ifgen (2.6.3).
 */
#pragma once

#include "../enums/ROSC_CTRL_ENABLE.h"
#include "../enums/ROSC_CTRL_FREQ_RANGE.h"
#include "../enums/ROSC_DIV_DIV.h"
#include "../enums/ROSC_FREQA_PASSWD.h"
#include "../enums/ROSC_FREQB_PASSWD.h"
#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] rosc
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;       /*!< rosc's identifier. */
    static constexpr std::size_t size = 36; /*!< rosc's size in bytes. */

    /* Fields. */
    uint32_t CTRL;                 /*!< (read-write) Ring Oscillator control */
    uint32_t FREQA;                /*!< (read-write) The FREQA & FREQB registers control the frequency by controlling the drive strength of each stage\n
                The drive strength has 4 levels determined by the number of bits set\n
                Increasing the number of bits set increases the drive strength and increases the oscillation frequency\n
                0 bits set is the default drive strength\n
                1 bit set doubles the drive strength\n
                2 bits set triples drive strength\n
                3 bits set quadruples drive strength */
    uint32_t FREQB;                /*!< (read-write) For a detailed description see freqa register */
    uint32_t DORMANT;              /*!< (read-write) Ring Oscillator pause control\n
                This is used to save power by pausing the ROSC\n
                On power-up this field is initialised to WAKE\n
                An invalid write will also select WAKE\n
                Warning: setup the irq before selecting dormant mode */
    uint32_t DIV;                  /*!< (read-write) Controls the output divider */
    uint32_t PHASE;                /*!< (read-write) Controls the phase shifted output */
    uint32_t STATUS;               /*!< (read-write) Ring Oscillator Status */
    const uint32_t RANDOMBIT = {}; /*!< (read-only) This just reads the state of the oscillator output so randomness is compromised if the ring oscillator is stopped or run at a harmonic of the bus frequency */
    uint32_t COUNT;                /*!< (read-write) A down counter running at the ROSC frequency which counts to zero and stops.\n
                To start the counter write a non-zero value.\n
                Can be used for short software pauses when setting up time sensitive hardware. */

    /* Methods. */

    /**
     * Get CTRL's FREQ_RANGE field.
     */
    ROSC_CTRL_FREQ_RANGE get_CTRL_FREQ_RANGE()
    {
        return ROSC_CTRL_FREQ_RANGE((CTRL >> 0u) & 0b111111111111u);
    }

    /**
     * Set CTRL's FREQ_RANGE field.
     */
    inline void set_CTRL_FREQ_RANGE(ROSC_CTRL_FREQ_RANGE value)
    {
        uint32_t curr = CTRL;

        curr &= ~(0b111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111111111u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL's ENABLE field.
     */
    ROSC_CTRL_ENABLE get_CTRL_ENABLE()
    {
        return ROSC_CTRL_ENABLE((CTRL >> 12u) & 0b111111111111u);
    }

    /**
     * Set CTRL's ENABLE field.
     */
    inline void set_CTRL_ENABLE(ROSC_CTRL_ENABLE value)
    {
        uint32_t curr = CTRL;

        curr &= ~(0b111111111111u << 12u);
        curr |= (std::to_underlying(value) & 0b111111111111u) << 12u;

        CTRL = curr;
    }

    /**
     * Get FREQA's DS0 field.
     */
    uint8_t get_FREQA_DS0()
    {
        return (FREQA >> 0u) & 0b111u;
    }

    /**
     * Set FREQA's DS0 field.
     */
    inline void set_FREQA_DS0(uint8_t value)
    {
        uint32_t curr = FREQA;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        FREQA = curr;
    }

    /**
     * Get FREQA's DS1 field.
     */
    uint8_t get_FREQA_DS1()
    {
        return (FREQA >> 4u) & 0b111u;
    }

    /**
     * Set FREQA's DS1 field.
     */
    inline void set_FREQA_DS1(uint8_t value)
    {
        uint32_t curr = FREQA;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        FREQA = curr;
    }

    /**
     * Get FREQA's DS2 field.
     */
    uint8_t get_FREQA_DS2()
    {
        return (FREQA >> 8u) & 0b111u;
    }

    /**
     * Set FREQA's DS2 field.
     */
    inline void set_FREQA_DS2(uint8_t value)
    {
        uint32_t curr = FREQA;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FREQA = curr;
    }

    /**
     * Get FREQA's DS3 field.
     */
    uint8_t get_FREQA_DS3()
    {
        return (FREQA >> 12u) & 0b111u;
    }

    /**
     * Set FREQA's DS3 field.
     */
    inline void set_FREQA_DS3(uint8_t value)
    {
        uint32_t curr = FREQA;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        FREQA = curr;
    }

    /**
     * Get FREQA's PASSWD field.
     */
    ROSC_FREQA_PASSWD get_FREQA_PASSWD()
    {
        return ROSC_FREQA_PASSWD((FREQA >> 16u) & 0b1111111111111111u);
    }

    /**
     * Set FREQA's PASSWD field.
     */
    inline void set_FREQA_PASSWD(ROSC_FREQA_PASSWD value)
    {
        uint32_t curr = FREQA;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        FREQA = curr;
    }

    /**
     * Get FREQB's DS4 field.
     */
    uint8_t get_FREQB_DS4()
    {
        return (FREQB >> 0u) & 0b111u;
    }

    /**
     * Set FREQB's DS4 field.
     */
    inline void set_FREQB_DS4(uint8_t value)
    {
        uint32_t curr = FREQB;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        FREQB = curr;
    }

    /**
     * Get FREQB's DS5 field.
     */
    uint8_t get_FREQB_DS5()
    {
        return (FREQB >> 4u) & 0b111u;
    }

    /**
     * Set FREQB's DS5 field.
     */
    inline void set_FREQB_DS5(uint8_t value)
    {
        uint32_t curr = FREQB;

        curr &= ~(0b111u << 4u);
        curr |= (value & 0b111u) << 4u;

        FREQB = curr;
    }

    /**
     * Get FREQB's DS6 field.
     */
    uint8_t get_FREQB_DS6()
    {
        return (FREQB >> 8u) & 0b111u;
    }

    /**
     * Set FREQB's DS6 field.
     */
    inline void set_FREQB_DS6(uint8_t value)
    {
        uint32_t curr = FREQB;

        curr &= ~(0b111u << 8u);
        curr |= (value & 0b111u) << 8u;

        FREQB = curr;
    }

    /**
     * Get FREQB's DS7 field.
     */
    uint8_t get_FREQB_DS7()
    {
        return (FREQB >> 12u) & 0b111u;
    }

    /**
     * Set FREQB's DS7 field.
     */
    inline void set_FREQB_DS7(uint8_t value)
    {
        uint32_t curr = FREQB;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        FREQB = curr;
    }

    /**
     * Get FREQB's PASSWD field.
     */
    ROSC_FREQB_PASSWD get_FREQB_PASSWD()
    {
        return ROSC_FREQB_PASSWD((FREQB >> 16u) & 0b1111111111111111u);
    }

    /**
     * Set FREQB's PASSWD field.
     */
    inline void set_FREQB_PASSWD(ROSC_FREQB_PASSWD value)
    {
        uint32_t curr = FREQB;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (std::to_underlying(value) & 0b1111111111111111u) << 16u;

        FREQB = curr;
    }

    /**
     * Get DIV's DIV field.
     */
    ROSC_DIV_DIV get_DIV_DIV()
    {
        return ROSC_DIV_DIV((DIV >> 0u) & 0b111111111111u);
    }

    /**
     * Set DIV's DIV field.
     */
    inline void set_DIV_DIV(ROSC_DIV_DIV value)
    {
        uint32_t curr = DIV;

        curr &= ~(0b111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111111111u) << 0u;

        DIV = curr;
    }

    /**
     * Get PHASE's SHIFT field.
     */
    uint8_t get_PHASE_SHIFT()
    {
        return (PHASE >> 0u) & 0b11u;
    }

    /**
     * Set PHASE's SHIFT field.
     */
    inline void set_PHASE_SHIFT(uint8_t value)
    {
        uint32_t curr = PHASE;

        curr &= ~(0b11u << 0u);
        curr |= (value & 0b11u) << 0u;

        PHASE = curr;
    }

    /**
     * Get PHASE's FLIP bit.
     */
    bool get_PHASE_FLIP()
    {
        return PHASE & (1u << 2u);
    }

    /**
     * Set PHASE's FLIP bit.
     */
    inline void set_PHASE_FLIP()
    {
        PHASE |= 1u << 2u;
    }

    /**
     * Clear PHASE's FLIP bit.
     */
    inline void clear_PHASE_FLIP()
    {
        PHASE &= ~(1u << 2u);
    }

    /**
     * Toggle PHASE's FLIP bit.
     */
    inline void toggle_PHASE_FLIP()
    {
        PHASE ^= 1u << 2u;
    }

    /**
     * Get PHASE's ENABLE bit.
     */
    bool get_PHASE_ENABLE()
    {
        return PHASE & (1u << 3u);
    }

    /**
     * Set PHASE's ENABLE bit.
     */
    inline void set_PHASE_ENABLE()
    {
        PHASE |= 1u << 3u;
    }

    /**
     * Clear PHASE's ENABLE bit.
     */
    inline void clear_PHASE_ENABLE()
    {
        PHASE &= ~(1u << 3u);
    }

    /**
     * Toggle PHASE's ENABLE bit.
     */
    inline void toggle_PHASE_ENABLE()
    {
        PHASE ^= 1u << 3u;
    }

    /**
     * Get PHASE's PASSWD field.
     */
    uint8_t get_PHASE_PASSWD()
    {
        return (PHASE >> 4u) & 0b11111111u;
    }

    /**
     * Set PHASE's PASSWD field.
     */
    inline void set_PHASE_PASSWD(uint8_t value)
    {
        uint32_t curr = PHASE;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        PHASE = curr;
    }

    /**
     * Get STATUS's ENABLED bit.
     */
    bool get_STATUS_ENABLED()
    {
        return STATUS & (1u << 12u);
    }

    /**
     * Get STATUS's DIV_RUNNING bit.
     */
    bool get_STATUS_DIV_RUNNING()
    {
        return STATUS & (1u << 16u);
    }

    /**
     * Get STATUS's BADWRITE bit.
     */
    bool get_STATUS_BADWRITE()
    {
        return STATUS & (1u << 24u);
    }

    /**
     * Set STATUS's BADWRITE bit.
     */
    inline void set_STATUS_BADWRITE()
    {
        STATUS |= 1u << 24u;
    }

    /**
     * Clear STATUS's BADWRITE bit.
     */
    inline void clear_STATUS_BADWRITE()
    {
        STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle STATUS's BADWRITE bit.
     */
    inline void toggle_STATUS_BADWRITE()
    {
        STATUS ^= 1u << 24u;
    }

    /**
     * Get STATUS's STABLE bit.
     */
    bool get_STATUS_STABLE()
    {
        return STATUS & (1u << 31u);
    }

    /**
     * Get RANDOMBIT's RANDOMBIT bit.
     */
    bool get_RANDOMBIT_RANDOMBIT()
    {
        return RANDOMBIT & (1u << 0u);
    }

    /**
     * Get COUNT's COUNT field.
     */
    uint8_t get_COUNT_COUNT()
    {
        return (COUNT >> 0u) & 0b11111111u;
    }

    /**
     * Set COUNT's COUNT field.
     */
    inline void set_COUNT_COUNT(uint8_t value)
    {
        uint32_t curr = COUNT;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        COUNT = curr;
    }
};

static_assert(sizeof(rosc) == rosc::size);

static volatile rosc *const ROSC = reinterpret_cast<rosc *>(0x40060000);

}; // namespace RP2040
