/**
 * \file
 * \brief Generated by ifgen (3.1.1).
 */
#pragma once

#include "../enums/PIO0_SM0_EXECCTRL_STATUS_SEL.h"
#include "../enums/PIO0_SM1_EXECCTRL_STATUS_SEL.h"
#include "../enums/PIO0_SM2_EXECCTRL_STATUS_SEL.h"
#include "../enums/PIO0_SM3_EXECCTRL_STATUS_SEL.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * Programmable IO block
 */
struct [[gnu::packed]] pio0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 324; /*!< pio0's size in bytes. */

    /* Fields. */
    uint32_t CTRL;              /*!< (read-write) PIO control register */
    const uint32_t FSTAT = {};  /*!< (read-only) FIFO status register */
    uint32_t FDEBUG;            /*!< (read-write) FIFO debug register */
    const uint32_t FLEVEL = {}; /*!< (read-only) FIFO levels */
    uint32_t TXF0; /*!< (read-write) Direct write access to the TX FIFO for
                      this state machine. Each write pushes one word to the
                      FIFO. Attempting to write to a full FIFO has no effect on
                      the FIFO state or contents, and sets the sticky
                      FDEBUG_TXOVER error flag for this FIFO. */
    uint32_t TXF1; /*!< (read-write) Direct write access to the TX FIFO for
                      this state machine. Each write pushes one word to the
                      FIFO. Attempting to write to a full FIFO has no effect on
                      the FIFO state or contents, and sets the sticky
                      FDEBUG_TXOVER error flag for this FIFO. */
    uint32_t TXF2; /*!< (read-write) Direct write access to the TX FIFO for
                      this state machine. Each write pushes one word to the
                      FIFO. Attempting to write to a full FIFO has no effect on
                      the FIFO state or contents, and sets the sticky
                      FDEBUG_TXOVER error flag for this FIFO. */
    uint32_t TXF3; /*!< (read-write) Direct write access to the TX FIFO for
                      this state machine. Each write pushes one word to the
                      FIFO. Attempting to write to a full FIFO has no effect on
                      the FIFO state or contents, and sets the sticky
                      FDEBUG_TXOVER error flag for this FIFO. */
    uint32_t RXF0; /*!< (read-write) Direct read access to the RX FIFO for this
                      state machine. Each read pops one word from the FIFO.
                      Attempting to read from an empty FIFO has no effect on
                      the FIFO state, and sets the sticky FDEBUG_RXUNDER error
                      flag for this FIFO. The data returned to the system on a
                      read from an empty FIFO is undefined. */
    uint32_t RXF1; /*!< (read-write) Direct read access to the RX FIFO for this
                      state machine. Each read pops one word from the FIFO.
                      Attempting to read from an empty FIFO has no effect on
                      the FIFO state, and sets the sticky FDEBUG_RXUNDER error
                      flag for this FIFO. The data returned to the system on a
                      read from an empty FIFO is undefined. */
    uint32_t RXF2; /*!< (read-write) Direct read access to the RX FIFO for this
                      state machine. Each read pops one word from the FIFO.
                      Attempting to read from an empty FIFO has no effect on
                      the FIFO state, and sets the sticky FDEBUG_RXUNDER error
                      flag for this FIFO. The data returned to the system on a
                      read from an empty FIFO is undefined. */
    uint32_t RXF3; /*!< (read-write) Direct read access to the RX FIFO for this
                      state machine. Each read pops one word from the FIFO.
                      Attempting to read from an empty FIFO has no effect on
                      the FIFO state, and sets the sticky FDEBUG_RXUNDER error
                      flag for this FIFO. The data returned to the system on a
                      read from an empty FIFO is undefined. */
    uint32_t IRQ;  /*!< (read-write) State machine IRQ flags register. Write 1
 to clear. There are 8 state machine IRQ flags, which can be set, cleared, and
 waited on by the state machines. There's no fixed association between flags and
 state machines -- any state machine can use any flag.\n\n  Any of the 8 flags
 can be used for timing synchronisation between state machines, using IRQ and
 WAIT instructions. The lower four of these flags are also routed out to
 system-level interrupt requests, alongside FIFO status interrupts -- see e.g.
 IRQ0_INTE. */
    uint32_t IRQ_FORCE; /*!< (write-only) Writing a 1 to each of these bits
                           will forcibly assert the corresponding IRQ. Note
                           this is different to the INTF register: writing here
                           affects PIO internal state. INTF just asserts the
                           processor-facing IRQ signal for testing ISRs, and is
                           not visible to the state machines. */
    uint32_t INPUT_SYNC_BYPASS; /*!< (read-write) There is a 2-flipflop
           synchronizer on each GPIO input, which protects PIO logic from
           metastabilities. This increases input delay, and for fast
           synchronous IO (e.g. SPI) these synchronizers may need to be
           bypassed. Each bit in this register corresponds to one GPIO.\n 0 ->
           input is synchronized (default)\n 1 -> synchronizer is bypassed\n If
           in doubt, leave this register as all zeroes. */
    uint32_t DBG_PADOUT; /*!< (read-write) Read to sample the pad output values
                            PIO is currently driving to the GPIOs. On RP2040
                            there are 30 GPIOs, so the two most significant
                            bits are hardwired to 0. */
    uint32_t DBG_PADOE; /*!< (read-write) Read to sample the pad output enables
                           (direction) PIO is currently driving to the GPIOs.
                           On RP2040 there are 30 GPIOs, so the two most
                           significant bits are hardwired to 0. */
    const uint32_t DBG_CFGINFO =
        {}; /*!< (read-only) The PIO hardware has some free parameters that may
vary between chip products.\n These should be provided in the chip datasheet,
but are also exposed here. */
    uint32_t INSTR_MEM0;   /*!< (write-only) Write-only access to instruction
                              memory location 0 */
    uint32_t INSTR_MEM1;   /*!< (write-only) Write-only access to instruction
                              memory location 1 */
    uint32_t INSTR_MEM2;   /*!< (write-only) Write-only access to instruction
                              memory location 2 */
    uint32_t INSTR_MEM3;   /*!< (write-only) Write-only access to instruction
                              memory location 3 */
    uint32_t INSTR_MEM4;   /*!< (write-only) Write-only access to instruction
                              memory location 4 */
    uint32_t INSTR_MEM5;   /*!< (write-only) Write-only access to instruction
                              memory location 5 */
    uint32_t INSTR_MEM6;   /*!< (write-only) Write-only access to instruction
                              memory location 6 */
    uint32_t INSTR_MEM7;   /*!< (write-only) Write-only access to instruction
                              memory location 7 */
    uint32_t INSTR_MEM8;   /*!< (write-only) Write-only access to instruction
                              memory location 8 */
    uint32_t INSTR_MEM9;   /*!< (write-only) Write-only access to instruction
                              memory location 9 */
    uint32_t INSTR_MEM10;  /*!< (write-only) Write-only access to instruction
                              memory location 10 */
    uint32_t INSTR_MEM11;  /*!< (write-only) Write-only access to instruction
                              memory location 11 */
    uint32_t INSTR_MEM12;  /*!< (write-only) Write-only access to instruction
                              memory location 12 */
    uint32_t INSTR_MEM13;  /*!< (write-only) Write-only access to instruction
                              memory location 13 */
    uint32_t INSTR_MEM14;  /*!< (write-only) Write-only access to instruction
                              memory location 14 */
    uint32_t INSTR_MEM15;  /*!< (write-only) Write-only access to instruction
                              memory location 15 */
    uint32_t INSTR_MEM16;  /*!< (write-only) Write-only access to instruction
                              memory location 16 */
    uint32_t INSTR_MEM17;  /*!< (write-only) Write-only access to instruction
                              memory location 17 */
    uint32_t INSTR_MEM18;  /*!< (write-only) Write-only access to instruction
                              memory location 18 */
    uint32_t INSTR_MEM19;  /*!< (write-only) Write-only access to instruction
                              memory location 19 */
    uint32_t INSTR_MEM20;  /*!< (write-only) Write-only access to instruction
                              memory location 20 */
    uint32_t INSTR_MEM21;  /*!< (write-only) Write-only access to instruction
                              memory location 21 */
    uint32_t INSTR_MEM22;  /*!< (write-only) Write-only access to instruction
                              memory location 22 */
    uint32_t INSTR_MEM23;  /*!< (write-only) Write-only access to instruction
                              memory location 23 */
    uint32_t INSTR_MEM24;  /*!< (write-only) Write-only access to instruction
                              memory location 24 */
    uint32_t INSTR_MEM25;  /*!< (write-only) Write-only access to instruction
                              memory location 25 */
    uint32_t INSTR_MEM26;  /*!< (write-only) Write-only access to instruction
                              memory location 26 */
    uint32_t INSTR_MEM27;  /*!< (write-only) Write-only access to instruction
                              memory location 27 */
    uint32_t INSTR_MEM28;  /*!< (write-only) Write-only access to instruction
                              memory location 28 */
    uint32_t INSTR_MEM29;  /*!< (write-only) Write-only access to instruction
                              memory location 29 */
    uint32_t INSTR_MEM30;  /*!< (write-only) Write-only access to instruction
                              memory location 30 */
    uint32_t INSTR_MEM31;  /*!< (write-only) Write-only access to instruction
                              memory location 31 */
    uint32_t SM0_CLKDIV;   /*!< (read-write) Clock divisor register for state
      machine 0\n   Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */
    uint32_t SM0_EXECCTRL; /*!< (read-write) Execution/behavioural settings for
                              state machine 0 */
    uint32_t
        SM0_SHIFTCTRL; /*!< (read-write) Control behaviour of the input/output
                          shift registers for state machine 0 */
    const uint32_t SM0_ADDR =
        {}; /*!< (read-only) Current instruction address of state machine 0 */
    uint32_t SM0_INSTR; /*!< (read-write) Read to see the instruction currently
   addressed by state machine 0's program counter\n Write to execute an
   instruction immediately (including jumps) and then resume execution. */
    uint32_t SM0_PINCTRL;  /*!< (read-write) State machine pin control */
    uint32_t SM1_CLKDIV;   /*!< (read-write) Clock divisor register for state
      machine 1\n   Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */
    uint32_t SM1_EXECCTRL; /*!< (read-write) Execution/behavioural settings for
                              state machine 1 */
    uint32_t
        SM1_SHIFTCTRL; /*!< (read-write) Control behaviour of the input/output
                          shift registers for state machine 1 */
    const uint32_t SM1_ADDR =
        {}; /*!< (read-only) Current instruction address of state machine 1 */
    uint32_t SM1_INSTR; /*!< (read-write) Read to see the instruction currently
   addressed by state machine 1's program counter\n Write to execute an
   instruction immediately (including jumps) and then resume execution. */
    uint32_t SM1_PINCTRL;  /*!< (read-write) State machine pin control */
    uint32_t SM2_CLKDIV;   /*!< (read-write) Clock divisor register for state
      machine 2\n   Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */
    uint32_t SM2_EXECCTRL; /*!< (read-write) Execution/behavioural settings for
                              state machine 2 */
    uint32_t
        SM2_SHIFTCTRL; /*!< (read-write) Control behaviour of the input/output
                          shift registers for state machine 2 */
    const uint32_t SM2_ADDR =
        {}; /*!< (read-only) Current instruction address of state machine 2 */
    uint32_t SM2_INSTR; /*!< (read-write) Read to see the instruction currently
   addressed by state machine 2's program counter\n Write to execute an
   instruction immediately (including jumps) and then resume execution. */
    uint32_t SM2_PINCTRL;  /*!< (read-write) State machine pin control */
    uint32_t SM3_CLKDIV;   /*!< (read-write) Clock divisor register for state
      machine 3\n   Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC / 256) */
    uint32_t SM3_EXECCTRL; /*!< (read-write) Execution/behavioural settings for
                              state machine 3 */
    uint32_t
        SM3_SHIFTCTRL; /*!< (read-write) Control behaviour of the input/output
                          shift registers for state machine 3 */
    const uint32_t SM3_ADDR =
        {}; /*!< (read-only) Current instruction address of state machine 3 */
    uint32_t SM3_INSTR; /*!< (read-write) Read to see the instruction currently
   addressed by state machine 3's program counter\n Write to execute an
   instruction immediately (including jumps) and then resume execution. */
    uint32_t SM3_PINCTRL;     /*!< (read-write) State machine pin control */
    const uint32_t INTR = {}; /*!< (read-only) Raw Interrupts */
    uint32_t IRQ0_INTE;       /*!< (read-write) Interrupt Enable for irq0 */
    uint32_t IRQ0_INTF;       /*!< (read-write) Interrupt Force for irq0 */
    const uint32_t IRQ0_INTS = {}; /*!< (read-only) Interrupt status after
                                      masking & forcing for irq0 */
    uint32_t IRQ1_INTE; /*!< (read-write) Interrupt Enable for irq1 */
    uint32_t IRQ1_INTF; /*!< (read-write) Interrupt Force for irq1 */
    const uint32_t IRQ1_INTS = {}; /*!< (read-only) Interrupt status after
                                      masking & forcing for irq1 */

    /* Methods. */

    /**
     * Get CTRL's SM_ENABLE field.
     */
    inline uint8_t get_CTRL_SM_ENABLE() volatile
    {
        return (CTRL >> 0u) & 0b1111u;
    }

    /**
     * Set CTRL's SM_ENABLE field.
     */
    inline void set_CTRL_SM_ENABLE(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL's SM_RESTART field.
     */
    inline uint8_t get_CTRL_SM_RESTART() volatile
    {
        return (CTRL >> 4u) & 0b1111u;
    }

    /**
     * Set CTRL's SM_RESTART field.
     */
    inline void set_CTRL_SM_RESTART(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        CTRL = curr;
    }

    /**
     * Get CTRL's CLKDIV_RESTART field.
     */
    inline uint8_t get_CTRL_CLKDIV_RESTART() volatile
    {
        return (CTRL >> 8u) & 0b1111u;
    }

    /**
     * Set CTRL's CLKDIV_RESTART field.
     */
    inline void set_CTRL_CLKDIV_RESTART(uint8_t value) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        CTRL = curr;
    }

    /**
     * Get all of CTRL's bit fields.
     */
    inline void get_CTRL(uint8_t &SM_ENABLE, uint8_t &SM_RESTART,
                         uint8_t &CLKDIV_RESTART) volatile
    {
        uint32_t curr = CTRL;

        SM_ENABLE = (curr >> 0u) & 0b1111u;
        SM_RESTART = (curr >> 4u) & 0b1111u;
        CLKDIV_RESTART = (curr >> 8u) & 0b1111u;
    }

    /**
     * Set all of CTRL's bit fields.
     */
    inline void set_CTRL(uint8_t SM_ENABLE, uint8_t SM_RESTART,
                         uint8_t CLKDIV_RESTART) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (SM_ENABLE & 0b1111u) << 0u;
        curr &= ~(0b1111u << 4u);
        curr |= (SM_RESTART & 0b1111u) << 4u;
        curr &= ~(0b1111u << 8u);
        curr |= (CLKDIV_RESTART & 0b1111u) << 8u;

        CTRL = curr;
    }

    /**
     * Get FSTAT's RXFULL field.
     */
    inline uint8_t get_FSTAT_RXFULL() volatile
    {
        return (FSTAT >> 0u) & 0b1111u;
    }

    /**
     * Get FSTAT's RXEMPTY field.
     */
    inline uint8_t get_FSTAT_RXEMPTY() volatile
    {
        return (FSTAT >> 8u) & 0b1111u;
    }

    /**
     * Get FSTAT's TXFULL field.
     */
    inline uint8_t get_FSTAT_TXFULL() volatile
    {
        return (FSTAT >> 16u) & 0b1111u;
    }

    /**
     * Get FSTAT's TXEMPTY field.
     */
    inline uint8_t get_FSTAT_TXEMPTY() volatile
    {
        return (FSTAT >> 24u) & 0b1111u;
    }

    /**
     * Get all of FSTAT's bit fields.
     */
    inline void get_FSTAT(uint8_t &RXFULL, uint8_t &RXEMPTY, uint8_t &TXFULL,
                          uint8_t &TXEMPTY) volatile
    {
        uint32_t curr = FSTAT;

        RXFULL = (curr >> 0u) & 0b1111u;
        RXEMPTY = (curr >> 8u) & 0b1111u;
        TXFULL = (curr >> 16u) & 0b1111u;
        TXEMPTY = (curr >> 24u) & 0b1111u;
    }

    /**
     * Get FDEBUG's RXSTALL field.
     */
    inline uint8_t get_FDEBUG_RXSTALL() volatile
    {
        return (FDEBUG >> 0u) & 0b1111u;
    }

    /**
     * Set FDEBUG's RXSTALL field.
     */
    inline void set_FDEBUG_RXSTALL(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FDEBUG = curr;
    }

    /**
     * Get FDEBUG's RXUNDER field.
     */
    inline uint8_t get_FDEBUG_RXUNDER() volatile
    {
        return (FDEBUG >> 8u) & 0b1111u;
    }

    /**
     * Set FDEBUG's RXUNDER field.
     */
    inline void set_FDEBUG_RXUNDER(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0b1111u << 8u);
        curr |= (value & 0b1111u) << 8u;

        FDEBUG = curr;
    }

    /**
     * Get FDEBUG's TXOVER field.
     */
    inline uint8_t get_FDEBUG_TXOVER() volatile
    {
        return (FDEBUG >> 16u) & 0b1111u;
    }

    /**
     * Set FDEBUG's TXOVER field.
     */
    inline void set_FDEBUG_TXOVER(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        FDEBUG = curr;
    }

    /**
     * Get FDEBUG's TXSTALL field.
     */
    inline uint8_t get_FDEBUG_TXSTALL() volatile
    {
        return (FDEBUG >> 24u) & 0b1111u;
    }

    /**
     * Set FDEBUG's TXSTALL field.
     */
    inline void set_FDEBUG_TXSTALL(uint8_t value) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        FDEBUG = curr;
    }

    /**
     * Get all of FDEBUG's bit fields.
     */
    inline void get_FDEBUG(uint8_t &RXSTALL, uint8_t &RXUNDER, uint8_t &TXOVER,
                           uint8_t &TXSTALL) volatile
    {
        uint32_t curr = FDEBUG;

        RXSTALL = (curr >> 0u) & 0b1111u;
        RXUNDER = (curr >> 8u) & 0b1111u;
        TXOVER = (curr >> 16u) & 0b1111u;
        TXSTALL = (curr >> 24u) & 0b1111u;
    }

    /**
     * Set all of FDEBUG's bit fields.
     */
    inline void set_FDEBUG(uint8_t RXSTALL, uint8_t RXUNDER, uint8_t TXOVER,
                           uint8_t TXSTALL) volatile
    {
        uint32_t curr = FDEBUG;

        curr &= ~(0b1111u << 0u);
        curr |= (RXSTALL & 0b1111u) << 0u;
        curr &= ~(0b1111u << 8u);
        curr |= (RXUNDER & 0b1111u) << 8u;
        curr &= ~(0b1111u << 16u);
        curr |= (TXOVER & 0b1111u) << 16u;
        curr &= ~(0b1111u << 24u);
        curr |= (TXSTALL & 0b1111u) << 24u;

        FDEBUG = curr;
    }

    /**
     * Get FLEVEL's TX0 field.
     */
    inline uint8_t get_FLEVEL_TX0() volatile
    {
        return (FLEVEL >> 0u) & 0b1111u;
    }

    /**
     * Get FLEVEL's RX0 field.
     */
    inline uint8_t get_FLEVEL_RX0() volatile
    {
        return (FLEVEL >> 4u) & 0b1111u;
    }

    /**
     * Get FLEVEL's TX1 field.
     */
    inline uint8_t get_FLEVEL_TX1() volatile
    {
        return (FLEVEL >> 8u) & 0b1111u;
    }

    /**
     * Get FLEVEL's RX1 field.
     */
    inline uint8_t get_FLEVEL_RX1() volatile
    {
        return (FLEVEL >> 12u) & 0b1111u;
    }

    /**
     * Get FLEVEL's TX2 field.
     */
    inline uint8_t get_FLEVEL_TX2() volatile
    {
        return (FLEVEL >> 16u) & 0b1111u;
    }

    /**
     * Get FLEVEL's RX2 field.
     */
    inline uint8_t get_FLEVEL_RX2() volatile
    {
        return (FLEVEL >> 20u) & 0b1111u;
    }

    /**
     * Get FLEVEL's TX3 field.
     */
    inline uint8_t get_FLEVEL_TX3() volatile
    {
        return (FLEVEL >> 24u) & 0b1111u;
    }

    /**
     * Get FLEVEL's RX3 field.
     */
    inline uint8_t get_FLEVEL_RX3() volatile
    {
        return (FLEVEL >> 28u) & 0b1111u;
    }

    /**
     * Get all of FLEVEL's bit fields.
     */
    inline void get_FLEVEL(uint8_t &TX0, uint8_t &RX0, uint8_t &TX1,
                           uint8_t &RX1, uint8_t &TX2, uint8_t &RX2,
                           uint8_t &TX3, uint8_t &RX3) volatile
    {
        uint32_t curr = FLEVEL;

        TX0 = (curr >> 0u) & 0b1111u;
        RX0 = (curr >> 4u) & 0b1111u;
        TX1 = (curr >> 8u) & 0b1111u;
        RX1 = (curr >> 12u) & 0b1111u;
        TX2 = (curr >> 16u) & 0b1111u;
        RX2 = (curr >> 20u) & 0b1111u;
        TX3 = (curr >> 24u) & 0b1111u;
        RX3 = (curr >> 28u) & 0b1111u;
    }

    /**
     * Get IRQ's IRQ field.
     */
    inline uint8_t get_IRQ_IRQ() volatile
    {
        return (IRQ >> 0u) & 0b11111111u;
    }

    /**
     * Set IRQ's IRQ field.
     */
    inline void set_IRQ_IRQ(uint8_t value) volatile
    {
        uint32_t curr = IRQ;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IRQ = curr;
    }

    /**
     * Set IRQ_FORCE's IRQ_FORCE field.
     */
    inline void set_IRQ_FORCE_IRQ_FORCE(uint8_t value) volatile
    {
        uint32_t curr = IRQ_FORCE;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IRQ_FORCE = curr;
    }

    /**
     * Get DBG_CFGINFO's FIFO_DEPTH field.
     */
    inline uint8_t get_DBG_CFGINFO_FIFO_DEPTH() volatile
    {
        return (DBG_CFGINFO >> 0u) & 0b111111u;
    }

    /**
     * Get DBG_CFGINFO's SM_COUNT field.
     */
    inline uint8_t get_DBG_CFGINFO_SM_COUNT() volatile
    {
        return (DBG_CFGINFO >> 8u) & 0b1111u;
    }

    /**
     * Get DBG_CFGINFO's IMEM_SIZE field.
     */
    inline uint8_t get_DBG_CFGINFO_IMEM_SIZE() volatile
    {
        return (DBG_CFGINFO >> 16u) & 0b111111u;
    }

    /**
     * Get all of DBG_CFGINFO's bit fields.
     */
    inline void get_DBG_CFGINFO(uint8_t &FIFO_DEPTH, uint8_t &SM_COUNT,
                                uint8_t &IMEM_SIZE) volatile
    {
        uint32_t curr = DBG_CFGINFO;

        FIFO_DEPTH = (curr >> 0u) & 0b111111u;
        SM_COUNT = (curr >> 8u) & 0b1111u;
        IMEM_SIZE = (curr >> 16u) & 0b111111u;
    }

    /**
     * Set INSTR_MEM0's INSTR_MEM0 field.
     */
    inline void set_INSTR_MEM0_INSTR_MEM0(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM0 = curr;
    }

    /**
     * Set INSTR_MEM1's INSTR_MEM1 field.
     */
    inline void set_INSTR_MEM1_INSTR_MEM1(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM1 = curr;
    }

    /**
     * Set INSTR_MEM2's INSTR_MEM2 field.
     */
    inline void set_INSTR_MEM2_INSTR_MEM2(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM2 = curr;
    }

    /**
     * Set INSTR_MEM3's INSTR_MEM3 field.
     */
    inline void set_INSTR_MEM3_INSTR_MEM3(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM3 = curr;
    }

    /**
     * Set INSTR_MEM4's INSTR_MEM4 field.
     */
    inline void set_INSTR_MEM4_INSTR_MEM4(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM4;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM4 = curr;
    }

    /**
     * Set INSTR_MEM5's INSTR_MEM5 field.
     */
    inline void set_INSTR_MEM5_INSTR_MEM5(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM5;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM5 = curr;
    }

    /**
     * Set INSTR_MEM6's INSTR_MEM6 field.
     */
    inline void set_INSTR_MEM6_INSTR_MEM6(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM6;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM6 = curr;
    }

    /**
     * Set INSTR_MEM7's INSTR_MEM7 field.
     */
    inline void set_INSTR_MEM7_INSTR_MEM7(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM7;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM7 = curr;
    }

    /**
     * Set INSTR_MEM8's INSTR_MEM8 field.
     */
    inline void set_INSTR_MEM8_INSTR_MEM8(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM8;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM8 = curr;
    }

    /**
     * Set INSTR_MEM9's INSTR_MEM9 field.
     */
    inline void set_INSTR_MEM9_INSTR_MEM9(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM9;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM9 = curr;
    }

    /**
     * Set INSTR_MEM10's INSTR_MEM10 field.
     */
    inline void set_INSTR_MEM10_INSTR_MEM10(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM10;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM10 = curr;
    }

    /**
     * Set INSTR_MEM11's INSTR_MEM11 field.
     */
    inline void set_INSTR_MEM11_INSTR_MEM11(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM11;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM11 = curr;
    }

    /**
     * Set INSTR_MEM12's INSTR_MEM12 field.
     */
    inline void set_INSTR_MEM12_INSTR_MEM12(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM12;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM12 = curr;
    }

    /**
     * Set INSTR_MEM13's INSTR_MEM13 field.
     */
    inline void set_INSTR_MEM13_INSTR_MEM13(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM13;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM13 = curr;
    }

    /**
     * Set INSTR_MEM14's INSTR_MEM14 field.
     */
    inline void set_INSTR_MEM14_INSTR_MEM14(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM14;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM14 = curr;
    }

    /**
     * Set INSTR_MEM15's INSTR_MEM15 field.
     */
    inline void set_INSTR_MEM15_INSTR_MEM15(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM15;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM15 = curr;
    }

    /**
     * Set INSTR_MEM16's INSTR_MEM16 field.
     */
    inline void set_INSTR_MEM16_INSTR_MEM16(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM16;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM16 = curr;
    }

    /**
     * Set INSTR_MEM17's INSTR_MEM17 field.
     */
    inline void set_INSTR_MEM17_INSTR_MEM17(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM17;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM17 = curr;
    }

    /**
     * Set INSTR_MEM18's INSTR_MEM18 field.
     */
    inline void set_INSTR_MEM18_INSTR_MEM18(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM18;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM18 = curr;
    }

    /**
     * Set INSTR_MEM19's INSTR_MEM19 field.
     */
    inline void set_INSTR_MEM19_INSTR_MEM19(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM19;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM19 = curr;
    }

    /**
     * Set INSTR_MEM20's INSTR_MEM20 field.
     */
    inline void set_INSTR_MEM20_INSTR_MEM20(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM20;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM20 = curr;
    }

    /**
     * Set INSTR_MEM21's INSTR_MEM21 field.
     */
    inline void set_INSTR_MEM21_INSTR_MEM21(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM21;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM21 = curr;
    }

    /**
     * Set INSTR_MEM22's INSTR_MEM22 field.
     */
    inline void set_INSTR_MEM22_INSTR_MEM22(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM22;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM22 = curr;
    }

    /**
     * Set INSTR_MEM23's INSTR_MEM23 field.
     */
    inline void set_INSTR_MEM23_INSTR_MEM23(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM23;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM23 = curr;
    }

    /**
     * Set INSTR_MEM24's INSTR_MEM24 field.
     */
    inline void set_INSTR_MEM24_INSTR_MEM24(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM24;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM24 = curr;
    }

    /**
     * Set INSTR_MEM25's INSTR_MEM25 field.
     */
    inline void set_INSTR_MEM25_INSTR_MEM25(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM25;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM25 = curr;
    }

    /**
     * Set INSTR_MEM26's INSTR_MEM26 field.
     */
    inline void set_INSTR_MEM26_INSTR_MEM26(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM26;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM26 = curr;
    }

    /**
     * Set INSTR_MEM27's INSTR_MEM27 field.
     */
    inline void set_INSTR_MEM27_INSTR_MEM27(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM27;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM27 = curr;
    }

    /**
     * Set INSTR_MEM28's INSTR_MEM28 field.
     */
    inline void set_INSTR_MEM28_INSTR_MEM28(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM28;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM28 = curr;
    }

    /**
     * Set INSTR_MEM29's INSTR_MEM29 field.
     */
    inline void set_INSTR_MEM29_INSTR_MEM29(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM29;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM29 = curr;
    }

    /**
     * Set INSTR_MEM30's INSTR_MEM30 field.
     */
    inline void set_INSTR_MEM30_INSTR_MEM30(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM30;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM30 = curr;
    }

    /**
     * Set INSTR_MEM31's INSTR_MEM31 field.
     */
    inline void set_INSTR_MEM31_INSTR_MEM31(uint16_t value) volatile
    {
        uint32_t curr = INSTR_MEM31;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INSTR_MEM31 = curr;
    }

    /**
     * Get SM0_CLKDIV's FRAC field.
     */
    inline uint8_t get_SM0_CLKDIV_FRAC() volatile
    {
        return (SM0_CLKDIV >> 8u) & 0b11111111u;
    }

    /**
     * Set SM0_CLKDIV's FRAC field.
     */
    inline void set_SM0_CLKDIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = SM0_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SM0_CLKDIV = curr;
    }

    /**
     * Get SM0_CLKDIV's INT field.
     */
    inline uint16_t get_SM0_CLKDIV_INT() volatile
    {
        return (SM0_CLKDIV >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SM0_CLKDIV's INT field.
     */
    inline void set_SM0_CLKDIV_INT(uint16_t value) volatile
    {
        uint32_t curr = SM0_CLKDIV;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SM0_CLKDIV = curr;
    }

    /**
     * Get all of SM0_CLKDIV's bit fields.
     */
    inline void get_SM0_CLKDIV(uint8_t &FRAC, uint16_t &INT) volatile
    {
        uint32_t curr = SM0_CLKDIV;

        FRAC = (curr >> 8u) & 0b11111111u;
        INT = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of SM0_CLKDIV's bit fields.
     */
    inline void set_SM0_CLKDIV(uint8_t FRAC, uint16_t INT) volatile
    {
        uint32_t curr = SM0_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (FRAC & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (INT & 0b1111111111111111u) << 16u;

        SM0_CLKDIV = curr;
    }

    /**
     * Get SM0_EXECCTRL's STATUS_N field.
     */
    inline uint8_t get_SM0_EXECCTRL_STATUS_N() volatile
    {
        return (SM0_EXECCTRL >> 0u) & 0b1111u;
    }

    /**
     * Set SM0_EXECCTRL's STATUS_N field.
     */
    inline void set_SM0_EXECCTRL_STATUS_N(uint8_t value) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SM0_EXECCTRL = curr;
    }

    /**
     * Get SM0_EXECCTRL's STATUS_SEL bit.
     */
    inline PIO0_SM0_EXECCTRL_STATUS_SEL get_SM0_EXECCTRL_STATUS_SEL() volatile
    {
        return PIO0_SM0_EXECCTRL_STATUS_SEL(SM0_EXECCTRL & (1u << 4u));
    }

    /**
     * Set SM0_EXECCTRL's STATUS_SEL bit.
     */
    inline void set_SM0_EXECCTRL_STATUS_SEL() volatile
    {
        SM0_EXECCTRL |= 1u << 4u;
    }

    /**
     * Clear SM0_EXECCTRL's STATUS_SEL bit.
     */
    inline void clear_SM0_EXECCTRL_STATUS_SEL() volatile
    {
        SM0_EXECCTRL &= ~(1u << 4u);
    }

    /**
     * Toggle SM0_EXECCTRL's STATUS_SEL bit.
     */
    inline void toggle_SM0_EXECCTRL_STATUS_SEL() volatile
    {
        SM0_EXECCTRL ^= 1u << 4u;
    }

    /**
     * Get SM0_EXECCTRL's WRAP_BOTTOM field.
     */
    inline uint8_t get_SM0_EXECCTRL_WRAP_BOTTOM() volatile
    {
        return (SM0_EXECCTRL >> 7u) & 0b11111u;
    }

    /**
     * Set SM0_EXECCTRL's WRAP_BOTTOM field.
     */
    inline void set_SM0_EXECCTRL_WRAP_BOTTOM(uint8_t value) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        curr &= ~(0b11111u << 7u);
        curr |= (value & 0b11111u) << 7u;

        SM0_EXECCTRL = curr;
    }

    /**
     * Get SM0_EXECCTRL's WRAP_TOP field.
     */
    inline uint8_t get_SM0_EXECCTRL_WRAP_TOP() volatile
    {
        return (SM0_EXECCTRL >> 12u) & 0b11111u;
    }

    /**
     * Set SM0_EXECCTRL's WRAP_TOP field.
     */
    inline void set_SM0_EXECCTRL_WRAP_TOP(uint8_t value) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        curr &= ~(0b11111u << 12u);
        curr |= (value & 0b11111u) << 12u;

        SM0_EXECCTRL = curr;
    }

    /**
     * Get SM0_EXECCTRL's OUT_STICKY bit.
     */
    inline bool get_SM0_EXECCTRL_OUT_STICKY() volatile
    {
        return SM0_EXECCTRL & (1u << 17u);
    }

    /**
     * Set SM0_EXECCTRL's OUT_STICKY bit.
     */
    inline void set_SM0_EXECCTRL_OUT_STICKY() volatile
    {
        SM0_EXECCTRL |= 1u << 17u;
    }

    /**
     * Clear SM0_EXECCTRL's OUT_STICKY bit.
     */
    inline void clear_SM0_EXECCTRL_OUT_STICKY() volatile
    {
        SM0_EXECCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM0_EXECCTRL's OUT_STICKY bit.
     */
    inline void toggle_SM0_EXECCTRL_OUT_STICKY() volatile
    {
        SM0_EXECCTRL ^= 1u << 17u;
    }

    /**
     * Get SM0_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline bool get_SM0_EXECCTRL_INLINE_OUT_EN() volatile
    {
        return SM0_EXECCTRL & (1u << 18u);
    }

    /**
     * Set SM0_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void set_SM0_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM0_EXECCTRL |= 1u << 18u;
    }

    /**
     * Clear SM0_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void clear_SM0_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM0_EXECCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM0_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void toggle_SM0_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM0_EXECCTRL ^= 1u << 18u;
    }

    /**
     * Get SM0_EXECCTRL's OUT_EN_SEL field.
     */
    inline uint8_t get_SM0_EXECCTRL_OUT_EN_SEL() volatile
    {
        return (SM0_EXECCTRL >> 19u) & 0b11111u;
    }

    /**
     * Set SM0_EXECCTRL's OUT_EN_SEL field.
     */
    inline void set_SM0_EXECCTRL_OUT_EN_SEL(uint8_t value) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        SM0_EXECCTRL = curr;
    }

    /**
     * Get SM0_EXECCTRL's JMP_PIN field.
     */
    inline uint8_t get_SM0_EXECCTRL_JMP_PIN() volatile
    {
        return (SM0_EXECCTRL >> 24u) & 0b11111u;
    }

    /**
     * Set SM0_EXECCTRL's JMP_PIN field.
     */
    inline void set_SM0_EXECCTRL_JMP_PIN(uint8_t value) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        SM0_EXECCTRL = curr;
    }

    /**
     * Get SM0_EXECCTRL's SIDE_PINDIR bit.
     */
    inline bool get_SM0_EXECCTRL_SIDE_PINDIR() volatile
    {
        return SM0_EXECCTRL & (1u << 29u);
    }

    /**
     * Set SM0_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void set_SM0_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM0_EXECCTRL |= 1u << 29u;
    }

    /**
     * Clear SM0_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void clear_SM0_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM0_EXECCTRL &= ~(1u << 29u);
    }

    /**
     * Toggle SM0_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void toggle_SM0_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM0_EXECCTRL ^= 1u << 29u;
    }

    /**
     * Get SM0_EXECCTRL's SIDE_EN bit.
     */
    inline bool get_SM0_EXECCTRL_SIDE_EN() volatile
    {
        return SM0_EXECCTRL & (1u << 30u);
    }

    /**
     * Set SM0_EXECCTRL's SIDE_EN bit.
     */
    inline void set_SM0_EXECCTRL_SIDE_EN() volatile
    {
        SM0_EXECCTRL |= 1u << 30u;
    }

    /**
     * Clear SM0_EXECCTRL's SIDE_EN bit.
     */
    inline void clear_SM0_EXECCTRL_SIDE_EN() volatile
    {
        SM0_EXECCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM0_EXECCTRL's SIDE_EN bit.
     */
    inline void toggle_SM0_EXECCTRL_SIDE_EN() volatile
    {
        SM0_EXECCTRL ^= 1u << 30u;
    }

    /**
     * Get SM0_EXECCTRL's EXEC_STALLED bit.
     */
    inline bool get_SM0_EXECCTRL_EXEC_STALLED() volatile
    {
        return SM0_EXECCTRL & (1u << 31u);
    }

    /**
     * Get all of SM0_EXECCTRL's bit fields.
     */
    inline void get_SM0_EXECCTRL(uint8_t &STATUS_N,
                                 PIO0_SM0_EXECCTRL_STATUS_SEL &STATUS_SEL,
                                 uint8_t &WRAP_BOTTOM, uint8_t &WRAP_TOP,
                                 bool &OUT_STICKY, bool &INLINE_OUT_EN,
                                 uint8_t &OUT_EN_SEL, uint8_t &JMP_PIN,
                                 bool &SIDE_PINDIR, bool &SIDE_EN,
                                 bool &EXEC_STALLED) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        STATUS_N = (curr >> 0u) & 0b1111u;
        STATUS_SEL = PIO0_SM0_EXECCTRL_STATUS_SEL(curr & (1u << 4u));
        WRAP_BOTTOM = (curr >> 7u) & 0b11111u;
        WRAP_TOP = (curr >> 12u) & 0b11111u;
        OUT_STICKY = curr & (1u << 17u);
        INLINE_OUT_EN = curr & (1u << 18u);
        OUT_EN_SEL = (curr >> 19u) & 0b11111u;
        JMP_PIN = (curr >> 24u) & 0b11111u;
        SIDE_PINDIR = curr & (1u << 29u);
        SIDE_EN = curr & (1u << 30u);
        EXEC_STALLED = curr & (1u << 31u);
    }

    /**
     * Set all of SM0_EXECCTRL's bit fields.
     */
    inline void set_SM0_EXECCTRL(uint8_t STATUS_N,
                                 PIO0_SM0_EXECCTRL_STATUS_SEL STATUS_SEL,
                                 uint8_t WRAP_BOTTOM, uint8_t WRAP_TOP,
                                 bool OUT_STICKY, bool INLINE_OUT_EN,
                                 uint8_t OUT_EN_SEL, uint8_t JMP_PIN,
                                 bool SIDE_PINDIR, bool SIDE_EN) volatile
    {
        uint32_t curr = SM0_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (STATUS_N & 0b1111u) << 0u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(STATUS_SEL) & 0b1u) << 4u;
        curr &= ~(0b11111u << 7u);
        curr |= (WRAP_BOTTOM & 0b11111u) << 7u;
        curr &= ~(0b11111u << 12u);
        curr |= (WRAP_TOP & 0b11111u) << 12u;
        curr &= ~(0b1u << 17u);
        curr |= (OUT_STICKY & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (INLINE_OUT_EN & 0b1u) << 18u;
        curr &= ~(0b11111u << 19u);
        curr |= (OUT_EN_SEL & 0b11111u) << 19u;
        curr &= ~(0b11111u << 24u);
        curr |= (JMP_PIN & 0b11111u) << 24u;
        curr &= ~(0b1u << 29u);
        curr |= (SIDE_PINDIR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (SIDE_EN & 0b1u) << 30u;

        SM0_EXECCTRL = curr;
    }

    /**
     * Get SM0_SHIFTCTRL's AUTOPUSH bit.
     */
    inline bool get_SM0_SHIFTCTRL_AUTOPUSH() volatile
    {
        return SM0_SHIFTCTRL & (1u << 16u);
    }

    /**
     * Set SM0_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void set_SM0_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM0_SHIFTCTRL |= 1u << 16u;
    }

    /**
     * Clear SM0_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void clear_SM0_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM0_SHIFTCTRL &= ~(1u << 16u);
    }

    /**
     * Toggle SM0_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void toggle_SM0_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM0_SHIFTCTRL ^= 1u << 16u;
    }

    /**
     * Get SM0_SHIFTCTRL's AUTOPULL bit.
     */
    inline bool get_SM0_SHIFTCTRL_AUTOPULL() volatile
    {
        return SM0_SHIFTCTRL & (1u << 17u);
    }

    /**
     * Set SM0_SHIFTCTRL's AUTOPULL bit.
     */
    inline void set_SM0_SHIFTCTRL_AUTOPULL() volatile
    {
        SM0_SHIFTCTRL |= 1u << 17u;
    }

    /**
     * Clear SM0_SHIFTCTRL's AUTOPULL bit.
     */
    inline void clear_SM0_SHIFTCTRL_AUTOPULL() volatile
    {
        SM0_SHIFTCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM0_SHIFTCTRL's AUTOPULL bit.
     */
    inline void toggle_SM0_SHIFTCTRL_AUTOPULL() volatile
    {
        SM0_SHIFTCTRL ^= 1u << 17u;
    }

    /**
     * Get SM0_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline bool get_SM0_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        return SM0_SHIFTCTRL & (1u << 18u);
    }

    /**
     * Set SM0_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void set_SM0_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM0_SHIFTCTRL |= 1u << 18u;
    }

    /**
     * Clear SM0_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void clear_SM0_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM0_SHIFTCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM0_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void toggle_SM0_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM0_SHIFTCTRL ^= 1u << 18u;
    }

    /**
     * Get SM0_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline bool get_SM0_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        return SM0_SHIFTCTRL & (1u << 19u);
    }

    /**
     * Set SM0_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void set_SM0_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM0_SHIFTCTRL |= 1u << 19u;
    }

    /**
     * Clear SM0_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void clear_SM0_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM0_SHIFTCTRL &= ~(1u << 19u);
    }

    /**
     * Toggle SM0_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void toggle_SM0_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM0_SHIFTCTRL ^= 1u << 19u;
    }

    /**
     * Get SM0_SHIFTCTRL's PUSH_THRESH field.
     */
    inline uint8_t get_SM0_SHIFTCTRL_PUSH_THRESH() volatile
    {
        return (SM0_SHIFTCTRL >> 20u) & 0b11111u;
    }

    /**
     * Set SM0_SHIFTCTRL's PUSH_THRESH field.
     */
    inline void set_SM0_SHIFTCTRL_PUSH_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM0_SHIFTCTRL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        SM0_SHIFTCTRL = curr;
    }

    /**
     * Get SM0_SHIFTCTRL's PULL_THRESH field.
     */
    inline uint8_t get_SM0_SHIFTCTRL_PULL_THRESH() volatile
    {
        return (SM0_SHIFTCTRL >> 25u) & 0b11111u;
    }

    /**
     * Set SM0_SHIFTCTRL's PULL_THRESH field.
     */
    inline void set_SM0_SHIFTCTRL_PULL_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM0_SHIFTCTRL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        SM0_SHIFTCTRL = curr;
    }

    /**
     * Get SM0_SHIFTCTRL's FJOIN_TX bit.
     */
    inline bool get_SM0_SHIFTCTRL_FJOIN_TX() volatile
    {
        return SM0_SHIFTCTRL & (1u << 30u);
    }

    /**
     * Set SM0_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void set_SM0_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM0_SHIFTCTRL |= 1u << 30u;
    }

    /**
     * Clear SM0_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void clear_SM0_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM0_SHIFTCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM0_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void toggle_SM0_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM0_SHIFTCTRL ^= 1u << 30u;
    }

    /**
     * Get SM0_SHIFTCTRL's FJOIN_RX bit.
     */
    inline bool get_SM0_SHIFTCTRL_FJOIN_RX() volatile
    {
        return SM0_SHIFTCTRL & (1u << 31u);
    }

    /**
     * Set SM0_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void set_SM0_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM0_SHIFTCTRL |= 1u << 31u;
    }

    /**
     * Clear SM0_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void clear_SM0_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM0_SHIFTCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle SM0_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void toggle_SM0_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM0_SHIFTCTRL ^= 1u << 31u;
    }

    /**
     * Get all of SM0_SHIFTCTRL's bit fields.
     */
    inline void get_SM0_SHIFTCTRL(bool &AUTOPUSH, bool &AUTOPULL,
                                  bool &IN_SHIFTDIR, bool &OUT_SHIFTDIR,
                                  uint8_t &PUSH_THRESH, uint8_t &PULL_THRESH,
                                  bool &FJOIN_TX, bool &FJOIN_RX) volatile
    {
        uint32_t curr = SM0_SHIFTCTRL;

        AUTOPUSH = curr & (1u << 16u);
        AUTOPULL = curr & (1u << 17u);
        IN_SHIFTDIR = curr & (1u << 18u);
        OUT_SHIFTDIR = curr & (1u << 19u);
        PUSH_THRESH = (curr >> 20u) & 0b11111u;
        PULL_THRESH = (curr >> 25u) & 0b11111u;
        FJOIN_TX = curr & (1u << 30u);
        FJOIN_RX = curr & (1u << 31u);
    }

    /**
     * Set all of SM0_SHIFTCTRL's bit fields.
     */
    inline void set_SM0_SHIFTCTRL(bool AUTOPUSH, bool AUTOPULL,
                                  bool IN_SHIFTDIR, bool OUT_SHIFTDIR,
                                  uint8_t PUSH_THRESH, uint8_t PULL_THRESH,
                                  bool FJOIN_TX, bool FJOIN_RX) volatile
    {
        uint32_t curr = SM0_SHIFTCTRL;

        curr &= ~(0b1u << 16u);
        curr |= (AUTOPUSH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (AUTOPULL & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (IN_SHIFTDIR & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (OUT_SHIFTDIR & 0b1u) << 19u;
        curr &= ~(0b11111u << 20u);
        curr |= (PUSH_THRESH & 0b11111u) << 20u;
        curr &= ~(0b11111u << 25u);
        curr |= (PULL_THRESH & 0b11111u) << 25u;
        curr &= ~(0b1u << 30u);
        curr |= (FJOIN_TX & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FJOIN_RX & 0b1u) << 31u;

        SM0_SHIFTCTRL = curr;
    }

    /**
     * Get SM0_ADDR's SM0_ADDR field.
     */
    inline uint8_t get_SM0_ADDR_SM0_ADDR() volatile
    {
        return (SM0_ADDR >> 0u) & 0b11111u;
    }

    /**
     * Get SM0_INSTR's SM0_INSTR field.
     */
    inline uint16_t get_SM0_INSTR_SM0_INSTR() volatile
    {
        return (SM0_INSTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set SM0_INSTR's SM0_INSTR field.
     */
    inline void set_SM0_INSTR_SM0_INSTR(uint16_t value) volatile
    {
        uint32_t curr = SM0_INSTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        SM0_INSTR = curr;
    }

    /**
     * Get SM0_PINCTRL's OUT_BASE field.
     */
    inline uint8_t get_SM0_PINCTRL_OUT_BASE() volatile
    {
        return (SM0_PINCTRL >> 0u) & 0b11111u;
    }

    /**
     * Set SM0_PINCTRL's OUT_BASE field.
     */
    inline void set_SM0_PINCTRL_OUT_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM0_PINCTRL's SET_BASE field.
     */
    inline uint8_t get_SM0_PINCTRL_SET_BASE() volatile
    {
        return (SM0_PINCTRL >> 5u) & 0b11111u;
    }

    /**
     * Set SM0_PINCTRL's SET_BASE field.
     */
    inline void set_SM0_PINCTRL_SET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM0_PINCTRL's SIDESET_BASE field.
     */
    inline uint8_t get_SM0_PINCTRL_SIDESET_BASE() volatile
    {
        return (SM0_PINCTRL >> 10u) & 0b11111u;
    }

    /**
     * Set SM0_PINCTRL's SIDESET_BASE field.
     */
    inline void set_SM0_PINCTRL_SIDESET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM0_PINCTRL's IN_BASE field.
     */
    inline uint8_t get_SM0_PINCTRL_IN_BASE() volatile
    {
        return (SM0_PINCTRL >> 15u) & 0b11111u;
    }

    /**
     * Set SM0_PINCTRL's IN_BASE field.
     */
    inline void set_SM0_PINCTRL_IN_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM0_PINCTRL's OUT_COUNT field.
     */
    inline uint8_t get_SM0_PINCTRL_OUT_COUNT() volatile
    {
        return (SM0_PINCTRL >> 20u) & 0b111111u;
    }

    /**
     * Set SM0_PINCTRL's OUT_COUNT field.
     */
    inline void set_SM0_PINCTRL_OUT_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b111111u << 20u);
        curr |= (value & 0b111111u) << 20u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM0_PINCTRL's SET_COUNT field.
     */
    inline uint8_t get_SM0_PINCTRL_SET_COUNT() volatile
    {
        return (SM0_PINCTRL >> 26u) & 0b111u;
    }

    /**
     * Set SM0_PINCTRL's SET_COUNT field.
     */
    inline void set_SM0_PINCTRL_SET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b111u << 26u);
        curr |= (value & 0b111u) << 26u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM0_PINCTRL's SIDESET_COUNT field.
     */
    inline uint8_t get_SM0_PINCTRL_SIDESET_COUNT() volatile
    {
        return (SM0_PINCTRL >> 29u) & 0b111u;
    }

    /**
     * Set SM0_PINCTRL's SIDESET_COUNT field.
     */
    inline void set_SM0_PINCTRL_SIDESET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b111u << 29u);
        curr |= (value & 0b111u) << 29u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get all of SM0_PINCTRL's bit fields.
     */
    inline void get_SM0_PINCTRL(uint8_t &OUT_BASE, uint8_t &SET_BASE,
                                uint8_t &SIDESET_BASE, uint8_t &IN_BASE,
                                uint8_t &OUT_COUNT, uint8_t &SET_COUNT,
                                uint8_t &SIDESET_COUNT) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        OUT_BASE = (curr >> 0u) & 0b11111u;
        SET_BASE = (curr >> 5u) & 0b11111u;
        SIDESET_BASE = (curr >> 10u) & 0b11111u;
        IN_BASE = (curr >> 15u) & 0b11111u;
        OUT_COUNT = (curr >> 20u) & 0b111111u;
        SET_COUNT = (curr >> 26u) & 0b111u;
        SIDESET_COUNT = (curr >> 29u) & 0b111u;
    }

    /**
     * Set all of SM0_PINCTRL's bit fields.
     */
    inline void set_SM0_PINCTRL(uint8_t OUT_BASE, uint8_t SET_BASE,
                                uint8_t SIDESET_BASE, uint8_t IN_BASE,
                                uint8_t OUT_COUNT, uint8_t SET_COUNT,
                                uint8_t SIDESET_COUNT) volatile
    {
        uint32_t curr = SM0_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (OUT_BASE & 0b11111u) << 0u;
        curr &= ~(0b11111u << 5u);
        curr |= (SET_BASE & 0b11111u) << 5u;
        curr &= ~(0b11111u << 10u);
        curr |= (SIDESET_BASE & 0b11111u) << 10u;
        curr &= ~(0b11111u << 15u);
        curr |= (IN_BASE & 0b11111u) << 15u;
        curr &= ~(0b111111u << 20u);
        curr |= (OUT_COUNT & 0b111111u) << 20u;
        curr &= ~(0b111u << 26u);
        curr |= (SET_COUNT & 0b111u) << 26u;
        curr &= ~(0b111u << 29u);
        curr |= (SIDESET_COUNT & 0b111u) << 29u;

        SM0_PINCTRL = curr;
    }

    /**
     * Get SM1_CLKDIV's FRAC field.
     */
    inline uint8_t get_SM1_CLKDIV_FRAC() volatile
    {
        return (SM1_CLKDIV >> 8u) & 0b11111111u;
    }

    /**
     * Set SM1_CLKDIV's FRAC field.
     */
    inline void set_SM1_CLKDIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = SM1_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SM1_CLKDIV = curr;
    }

    /**
     * Get SM1_CLKDIV's INT field.
     */
    inline uint16_t get_SM1_CLKDIV_INT() volatile
    {
        return (SM1_CLKDIV >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SM1_CLKDIV's INT field.
     */
    inline void set_SM1_CLKDIV_INT(uint16_t value) volatile
    {
        uint32_t curr = SM1_CLKDIV;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SM1_CLKDIV = curr;
    }

    /**
     * Get all of SM1_CLKDIV's bit fields.
     */
    inline void get_SM1_CLKDIV(uint8_t &FRAC, uint16_t &INT) volatile
    {
        uint32_t curr = SM1_CLKDIV;

        FRAC = (curr >> 8u) & 0b11111111u;
        INT = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of SM1_CLKDIV's bit fields.
     */
    inline void set_SM1_CLKDIV(uint8_t FRAC, uint16_t INT) volatile
    {
        uint32_t curr = SM1_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (FRAC & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (INT & 0b1111111111111111u) << 16u;

        SM1_CLKDIV = curr;
    }

    /**
     * Get SM1_EXECCTRL's STATUS_N field.
     */
    inline uint8_t get_SM1_EXECCTRL_STATUS_N() volatile
    {
        return (SM1_EXECCTRL >> 0u) & 0b1111u;
    }

    /**
     * Set SM1_EXECCTRL's STATUS_N field.
     */
    inline void set_SM1_EXECCTRL_STATUS_N(uint8_t value) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SM1_EXECCTRL = curr;
    }

    /**
     * Get SM1_EXECCTRL's STATUS_SEL bit.
     */
    inline PIO0_SM1_EXECCTRL_STATUS_SEL get_SM1_EXECCTRL_STATUS_SEL() volatile
    {
        return PIO0_SM1_EXECCTRL_STATUS_SEL(SM1_EXECCTRL & (1u << 4u));
    }

    /**
     * Set SM1_EXECCTRL's STATUS_SEL bit.
     */
    inline void set_SM1_EXECCTRL_STATUS_SEL() volatile
    {
        SM1_EXECCTRL |= 1u << 4u;
    }

    /**
     * Clear SM1_EXECCTRL's STATUS_SEL bit.
     */
    inline void clear_SM1_EXECCTRL_STATUS_SEL() volatile
    {
        SM1_EXECCTRL &= ~(1u << 4u);
    }

    /**
     * Toggle SM1_EXECCTRL's STATUS_SEL bit.
     */
    inline void toggle_SM1_EXECCTRL_STATUS_SEL() volatile
    {
        SM1_EXECCTRL ^= 1u << 4u;
    }

    /**
     * Get SM1_EXECCTRL's WRAP_BOTTOM field.
     */
    inline uint8_t get_SM1_EXECCTRL_WRAP_BOTTOM() volatile
    {
        return (SM1_EXECCTRL >> 7u) & 0b11111u;
    }

    /**
     * Set SM1_EXECCTRL's WRAP_BOTTOM field.
     */
    inline void set_SM1_EXECCTRL_WRAP_BOTTOM(uint8_t value) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        curr &= ~(0b11111u << 7u);
        curr |= (value & 0b11111u) << 7u;

        SM1_EXECCTRL = curr;
    }

    /**
     * Get SM1_EXECCTRL's WRAP_TOP field.
     */
    inline uint8_t get_SM1_EXECCTRL_WRAP_TOP() volatile
    {
        return (SM1_EXECCTRL >> 12u) & 0b11111u;
    }

    /**
     * Set SM1_EXECCTRL's WRAP_TOP field.
     */
    inline void set_SM1_EXECCTRL_WRAP_TOP(uint8_t value) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        curr &= ~(0b11111u << 12u);
        curr |= (value & 0b11111u) << 12u;

        SM1_EXECCTRL = curr;
    }

    /**
     * Get SM1_EXECCTRL's OUT_STICKY bit.
     */
    inline bool get_SM1_EXECCTRL_OUT_STICKY() volatile
    {
        return SM1_EXECCTRL & (1u << 17u);
    }

    /**
     * Set SM1_EXECCTRL's OUT_STICKY bit.
     */
    inline void set_SM1_EXECCTRL_OUT_STICKY() volatile
    {
        SM1_EXECCTRL |= 1u << 17u;
    }

    /**
     * Clear SM1_EXECCTRL's OUT_STICKY bit.
     */
    inline void clear_SM1_EXECCTRL_OUT_STICKY() volatile
    {
        SM1_EXECCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM1_EXECCTRL's OUT_STICKY bit.
     */
    inline void toggle_SM1_EXECCTRL_OUT_STICKY() volatile
    {
        SM1_EXECCTRL ^= 1u << 17u;
    }

    /**
     * Get SM1_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline bool get_SM1_EXECCTRL_INLINE_OUT_EN() volatile
    {
        return SM1_EXECCTRL & (1u << 18u);
    }

    /**
     * Set SM1_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void set_SM1_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM1_EXECCTRL |= 1u << 18u;
    }

    /**
     * Clear SM1_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void clear_SM1_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM1_EXECCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM1_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void toggle_SM1_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM1_EXECCTRL ^= 1u << 18u;
    }

    /**
     * Get SM1_EXECCTRL's OUT_EN_SEL field.
     */
    inline uint8_t get_SM1_EXECCTRL_OUT_EN_SEL() volatile
    {
        return (SM1_EXECCTRL >> 19u) & 0b11111u;
    }

    /**
     * Set SM1_EXECCTRL's OUT_EN_SEL field.
     */
    inline void set_SM1_EXECCTRL_OUT_EN_SEL(uint8_t value) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        SM1_EXECCTRL = curr;
    }

    /**
     * Get SM1_EXECCTRL's JMP_PIN field.
     */
    inline uint8_t get_SM1_EXECCTRL_JMP_PIN() volatile
    {
        return (SM1_EXECCTRL >> 24u) & 0b11111u;
    }

    /**
     * Set SM1_EXECCTRL's JMP_PIN field.
     */
    inline void set_SM1_EXECCTRL_JMP_PIN(uint8_t value) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        SM1_EXECCTRL = curr;
    }

    /**
     * Get SM1_EXECCTRL's SIDE_PINDIR bit.
     */
    inline bool get_SM1_EXECCTRL_SIDE_PINDIR() volatile
    {
        return SM1_EXECCTRL & (1u << 29u);
    }

    /**
     * Set SM1_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void set_SM1_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM1_EXECCTRL |= 1u << 29u;
    }

    /**
     * Clear SM1_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void clear_SM1_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM1_EXECCTRL &= ~(1u << 29u);
    }

    /**
     * Toggle SM1_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void toggle_SM1_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM1_EXECCTRL ^= 1u << 29u;
    }

    /**
     * Get SM1_EXECCTRL's SIDE_EN bit.
     */
    inline bool get_SM1_EXECCTRL_SIDE_EN() volatile
    {
        return SM1_EXECCTRL & (1u << 30u);
    }

    /**
     * Set SM1_EXECCTRL's SIDE_EN bit.
     */
    inline void set_SM1_EXECCTRL_SIDE_EN() volatile
    {
        SM1_EXECCTRL |= 1u << 30u;
    }

    /**
     * Clear SM1_EXECCTRL's SIDE_EN bit.
     */
    inline void clear_SM1_EXECCTRL_SIDE_EN() volatile
    {
        SM1_EXECCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM1_EXECCTRL's SIDE_EN bit.
     */
    inline void toggle_SM1_EXECCTRL_SIDE_EN() volatile
    {
        SM1_EXECCTRL ^= 1u << 30u;
    }

    /**
     * Get SM1_EXECCTRL's EXEC_STALLED bit.
     */
    inline bool get_SM1_EXECCTRL_EXEC_STALLED() volatile
    {
        return SM1_EXECCTRL & (1u << 31u);
    }

    /**
     * Get all of SM1_EXECCTRL's bit fields.
     */
    inline void get_SM1_EXECCTRL(uint8_t &STATUS_N,
                                 PIO0_SM1_EXECCTRL_STATUS_SEL &STATUS_SEL,
                                 uint8_t &WRAP_BOTTOM, uint8_t &WRAP_TOP,
                                 bool &OUT_STICKY, bool &INLINE_OUT_EN,
                                 uint8_t &OUT_EN_SEL, uint8_t &JMP_PIN,
                                 bool &SIDE_PINDIR, bool &SIDE_EN,
                                 bool &EXEC_STALLED) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        STATUS_N = (curr >> 0u) & 0b1111u;
        STATUS_SEL = PIO0_SM1_EXECCTRL_STATUS_SEL(curr & (1u << 4u));
        WRAP_BOTTOM = (curr >> 7u) & 0b11111u;
        WRAP_TOP = (curr >> 12u) & 0b11111u;
        OUT_STICKY = curr & (1u << 17u);
        INLINE_OUT_EN = curr & (1u << 18u);
        OUT_EN_SEL = (curr >> 19u) & 0b11111u;
        JMP_PIN = (curr >> 24u) & 0b11111u;
        SIDE_PINDIR = curr & (1u << 29u);
        SIDE_EN = curr & (1u << 30u);
        EXEC_STALLED = curr & (1u << 31u);
    }

    /**
     * Set all of SM1_EXECCTRL's bit fields.
     */
    inline void set_SM1_EXECCTRL(uint8_t STATUS_N,
                                 PIO0_SM1_EXECCTRL_STATUS_SEL STATUS_SEL,
                                 uint8_t WRAP_BOTTOM, uint8_t WRAP_TOP,
                                 bool OUT_STICKY, bool INLINE_OUT_EN,
                                 uint8_t OUT_EN_SEL, uint8_t JMP_PIN,
                                 bool SIDE_PINDIR, bool SIDE_EN) volatile
    {
        uint32_t curr = SM1_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (STATUS_N & 0b1111u) << 0u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(STATUS_SEL) & 0b1u) << 4u;
        curr &= ~(0b11111u << 7u);
        curr |= (WRAP_BOTTOM & 0b11111u) << 7u;
        curr &= ~(0b11111u << 12u);
        curr |= (WRAP_TOP & 0b11111u) << 12u;
        curr &= ~(0b1u << 17u);
        curr |= (OUT_STICKY & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (INLINE_OUT_EN & 0b1u) << 18u;
        curr &= ~(0b11111u << 19u);
        curr |= (OUT_EN_SEL & 0b11111u) << 19u;
        curr &= ~(0b11111u << 24u);
        curr |= (JMP_PIN & 0b11111u) << 24u;
        curr &= ~(0b1u << 29u);
        curr |= (SIDE_PINDIR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (SIDE_EN & 0b1u) << 30u;

        SM1_EXECCTRL = curr;
    }

    /**
     * Get SM1_SHIFTCTRL's AUTOPUSH bit.
     */
    inline bool get_SM1_SHIFTCTRL_AUTOPUSH() volatile
    {
        return SM1_SHIFTCTRL & (1u << 16u);
    }

    /**
     * Set SM1_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void set_SM1_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM1_SHIFTCTRL |= 1u << 16u;
    }

    /**
     * Clear SM1_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void clear_SM1_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM1_SHIFTCTRL &= ~(1u << 16u);
    }

    /**
     * Toggle SM1_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void toggle_SM1_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM1_SHIFTCTRL ^= 1u << 16u;
    }

    /**
     * Get SM1_SHIFTCTRL's AUTOPULL bit.
     */
    inline bool get_SM1_SHIFTCTRL_AUTOPULL() volatile
    {
        return SM1_SHIFTCTRL & (1u << 17u);
    }

    /**
     * Set SM1_SHIFTCTRL's AUTOPULL bit.
     */
    inline void set_SM1_SHIFTCTRL_AUTOPULL() volatile
    {
        SM1_SHIFTCTRL |= 1u << 17u;
    }

    /**
     * Clear SM1_SHIFTCTRL's AUTOPULL bit.
     */
    inline void clear_SM1_SHIFTCTRL_AUTOPULL() volatile
    {
        SM1_SHIFTCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM1_SHIFTCTRL's AUTOPULL bit.
     */
    inline void toggle_SM1_SHIFTCTRL_AUTOPULL() volatile
    {
        SM1_SHIFTCTRL ^= 1u << 17u;
    }

    /**
     * Get SM1_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline bool get_SM1_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        return SM1_SHIFTCTRL & (1u << 18u);
    }

    /**
     * Set SM1_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void set_SM1_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM1_SHIFTCTRL |= 1u << 18u;
    }

    /**
     * Clear SM1_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void clear_SM1_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM1_SHIFTCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM1_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void toggle_SM1_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM1_SHIFTCTRL ^= 1u << 18u;
    }

    /**
     * Get SM1_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline bool get_SM1_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        return SM1_SHIFTCTRL & (1u << 19u);
    }

    /**
     * Set SM1_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void set_SM1_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM1_SHIFTCTRL |= 1u << 19u;
    }

    /**
     * Clear SM1_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void clear_SM1_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM1_SHIFTCTRL &= ~(1u << 19u);
    }

    /**
     * Toggle SM1_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void toggle_SM1_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM1_SHIFTCTRL ^= 1u << 19u;
    }

    /**
     * Get SM1_SHIFTCTRL's PUSH_THRESH field.
     */
    inline uint8_t get_SM1_SHIFTCTRL_PUSH_THRESH() volatile
    {
        return (SM1_SHIFTCTRL >> 20u) & 0b11111u;
    }

    /**
     * Set SM1_SHIFTCTRL's PUSH_THRESH field.
     */
    inline void set_SM1_SHIFTCTRL_PUSH_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM1_SHIFTCTRL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        SM1_SHIFTCTRL = curr;
    }

    /**
     * Get SM1_SHIFTCTRL's PULL_THRESH field.
     */
    inline uint8_t get_SM1_SHIFTCTRL_PULL_THRESH() volatile
    {
        return (SM1_SHIFTCTRL >> 25u) & 0b11111u;
    }

    /**
     * Set SM1_SHIFTCTRL's PULL_THRESH field.
     */
    inline void set_SM1_SHIFTCTRL_PULL_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM1_SHIFTCTRL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        SM1_SHIFTCTRL = curr;
    }

    /**
     * Get SM1_SHIFTCTRL's FJOIN_TX bit.
     */
    inline bool get_SM1_SHIFTCTRL_FJOIN_TX() volatile
    {
        return SM1_SHIFTCTRL & (1u << 30u);
    }

    /**
     * Set SM1_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void set_SM1_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM1_SHIFTCTRL |= 1u << 30u;
    }

    /**
     * Clear SM1_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void clear_SM1_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM1_SHIFTCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM1_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void toggle_SM1_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM1_SHIFTCTRL ^= 1u << 30u;
    }

    /**
     * Get SM1_SHIFTCTRL's FJOIN_RX bit.
     */
    inline bool get_SM1_SHIFTCTRL_FJOIN_RX() volatile
    {
        return SM1_SHIFTCTRL & (1u << 31u);
    }

    /**
     * Set SM1_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void set_SM1_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM1_SHIFTCTRL |= 1u << 31u;
    }

    /**
     * Clear SM1_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void clear_SM1_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM1_SHIFTCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle SM1_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void toggle_SM1_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM1_SHIFTCTRL ^= 1u << 31u;
    }

    /**
     * Get all of SM1_SHIFTCTRL's bit fields.
     */
    inline void get_SM1_SHIFTCTRL(bool &AUTOPUSH, bool &AUTOPULL,
                                  bool &IN_SHIFTDIR, bool &OUT_SHIFTDIR,
                                  uint8_t &PUSH_THRESH, uint8_t &PULL_THRESH,
                                  bool &FJOIN_TX, bool &FJOIN_RX) volatile
    {
        uint32_t curr = SM1_SHIFTCTRL;

        AUTOPUSH = curr & (1u << 16u);
        AUTOPULL = curr & (1u << 17u);
        IN_SHIFTDIR = curr & (1u << 18u);
        OUT_SHIFTDIR = curr & (1u << 19u);
        PUSH_THRESH = (curr >> 20u) & 0b11111u;
        PULL_THRESH = (curr >> 25u) & 0b11111u;
        FJOIN_TX = curr & (1u << 30u);
        FJOIN_RX = curr & (1u << 31u);
    }

    /**
     * Set all of SM1_SHIFTCTRL's bit fields.
     */
    inline void set_SM1_SHIFTCTRL(bool AUTOPUSH, bool AUTOPULL,
                                  bool IN_SHIFTDIR, bool OUT_SHIFTDIR,
                                  uint8_t PUSH_THRESH, uint8_t PULL_THRESH,
                                  bool FJOIN_TX, bool FJOIN_RX) volatile
    {
        uint32_t curr = SM1_SHIFTCTRL;

        curr &= ~(0b1u << 16u);
        curr |= (AUTOPUSH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (AUTOPULL & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (IN_SHIFTDIR & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (OUT_SHIFTDIR & 0b1u) << 19u;
        curr &= ~(0b11111u << 20u);
        curr |= (PUSH_THRESH & 0b11111u) << 20u;
        curr &= ~(0b11111u << 25u);
        curr |= (PULL_THRESH & 0b11111u) << 25u;
        curr &= ~(0b1u << 30u);
        curr |= (FJOIN_TX & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FJOIN_RX & 0b1u) << 31u;

        SM1_SHIFTCTRL = curr;
    }

    /**
     * Get SM1_ADDR's SM1_ADDR field.
     */
    inline uint8_t get_SM1_ADDR_SM1_ADDR() volatile
    {
        return (SM1_ADDR >> 0u) & 0b11111u;
    }

    /**
     * Get SM1_INSTR's SM1_INSTR field.
     */
    inline uint16_t get_SM1_INSTR_SM1_INSTR() volatile
    {
        return (SM1_INSTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set SM1_INSTR's SM1_INSTR field.
     */
    inline void set_SM1_INSTR_SM1_INSTR(uint16_t value) volatile
    {
        uint32_t curr = SM1_INSTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        SM1_INSTR = curr;
    }

    /**
     * Get SM1_PINCTRL's OUT_BASE field.
     */
    inline uint8_t get_SM1_PINCTRL_OUT_BASE() volatile
    {
        return (SM1_PINCTRL >> 0u) & 0b11111u;
    }

    /**
     * Set SM1_PINCTRL's OUT_BASE field.
     */
    inline void set_SM1_PINCTRL_OUT_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM1_PINCTRL's SET_BASE field.
     */
    inline uint8_t get_SM1_PINCTRL_SET_BASE() volatile
    {
        return (SM1_PINCTRL >> 5u) & 0b11111u;
    }

    /**
     * Set SM1_PINCTRL's SET_BASE field.
     */
    inline void set_SM1_PINCTRL_SET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM1_PINCTRL's SIDESET_BASE field.
     */
    inline uint8_t get_SM1_PINCTRL_SIDESET_BASE() volatile
    {
        return (SM1_PINCTRL >> 10u) & 0b11111u;
    }

    /**
     * Set SM1_PINCTRL's SIDESET_BASE field.
     */
    inline void set_SM1_PINCTRL_SIDESET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM1_PINCTRL's IN_BASE field.
     */
    inline uint8_t get_SM1_PINCTRL_IN_BASE() volatile
    {
        return (SM1_PINCTRL >> 15u) & 0b11111u;
    }

    /**
     * Set SM1_PINCTRL's IN_BASE field.
     */
    inline void set_SM1_PINCTRL_IN_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM1_PINCTRL's OUT_COUNT field.
     */
    inline uint8_t get_SM1_PINCTRL_OUT_COUNT() volatile
    {
        return (SM1_PINCTRL >> 20u) & 0b111111u;
    }

    /**
     * Set SM1_PINCTRL's OUT_COUNT field.
     */
    inline void set_SM1_PINCTRL_OUT_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b111111u << 20u);
        curr |= (value & 0b111111u) << 20u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM1_PINCTRL's SET_COUNT field.
     */
    inline uint8_t get_SM1_PINCTRL_SET_COUNT() volatile
    {
        return (SM1_PINCTRL >> 26u) & 0b111u;
    }

    /**
     * Set SM1_PINCTRL's SET_COUNT field.
     */
    inline void set_SM1_PINCTRL_SET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b111u << 26u);
        curr |= (value & 0b111u) << 26u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM1_PINCTRL's SIDESET_COUNT field.
     */
    inline uint8_t get_SM1_PINCTRL_SIDESET_COUNT() volatile
    {
        return (SM1_PINCTRL >> 29u) & 0b111u;
    }

    /**
     * Set SM1_PINCTRL's SIDESET_COUNT field.
     */
    inline void set_SM1_PINCTRL_SIDESET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b111u << 29u);
        curr |= (value & 0b111u) << 29u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get all of SM1_PINCTRL's bit fields.
     */
    inline void get_SM1_PINCTRL(uint8_t &OUT_BASE, uint8_t &SET_BASE,
                                uint8_t &SIDESET_BASE, uint8_t &IN_BASE,
                                uint8_t &OUT_COUNT, uint8_t &SET_COUNT,
                                uint8_t &SIDESET_COUNT) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        OUT_BASE = (curr >> 0u) & 0b11111u;
        SET_BASE = (curr >> 5u) & 0b11111u;
        SIDESET_BASE = (curr >> 10u) & 0b11111u;
        IN_BASE = (curr >> 15u) & 0b11111u;
        OUT_COUNT = (curr >> 20u) & 0b111111u;
        SET_COUNT = (curr >> 26u) & 0b111u;
        SIDESET_COUNT = (curr >> 29u) & 0b111u;
    }

    /**
     * Set all of SM1_PINCTRL's bit fields.
     */
    inline void set_SM1_PINCTRL(uint8_t OUT_BASE, uint8_t SET_BASE,
                                uint8_t SIDESET_BASE, uint8_t IN_BASE,
                                uint8_t OUT_COUNT, uint8_t SET_COUNT,
                                uint8_t SIDESET_COUNT) volatile
    {
        uint32_t curr = SM1_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (OUT_BASE & 0b11111u) << 0u;
        curr &= ~(0b11111u << 5u);
        curr |= (SET_BASE & 0b11111u) << 5u;
        curr &= ~(0b11111u << 10u);
        curr |= (SIDESET_BASE & 0b11111u) << 10u;
        curr &= ~(0b11111u << 15u);
        curr |= (IN_BASE & 0b11111u) << 15u;
        curr &= ~(0b111111u << 20u);
        curr |= (OUT_COUNT & 0b111111u) << 20u;
        curr &= ~(0b111u << 26u);
        curr |= (SET_COUNT & 0b111u) << 26u;
        curr &= ~(0b111u << 29u);
        curr |= (SIDESET_COUNT & 0b111u) << 29u;

        SM1_PINCTRL = curr;
    }

    /**
     * Get SM2_CLKDIV's FRAC field.
     */
    inline uint8_t get_SM2_CLKDIV_FRAC() volatile
    {
        return (SM2_CLKDIV >> 8u) & 0b11111111u;
    }

    /**
     * Set SM2_CLKDIV's FRAC field.
     */
    inline void set_SM2_CLKDIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = SM2_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SM2_CLKDIV = curr;
    }

    /**
     * Get SM2_CLKDIV's INT field.
     */
    inline uint16_t get_SM2_CLKDIV_INT() volatile
    {
        return (SM2_CLKDIV >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SM2_CLKDIV's INT field.
     */
    inline void set_SM2_CLKDIV_INT(uint16_t value) volatile
    {
        uint32_t curr = SM2_CLKDIV;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SM2_CLKDIV = curr;
    }

    /**
     * Get all of SM2_CLKDIV's bit fields.
     */
    inline void get_SM2_CLKDIV(uint8_t &FRAC, uint16_t &INT) volatile
    {
        uint32_t curr = SM2_CLKDIV;

        FRAC = (curr >> 8u) & 0b11111111u;
        INT = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of SM2_CLKDIV's bit fields.
     */
    inline void set_SM2_CLKDIV(uint8_t FRAC, uint16_t INT) volatile
    {
        uint32_t curr = SM2_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (FRAC & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (INT & 0b1111111111111111u) << 16u;

        SM2_CLKDIV = curr;
    }

    /**
     * Get SM2_EXECCTRL's STATUS_N field.
     */
    inline uint8_t get_SM2_EXECCTRL_STATUS_N() volatile
    {
        return (SM2_EXECCTRL >> 0u) & 0b1111u;
    }

    /**
     * Set SM2_EXECCTRL's STATUS_N field.
     */
    inline void set_SM2_EXECCTRL_STATUS_N(uint8_t value) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SM2_EXECCTRL = curr;
    }

    /**
     * Get SM2_EXECCTRL's STATUS_SEL bit.
     */
    inline PIO0_SM2_EXECCTRL_STATUS_SEL get_SM2_EXECCTRL_STATUS_SEL() volatile
    {
        return PIO0_SM2_EXECCTRL_STATUS_SEL(SM2_EXECCTRL & (1u << 4u));
    }

    /**
     * Set SM2_EXECCTRL's STATUS_SEL bit.
     */
    inline void set_SM2_EXECCTRL_STATUS_SEL() volatile
    {
        SM2_EXECCTRL |= 1u << 4u;
    }

    /**
     * Clear SM2_EXECCTRL's STATUS_SEL bit.
     */
    inline void clear_SM2_EXECCTRL_STATUS_SEL() volatile
    {
        SM2_EXECCTRL &= ~(1u << 4u);
    }

    /**
     * Toggle SM2_EXECCTRL's STATUS_SEL bit.
     */
    inline void toggle_SM2_EXECCTRL_STATUS_SEL() volatile
    {
        SM2_EXECCTRL ^= 1u << 4u;
    }

    /**
     * Get SM2_EXECCTRL's WRAP_BOTTOM field.
     */
    inline uint8_t get_SM2_EXECCTRL_WRAP_BOTTOM() volatile
    {
        return (SM2_EXECCTRL >> 7u) & 0b11111u;
    }

    /**
     * Set SM2_EXECCTRL's WRAP_BOTTOM field.
     */
    inline void set_SM2_EXECCTRL_WRAP_BOTTOM(uint8_t value) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        curr &= ~(0b11111u << 7u);
        curr |= (value & 0b11111u) << 7u;

        SM2_EXECCTRL = curr;
    }

    /**
     * Get SM2_EXECCTRL's WRAP_TOP field.
     */
    inline uint8_t get_SM2_EXECCTRL_WRAP_TOP() volatile
    {
        return (SM2_EXECCTRL >> 12u) & 0b11111u;
    }

    /**
     * Set SM2_EXECCTRL's WRAP_TOP field.
     */
    inline void set_SM2_EXECCTRL_WRAP_TOP(uint8_t value) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        curr &= ~(0b11111u << 12u);
        curr |= (value & 0b11111u) << 12u;

        SM2_EXECCTRL = curr;
    }

    /**
     * Get SM2_EXECCTRL's OUT_STICKY bit.
     */
    inline bool get_SM2_EXECCTRL_OUT_STICKY() volatile
    {
        return SM2_EXECCTRL & (1u << 17u);
    }

    /**
     * Set SM2_EXECCTRL's OUT_STICKY bit.
     */
    inline void set_SM2_EXECCTRL_OUT_STICKY() volatile
    {
        SM2_EXECCTRL |= 1u << 17u;
    }

    /**
     * Clear SM2_EXECCTRL's OUT_STICKY bit.
     */
    inline void clear_SM2_EXECCTRL_OUT_STICKY() volatile
    {
        SM2_EXECCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM2_EXECCTRL's OUT_STICKY bit.
     */
    inline void toggle_SM2_EXECCTRL_OUT_STICKY() volatile
    {
        SM2_EXECCTRL ^= 1u << 17u;
    }

    /**
     * Get SM2_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline bool get_SM2_EXECCTRL_INLINE_OUT_EN() volatile
    {
        return SM2_EXECCTRL & (1u << 18u);
    }

    /**
     * Set SM2_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void set_SM2_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM2_EXECCTRL |= 1u << 18u;
    }

    /**
     * Clear SM2_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void clear_SM2_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM2_EXECCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM2_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void toggle_SM2_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM2_EXECCTRL ^= 1u << 18u;
    }

    /**
     * Get SM2_EXECCTRL's OUT_EN_SEL field.
     */
    inline uint8_t get_SM2_EXECCTRL_OUT_EN_SEL() volatile
    {
        return (SM2_EXECCTRL >> 19u) & 0b11111u;
    }

    /**
     * Set SM2_EXECCTRL's OUT_EN_SEL field.
     */
    inline void set_SM2_EXECCTRL_OUT_EN_SEL(uint8_t value) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        SM2_EXECCTRL = curr;
    }

    /**
     * Get SM2_EXECCTRL's JMP_PIN field.
     */
    inline uint8_t get_SM2_EXECCTRL_JMP_PIN() volatile
    {
        return (SM2_EXECCTRL >> 24u) & 0b11111u;
    }

    /**
     * Set SM2_EXECCTRL's JMP_PIN field.
     */
    inline void set_SM2_EXECCTRL_JMP_PIN(uint8_t value) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        SM2_EXECCTRL = curr;
    }

    /**
     * Get SM2_EXECCTRL's SIDE_PINDIR bit.
     */
    inline bool get_SM2_EXECCTRL_SIDE_PINDIR() volatile
    {
        return SM2_EXECCTRL & (1u << 29u);
    }

    /**
     * Set SM2_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void set_SM2_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM2_EXECCTRL |= 1u << 29u;
    }

    /**
     * Clear SM2_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void clear_SM2_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM2_EXECCTRL &= ~(1u << 29u);
    }

    /**
     * Toggle SM2_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void toggle_SM2_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM2_EXECCTRL ^= 1u << 29u;
    }

    /**
     * Get SM2_EXECCTRL's SIDE_EN bit.
     */
    inline bool get_SM2_EXECCTRL_SIDE_EN() volatile
    {
        return SM2_EXECCTRL & (1u << 30u);
    }

    /**
     * Set SM2_EXECCTRL's SIDE_EN bit.
     */
    inline void set_SM2_EXECCTRL_SIDE_EN() volatile
    {
        SM2_EXECCTRL |= 1u << 30u;
    }

    /**
     * Clear SM2_EXECCTRL's SIDE_EN bit.
     */
    inline void clear_SM2_EXECCTRL_SIDE_EN() volatile
    {
        SM2_EXECCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM2_EXECCTRL's SIDE_EN bit.
     */
    inline void toggle_SM2_EXECCTRL_SIDE_EN() volatile
    {
        SM2_EXECCTRL ^= 1u << 30u;
    }

    /**
     * Get SM2_EXECCTRL's EXEC_STALLED bit.
     */
    inline bool get_SM2_EXECCTRL_EXEC_STALLED() volatile
    {
        return SM2_EXECCTRL & (1u << 31u);
    }

    /**
     * Get all of SM2_EXECCTRL's bit fields.
     */
    inline void get_SM2_EXECCTRL(uint8_t &STATUS_N,
                                 PIO0_SM2_EXECCTRL_STATUS_SEL &STATUS_SEL,
                                 uint8_t &WRAP_BOTTOM, uint8_t &WRAP_TOP,
                                 bool &OUT_STICKY, bool &INLINE_OUT_EN,
                                 uint8_t &OUT_EN_SEL, uint8_t &JMP_PIN,
                                 bool &SIDE_PINDIR, bool &SIDE_EN,
                                 bool &EXEC_STALLED) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        STATUS_N = (curr >> 0u) & 0b1111u;
        STATUS_SEL = PIO0_SM2_EXECCTRL_STATUS_SEL(curr & (1u << 4u));
        WRAP_BOTTOM = (curr >> 7u) & 0b11111u;
        WRAP_TOP = (curr >> 12u) & 0b11111u;
        OUT_STICKY = curr & (1u << 17u);
        INLINE_OUT_EN = curr & (1u << 18u);
        OUT_EN_SEL = (curr >> 19u) & 0b11111u;
        JMP_PIN = (curr >> 24u) & 0b11111u;
        SIDE_PINDIR = curr & (1u << 29u);
        SIDE_EN = curr & (1u << 30u);
        EXEC_STALLED = curr & (1u << 31u);
    }

    /**
     * Set all of SM2_EXECCTRL's bit fields.
     */
    inline void set_SM2_EXECCTRL(uint8_t STATUS_N,
                                 PIO0_SM2_EXECCTRL_STATUS_SEL STATUS_SEL,
                                 uint8_t WRAP_BOTTOM, uint8_t WRAP_TOP,
                                 bool OUT_STICKY, bool INLINE_OUT_EN,
                                 uint8_t OUT_EN_SEL, uint8_t JMP_PIN,
                                 bool SIDE_PINDIR, bool SIDE_EN) volatile
    {
        uint32_t curr = SM2_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (STATUS_N & 0b1111u) << 0u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(STATUS_SEL) & 0b1u) << 4u;
        curr &= ~(0b11111u << 7u);
        curr |= (WRAP_BOTTOM & 0b11111u) << 7u;
        curr &= ~(0b11111u << 12u);
        curr |= (WRAP_TOP & 0b11111u) << 12u;
        curr &= ~(0b1u << 17u);
        curr |= (OUT_STICKY & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (INLINE_OUT_EN & 0b1u) << 18u;
        curr &= ~(0b11111u << 19u);
        curr |= (OUT_EN_SEL & 0b11111u) << 19u;
        curr &= ~(0b11111u << 24u);
        curr |= (JMP_PIN & 0b11111u) << 24u;
        curr &= ~(0b1u << 29u);
        curr |= (SIDE_PINDIR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (SIDE_EN & 0b1u) << 30u;

        SM2_EXECCTRL = curr;
    }

    /**
     * Get SM2_SHIFTCTRL's AUTOPUSH bit.
     */
    inline bool get_SM2_SHIFTCTRL_AUTOPUSH() volatile
    {
        return SM2_SHIFTCTRL & (1u << 16u);
    }

    /**
     * Set SM2_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void set_SM2_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM2_SHIFTCTRL |= 1u << 16u;
    }

    /**
     * Clear SM2_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void clear_SM2_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM2_SHIFTCTRL &= ~(1u << 16u);
    }

    /**
     * Toggle SM2_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void toggle_SM2_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM2_SHIFTCTRL ^= 1u << 16u;
    }

    /**
     * Get SM2_SHIFTCTRL's AUTOPULL bit.
     */
    inline bool get_SM2_SHIFTCTRL_AUTOPULL() volatile
    {
        return SM2_SHIFTCTRL & (1u << 17u);
    }

    /**
     * Set SM2_SHIFTCTRL's AUTOPULL bit.
     */
    inline void set_SM2_SHIFTCTRL_AUTOPULL() volatile
    {
        SM2_SHIFTCTRL |= 1u << 17u;
    }

    /**
     * Clear SM2_SHIFTCTRL's AUTOPULL bit.
     */
    inline void clear_SM2_SHIFTCTRL_AUTOPULL() volatile
    {
        SM2_SHIFTCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM2_SHIFTCTRL's AUTOPULL bit.
     */
    inline void toggle_SM2_SHIFTCTRL_AUTOPULL() volatile
    {
        SM2_SHIFTCTRL ^= 1u << 17u;
    }

    /**
     * Get SM2_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline bool get_SM2_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        return SM2_SHIFTCTRL & (1u << 18u);
    }

    /**
     * Set SM2_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void set_SM2_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM2_SHIFTCTRL |= 1u << 18u;
    }

    /**
     * Clear SM2_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void clear_SM2_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM2_SHIFTCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM2_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void toggle_SM2_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM2_SHIFTCTRL ^= 1u << 18u;
    }

    /**
     * Get SM2_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline bool get_SM2_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        return SM2_SHIFTCTRL & (1u << 19u);
    }

    /**
     * Set SM2_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void set_SM2_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM2_SHIFTCTRL |= 1u << 19u;
    }

    /**
     * Clear SM2_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void clear_SM2_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM2_SHIFTCTRL &= ~(1u << 19u);
    }

    /**
     * Toggle SM2_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void toggle_SM2_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM2_SHIFTCTRL ^= 1u << 19u;
    }

    /**
     * Get SM2_SHIFTCTRL's PUSH_THRESH field.
     */
    inline uint8_t get_SM2_SHIFTCTRL_PUSH_THRESH() volatile
    {
        return (SM2_SHIFTCTRL >> 20u) & 0b11111u;
    }

    /**
     * Set SM2_SHIFTCTRL's PUSH_THRESH field.
     */
    inline void set_SM2_SHIFTCTRL_PUSH_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM2_SHIFTCTRL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        SM2_SHIFTCTRL = curr;
    }

    /**
     * Get SM2_SHIFTCTRL's PULL_THRESH field.
     */
    inline uint8_t get_SM2_SHIFTCTRL_PULL_THRESH() volatile
    {
        return (SM2_SHIFTCTRL >> 25u) & 0b11111u;
    }

    /**
     * Set SM2_SHIFTCTRL's PULL_THRESH field.
     */
    inline void set_SM2_SHIFTCTRL_PULL_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM2_SHIFTCTRL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        SM2_SHIFTCTRL = curr;
    }

    /**
     * Get SM2_SHIFTCTRL's FJOIN_TX bit.
     */
    inline bool get_SM2_SHIFTCTRL_FJOIN_TX() volatile
    {
        return SM2_SHIFTCTRL & (1u << 30u);
    }

    /**
     * Set SM2_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void set_SM2_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM2_SHIFTCTRL |= 1u << 30u;
    }

    /**
     * Clear SM2_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void clear_SM2_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM2_SHIFTCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM2_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void toggle_SM2_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM2_SHIFTCTRL ^= 1u << 30u;
    }

    /**
     * Get SM2_SHIFTCTRL's FJOIN_RX bit.
     */
    inline bool get_SM2_SHIFTCTRL_FJOIN_RX() volatile
    {
        return SM2_SHIFTCTRL & (1u << 31u);
    }

    /**
     * Set SM2_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void set_SM2_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM2_SHIFTCTRL |= 1u << 31u;
    }

    /**
     * Clear SM2_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void clear_SM2_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM2_SHIFTCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle SM2_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void toggle_SM2_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM2_SHIFTCTRL ^= 1u << 31u;
    }

    /**
     * Get all of SM2_SHIFTCTRL's bit fields.
     */
    inline void get_SM2_SHIFTCTRL(bool &AUTOPUSH, bool &AUTOPULL,
                                  bool &IN_SHIFTDIR, bool &OUT_SHIFTDIR,
                                  uint8_t &PUSH_THRESH, uint8_t &PULL_THRESH,
                                  bool &FJOIN_TX, bool &FJOIN_RX) volatile
    {
        uint32_t curr = SM2_SHIFTCTRL;

        AUTOPUSH = curr & (1u << 16u);
        AUTOPULL = curr & (1u << 17u);
        IN_SHIFTDIR = curr & (1u << 18u);
        OUT_SHIFTDIR = curr & (1u << 19u);
        PUSH_THRESH = (curr >> 20u) & 0b11111u;
        PULL_THRESH = (curr >> 25u) & 0b11111u;
        FJOIN_TX = curr & (1u << 30u);
        FJOIN_RX = curr & (1u << 31u);
    }

    /**
     * Set all of SM2_SHIFTCTRL's bit fields.
     */
    inline void set_SM2_SHIFTCTRL(bool AUTOPUSH, bool AUTOPULL,
                                  bool IN_SHIFTDIR, bool OUT_SHIFTDIR,
                                  uint8_t PUSH_THRESH, uint8_t PULL_THRESH,
                                  bool FJOIN_TX, bool FJOIN_RX) volatile
    {
        uint32_t curr = SM2_SHIFTCTRL;

        curr &= ~(0b1u << 16u);
        curr |= (AUTOPUSH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (AUTOPULL & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (IN_SHIFTDIR & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (OUT_SHIFTDIR & 0b1u) << 19u;
        curr &= ~(0b11111u << 20u);
        curr |= (PUSH_THRESH & 0b11111u) << 20u;
        curr &= ~(0b11111u << 25u);
        curr |= (PULL_THRESH & 0b11111u) << 25u;
        curr &= ~(0b1u << 30u);
        curr |= (FJOIN_TX & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FJOIN_RX & 0b1u) << 31u;

        SM2_SHIFTCTRL = curr;
    }

    /**
     * Get SM2_ADDR's SM2_ADDR field.
     */
    inline uint8_t get_SM2_ADDR_SM2_ADDR() volatile
    {
        return (SM2_ADDR >> 0u) & 0b11111u;
    }

    /**
     * Get SM2_INSTR's SM2_INSTR field.
     */
    inline uint16_t get_SM2_INSTR_SM2_INSTR() volatile
    {
        return (SM2_INSTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set SM2_INSTR's SM2_INSTR field.
     */
    inline void set_SM2_INSTR_SM2_INSTR(uint16_t value) volatile
    {
        uint32_t curr = SM2_INSTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        SM2_INSTR = curr;
    }

    /**
     * Get SM2_PINCTRL's OUT_BASE field.
     */
    inline uint8_t get_SM2_PINCTRL_OUT_BASE() volatile
    {
        return (SM2_PINCTRL >> 0u) & 0b11111u;
    }

    /**
     * Set SM2_PINCTRL's OUT_BASE field.
     */
    inline void set_SM2_PINCTRL_OUT_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM2_PINCTRL's SET_BASE field.
     */
    inline uint8_t get_SM2_PINCTRL_SET_BASE() volatile
    {
        return (SM2_PINCTRL >> 5u) & 0b11111u;
    }

    /**
     * Set SM2_PINCTRL's SET_BASE field.
     */
    inline void set_SM2_PINCTRL_SET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM2_PINCTRL's SIDESET_BASE field.
     */
    inline uint8_t get_SM2_PINCTRL_SIDESET_BASE() volatile
    {
        return (SM2_PINCTRL >> 10u) & 0b11111u;
    }

    /**
     * Set SM2_PINCTRL's SIDESET_BASE field.
     */
    inline void set_SM2_PINCTRL_SIDESET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM2_PINCTRL's IN_BASE field.
     */
    inline uint8_t get_SM2_PINCTRL_IN_BASE() volatile
    {
        return (SM2_PINCTRL >> 15u) & 0b11111u;
    }

    /**
     * Set SM2_PINCTRL's IN_BASE field.
     */
    inline void set_SM2_PINCTRL_IN_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM2_PINCTRL's OUT_COUNT field.
     */
    inline uint8_t get_SM2_PINCTRL_OUT_COUNT() volatile
    {
        return (SM2_PINCTRL >> 20u) & 0b111111u;
    }

    /**
     * Set SM2_PINCTRL's OUT_COUNT field.
     */
    inline void set_SM2_PINCTRL_OUT_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b111111u << 20u);
        curr |= (value & 0b111111u) << 20u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM2_PINCTRL's SET_COUNT field.
     */
    inline uint8_t get_SM2_PINCTRL_SET_COUNT() volatile
    {
        return (SM2_PINCTRL >> 26u) & 0b111u;
    }

    /**
     * Set SM2_PINCTRL's SET_COUNT field.
     */
    inline void set_SM2_PINCTRL_SET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b111u << 26u);
        curr |= (value & 0b111u) << 26u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM2_PINCTRL's SIDESET_COUNT field.
     */
    inline uint8_t get_SM2_PINCTRL_SIDESET_COUNT() volatile
    {
        return (SM2_PINCTRL >> 29u) & 0b111u;
    }

    /**
     * Set SM2_PINCTRL's SIDESET_COUNT field.
     */
    inline void set_SM2_PINCTRL_SIDESET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b111u << 29u);
        curr |= (value & 0b111u) << 29u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get all of SM2_PINCTRL's bit fields.
     */
    inline void get_SM2_PINCTRL(uint8_t &OUT_BASE, uint8_t &SET_BASE,
                                uint8_t &SIDESET_BASE, uint8_t &IN_BASE,
                                uint8_t &OUT_COUNT, uint8_t &SET_COUNT,
                                uint8_t &SIDESET_COUNT) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        OUT_BASE = (curr >> 0u) & 0b11111u;
        SET_BASE = (curr >> 5u) & 0b11111u;
        SIDESET_BASE = (curr >> 10u) & 0b11111u;
        IN_BASE = (curr >> 15u) & 0b11111u;
        OUT_COUNT = (curr >> 20u) & 0b111111u;
        SET_COUNT = (curr >> 26u) & 0b111u;
        SIDESET_COUNT = (curr >> 29u) & 0b111u;
    }

    /**
     * Set all of SM2_PINCTRL's bit fields.
     */
    inline void set_SM2_PINCTRL(uint8_t OUT_BASE, uint8_t SET_BASE,
                                uint8_t SIDESET_BASE, uint8_t IN_BASE,
                                uint8_t OUT_COUNT, uint8_t SET_COUNT,
                                uint8_t SIDESET_COUNT) volatile
    {
        uint32_t curr = SM2_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (OUT_BASE & 0b11111u) << 0u;
        curr &= ~(0b11111u << 5u);
        curr |= (SET_BASE & 0b11111u) << 5u;
        curr &= ~(0b11111u << 10u);
        curr |= (SIDESET_BASE & 0b11111u) << 10u;
        curr &= ~(0b11111u << 15u);
        curr |= (IN_BASE & 0b11111u) << 15u;
        curr &= ~(0b111111u << 20u);
        curr |= (OUT_COUNT & 0b111111u) << 20u;
        curr &= ~(0b111u << 26u);
        curr |= (SET_COUNT & 0b111u) << 26u;
        curr &= ~(0b111u << 29u);
        curr |= (SIDESET_COUNT & 0b111u) << 29u;

        SM2_PINCTRL = curr;
    }

    /**
     * Get SM3_CLKDIV's FRAC field.
     */
    inline uint8_t get_SM3_CLKDIV_FRAC() volatile
    {
        return (SM3_CLKDIV >> 8u) & 0b11111111u;
    }

    /**
     * Set SM3_CLKDIV's FRAC field.
     */
    inline void set_SM3_CLKDIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = SM3_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SM3_CLKDIV = curr;
    }

    /**
     * Get SM3_CLKDIV's INT field.
     */
    inline uint16_t get_SM3_CLKDIV_INT() volatile
    {
        return (SM3_CLKDIV >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SM3_CLKDIV's INT field.
     */
    inline void set_SM3_CLKDIV_INT(uint16_t value) volatile
    {
        uint32_t curr = SM3_CLKDIV;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SM3_CLKDIV = curr;
    }

    /**
     * Get all of SM3_CLKDIV's bit fields.
     */
    inline void get_SM3_CLKDIV(uint8_t &FRAC, uint16_t &INT) volatile
    {
        uint32_t curr = SM3_CLKDIV;

        FRAC = (curr >> 8u) & 0b11111111u;
        INT = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of SM3_CLKDIV's bit fields.
     */
    inline void set_SM3_CLKDIV(uint8_t FRAC, uint16_t INT) volatile
    {
        uint32_t curr = SM3_CLKDIV;

        curr &= ~(0b11111111u << 8u);
        curr |= (FRAC & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (INT & 0b1111111111111111u) << 16u;

        SM3_CLKDIV = curr;
    }

    /**
     * Get SM3_EXECCTRL's STATUS_N field.
     */
    inline uint8_t get_SM3_EXECCTRL_STATUS_N() volatile
    {
        return (SM3_EXECCTRL >> 0u) & 0b1111u;
    }

    /**
     * Set SM3_EXECCTRL's STATUS_N field.
     */
    inline void set_SM3_EXECCTRL_STATUS_N(uint8_t value) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        SM3_EXECCTRL = curr;
    }

    /**
     * Get SM3_EXECCTRL's STATUS_SEL bit.
     */
    inline PIO0_SM3_EXECCTRL_STATUS_SEL get_SM3_EXECCTRL_STATUS_SEL() volatile
    {
        return PIO0_SM3_EXECCTRL_STATUS_SEL(SM3_EXECCTRL & (1u << 4u));
    }

    /**
     * Set SM3_EXECCTRL's STATUS_SEL bit.
     */
    inline void set_SM3_EXECCTRL_STATUS_SEL() volatile
    {
        SM3_EXECCTRL |= 1u << 4u;
    }

    /**
     * Clear SM3_EXECCTRL's STATUS_SEL bit.
     */
    inline void clear_SM3_EXECCTRL_STATUS_SEL() volatile
    {
        SM3_EXECCTRL &= ~(1u << 4u);
    }

    /**
     * Toggle SM3_EXECCTRL's STATUS_SEL bit.
     */
    inline void toggle_SM3_EXECCTRL_STATUS_SEL() volatile
    {
        SM3_EXECCTRL ^= 1u << 4u;
    }

    /**
     * Get SM3_EXECCTRL's WRAP_BOTTOM field.
     */
    inline uint8_t get_SM3_EXECCTRL_WRAP_BOTTOM() volatile
    {
        return (SM3_EXECCTRL >> 7u) & 0b11111u;
    }

    /**
     * Set SM3_EXECCTRL's WRAP_BOTTOM field.
     */
    inline void set_SM3_EXECCTRL_WRAP_BOTTOM(uint8_t value) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        curr &= ~(0b11111u << 7u);
        curr |= (value & 0b11111u) << 7u;

        SM3_EXECCTRL = curr;
    }

    /**
     * Get SM3_EXECCTRL's WRAP_TOP field.
     */
    inline uint8_t get_SM3_EXECCTRL_WRAP_TOP() volatile
    {
        return (SM3_EXECCTRL >> 12u) & 0b11111u;
    }

    /**
     * Set SM3_EXECCTRL's WRAP_TOP field.
     */
    inline void set_SM3_EXECCTRL_WRAP_TOP(uint8_t value) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        curr &= ~(0b11111u << 12u);
        curr |= (value & 0b11111u) << 12u;

        SM3_EXECCTRL = curr;
    }

    /**
     * Get SM3_EXECCTRL's OUT_STICKY bit.
     */
    inline bool get_SM3_EXECCTRL_OUT_STICKY() volatile
    {
        return SM3_EXECCTRL & (1u << 17u);
    }

    /**
     * Set SM3_EXECCTRL's OUT_STICKY bit.
     */
    inline void set_SM3_EXECCTRL_OUT_STICKY() volatile
    {
        SM3_EXECCTRL |= 1u << 17u;
    }

    /**
     * Clear SM3_EXECCTRL's OUT_STICKY bit.
     */
    inline void clear_SM3_EXECCTRL_OUT_STICKY() volatile
    {
        SM3_EXECCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM3_EXECCTRL's OUT_STICKY bit.
     */
    inline void toggle_SM3_EXECCTRL_OUT_STICKY() volatile
    {
        SM3_EXECCTRL ^= 1u << 17u;
    }

    /**
     * Get SM3_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline bool get_SM3_EXECCTRL_INLINE_OUT_EN() volatile
    {
        return SM3_EXECCTRL & (1u << 18u);
    }

    /**
     * Set SM3_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void set_SM3_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM3_EXECCTRL |= 1u << 18u;
    }

    /**
     * Clear SM3_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void clear_SM3_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM3_EXECCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM3_EXECCTRL's INLINE_OUT_EN bit.
     */
    inline void toggle_SM3_EXECCTRL_INLINE_OUT_EN() volatile
    {
        SM3_EXECCTRL ^= 1u << 18u;
    }

    /**
     * Get SM3_EXECCTRL's OUT_EN_SEL field.
     */
    inline uint8_t get_SM3_EXECCTRL_OUT_EN_SEL() volatile
    {
        return (SM3_EXECCTRL >> 19u) & 0b11111u;
    }

    /**
     * Set SM3_EXECCTRL's OUT_EN_SEL field.
     */
    inline void set_SM3_EXECCTRL_OUT_EN_SEL(uint8_t value) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        curr &= ~(0b11111u << 19u);
        curr |= (value & 0b11111u) << 19u;

        SM3_EXECCTRL = curr;
    }

    /**
     * Get SM3_EXECCTRL's JMP_PIN field.
     */
    inline uint8_t get_SM3_EXECCTRL_JMP_PIN() volatile
    {
        return (SM3_EXECCTRL >> 24u) & 0b11111u;
    }

    /**
     * Set SM3_EXECCTRL's JMP_PIN field.
     */
    inline void set_SM3_EXECCTRL_JMP_PIN(uint8_t value) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        curr &= ~(0b11111u << 24u);
        curr |= (value & 0b11111u) << 24u;

        SM3_EXECCTRL = curr;
    }

    /**
     * Get SM3_EXECCTRL's SIDE_PINDIR bit.
     */
    inline bool get_SM3_EXECCTRL_SIDE_PINDIR() volatile
    {
        return SM3_EXECCTRL & (1u << 29u);
    }

    /**
     * Set SM3_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void set_SM3_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM3_EXECCTRL |= 1u << 29u;
    }

    /**
     * Clear SM3_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void clear_SM3_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM3_EXECCTRL &= ~(1u << 29u);
    }

    /**
     * Toggle SM3_EXECCTRL's SIDE_PINDIR bit.
     */
    inline void toggle_SM3_EXECCTRL_SIDE_PINDIR() volatile
    {
        SM3_EXECCTRL ^= 1u << 29u;
    }

    /**
     * Get SM3_EXECCTRL's SIDE_EN bit.
     */
    inline bool get_SM3_EXECCTRL_SIDE_EN() volatile
    {
        return SM3_EXECCTRL & (1u << 30u);
    }

    /**
     * Set SM3_EXECCTRL's SIDE_EN bit.
     */
    inline void set_SM3_EXECCTRL_SIDE_EN() volatile
    {
        SM3_EXECCTRL |= 1u << 30u;
    }

    /**
     * Clear SM3_EXECCTRL's SIDE_EN bit.
     */
    inline void clear_SM3_EXECCTRL_SIDE_EN() volatile
    {
        SM3_EXECCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM3_EXECCTRL's SIDE_EN bit.
     */
    inline void toggle_SM3_EXECCTRL_SIDE_EN() volatile
    {
        SM3_EXECCTRL ^= 1u << 30u;
    }

    /**
     * Get SM3_EXECCTRL's EXEC_STALLED bit.
     */
    inline bool get_SM3_EXECCTRL_EXEC_STALLED() volatile
    {
        return SM3_EXECCTRL & (1u << 31u);
    }

    /**
     * Get all of SM3_EXECCTRL's bit fields.
     */
    inline void get_SM3_EXECCTRL(uint8_t &STATUS_N,
                                 PIO0_SM3_EXECCTRL_STATUS_SEL &STATUS_SEL,
                                 uint8_t &WRAP_BOTTOM, uint8_t &WRAP_TOP,
                                 bool &OUT_STICKY, bool &INLINE_OUT_EN,
                                 uint8_t &OUT_EN_SEL, uint8_t &JMP_PIN,
                                 bool &SIDE_PINDIR, bool &SIDE_EN,
                                 bool &EXEC_STALLED) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        STATUS_N = (curr >> 0u) & 0b1111u;
        STATUS_SEL = PIO0_SM3_EXECCTRL_STATUS_SEL(curr & (1u << 4u));
        WRAP_BOTTOM = (curr >> 7u) & 0b11111u;
        WRAP_TOP = (curr >> 12u) & 0b11111u;
        OUT_STICKY = curr & (1u << 17u);
        INLINE_OUT_EN = curr & (1u << 18u);
        OUT_EN_SEL = (curr >> 19u) & 0b11111u;
        JMP_PIN = (curr >> 24u) & 0b11111u;
        SIDE_PINDIR = curr & (1u << 29u);
        SIDE_EN = curr & (1u << 30u);
        EXEC_STALLED = curr & (1u << 31u);
    }

    /**
     * Set all of SM3_EXECCTRL's bit fields.
     */
    inline void set_SM3_EXECCTRL(uint8_t STATUS_N,
                                 PIO0_SM3_EXECCTRL_STATUS_SEL STATUS_SEL,
                                 uint8_t WRAP_BOTTOM, uint8_t WRAP_TOP,
                                 bool OUT_STICKY, bool INLINE_OUT_EN,
                                 uint8_t OUT_EN_SEL, uint8_t JMP_PIN,
                                 bool SIDE_PINDIR, bool SIDE_EN) volatile
    {
        uint32_t curr = SM3_EXECCTRL;

        curr &= ~(0b1111u << 0u);
        curr |= (STATUS_N & 0b1111u) << 0u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(STATUS_SEL) & 0b1u) << 4u;
        curr &= ~(0b11111u << 7u);
        curr |= (WRAP_BOTTOM & 0b11111u) << 7u;
        curr &= ~(0b11111u << 12u);
        curr |= (WRAP_TOP & 0b11111u) << 12u;
        curr &= ~(0b1u << 17u);
        curr |= (OUT_STICKY & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (INLINE_OUT_EN & 0b1u) << 18u;
        curr &= ~(0b11111u << 19u);
        curr |= (OUT_EN_SEL & 0b11111u) << 19u;
        curr &= ~(0b11111u << 24u);
        curr |= (JMP_PIN & 0b11111u) << 24u;
        curr &= ~(0b1u << 29u);
        curr |= (SIDE_PINDIR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (SIDE_EN & 0b1u) << 30u;

        SM3_EXECCTRL = curr;
    }

    /**
     * Get SM3_SHIFTCTRL's AUTOPUSH bit.
     */
    inline bool get_SM3_SHIFTCTRL_AUTOPUSH() volatile
    {
        return SM3_SHIFTCTRL & (1u << 16u);
    }

    /**
     * Set SM3_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void set_SM3_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM3_SHIFTCTRL |= 1u << 16u;
    }

    /**
     * Clear SM3_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void clear_SM3_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM3_SHIFTCTRL &= ~(1u << 16u);
    }

    /**
     * Toggle SM3_SHIFTCTRL's AUTOPUSH bit.
     */
    inline void toggle_SM3_SHIFTCTRL_AUTOPUSH() volatile
    {
        SM3_SHIFTCTRL ^= 1u << 16u;
    }

    /**
     * Get SM3_SHIFTCTRL's AUTOPULL bit.
     */
    inline bool get_SM3_SHIFTCTRL_AUTOPULL() volatile
    {
        return SM3_SHIFTCTRL & (1u << 17u);
    }

    /**
     * Set SM3_SHIFTCTRL's AUTOPULL bit.
     */
    inline void set_SM3_SHIFTCTRL_AUTOPULL() volatile
    {
        SM3_SHIFTCTRL |= 1u << 17u;
    }

    /**
     * Clear SM3_SHIFTCTRL's AUTOPULL bit.
     */
    inline void clear_SM3_SHIFTCTRL_AUTOPULL() volatile
    {
        SM3_SHIFTCTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SM3_SHIFTCTRL's AUTOPULL bit.
     */
    inline void toggle_SM3_SHIFTCTRL_AUTOPULL() volatile
    {
        SM3_SHIFTCTRL ^= 1u << 17u;
    }

    /**
     * Get SM3_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline bool get_SM3_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        return SM3_SHIFTCTRL & (1u << 18u);
    }

    /**
     * Set SM3_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void set_SM3_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM3_SHIFTCTRL |= 1u << 18u;
    }

    /**
     * Clear SM3_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void clear_SM3_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM3_SHIFTCTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SM3_SHIFTCTRL's IN_SHIFTDIR bit.
     */
    inline void toggle_SM3_SHIFTCTRL_IN_SHIFTDIR() volatile
    {
        SM3_SHIFTCTRL ^= 1u << 18u;
    }

    /**
     * Get SM3_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline bool get_SM3_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        return SM3_SHIFTCTRL & (1u << 19u);
    }

    /**
     * Set SM3_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void set_SM3_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM3_SHIFTCTRL |= 1u << 19u;
    }

    /**
     * Clear SM3_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void clear_SM3_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM3_SHIFTCTRL &= ~(1u << 19u);
    }

    /**
     * Toggle SM3_SHIFTCTRL's OUT_SHIFTDIR bit.
     */
    inline void toggle_SM3_SHIFTCTRL_OUT_SHIFTDIR() volatile
    {
        SM3_SHIFTCTRL ^= 1u << 19u;
    }

    /**
     * Get SM3_SHIFTCTRL's PUSH_THRESH field.
     */
    inline uint8_t get_SM3_SHIFTCTRL_PUSH_THRESH() volatile
    {
        return (SM3_SHIFTCTRL >> 20u) & 0b11111u;
    }

    /**
     * Set SM3_SHIFTCTRL's PUSH_THRESH field.
     */
    inline void set_SM3_SHIFTCTRL_PUSH_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM3_SHIFTCTRL;

        curr &= ~(0b11111u << 20u);
        curr |= (value & 0b11111u) << 20u;

        SM3_SHIFTCTRL = curr;
    }

    /**
     * Get SM3_SHIFTCTRL's PULL_THRESH field.
     */
    inline uint8_t get_SM3_SHIFTCTRL_PULL_THRESH() volatile
    {
        return (SM3_SHIFTCTRL >> 25u) & 0b11111u;
    }

    /**
     * Set SM3_SHIFTCTRL's PULL_THRESH field.
     */
    inline void set_SM3_SHIFTCTRL_PULL_THRESH(uint8_t value) volatile
    {
        uint32_t curr = SM3_SHIFTCTRL;

        curr &= ~(0b11111u << 25u);
        curr |= (value & 0b11111u) << 25u;

        SM3_SHIFTCTRL = curr;
    }

    /**
     * Get SM3_SHIFTCTRL's FJOIN_TX bit.
     */
    inline bool get_SM3_SHIFTCTRL_FJOIN_TX() volatile
    {
        return SM3_SHIFTCTRL & (1u << 30u);
    }

    /**
     * Set SM3_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void set_SM3_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM3_SHIFTCTRL |= 1u << 30u;
    }

    /**
     * Clear SM3_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void clear_SM3_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM3_SHIFTCTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SM3_SHIFTCTRL's FJOIN_TX bit.
     */
    inline void toggle_SM3_SHIFTCTRL_FJOIN_TX() volatile
    {
        SM3_SHIFTCTRL ^= 1u << 30u;
    }

    /**
     * Get SM3_SHIFTCTRL's FJOIN_RX bit.
     */
    inline bool get_SM3_SHIFTCTRL_FJOIN_RX() volatile
    {
        return SM3_SHIFTCTRL & (1u << 31u);
    }

    /**
     * Set SM3_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void set_SM3_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM3_SHIFTCTRL |= 1u << 31u;
    }

    /**
     * Clear SM3_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void clear_SM3_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM3_SHIFTCTRL &= ~(1u << 31u);
    }

    /**
     * Toggle SM3_SHIFTCTRL's FJOIN_RX bit.
     */
    inline void toggle_SM3_SHIFTCTRL_FJOIN_RX() volatile
    {
        SM3_SHIFTCTRL ^= 1u << 31u;
    }

    /**
     * Get all of SM3_SHIFTCTRL's bit fields.
     */
    inline void get_SM3_SHIFTCTRL(bool &AUTOPUSH, bool &AUTOPULL,
                                  bool &IN_SHIFTDIR, bool &OUT_SHIFTDIR,
                                  uint8_t &PUSH_THRESH, uint8_t &PULL_THRESH,
                                  bool &FJOIN_TX, bool &FJOIN_RX) volatile
    {
        uint32_t curr = SM3_SHIFTCTRL;

        AUTOPUSH = curr & (1u << 16u);
        AUTOPULL = curr & (1u << 17u);
        IN_SHIFTDIR = curr & (1u << 18u);
        OUT_SHIFTDIR = curr & (1u << 19u);
        PUSH_THRESH = (curr >> 20u) & 0b11111u;
        PULL_THRESH = (curr >> 25u) & 0b11111u;
        FJOIN_TX = curr & (1u << 30u);
        FJOIN_RX = curr & (1u << 31u);
    }

    /**
     * Set all of SM3_SHIFTCTRL's bit fields.
     */
    inline void set_SM3_SHIFTCTRL(bool AUTOPUSH, bool AUTOPULL,
                                  bool IN_SHIFTDIR, bool OUT_SHIFTDIR,
                                  uint8_t PUSH_THRESH, uint8_t PULL_THRESH,
                                  bool FJOIN_TX, bool FJOIN_RX) volatile
    {
        uint32_t curr = SM3_SHIFTCTRL;

        curr &= ~(0b1u << 16u);
        curr |= (AUTOPUSH & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (AUTOPULL & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (IN_SHIFTDIR & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (OUT_SHIFTDIR & 0b1u) << 19u;
        curr &= ~(0b11111u << 20u);
        curr |= (PUSH_THRESH & 0b11111u) << 20u;
        curr &= ~(0b11111u << 25u);
        curr |= (PULL_THRESH & 0b11111u) << 25u;
        curr &= ~(0b1u << 30u);
        curr |= (FJOIN_TX & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FJOIN_RX & 0b1u) << 31u;

        SM3_SHIFTCTRL = curr;
    }

    /**
     * Get SM3_ADDR's SM3_ADDR field.
     */
    inline uint8_t get_SM3_ADDR_SM3_ADDR() volatile
    {
        return (SM3_ADDR >> 0u) & 0b11111u;
    }

    /**
     * Get SM3_INSTR's SM3_INSTR field.
     */
    inline uint16_t get_SM3_INSTR_SM3_INSTR() volatile
    {
        return (SM3_INSTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set SM3_INSTR's SM3_INSTR field.
     */
    inline void set_SM3_INSTR_SM3_INSTR(uint16_t value) volatile
    {
        uint32_t curr = SM3_INSTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        SM3_INSTR = curr;
    }

    /**
     * Get SM3_PINCTRL's OUT_BASE field.
     */
    inline uint8_t get_SM3_PINCTRL_OUT_BASE() volatile
    {
        return (SM3_PINCTRL >> 0u) & 0b11111u;
    }

    /**
     * Set SM3_PINCTRL's OUT_BASE field.
     */
    inline void set_SM3_PINCTRL_OUT_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get SM3_PINCTRL's SET_BASE field.
     */
    inline uint8_t get_SM3_PINCTRL_SET_BASE() volatile
    {
        return (SM3_PINCTRL >> 5u) & 0b11111u;
    }

    /**
     * Set SM3_PINCTRL's SET_BASE field.
     */
    inline void set_SM3_PINCTRL_SET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b11111u << 5u);
        curr |= (value & 0b11111u) << 5u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get SM3_PINCTRL's SIDESET_BASE field.
     */
    inline uint8_t get_SM3_PINCTRL_SIDESET_BASE() volatile
    {
        return (SM3_PINCTRL >> 10u) & 0b11111u;
    }

    /**
     * Set SM3_PINCTRL's SIDESET_BASE field.
     */
    inline void set_SM3_PINCTRL_SIDESET_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b11111u << 10u);
        curr |= (value & 0b11111u) << 10u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get SM3_PINCTRL's IN_BASE field.
     */
    inline uint8_t get_SM3_PINCTRL_IN_BASE() volatile
    {
        return (SM3_PINCTRL >> 15u) & 0b11111u;
    }

    /**
     * Set SM3_PINCTRL's IN_BASE field.
     */
    inline void set_SM3_PINCTRL_IN_BASE(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b11111u << 15u);
        curr |= (value & 0b11111u) << 15u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get SM3_PINCTRL's OUT_COUNT field.
     */
    inline uint8_t get_SM3_PINCTRL_OUT_COUNT() volatile
    {
        return (SM3_PINCTRL >> 20u) & 0b111111u;
    }

    /**
     * Set SM3_PINCTRL's OUT_COUNT field.
     */
    inline void set_SM3_PINCTRL_OUT_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b111111u << 20u);
        curr |= (value & 0b111111u) << 20u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get SM3_PINCTRL's SET_COUNT field.
     */
    inline uint8_t get_SM3_PINCTRL_SET_COUNT() volatile
    {
        return (SM3_PINCTRL >> 26u) & 0b111u;
    }

    /**
     * Set SM3_PINCTRL's SET_COUNT field.
     */
    inline void set_SM3_PINCTRL_SET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b111u << 26u);
        curr |= (value & 0b111u) << 26u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get SM3_PINCTRL's SIDESET_COUNT field.
     */
    inline uint8_t get_SM3_PINCTRL_SIDESET_COUNT() volatile
    {
        return (SM3_PINCTRL >> 29u) & 0b111u;
    }

    /**
     * Set SM3_PINCTRL's SIDESET_COUNT field.
     */
    inline void set_SM3_PINCTRL_SIDESET_COUNT(uint8_t value) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b111u << 29u);
        curr |= (value & 0b111u) << 29u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get all of SM3_PINCTRL's bit fields.
     */
    inline void get_SM3_PINCTRL(uint8_t &OUT_BASE, uint8_t &SET_BASE,
                                uint8_t &SIDESET_BASE, uint8_t &IN_BASE,
                                uint8_t &OUT_COUNT, uint8_t &SET_COUNT,
                                uint8_t &SIDESET_COUNT) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        OUT_BASE = (curr >> 0u) & 0b11111u;
        SET_BASE = (curr >> 5u) & 0b11111u;
        SIDESET_BASE = (curr >> 10u) & 0b11111u;
        IN_BASE = (curr >> 15u) & 0b11111u;
        OUT_COUNT = (curr >> 20u) & 0b111111u;
        SET_COUNT = (curr >> 26u) & 0b111u;
        SIDESET_COUNT = (curr >> 29u) & 0b111u;
    }

    /**
     * Set all of SM3_PINCTRL's bit fields.
     */
    inline void set_SM3_PINCTRL(uint8_t OUT_BASE, uint8_t SET_BASE,
                                uint8_t SIDESET_BASE, uint8_t IN_BASE,
                                uint8_t OUT_COUNT, uint8_t SET_COUNT,
                                uint8_t SIDESET_COUNT) volatile
    {
        uint32_t curr = SM3_PINCTRL;

        curr &= ~(0b11111u << 0u);
        curr |= (OUT_BASE & 0b11111u) << 0u;
        curr &= ~(0b11111u << 5u);
        curr |= (SET_BASE & 0b11111u) << 5u;
        curr &= ~(0b11111u << 10u);
        curr |= (SIDESET_BASE & 0b11111u) << 10u;
        curr &= ~(0b11111u << 15u);
        curr |= (IN_BASE & 0b11111u) << 15u;
        curr &= ~(0b111111u << 20u);
        curr |= (OUT_COUNT & 0b111111u) << 20u;
        curr &= ~(0b111u << 26u);
        curr |= (SET_COUNT & 0b111u) << 26u;
        curr &= ~(0b111u << 29u);
        curr |= (SIDESET_COUNT & 0b111u) << 29u;

        SM3_PINCTRL = curr;
    }

    /**
     * Get INTR's SM0_RXNEMPTY bit.
     */
    inline bool get_INTR_SM0_RXNEMPTY() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Get INTR's SM1_RXNEMPTY bit.
     */
    inline bool get_INTR_SM1_RXNEMPTY() volatile
    {
        return INTR & (1u << 1u);
    }

    /**
     * Get INTR's SM2_RXNEMPTY bit.
     */
    inline bool get_INTR_SM2_RXNEMPTY() volatile
    {
        return INTR & (1u << 2u);
    }

    /**
     * Get INTR's SM3_RXNEMPTY bit.
     */
    inline bool get_INTR_SM3_RXNEMPTY() volatile
    {
        return INTR & (1u << 3u);
    }

    /**
     * Get INTR's SM0_TXNFULL bit.
     */
    inline bool get_INTR_SM0_TXNFULL() volatile
    {
        return INTR & (1u << 4u);
    }

    /**
     * Get INTR's SM1_TXNFULL bit.
     */
    inline bool get_INTR_SM1_TXNFULL() volatile
    {
        return INTR & (1u << 5u);
    }

    /**
     * Get INTR's SM2_TXNFULL bit.
     */
    inline bool get_INTR_SM2_TXNFULL() volatile
    {
        return INTR & (1u << 6u);
    }

    /**
     * Get INTR's SM3_TXNFULL bit.
     */
    inline bool get_INTR_SM3_TXNFULL() volatile
    {
        return INTR & (1u << 7u);
    }

    /**
     * Get INTR's SM0 bit.
     */
    inline bool get_INTR_SM0() volatile
    {
        return INTR & (1u << 8u);
    }

    /**
     * Get INTR's SM1 bit.
     */
    inline bool get_INTR_SM1() volatile
    {
        return INTR & (1u << 9u);
    }

    /**
     * Get INTR's SM2 bit.
     */
    inline bool get_INTR_SM2() volatile
    {
        return INTR & (1u << 10u);
    }

    /**
     * Get INTR's SM3 bit.
     */
    inline bool get_INTR_SM3() volatile
    {
        return INTR & (1u << 11u);
    }

    /**
     * Get all of INTR's bit fields.
     */
    inline void get_INTR(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                         bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                         bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                         bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                         bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = INTR;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }

    /**
     * Get IRQ0_INTE's SM0_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTE_SM0_RXNEMPTY() volatile
    {
        return IRQ0_INTE & (1u << 0u);
    }

    /**
     * Set IRQ0_INTE's SM0_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTE_SM0_RXNEMPTY() volatile
    {
        IRQ0_INTE |= 1u << 0u;
    }

    /**
     * Clear IRQ0_INTE's SM0_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTE_SM0_RXNEMPTY() volatile
    {
        IRQ0_INTE &= ~(1u << 0u);
    }

    /**
     * Toggle IRQ0_INTE's SM0_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTE_SM0_RXNEMPTY() volatile
    {
        IRQ0_INTE ^= 1u << 0u;
    }

    /**
     * Get IRQ0_INTE's SM1_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTE_SM1_RXNEMPTY() volatile
    {
        return IRQ0_INTE & (1u << 1u);
    }

    /**
     * Set IRQ0_INTE's SM1_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTE_SM1_RXNEMPTY() volatile
    {
        IRQ0_INTE |= 1u << 1u;
    }

    /**
     * Clear IRQ0_INTE's SM1_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTE_SM1_RXNEMPTY() volatile
    {
        IRQ0_INTE &= ~(1u << 1u);
    }

    /**
     * Toggle IRQ0_INTE's SM1_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTE_SM1_RXNEMPTY() volatile
    {
        IRQ0_INTE ^= 1u << 1u;
    }

    /**
     * Get IRQ0_INTE's SM2_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTE_SM2_RXNEMPTY() volatile
    {
        return IRQ0_INTE & (1u << 2u);
    }

    /**
     * Set IRQ0_INTE's SM2_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTE_SM2_RXNEMPTY() volatile
    {
        IRQ0_INTE |= 1u << 2u;
    }

    /**
     * Clear IRQ0_INTE's SM2_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTE_SM2_RXNEMPTY() volatile
    {
        IRQ0_INTE &= ~(1u << 2u);
    }

    /**
     * Toggle IRQ0_INTE's SM2_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTE_SM2_RXNEMPTY() volatile
    {
        IRQ0_INTE ^= 1u << 2u;
    }

    /**
     * Get IRQ0_INTE's SM3_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTE_SM3_RXNEMPTY() volatile
    {
        return IRQ0_INTE & (1u << 3u);
    }

    /**
     * Set IRQ0_INTE's SM3_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTE_SM3_RXNEMPTY() volatile
    {
        IRQ0_INTE |= 1u << 3u;
    }

    /**
     * Clear IRQ0_INTE's SM3_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTE_SM3_RXNEMPTY() volatile
    {
        IRQ0_INTE &= ~(1u << 3u);
    }

    /**
     * Toggle IRQ0_INTE's SM3_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTE_SM3_RXNEMPTY() volatile
    {
        IRQ0_INTE ^= 1u << 3u;
    }

    /**
     * Get IRQ0_INTE's SM0_TXNFULL bit.
     */
    inline bool get_IRQ0_INTE_SM0_TXNFULL() volatile
    {
        return IRQ0_INTE & (1u << 4u);
    }

    /**
     * Set IRQ0_INTE's SM0_TXNFULL bit.
     */
    inline void set_IRQ0_INTE_SM0_TXNFULL() volatile
    {
        IRQ0_INTE |= 1u << 4u;
    }

    /**
     * Clear IRQ0_INTE's SM0_TXNFULL bit.
     */
    inline void clear_IRQ0_INTE_SM0_TXNFULL() volatile
    {
        IRQ0_INTE &= ~(1u << 4u);
    }

    /**
     * Toggle IRQ0_INTE's SM0_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTE_SM0_TXNFULL() volatile
    {
        IRQ0_INTE ^= 1u << 4u;
    }

    /**
     * Get IRQ0_INTE's SM1_TXNFULL bit.
     */
    inline bool get_IRQ0_INTE_SM1_TXNFULL() volatile
    {
        return IRQ0_INTE & (1u << 5u);
    }

    /**
     * Set IRQ0_INTE's SM1_TXNFULL bit.
     */
    inline void set_IRQ0_INTE_SM1_TXNFULL() volatile
    {
        IRQ0_INTE |= 1u << 5u;
    }

    /**
     * Clear IRQ0_INTE's SM1_TXNFULL bit.
     */
    inline void clear_IRQ0_INTE_SM1_TXNFULL() volatile
    {
        IRQ0_INTE &= ~(1u << 5u);
    }

    /**
     * Toggle IRQ0_INTE's SM1_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTE_SM1_TXNFULL() volatile
    {
        IRQ0_INTE ^= 1u << 5u;
    }

    /**
     * Get IRQ0_INTE's SM2_TXNFULL bit.
     */
    inline bool get_IRQ0_INTE_SM2_TXNFULL() volatile
    {
        return IRQ0_INTE & (1u << 6u);
    }

    /**
     * Set IRQ0_INTE's SM2_TXNFULL bit.
     */
    inline void set_IRQ0_INTE_SM2_TXNFULL() volatile
    {
        IRQ0_INTE |= 1u << 6u;
    }

    /**
     * Clear IRQ0_INTE's SM2_TXNFULL bit.
     */
    inline void clear_IRQ0_INTE_SM2_TXNFULL() volatile
    {
        IRQ0_INTE &= ~(1u << 6u);
    }

    /**
     * Toggle IRQ0_INTE's SM2_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTE_SM2_TXNFULL() volatile
    {
        IRQ0_INTE ^= 1u << 6u;
    }

    /**
     * Get IRQ0_INTE's SM3_TXNFULL bit.
     */
    inline bool get_IRQ0_INTE_SM3_TXNFULL() volatile
    {
        return IRQ0_INTE & (1u << 7u);
    }

    /**
     * Set IRQ0_INTE's SM3_TXNFULL bit.
     */
    inline void set_IRQ0_INTE_SM3_TXNFULL() volatile
    {
        IRQ0_INTE |= 1u << 7u;
    }

    /**
     * Clear IRQ0_INTE's SM3_TXNFULL bit.
     */
    inline void clear_IRQ0_INTE_SM3_TXNFULL() volatile
    {
        IRQ0_INTE &= ~(1u << 7u);
    }

    /**
     * Toggle IRQ0_INTE's SM3_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTE_SM3_TXNFULL() volatile
    {
        IRQ0_INTE ^= 1u << 7u;
    }

    /**
     * Get IRQ0_INTE's SM0 bit.
     */
    inline bool get_IRQ0_INTE_SM0() volatile
    {
        return IRQ0_INTE & (1u << 8u);
    }

    /**
     * Set IRQ0_INTE's SM0 bit.
     */
    inline void set_IRQ0_INTE_SM0() volatile
    {
        IRQ0_INTE |= 1u << 8u;
    }

    /**
     * Clear IRQ0_INTE's SM0 bit.
     */
    inline void clear_IRQ0_INTE_SM0() volatile
    {
        IRQ0_INTE &= ~(1u << 8u);
    }

    /**
     * Toggle IRQ0_INTE's SM0 bit.
     */
    inline void toggle_IRQ0_INTE_SM0() volatile
    {
        IRQ0_INTE ^= 1u << 8u;
    }

    /**
     * Get IRQ0_INTE's SM1 bit.
     */
    inline bool get_IRQ0_INTE_SM1() volatile
    {
        return IRQ0_INTE & (1u << 9u);
    }

    /**
     * Set IRQ0_INTE's SM1 bit.
     */
    inline void set_IRQ0_INTE_SM1() volatile
    {
        IRQ0_INTE |= 1u << 9u;
    }

    /**
     * Clear IRQ0_INTE's SM1 bit.
     */
    inline void clear_IRQ0_INTE_SM1() volatile
    {
        IRQ0_INTE &= ~(1u << 9u);
    }

    /**
     * Toggle IRQ0_INTE's SM1 bit.
     */
    inline void toggle_IRQ0_INTE_SM1() volatile
    {
        IRQ0_INTE ^= 1u << 9u;
    }

    /**
     * Get IRQ0_INTE's SM2 bit.
     */
    inline bool get_IRQ0_INTE_SM2() volatile
    {
        return IRQ0_INTE & (1u << 10u);
    }

    /**
     * Set IRQ0_INTE's SM2 bit.
     */
    inline void set_IRQ0_INTE_SM2() volatile
    {
        IRQ0_INTE |= 1u << 10u;
    }

    /**
     * Clear IRQ0_INTE's SM2 bit.
     */
    inline void clear_IRQ0_INTE_SM2() volatile
    {
        IRQ0_INTE &= ~(1u << 10u);
    }

    /**
     * Toggle IRQ0_INTE's SM2 bit.
     */
    inline void toggle_IRQ0_INTE_SM2() volatile
    {
        IRQ0_INTE ^= 1u << 10u;
    }

    /**
     * Get IRQ0_INTE's SM3 bit.
     */
    inline bool get_IRQ0_INTE_SM3() volatile
    {
        return IRQ0_INTE & (1u << 11u);
    }

    /**
     * Set IRQ0_INTE's SM3 bit.
     */
    inline void set_IRQ0_INTE_SM3() volatile
    {
        IRQ0_INTE |= 1u << 11u;
    }

    /**
     * Clear IRQ0_INTE's SM3 bit.
     */
    inline void clear_IRQ0_INTE_SM3() volatile
    {
        IRQ0_INTE &= ~(1u << 11u);
    }

    /**
     * Toggle IRQ0_INTE's SM3 bit.
     */
    inline void toggle_IRQ0_INTE_SM3() volatile
    {
        IRQ0_INTE ^= 1u << 11u;
    }

    /**
     * Get all of IRQ0_INTE's bit fields.
     */
    inline void get_IRQ0_INTE(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                              bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                              bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                              bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                              bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = IRQ0_INTE;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }

    /**
     * Set all of IRQ0_INTE's bit fields.
     */
    inline void set_IRQ0_INTE(bool SM0_RXNEMPTY, bool SM1_RXNEMPTY,
                              bool SM2_RXNEMPTY, bool SM3_RXNEMPTY,
                              bool SM0_TXNFULL, bool SM1_TXNFULL,
                              bool SM2_TXNFULL, bool SM3_TXNFULL, bool SM0,
                              bool SM1, bool SM2, bool SM3) volatile
    {
        uint32_t curr = IRQ0_INTE;

        curr &= ~(0b1u << 0u);
        curr |= (SM0_RXNEMPTY & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SM1_RXNEMPTY & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SM2_RXNEMPTY & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (SM3_RXNEMPTY & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (SM0_TXNFULL & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (SM1_TXNFULL & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (SM2_TXNFULL & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (SM3_TXNFULL & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (SM0 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (SM1 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (SM2 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (SM3 & 0b1u) << 11u;

        IRQ0_INTE = curr;
    }

    /**
     * Get IRQ0_INTF's SM0_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTF_SM0_RXNEMPTY() volatile
    {
        return IRQ0_INTF & (1u << 0u);
    }

    /**
     * Set IRQ0_INTF's SM0_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTF_SM0_RXNEMPTY() volatile
    {
        IRQ0_INTF |= 1u << 0u;
    }

    /**
     * Clear IRQ0_INTF's SM0_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTF_SM0_RXNEMPTY() volatile
    {
        IRQ0_INTF &= ~(1u << 0u);
    }

    /**
     * Toggle IRQ0_INTF's SM0_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTF_SM0_RXNEMPTY() volatile
    {
        IRQ0_INTF ^= 1u << 0u;
    }

    /**
     * Get IRQ0_INTF's SM1_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTF_SM1_RXNEMPTY() volatile
    {
        return IRQ0_INTF & (1u << 1u);
    }

    /**
     * Set IRQ0_INTF's SM1_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTF_SM1_RXNEMPTY() volatile
    {
        IRQ0_INTF |= 1u << 1u;
    }

    /**
     * Clear IRQ0_INTF's SM1_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTF_SM1_RXNEMPTY() volatile
    {
        IRQ0_INTF &= ~(1u << 1u);
    }

    /**
     * Toggle IRQ0_INTF's SM1_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTF_SM1_RXNEMPTY() volatile
    {
        IRQ0_INTF ^= 1u << 1u;
    }

    /**
     * Get IRQ0_INTF's SM2_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTF_SM2_RXNEMPTY() volatile
    {
        return IRQ0_INTF & (1u << 2u);
    }

    /**
     * Set IRQ0_INTF's SM2_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTF_SM2_RXNEMPTY() volatile
    {
        IRQ0_INTF |= 1u << 2u;
    }

    /**
     * Clear IRQ0_INTF's SM2_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTF_SM2_RXNEMPTY() volatile
    {
        IRQ0_INTF &= ~(1u << 2u);
    }

    /**
     * Toggle IRQ0_INTF's SM2_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTF_SM2_RXNEMPTY() volatile
    {
        IRQ0_INTF ^= 1u << 2u;
    }

    /**
     * Get IRQ0_INTF's SM3_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTF_SM3_RXNEMPTY() volatile
    {
        return IRQ0_INTF & (1u << 3u);
    }

    /**
     * Set IRQ0_INTF's SM3_RXNEMPTY bit.
     */
    inline void set_IRQ0_INTF_SM3_RXNEMPTY() volatile
    {
        IRQ0_INTF |= 1u << 3u;
    }

    /**
     * Clear IRQ0_INTF's SM3_RXNEMPTY bit.
     */
    inline void clear_IRQ0_INTF_SM3_RXNEMPTY() volatile
    {
        IRQ0_INTF &= ~(1u << 3u);
    }

    /**
     * Toggle IRQ0_INTF's SM3_RXNEMPTY bit.
     */
    inline void toggle_IRQ0_INTF_SM3_RXNEMPTY() volatile
    {
        IRQ0_INTF ^= 1u << 3u;
    }

    /**
     * Get IRQ0_INTF's SM0_TXNFULL bit.
     */
    inline bool get_IRQ0_INTF_SM0_TXNFULL() volatile
    {
        return IRQ0_INTF & (1u << 4u);
    }

    /**
     * Set IRQ0_INTF's SM0_TXNFULL bit.
     */
    inline void set_IRQ0_INTF_SM0_TXNFULL() volatile
    {
        IRQ0_INTF |= 1u << 4u;
    }

    /**
     * Clear IRQ0_INTF's SM0_TXNFULL bit.
     */
    inline void clear_IRQ0_INTF_SM0_TXNFULL() volatile
    {
        IRQ0_INTF &= ~(1u << 4u);
    }

    /**
     * Toggle IRQ0_INTF's SM0_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTF_SM0_TXNFULL() volatile
    {
        IRQ0_INTF ^= 1u << 4u;
    }

    /**
     * Get IRQ0_INTF's SM1_TXNFULL bit.
     */
    inline bool get_IRQ0_INTF_SM1_TXNFULL() volatile
    {
        return IRQ0_INTF & (1u << 5u);
    }

    /**
     * Set IRQ0_INTF's SM1_TXNFULL bit.
     */
    inline void set_IRQ0_INTF_SM1_TXNFULL() volatile
    {
        IRQ0_INTF |= 1u << 5u;
    }

    /**
     * Clear IRQ0_INTF's SM1_TXNFULL bit.
     */
    inline void clear_IRQ0_INTF_SM1_TXNFULL() volatile
    {
        IRQ0_INTF &= ~(1u << 5u);
    }

    /**
     * Toggle IRQ0_INTF's SM1_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTF_SM1_TXNFULL() volatile
    {
        IRQ0_INTF ^= 1u << 5u;
    }

    /**
     * Get IRQ0_INTF's SM2_TXNFULL bit.
     */
    inline bool get_IRQ0_INTF_SM2_TXNFULL() volatile
    {
        return IRQ0_INTF & (1u << 6u);
    }

    /**
     * Set IRQ0_INTF's SM2_TXNFULL bit.
     */
    inline void set_IRQ0_INTF_SM2_TXNFULL() volatile
    {
        IRQ0_INTF |= 1u << 6u;
    }

    /**
     * Clear IRQ0_INTF's SM2_TXNFULL bit.
     */
    inline void clear_IRQ0_INTF_SM2_TXNFULL() volatile
    {
        IRQ0_INTF &= ~(1u << 6u);
    }

    /**
     * Toggle IRQ0_INTF's SM2_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTF_SM2_TXNFULL() volatile
    {
        IRQ0_INTF ^= 1u << 6u;
    }

    /**
     * Get IRQ0_INTF's SM3_TXNFULL bit.
     */
    inline bool get_IRQ0_INTF_SM3_TXNFULL() volatile
    {
        return IRQ0_INTF & (1u << 7u);
    }

    /**
     * Set IRQ0_INTF's SM3_TXNFULL bit.
     */
    inline void set_IRQ0_INTF_SM3_TXNFULL() volatile
    {
        IRQ0_INTF |= 1u << 7u;
    }

    /**
     * Clear IRQ0_INTF's SM3_TXNFULL bit.
     */
    inline void clear_IRQ0_INTF_SM3_TXNFULL() volatile
    {
        IRQ0_INTF &= ~(1u << 7u);
    }

    /**
     * Toggle IRQ0_INTF's SM3_TXNFULL bit.
     */
    inline void toggle_IRQ0_INTF_SM3_TXNFULL() volatile
    {
        IRQ0_INTF ^= 1u << 7u;
    }

    /**
     * Get IRQ0_INTF's SM0 bit.
     */
    inline bool get_IRQ0_INTF_SM0() volatile
    {
        return IRQ0_INTF & (1u << 8u);
    }

    /**
     * Set IRQ0_INTF's SM0 bit.
     */
    inline void set_IRQ0_INTF_SM0() volatile
    {
        IRQ0_INTF |= 1u << 8u;
    }

    /**
     * Clear IRQ0_INTF's SM0 bit.
     */
    inline void clear_IRQ0_INTF_SM0() volatile
    {
        IRQ0_INTF &= ~(1u << 8u);
    }

    /**
     * Toggle IRQ0_INTF's SM0 bit.
     */
    inline void toggle_IRQ0_INTF_SM0() volatile
    {
        IRQ0_INTF ^= 1u << 8u;
    }

    /**
     * Get IRQ0_INTF's SM1 bit.
     */
    inline bool get_IRQ0_INTF_SM1() volatile
    {
        return IRQ0_INTF & (1u << 9u);
    }

    /**
     * Set IRQ0_INTF's SM1 bit.
     */
    inline void set_IRQ0_INTF_SM1() volatile
    {
        IRQ0_INTF |= 1u << 9u;
    }

    /**
     * Clear IRQ0_INTF's SM1 bit.
     */
    inline void clear_IRQ0_INTF_SM1() volatile
    {
        IRQ0_INTF &= ~(1u << 9u);
    }

    /**
     * Toggle IRQ0_INTF's SM1 bit.
     */
    inline void toggle_IRQ0_INTF_SM1() volatile
    {
        IRQ0_INTF ^= 1u << 9u;
    }

    /**
     * Get IRQ0_INTF's SM2 bit.
     */
    inline bool get_IRQ0_INTF_SM2() volatile
    {
        return IRQ0_INTF & (1u << 10u);
    }

    /**
     * Set IRQ0_INTF's SM2 bit.
     */
    inline void set_IRQ0_INTF_SM2() volatile
    {
        IRQ0_INTF |= 1u << 10u;
    }

    /**
     * Clear IRQ0_INTF's SM2 bit.
     */
    inline void clear_IRQ0_INTF_SM2() volatile
    {
        IRQ0_INTF &= ~(1u << 10u);
    }

    /**
     * Toggle IRQ0_INTF's SM2 bit.
     */
    inline void toggle_IRQ0_INTF_SM2() volatile
    {
        IRQ0_INTF ^= 1u << 10u;
    }

    /**
     * Get IRQ0_INTF's SM3 bit.
     */
    inline bool get_IRQ0_INTF_SM3() volatile
    {
        return IRQ0_INTF & (1u << 11u);
    }

    /**
     * Set IRQ0_INTF's SM3 bit.
     */
    inline void set_IRQ0_INTF_SM3() volatile
    {
        IRQ0_INTF |= 1u << 11u;
    }

    /**
     * Clear IRQ0_INTF's SM3 bit.
     */
    inline void clear_IRQ0_INTF_SM3() volatile
    {
        IRQ0_INTF &= ~(1u << 11u);
    }

    /**
     * Toggle IRQ0_INTF's SM3 bit.
     */
    inline void toggle_IRQ0_INTF_SM3() volatile
    {
        IRQ0_INTF ^= 1u << 11u;
    }

    /**
     * Get all of IRQ0_INTF's bit fields.
     */
    inline void get_IRQ0_INTF(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                              bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                              bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                              bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                              bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = IRQ0_INTF;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }

    /**
     * Set all of IRQ0_INTF's bit fields.
     */
    inline void set_IRQ0_INTF(bool SM0_RXNEMPTY, bool SM1_RXNEMPTY,
                              bool SM2_RXNEMPTY, bool SM3_RXNEMPTY,
                              bool SM0_TXNFULL, bool SM1_TXNFULL,
                              bool SM2_TXNFULL, bool SM3_TXNFULL, bool SM0,
                              bool SM1, bool SM2, bool SM3) volatile
    {
        uint32_t curr = IRQ0_INTF;

        curr &= ~(0b1u << 0u);
        curr |= (SM0_RXNEMPTY & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SM1_RXNEMPTY & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SM2_RXNEMPTY & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (SM3_RXNEMPTY & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (SM0_TXNFULL & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (SM1_TXNFULL & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (SM2_TXNFULL & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (SM3_TXNFULL & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (SM0 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (SM1 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (SM2 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (SM3 & 0b1u) << 11u;

        IRQ0_INTF = curr;
    }

    /**
     * Get IRQ0_INTS's SM0_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTS_SM0_RXNEMPTY() volatile
    {
        return IRQ0_INTS & (1u << 0u);
    }

    /**
     * Get IRQ0_INTS's SM1_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTS_SM1_RXNEMPTY() volatile
    {
        return IRQ0_INTS & (1u << 1u);
    }

    /**
     * Get IRQ0_INTS's SM2_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTS_SM2_RXNEMPTY() volatile
    {
        return IRQ0_INTS & (1u << 2u);
    }

    /**
     * Get IRQ0_INTS's SM3_RXNEMPTY bit.
     */
    inline bool get_IRQ0_INTS_SM3_RXNEMPTY() volatile
    {
        return IRQ0_INTS & (1u << 3u);
    }

    /**
     * Get IRQ0_INTS's SM0_TXNFULL bit.
     */
    inline bool get_IRQ0_INTS_SM0_TXNFULL() volatile
    {
        return IRQ0_INTS & (1u << 4u);
    }

    /**
     * Get IRQ0_INTS's SM1_TXNFULL bit.
     */
    inline bool get_IRQ0_INTS_SM1_TXNFULL() volatile
    {
        return IRQ0_INTS & (1u << 5u);
    }

    /**
     * Get IRQ0_INTS's SM2_TXNFULL bit.
     */
    inline bool get_IRQ0_INTS_SM2_TXNFULL() volatile
    {
        return IRQ0_INTS & (1u << 6u);
    }

    /**
     * Get IRQ0_INTS's SM3_TXNFULL bit.
     */
    inline bool get_IRQ0_INTS_SM3_TXNFULL() volatile
    {
        return IRQ0_INTS & (1u << 7u);
    }

    /**
     * Get IRQ0_INTS's SM0 bit.
     */
    inline bool get_IRQ0_INTS_SM0() volatile
    {
        return IRQ0_INTS & (1u << 8u);
    }

    /**
     * Get IRQ0_INTS's SM1 bit.
     */
    inline bool get_IRQ0_INTS_SM1() volatile
    {
        return IRQ0_INTS & (1u << 9u);
    }

    /**
     * Get IRQ0_INTS's SM2 bit.
     */
    inline bool get_IRQ0_INTS_SM2() volatile
    {
        return IRQ0_INTS & (1u << 10u);
    }

    /**
     * Get IRQ0_INTS's SM3 bit.
     */
    inline bool get_IRQ0_INTS_SM3() volatile
    {
        return IRQ0_INTS & (1u << 11u);
    }

    /**
     * Get all of IRQ0_INTS's bit fields.
     */
    inline void get_IRQ0_INTS(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                              bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                              bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                              bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                              bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = IRQ0_INTS;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }

    /**
     * Get IRQ1_INTE's SM0_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTE_SM0_RXNEMPTY() volatile
    {
        return IRQ1_INTE & (1u << 0u);
    }

    /**
     * Set IRQ1_INTE's SM0_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTE_SM0_RXNEMPTY() volatile
    {
        IRQ1_INTE |= 1u << 0u;
    }

    /**
     * Clear IRQ1_INTE's SM0_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTE_SM0_RXNEMPTY() volatile
    {
        IRQ1_INTE &= ~(1u << 0u);
    }

    /**
     * Toggle IRQ1_INTE's SM0_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTE_SM0_RXNEMPTY() volatile
    {
        IRQ1_INTE ^= 1u << 0u;
    }

    /**
     * Get IRQ1_INTE's SM1_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTE_SM1_RXNEMPTY() volatile
    {
        return IRQ1_INTE & (1u << 1u);
    }

    /**
     * Set IRQ1_INTE's SM1_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTE_SM1_RXNEMPTY() volatile
    {
        IRQ1_INTE |= 1u << 1u;
    }

    /**
     * Clear IRQ1_INTE's SM1_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTE_SM1_RXNEMPTY() volatile
    {
        IRQ1_INTE &= ~(1u << 1u);
    }

    /**
     * Toggle IRQ1_INTE's SM1_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTE_SM1_RXNEMPTY() volatile
    {
        IRQ1_INTE ^= 1u << 1u;
    }

    /**
     * Get IRQ1_INTE's SM2_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTE_SM2_RXNEMPTY() volatile
    {
        return IRQ1_INTE & (1u << 2u);
    }

    /**
     * Set IRQ1_INTE's SM2_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTE_SM2_RXNEMPTY() volatile
    {
        IRQ1_INTE |= 1u << 2u;
    }

    /**
     * Clear IRQ1_INTE's SM2_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTE_SM2_RXNEMPTY() volatile
    {
        IRQ1_INTE &= ~(1u << 2u);
    }

    /**
     * Toggle IRQ1_INTE's SM2_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTE_SM2_RXNEMPTY() volatile
    {
        IRQ1_INTE ^= 1u << 2u;
    }

    /**
     * Get IRQ1_INTE's SM3_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTE_SM3_RXNEMPTY() volatile
    {
        return IRQ1_INTE & (1u << 3u);
    }

    /**
     * Set IRQ1_INTE's SM3_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTE_SM3_RXNEMPTY() volatile
    {
        IRQ1_INTE |= 1u << 3u;
    }

    /**
     * Clear IRQ1_INTE's SM3_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTE_SM3_RXNEMPTY() volatile
    {
        IRQ1_INTE &= ~(1u << 3u);
    }

    /**
     * Toggle IRQ1_INTE's SM3_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTE_SM3_RXNEMPTY() volatile
    {
        IRQ1_INTE ^= 1u << 3u;
    }

    /**
     * Get IRQ1_INTE's SM0_TXNFULL bit.
     */
    inline bool get_IRQ1_INTE_SM0_TXNFULL() volatile
    {
        return IRQ1_INTE & (1u << 4u);
    }

    /**
     * Set IRQ1_INTE's SM0_TXNFULL bit.
     */
    inline void set_IRQ1_INTE_SM0_TXNFULL() volatile
    {
        IRQ1_INTE |= 1u << 4u;
    }

    /**
     * Clear IRQ1_INTE's SM0_TXNFULL bit.
     */
    inline void clear_IRQ1_INTE_SM0_TXNFULL() volatile
    {
        IRQ1_INTE &= ~(1u << 4u);
    }

    /**
     * Toggle IRQ1_INTE's SM0_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTE_SM0_TXNFULL() volatile
    {
        IRQ1_INTE ^= 1u << 4u;
    }

    /**
     * Get IRQ1_INTE's SM1_TXNFULL bit.
     */
    inline bool get_IRQ1_INTE_SM1_TXNFULL() volatile
    {
        return IRQ1_INTE & (1u << 5u);
    }

    /**
     * Set IRQ1_INTE's SM1_TXNFULL bit.
     */
    inline void set_IRQ1_INTE_SM1_TXNFULL() volatile
    {
        IRQ1_INTE |= 1u << 5u;
    }

    /**
     * Clear IRQ1_INTE's SM1_TXNFULL bit.
     */
    inline void clear_IRQ1_INTE_SM1_TXNFULL() volatile
    {
        IRQ1_INTE &= ~(1u << 5u);
    }

    /**
     * Toggle IRQ1_INTE's SM1_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTE_SM1_TXNFULL() volatile
    {
        IRQ1_INTE ^= 1u << 5u;
    }

    /**
     * Get IRQ1_INTE's SM2_TXNFULL bit.
     */
    inline bool get_IRQ1_INTE_SM2_TXNFULL() volatile
    {
        return IRQ1_INTE & (1u << 6u);
    }

    /**
     * Set IRQ1_INTE's SM2_TXNFULL bit.
     */
    inline void set_IRQ1_INTE_SM2_TXNFULL() volatile
    {
        IRQ1_INTE |= 1u << 6u;
    }

    /**
     * Clear IRQ1_INTE's SM2_TXNFULL bit.
     */
    inline void clear_IRQ1_INTE_SM2_TXNFULL() volatile
    {
        IRQ1_INTE &= ~(1u << 6u);
    }

    /**
     * Toggle IRQ1_INTE's SM2_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTE_SM2_TXNFULL() volatile
    {
        IRQ1_INTE ^= 1u << 6u;
    }

    /**
     * Get IRQ1_INTE's SM3_TXNFULL bit.
     */
    inline bool get_IRQ1_INTE_SM3_TXNFULL() volatile
    {
        return IRQ1_INTE & (1u << 7u);
    }

    /**
     * Set IRQ1_INTE's SM3_TXNFULL bit.
     */
    inline void set_IRQ1_INTE_SM3_TXNFULL() volatile
    {
        IRQ1_INTE |= 1u << 7u;
    }

    /**
     * Clear IRQ1_INTE's SM3_TXNFULL bit.
     */
    inline void clear_IRQ1_INTE_SM3_TXNFULL() volatile
    {
        IRQ1_INTE &= ~(1u << 7u);
    }

    /**
     * Toggle IRQ1_INTE's SM3_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTE_SM3_TXNFULL() volatile
    {
        IRQ1_INTE ^= 1u << 7u;
    }

    /**
     * Get IRQ1_INTE's SM0 bit.
     */
    inline bool get_IRQ1_INTE_SM0() volatile
    {
        return IRQ1_INTE & (1u << 8u);
    }

    /**
     * Set IRQ1_INTE's SM0 bit.
     */
    inline void set_IRQ1_INTE_SM0() volatile
    {
        IRQ1_INTE |= 1u << 8u;
    }

    /**
     * Clear IRQ1_INTE's SM0 bit.
     */
    inline void clear_IRQ1_INTE_SM0() volatile
    {
        IRQ1_INTE &= ~(1u << 8u);
    }

    /**
     * Toggle IRQ1_INTE's SM0 bit.
     */
    inline void toggle_IRQ1_INTE_SM0() volatile
    {
        IRQ1_INTE ^= 1u << 8u;
    }

    /**
     * Get IRQ1_INTE's SM1 bit.
     */
    inline bool get_IRQ1_INTE_SM1() volatile
    {
        return IRQ1_INTE & (1u << 9u);
    }

    /**
     * Set IRQ1_INTE's SM1 bit.
     */
    inline void set_IRQ1_INTE_SM1() volatile
    {
        IRQ1_INTE |= 1u << 9u;
    }

    /**
     * Clear IRQ1_INTE's SM1 bit.
     */
    inline void clear_IRQ1_INTE_SM1() volatile
    {
        IRQ1_INTE &= ~(1u << 9u);
    }

    /**
     * Toggle IRQ1_INTE's SM1 bit.
     */
    inline void toggle_IRQ1_INTE_SM1() volatile
    {
        IRQ1_INTE ^= 1u << 9u;
    }

    /**
     * Get IRQ1_INTE's SM2 bit.
     */
    inline bool get_IRQ1_INTE_SM2() volatile
    {
        return IRQ1_INTE & (1u << 10u);
    }

    /**
     * Set IRQ1_INTE's SM2 bit.
     */
    inline void set_IRQ1_INTE_SM2() volatile
    {
        IRQ1_INTE |= 1u << 10u;
    }

    /**
     * Clear IRQ1_INTE's SM2 bit.
     */
    inline void clear_IRQ1_INTE_SM2() volatile
    {
        IRQ1_INTE &= ~(1u << 10u);
    }

    /**
     * Toggle IRQ1_INTE's SM2 bit.
     */
    inline void toggle_IRQ1_INTE_SM2() volatile
    {
        IRQ1_INTE ^= 1u << 10u;
    }

    /**
     * Get IRQ1_INTE's SM3 bit.
     */
    inline bool get_IRQ1_INTE_SM3() volatile
    {
        return IRQ1_INTE & (1u << 11u);
    }

    /**
     * Set IRQ1_INTE's SM3 bit.
     */
    inline void set_IRQ1_INTE_SM3() volatile
    {
        IRQ1_INTE |= 1u << 11u;
    }

    /**
     * Clear IRQ1_INTE's SM3 bit.
     */
    inline void clear_IRQ1_INTE_SM3() volatile
    {
        IRQ1_INTE &= ~(1u << 11u);
    }

    /**
     * Toggle IRQ1_INTE's SM3 bit.
     */
    inline void toggle_IRQ1_INTE_SM3() volatile
    {
        IRQ1_INTE ^= 1u << 11u;
    }

    /**
     * Get all of IRQ1_INTE's bit fields.
     */
    inline void get_IRQ1_INTE(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                              bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                              bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                              bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                              bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = IRQ1_INTE;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }

    /**
     * Set all of IRQ1_INTE's bit fields.
     */
    inline void set_IRQ1_INTE(bool SM0_RXNEMPTY, bool SM1_RXNEMPTY,
                              bool SM2_RXNEMPTY, bool SM3_RXNEMPTY,
                              bool SM0_TXNFULL, bool SM1_TXNFULL,
                              bool SM2_TXNFULL, bool SM3_TXNFULL, bool SM0,
                              bool SM1, bool SM2, bool SM3) volatile
    {
        uint32_t curr = IRQ1_INTE;

        curr &= ~(0b1u << 0u);
        curr |= (SM0_RXNEMPTY & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SM1_RXNEMPTY & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SM2_RXNEMPTY & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (SM3_RXNEMPTY & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (SM0_TXNFULL & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (SM1_TXNFULL & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (SM2_TXNFULL & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (SM3_TXNFULL & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (SM0 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (SM1 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (SM2 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (SM3 & 0b1u) << 11u;

        IRQ1_INTE = curr;
    }

    /**
     * Get IRQ1_INTF's SM0_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTF_SM0_RXNEMPTY() volatile
    {
        return IRQ1_INTF & (1u << 0u);
    }

    /**
     * Set IRQ1_INTF's SM0_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTF_SM0_RXNEMPTY() volatile
    {
        IRQ1_INTF |= 1u << 0u;
    }

    /**
     * Clear IRQ1_INTF's SM0_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTF_SM0_RXNEMPTY() volatile
    {
        IRQ1_INTF &= ~(1u << 0u);
    }

    /**
     * Toggle IRQ1_INTF's SM0_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTF_SM0_RXNEMPTY() volatile
    {
        IRQ1_INTF ^= 1u << 0u;
    }

    /**
     * Get IRQ1_INTF's SM1_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTF_SM1_RXNEMPTY() volatile
    {
        return IRQ1_INTF & (1u << 1u);
    }

    /**
     * Set IRQ1_INTF's SM1_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTF_SM1_RXNEMPTY() volatile
    {
        IRQ1_INTF |= 1u << 1u;
    }

    /**
     * Clear IRQ1_INTF's SM1_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTF_SM1_RXNEMPTY() volatile
    {
        IRQ1_INTF &= ~(1u << 1u);
    }

    /**
     * Toggle IRQ1_INTF's SM1_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTF_SM1_RXNEMPTY() volatile
    {
        IRQ1_INTF ^= 1u << 1u;
    }

    /**
     * Get IRQ1_INTF's SM2_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTF_SM2_RXNEMPTY() volatile
    {
        return IRQ1_INTF & (1u << 2u);
    }

    /**
     * Set IRQ1_INTF's SM2_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTF_SM2_RXNEMPTY() volatile
    {
        IRQ1_INTF |= 1u << 2u;
    }

    /**
     * Clear IRQ1_INTF's SM2_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTF_SM2_RXNEMPTY() volatile
    {
        IRQ1_INTF &= ~(1u << 2u);
    }

    /**
     * Toggle IRQ1_INTF's SM2_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTF_SM2_RXNEMPTY() volatile
    {
        IRQ1_INTF ^= 1u << 2u;
    }

    /**
     * Get IRQ1_INTF's SM3_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTF_SM3_RXNEMPTY() volatile
    {
        return IRQ1_INTF & (1u << 3u);
    }

    /**
     * Set IRQ1_INTF's SM3_RXNEMPTY bit.
     */
    inline void set_IRQ1_INTF_SM3_RXNEMPTY() volatile
    {
        IRQ1_INTF |= 1u << 3u;
    }

    /**
     * Clear IRQ1_INTF's SM3_RXNEMPTY bit.
     */
    inline void clear_IRQ1_INTF_SM3_RXNEMPTY() volatile
    {
        IRQ1_INTF &= ~(1u << 3u);
    }

    /**
     * Toggle IRQ1_INTF's SM3_RXNEMPTY bit.
     */
    inline void toggle_IRQ1_INTF_SM3_RXNEMPTY() volatile
    {
        IRQ1_INTF ^= 1u << 3u;
    }

    /**
     * Get IRQ1_INTF's SM0_TXNFULL bit.
     */
    inline bool get_IRQ1_INTF_SM0_TXNFULL() volatile
    {
        return IRQ1_INTF & (1u << 4u);
    }

    /**
     * Set IRQ1_INTF's SM0_TXNFULL bit.
     */
    inline void set_IRQ1_INTF_SM0_TXNFULL() volatile
    {
        IRQ1_INTF |= 1u << 4u;
    }

    /**
     * Clear IRQ1_INTF's SM0_TXNFULL bit.
     */
    inline void clear_IRQ1_INTF_SM0_TXNFULL() volatile
    {
        IRQ1_INTF &= ~(1u << 4u);
    }

    /**
     * Toggle IRQ1_INTF's SM0_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTF_SM0_TXNFULL() volatile
    {
        IRQ1_INTF ^= 1u << 4u;
    }

    /**
     * Get IRQ1_INTF's SM1_TXNFULL bit.
     */
    inline bool get_IRQ1_INTF_SM1_TXNFULL() volatile
    {
        return IRQ1_INTF & (1u << 5u);
    }

    /**
     * Set IRQ1_INTF's SM1_TXNFULL bit.
     */
    inline void set_IRQ1_INTF_SM1_TXNFULL() volatile
    {
        IRQ1_INTF |= 1u << 5u;
    }

    /**
     * Clear IRQ1_INTF's SM1_TXNFULL bit.
     */
    inline void clear_IRQ1_INTF_SM1_TXNFULL() volatile
    {
        IRQ1_INTF &= ~(1u << 5u);
    }

    /**
     * Toggle IRQ1_INTF's SM1_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTF_SM1_TXNFULL() volatile
    {
        IRQ1_INTF ^= 1u << 5u;
    }

    /**
     * Get IRQ1_INTF's SM2_TXNFULL bit.
     */
    inline bool get_IRQ1_INTF_SM2_TXNFULL() volatile
    {
        return IRQ1_INTF & (1u << 6u);
    }

    /**
     * Set IRQ1_INTF's SM2_TXNFULL bit.
     */
    inline void set_IRQ1_INTF_SM2_TXNFULL() volatile
    {
        IRQ1_INTF |= 1u << 6u;
    }

    /**
     * Clear IRQ1_INTF's SM2_TXNFULL bit.
     */
    inline void clear_IRQ1_INTF_SM2_TXNFULL() volatile
    {
        IRQ1_INTF &= ~(1u << 6u);
    }

    /**
     * Toggle IRQ1_INTF's SM2_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTF_SM2_TXNFULL() volatile
    {
        IRQ1_INTF ^= 1u << 6u;
    }

    /**
     * Get IRQ1_INTF's SM3_TXNFULL bit.
     */
    inline bool get_IRQ1_INTF_SM3_TXNFULL() volatile
    {
        return IRQ1_INTF & (1u << 7u);
    }

    /**
     * Set IRQ1_INTF's SM3_TXNFULL bit.
     */
    inline void set_IRQ1_INTF_SM3_TXNFULL() volatile
    {
        IRQ1_INTF |= 1u << 7u;
    }

    /**
     * Clear IRQ1_INTF's SM3_TXNFULL bit.
     */
    inline void clear_IRQ1_INTF_SM3_TXNFULL() volatile
    {
        IRQ1_INTF &= ~(1u << 7u);
    }

    /**
     * Toggle IRQ1_INTF's SM3_TXNFULL bit.
     */
    inline void toggle_IRQ1_INTF_SM3_TXNFULL() volatile
    {
        IRQ1_INTF ^= 1u << 7u;
    }

    /**
     * Get IRQ1_INTF's SM0 bit.
     */
    inline bool get_IRQ1_INTF_SM0() volatile
    {
        return IRQ1_INTF & (1u << 8u);
    }

    /**
     * Set IRQ1_INTF's SM0 bit.
     */
    inline void set_IRQ1_INTF_SM0() volatile
    {
        IRQ1_INTF |= 1u << 8u;
    }

    /**
     * Clear IRQ1_INTF's SM0 bit.
     */
    inline void clear_IRQ1_INTF_SM0() volatile
    {
        IRQ1_INTF &= ~(1u << 8u);
    }

    /**
     * Toggle IRQ1_INTF's SM0 bit.
     */
    inline void toggle_IRQ1_INTF_SM0() volatile
    {
        IRQ1_INTF ^= 1u << 8u;
    }

    /**
     * Get IRQ1_INTF's SM1 bit.
     */
    inline bool get_IRQ1_INTF_SM1() volatile
    {
        return IRQ1_INTF & (1u << 9u);
    }

    /**
     * Set IRQ1_INTF's SM1 bit.
     */
    inline void set_IRQ1_INTF_SM1() volatile
    {
        IRQ1_INTF |= 1u << 9u;
    }

    /**
     * Clear IRQ1_INTF's SM1 bit.
     */
    inline void clear_IRQ1_INTF_SM1() volatile
    {
        IRQ1_INTF &= ~(1u << 9u);
    }

    /**
     * Toggle IRQ1_INTF's SM1 bit.
     */
    inline void toggle_IRQ1_INTF_SM1() volatile
    {
        IRQ1_INTF ^= 1u << 9u;
    }

    /**
     * Get IRQ1_INTF's SM2 bit.
     */
    inline bool get_IRQ1_INTF_SM2() volatile
    {
        return IRQ1_INTF & (1u << 10u);
    }

    /**
     * Set IRQ1_INTF's SM2 bit.
     */
    inline void set_IRQ1_INTF_SM2() volatile
    {
        IRQ1_INTF |= 1u << 10u;
    }

    /**
     * Clear IRQ1_INTF's SM2 bit.
     */
    inline void clear_IRQ1_INTF_SM2() volatile
    {
        IRQ1_INTF &= ~(1u << 10u);
    }

    /**
     * Toggle IRQ1_INTF's SM2 bit.
     */
    inline void toggle_IRQ1_INTF_SM2() volatile
    {
        IRQ1_INTF ^= 1u << 10u;
    }

    /**
     * Get IRQ1_INTF's SM3 bit.
     */
    inline bool get_IRQ1_INTF_SM3() volatile
    {
        return IRQ1_INTF & (1u << 11u);
    }

    /**
     * Set IRQ1_INTF's SM3 bit.
     */
    inline void set_IRQ1_INTF_SM3() volatile
    {
        IRQ1_INTF |= 1u << 11u;
    }

    /**
     * Clear IRQ1_INTF's SM3 bit.
     */
    inline void clear_IRQ1_INTF_SM3() volatile
    {
        IRQ1_INTF &= ~(1u << 11u);
    }

    /**
     * Toggle IRQ1_INTF's SM3 bit.
     */
    inline void toggle_IRQ1_INTF_SM3() volatile
    {
        IRQ1_INTF ^= 1u << 11u;
    }

    /**
     * Get all of IRQ1_INTF's bit fields.
     */
    inline void get_IRQ1_INTF(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                              bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                              bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                              bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                              bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = IRQ1_INTF;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }

    /**
     * Set all of IRQ1_INTF's bit fields.
     */
    inline void set_IRQ1_INTF(bool SM0_RXNEMPTY, bool SM1_RXNEMPTY,
                              bool SM2_RXNEMPTY, bool SM3_RXNEMPTY,
                              bool SM0_TXNFULL, bool SM1_TXNFULL,
                              bool SM2_TXNFULL, bool SM3_TXNFULL, bool SM0,
                              bool SM1, bool SM2, bool SM3) volatile
    {
        uint32_t curr = IRQ1_INTF;

        curr &= ~(0b1u << 0u);
        curr |= (SM0_RXNEMPTY & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SM1_RXNEMPTY & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SM2_RXNEMPTY & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (SM3_RXNEMPTY & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (SM0_TXNFULL & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (SM1_TXNFULL & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (SM2_TXNFULL & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (SM3_TXNFULL & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (SM0 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (SM1 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (SM2 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (SM3 & 0b1u) << 11u;

        IRQ1_INTF = curr;
    }

    /**
     * Get IRQ1_INTS's SM0_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTS_SM0_RXNEMPTY() volatile
    {
        return IRQ1_INTS & (1u << 0u);
    }

    /**
     * Get IRQ1_INTS's SM1_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTS_SM1_RXNEMPTY() volatile
    {
        return IRQ1_INTS & (1u << 1u);
    }

    /**
     * Get IRQ1_INTS's SM2_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTS_SM2_RXNEMPTY() volatile
    {
        return IRQ1_INTS & (1u << 2u);
    }

    /**
     * Get IRQ1_INTS's SM3_RXNEMPTY bit.
     */
    inline bool get_IRQ1_INTS_SM3_RXNEMPTY() volatile
    {
        return IRQ1_INTS & (1u << 3u);
    }

    /**
     * Get IRQ1_INTS's SM0_TXNFULL bit.
     */
    inline bool get_IRQ1_INTS_SM0_TXNFULL() volatile
    {
        return IRQ1_INTS & (1u << 4u);
    }

    /**
     * Get IRQ1_INTS's SM1_TXNFULL bit.
     */
    inline bool get_IRQ1_INTS_SM1_TXNFULL() volatile
    {
        return IRQ1_INTS & (1u << 5u);
    }

    /**
     * Get IRQ1_INTS's SM2_TXNFULL bit.
     */
    inline bool get_IRQ1_INTS_SM2_TXNFULL() volatile
    {
        return IRQ1_INTS & (1u << 6u);
    }

    /**
     * Get IRQ1_INTS's SM3_TXNFULL bit.
     */
    inline bool get_IRQ1_INTS_SM3_TXNFULL() volatile
    {
        return IRQ1_INTS & (1u << 7u);
    }

    /**
     * Get IRQ1_INTS's SM0 bit.
     */
    inline bool get_IRQ1_INTS_SM0() volatile
    {
        return IRQ1_INTS & (1u << 8u);
    }

    /**
     * Get IRQ1_INTS's SM1 bit.
     */
    inline bool get_IRQ1_INTS_SM1() volatile
    {
        return IRQ1_INTS & (1u << 9u);
    }

    /**
     * Get IRQ1_INTS's SM2 bit.
     */
    inline bool get_IRQ1_INTS_SM2() volatile
    {
        return IRQ1_INTS & (1u << 10u);
    }

    /**
     * Get IRQ1_INTS's SM3 bit.
     */
    inline bool get_IRQ1_INTS_SM3() volatile
    {
        return IRQ1_INTS & (1u << 11u);
    }

    /**
     * Get all of IRQ1_INTS's bit fields.
     */
    inline void get_IRQ1_INTS(bool &SM0_RXNEMPTY, bool &SM1_RXNEMPTY,
                              bool &SM2_RXNEMPTY, bool &SM3_RXNEMPTY,
                              bool &SM0_TXNFULL, bool &SM1_TXNFULL,
                              bool &SM2_TXNFULL, bool &SM3_TXNFULL, bool &SM0,
                              bool &SM1, bool &SM2, bool &SM3) volatile
    {
        uint32_t curr = IRQ1_INTS;

        SM0_RXNEMPTY = curr & (1u << 0u);
        SM1_RXNEMPTY = curr & (1u << 1u);
        SM2_RXNEMPTY = curr & (1u << 2u);
        SM3_RXNEMPTY = curr & (1u << 3u);
        SM0_TXNFULL = curr & (1u << 4u);
        SM1_TXNFULL = curr & (1u << 5u);
        SM2_TXNFULL = curr & (1u << 6u);
        SM3_TXNFULL = curr & (1u << 7u);
        SM0 = curr & (1u << 8u);
        SM1 = curr & (1u << 9u);
        SM2 = curr & (1u << 10u);
        SM3 = curr & (1u << 11u);
    }
};

static_assert(sizeof(pio0) == pio0::size);

static volatile pio0 *const PIO0 = reinterpret_cast<pio0 *>(0x50200000);

static volatile pio0 *const PIO1 = reinterpret_cast<pio0 *>(0x50300000);

}; // namespace RP2040
