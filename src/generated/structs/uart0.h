/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] uart0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 4096; /*!< uart0's size in bytes. */

    /* Fields. */
    uint32_t UARTDR;  /*!< (read-write) Data Register, UARTDR */
    uint32_t UARTRSR; /*!< (read-write) Receive Status Register/Error Clear
                         Register, UARTRSR/UARTECR */
    static constexpr std::size_t reserved_padding0_length = 4;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    const uint32_t UARTFR = {}; /*!< (read-only) Flag Register, UARTFR */
    const uint32_t reserved_padding1 = {};
    uint32_t UARTILPR; /*!< (read-write) IrDA Low-Power Counter Register,
                          UARTILPR */
    uint32_t
        UARTIBRD; /*!< (read-write) Integer Baud Rate Register, UARTIBRD */
    uint32_t
        UARTFBRD; /*!< (read-write) Fractional Baud Rate Register, UARTFBRD */
    uint32_t UARTLCR_H; /*!< (read-write) Line Control Register, UARTLCR_H */
    uint32_t UARTCR;    /*!< (read-write) Control Register, UARTCR */
    uint32_t UARTIFLS;  /*!< (read-write) Interrupt FIFO Level Select Register,
                           UARTIFLS */
    uint32_t UARTIMSC;  /*!< (read-write) Interrupt Mask Set/Clear Register,
                           UARTIMSC */
    const uint32_t UARTRIS =
        {}; /*!< (read-only) Raw Interrupt Status Register, UARTRIS */
    const uint32_t UARTMIS =
        {}; /*!< (read-only) Masked Interrupt Status Register, UARTMIS */
    uint32_t UARTICR;   /*!< (read-write) Interrupt Clear Register, UARTICR */
    uint32_t UARTDMACR; /*!< (read-write) DMA Control Register, UARTDMACR */
    static constexpr std::size_t reserved_padding2_length = 997;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    const uint32_t UARTPERIPHID0 =
        {}; /*!< (read-only) UARTPeriphID0 Register */
    const uint32_t UARTPERIPHID1 =
        {}; /*!< (read-only) UARTPeriphID1 Register */
    const uint32_t UARTPERIPHID2 =
        {}; /*!< (read-only) UARTPeriphID2 Register */
    const uint32_t UARTPERIPHID3 =
        {}; /*!< (read-only) UARTPeriphID3 Register */
    const uint32_t UARTPCELLID0 = {}; /*!< (read-only) UARTPCellID0 Register */
    const uint32_t UARTPCELLID1 = {}; /*!< (read-only) UARTPCellID1 Register */
    const uint32_t UARTPCELLID2 = {}; /*!< (read-only) UARTPCellID2 Register */
    const uint32_t UARTPCELLID3 = {}; /*!< (read-only) UARTPCellID3 Register */

    /* Methods. */

    /**
     * Get UARTDR's DATA field.
     *
     * Receive (read) data character. Transmit (write) data character.
     */
    inline uint8_t get_UARTDR_DATA() volatile
    {
        return (UARTDR >> 0u) & 0b11111111u;
    }

    /**
     * Set UARTDR's DATA field.
     *
     * Receive (read) data character. Transmit (write) data character.
     */
    inline void set_UARTDR_DATA(uint8_t value) volatile
    {
        uint32_t curr = UARTDR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        UARTDR = curr;
    }

    /**
     * Get UARTDR's FE bit.
     *
     * Framing error. When set to 1, it indicates that the received character
     * did not have a valid stop bit (a valid stop bit is 1). In FIFO mode,
     * this error is associated with the character at the top of the FIFO.
     */
    inline bool get_UARTDR_FE() volatile
    {
        return UARTDR & (1u << 8u);
    }

    /**
     * Get UARTDR's PE bit.
     *
     * Parity error. When set to 1, it indicates that the parity of the
     * received data character does not match the parity that the EPS and SPS
     * bits in the Line Control Register, UARTLCR_H. In FIFO mode, this error
     * is associated with the character at the top of the FIFO.
     */
    inline bool get_UARTDR_PE() volatile
    {
        return UARTDR & (1u << 9u);
    }

    /**
     * Get UARTDR's BE bit.
     *
     * Break error. This bit is set to 1 if a break condition was detected,
     * indicating that the received data input was held LOW for longer than a
     * full-word transmission time (defined as start, data, parity and stop
     * bits). In FIFO mode, this error is associated with the character at the
     * top of the FIFO. When a break occurs, only one 0 character is loaded
     * into the FIFO. The next character is only enabled after the receive data
     * input goes to a 1 (marking state), and the next valid start bit is
     * received.
     */
    inline bool get_UARTDR_BE() volatile
    {
        return UARTDR & (1u << 10u);
    }

    /**
     * Get UARTDR's OE bit.
     *
     * Overrun error. This bit is set to 1 if data is received and the receive
     * FIFO is already full. This is cleared to 0 once there is an empty space
     * in the FIFO and a new character can be written to it.
     */
    inline bool get_UARTDR_OE() volatile
    {
        return UARTDR & (1u << 11u);
    }

    /**
     * Get all of UARTDR's bit fields.
     *
     * (read-write) Data Register, UARTDR
     */
    inline void get_UARTDR(uint8_t &DATA, bool &FE, bool &PE, bool &BE,
                           bool &OE) volatile
    {
        uint32_t curr = UARTDR;

        DATA = (curr >> 0u) & 0b11111111u;
        FE = curr & (1u << 8u);
        PE = curr & (1u << 9u);
        BE = curr & (1u << 10u);
        OE = curr & (1u << 11u);
    }

    /**
     * Get UARTRSR's FE bit.
     *
     * Framing error. When set to 1, it indicates that the received character
     * did not have a valid stop bit (a valid stop bit is 1). This bit is
     * cleared to 0 by a write to UARTECR. In FIFO mode, this error is
     * associated with the character at the top of the FIFO.
     */
    inline bool get_UARTRSR_FE() volatile
    {
        return UARTRSR & (1u << 0u);
    }

    /**
     * Set UARTRSR's FE bit.
     *
     * Framing error. When set to 1, it indicates that the received character
     * did not have a valid stop bit (a valid stop bit is 1). This bit is
     * cleared to 0 by a write to UARTECR. In FIFO mode, this error is
     * associated with the character at the top of the FIFO.
     */
    inline void set_UARTRSR_FE() volatile
    {
        UARTRSR |= 1u << 0u;
    }

    /**
     * Clear UARTRSR's FE bit.
     *
     * Framing error. When set to 1, it indicates that the received character
     * did not have a valid stop bit (a valid stop bit is 1). This bit is
     * cleared to 0 by a write to UARTECR. In FIFO mode, this error is
     * associated with the character at the top of the FIFO.
     */
    inline void clear_UARTRSR_FE() volatile
    {
        UARTRSR &= ~(1u << 0u);
    }

    /**
     * Toggle UARTRSR's FE bit.
     *
     * Framing error. When set to 1, it indicates that the received character
     * did not have a valid stop bit (a valid stop bit is 1). This bit is
     * cleared to 0 by a write to UARTECR. In FIFO mode, this error is
     * associated with the character at the top of the FIFO.
     */
    inline void toggle_UARTRSR_FE() volatile
    {
        UARTRSR ^= 1u << 0u;
    }

    /**
     * Get UARTRSR's PE bit.
     *
     * Parity error. When set to 1, it indicates that the parity of the
     * received data character does not match the parity that the EPS and SPS
     * bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0
     * by a write to UARTECR. In FIFO mode, this error is associated with the
     * character at the top of the FIFO.
     */
    inline bool get_UARTRSR_PE() volatile
    {
        return UARTRSR & (1u << 1u);
    }

    /**
     * Set UARTRSR's PE bit.
     *
     * Parity error. When set to 1, it indicates that the parity of the
     * received data character does not match the parity that the EPS and SPS
     * bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0
     * by a write to UARTECR. In FIFO mode, this error is associated with the
     * character at the top of the FIFO.
     */
    inline void set_UARTRSR_PE() volatile
    {
        UARTRSR |= 1u << 1u;
    }

    /**
     * Clear UARTRSR's PE bit.
     *
     * Parity error. When set to 1, it indicates that the parity of the
     * received data character does not match the parity that the EPS and SPS
     * bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0
     * by a write to UARTECR. In FIFO mode, this error is associated with the
     * character at the top of the FIFO.
     */
    inline void clear_UARTRSR_PE() volatile
    {
        UARTRSR &= ~(1u << 1u);
    }

    /**
     * Toggle UARTRSR's PE bit.
     *
     * Parity error. When set to 1, it indicates that the parity of the
     * received data character does not match the parity that the EPS and SPS
     * bits in the Line Control Register, UARTLCR_H. This bit is cleared to 0
     * by a write to UARTECR. In FIFO mode, this error is associated with the
     * character at the top of the FIFO.
     */
    inline void toggle_UARTRSR_PE() volatile
    {
        UARTRSR ^= 1u << 1u;
    }

    /**
     * Get UARTRSR's BE bit.
     *
     * Break error. This bit is set to 1 if a break condition was detected,
     * indicating that the received data input was held LOW for longer than a
     * full-word transmission time (defined as start, data, parity, and stop
     * bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode,
     * this error is associated with the character at the top of the FIFO. When
     * a break occurs, only one 0 character is loaded into the FIFO. The next
     * character is only enabled after the receive data input goes to a 1
     * (marking state) and the next valid start bit is received.
     */
    inline bool get_UARTRSR_BE() volatile
    {
        return UARTRSR & (1u << 2u);
    }

    /**
     * Set UARTRSR's BE bit.
     *
     * Break error. This bit is set to 1 if a break condition was detected,
     * indicating that the received data input was held LOW for longer than a
     * full-word transmission time (defined as start, data, parity, and stop
     * bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode,
     * this error is associated with the character at the top of the FIFO. When
     * a break occurs, only one 0 character is loaded into the FIFO. The next
     * character is only enabled after the receive data input goes to a 1
     * (marking state) and the next valid start bit is received.
     */
    inline void set_UARTRSR_BE() volatile
    {
        UARTRSR |= 1u << 2u;
    }

    /**
     * Clear UARTRSR's BE bit.
     *
     * Break error. This bit is set to 1 if a break condition was detected,
     * indicating that the received data input was held LOW for longer than a
     * full-word transmission time (defined as start, data, parity, and stop
     * bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode,
     * this error is associated with the character at the top of the FIFO. When
     * a break occurs, only one 0 character is loaded into the FIFO. The next
     * character is only enabled after the receive data input goes to a 1
     * (marking state) and the next valid start bit is received.
     */
    inline void clear_UARTRSR_BE() volatile
    {
        UARTRSR &= ~(1u << 2u);
    }

    /**
     * Toggle UARTRSR's BE bit.
     *
     * Break error. This bit is set to 1 if a break condition was detected,
     * indicating that the received data input was held LOW for longer than a
     * full-word transmission time (defined as start, data, parity, and stop
     * bits). This bit is cleared to 0 after a write to UARTECR. In FIFO mode,
     * this error is associated with the character at the top of the FIFO. When
     * a break occurs, only one 0 character is loaded into the FIFO. The next
     * character is only enabled after the receive data input goes to a 1
     * (marking state) and the next valid start bit is received.
     */
    inline void toggle_UARTRSR_BE() volatile
    {
        UARTRSR ^= 1u << 2u;
    }

    /**
     * Get UARTRSR's OE bit.
     *
     * Overrun error. This bit is set to 1 if data is received and the FIFO is
     * already full. This bit is cleared to 0 by a write to UARTECR. The FIFO
     * contents remain valid because no more data is written when the FIFO is
     * full, only the contents of the shift register are overwritten. The CPU
     * must now read the data, to empty the FIFO.
     */
    inline bool get_UARTRSR_OE() volatile
    {
        return UARTRSR & (1u << 3u);
    }

    /**
     * Set UARTRSR's OE bit.
     *
     * Overrun error. This bit is set to 1 if data is received and the FIFO is
     * already full. This bit is cleared to 0 by a write to UARTECR. The FIFO
     * contents remain valid because no more data is written when the FIFO is
     * full, only the contents of the shift register are overwritten. The CPU
     * must now read the data, to empty the FIFO.
     */
    inline void set_UARTRSR_OE() volatile
    {
        UARTRSR |= 1u << 3u;
    }

    /**
     * Clear UARTRSR's OE bit.
     *
     * Overrun error. This bit is set to 1 if data is received and the FIFO is
     * already full. This bit is cleared to 0 by a write to UARTECR. The FIFO
     * contents remain valid because no more data is written when the FIFO is
     * full, only the contents of the shift register are overwritten. The CPU
     * must now read the data, to empty the FIFO.
     */
    inline void clear_UARTRSR_OE() volatile
    {
        UARTRSR &= ~(1u << 3u);
    }

    /**
     * Toggle UARTRSR's OE bit.
     *
     * Overrun error. This bit is set to 1 if data is received and the FIFO is
     * already full. This bit is cleared to 0 by a write to UARTECR. The FIFO
     * contents remain valid because no more data is written when the FIFO is
     * full, only the contents of the shift register are overwritten. The CPU
     * must now read the data, to empty the FIFO.
     */
    inline void toggle_UARTRSR_OE() volatile
    {
        UARTRSR ^= 1u << 3u;
    }

    /**
     * Get all of UARTRSR's bit fields.
     *
     * (read-write) Receive Status Register/Error Clear Register,
     * UARTRSR/UARTECR
     */
    inline void get_UARTRSR(bool &FE, bool &PE, bool &BE, bool &OE) volatile
    {
        uint32_t curr = UARTRSR;

        FE = curr & (1u << 0u);
        PE = curr & (1u << 1u);
        BE = curr & (1u << 2u);
        OE = curr & (1u << 3u);
    }

    /**
     * Set all of UARTRSR's bit fields.
     *
     * (read-write) Receive Status Register/Error Clear Register,
     * UARTRSR/UARTECR
     */
    inline void set_UARTRSR(bool FE, bool PE, bool BE, bool OE) volatile
    {
        uint32_t curr = UARTRSR;

        curr &= ~(0b1u << 0u);
        curr |= (FE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PE & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (BE & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (OE & 0b1u) << 3u;

        UARTRSR = curr;
    }

    /**
     * Get UARTFR's CTS bit.
     *
     * Clear to send. This bit is the complement of the UART clear to send,
     * nUARTCTS, modem status input. That is, the bit is 1 when nUARTCTS is
     * LOW.
     */
    inline bool get_UARTFR_CTS() volatile
    {
        return UARTFR & (1u << 0u);
    }

    /**
     * Get UARTFR's DSR bit.
     *
     * Data set ready. This bit is the complement of the UART data set ready,
     * nUARTDSR, modem status input. That is, the bit is 1 when nUARTDSR is
     * LOW.
     */
    inline bool get_UARTFR_DSR() volatile
    {
        return UARTFR & (1u << 1u);
    }

    /**
     * Get UARTFR's DCD bit.
     *
     * Data carrier detect. This bit is the complement of the UART data carrier
     * detect, nUARTDCD, modem status input. That is, the bit is 1 when
     * nUARTDCD is LOW.
     */
    inline bool get_UARTFR_DCD() volatile
    {
        return UARTFR & (1u << 2u);
    }

    /**
     * Get UARTFR's BUSY bit.
     *
     * UART busy. If this bit is set to 1, the UART is busy transmitting data.
     * This bit remains set until the complete byte, including all the stop
     * bits, has been sent from the shift register. This bit is set as soon as
     * the transmit FIFO becomes non-empty, regardless of whether the UART is
     * enabled or not.
     */
    inline bool get_UARTFR_BUSY() volatile
    {
        return UARTFR & (1u << 3u);
    }

    /**
     * Get UARTFR's RXFE bit.
     *
     * Receive FIFO empty. The meaning of this bit depends on the state of the
     * FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is
     * set when the receive holding register is empty. If the FIFO is enabled,
     * the RXFE bit is set when the receive FIFO is empty.
     */
    inline bool get_UARTFR_RXFE() volatile
    {
        return UARTFR & (1u << 4u);
    }

    /**
     * Get UARTFR's TXFF bit.
     *
     * Transmit FIFO full. The meaning of this bit depends on the state of the
     * FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is
     * set when the transmit holding register is full. If the FIFO is enabled,
     * the TXFF bit is set when the transmit FIFO is full.
     */
    inline bool get_UARTFR_TXFF() volatile
    {
        return UARTFR & (1u << 5u);
    }

    /**
     * Get UARTFR's RXFF bit.
     *
     * Receive FIFO full. The meaning of this bit depends on the state of the
     * FEN bit in the UARTLCR_H Register. If the FIFO is disabled, this bit is
     * set when the receive holding register is full. If the FIFO is enabled,
     * the RXFF bit is set when the receive FIFO is full.
     */
    inline bool get_UARTFR_RXFF() volatile
    {
        return UARTFR & (1u << 6u);
    }

    /**
     * Get UARTFR's TXFE bit.
     *
     * Transmit FIFO empty. The meaning of this bit depends on the state of the
     * FEN bit in the Line Control Register, UARTLCR_H. If the FIFO is
     * disabled, this bit is set when the transmit holding register is empty.
     * If the FIFO is enabled, the TXFE bit is set when the transmit FIFO is
     * empty. This bit does not indicate if there is data in the transmit shift
     * register.
     */
    inline bool get_UARTFR_TXFE() volatile
    {
        return UARTFR & (1u << 7u);
    }

    /**
     * Get UARTFR's RI bit.
     *
     * Ring indicator. This bit is the complement of the UART ring indicator,
     * nUARTRI, modem status input. That is, the bit is 1 when nUARTRI is LOW.
     */
    inline bool get_UARTFR_RI() volatile
    {
        return UARTFR & (1u << 8u);
    }

    /**
     * Get all of UARTFR's bit fields.
     *
     * (read-only) Flag Register, UARTFR
     */
    inline void get_UARTFR(bool &CTS, bool &DSR, bool &DCD, bool &BUSY,
                           bool &RXFE, bool &TXFF, bool &RXFF, bool &TXFE,
                           bool &RI) volatile
    {
        uint32_t curr = UARTFR;

        CTS = curr & (1u << 0u);
        DSR = curr & (1u << 1u);
        DCD = curr & (1u << 2u);
        BUSY = curr & (1u << 3u);
        RXFE = curr & (1u << 4u);
        TXFF = curr & (1u << 5u);
        RXFF = curr & (1u << 6u);
        TXFE = curr & (1u << 7u);
        RI = curr & (1u << 8u);
    }

    /**
     * Get UARTILPR's ILPDVSR field.
     *
     * 8-bit low-power divisor value. These bits are cleared to 0 at reset.
     */
    inline uint8_t get_UARTILPR_ILPDVSR() volatile
    {
        return (UARTILPR >> 0u) & 0b11111111u;
    }

    /**
     * Set UARTILPR's ILPDVSR field.
     *
     * 8-bit low-power divisor value. These bits are cleared to 0 at reset.
     */
    inline void set_UARTILPR_ILPDVSR(uint8_t value) volatile
    {
        uint32_t curr = UARTILPR;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        UARTILPR = curr;
    }

    /**
     * Get UARTIBRD's BAUD_DIVINT field.
     *
     * The integer baud rate divisor. These bits are cleared to 0 on reset.
     */
    inline uint16_t get_UARTIBRD_BAUD_DIVINT() volatile
    {
        return (UARTIBRD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set UARTIBRD's BAUD_DIVINT field.
     *
     * The integer baud rate divisor. These bits are cleared to 0 on reset.
     */
    inline void set_UARTIBRD_BAUD_DIVINT(uint16_t value) volatile
    {
        uint32_t curr = UARTIBRD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        UARTIBRD = curr;
    }

    /**
     * Get UARTFBRD's BAUD_DIVFRAC field.
     *
     * The fractional baud rate divisor. These bits are cleared to 0 on reset.
     */
    inline uint8_t get_UARTFBRD_BAUD_DIVFRAC() volatile
    {
        return (UARTFBRD >> 0u) & 0b111111u;
    }

    /**
     * Set UARTFBRD's BAUD_DIVFRAC field.
     *
     * The fractional baud rate divisor. These bits are cleared to 0 on reset.
     */
    inline void set_UARTFBRD_BAUD_DIVFRAC(uint8_t value) volatile
    {
        uint32_t curr = UARTFBRD;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        UARTFBRD = curr;
    }

    /**
     * Get UARTLCR_H's BRK bit.
     *
     * Send break. If this bit is set to 1, a low-level is continually output
     * on the UARTTXD output, after completing transmission of the current
     * character. For the proper execution of the break command, the software
     * must set this bit for at least two complete frames. For normal use, this
     * bit must be cleared to 0.
     */
    inline bool get_UARTLCR_H_BRK() volatile
    {
        return UARTLCR_H & (1u << 0u);
    }

    /**
     * Set UARTLCR_H's BRK bit.
     *
     * Send break. If this bit is set to 1, a low-level is continually output
     * on the UARTTXD output, after completing transmission of the current
     * character. For the proper execution of the break command, the software
     * must set this bit for at least two complete frames. For normal use, this
     * bit must be cleared to 0.
     */
    inline void set_UARTLCR_H_BRK() volatile
    {
        UARTLCR_H |= 1u << 0u;
    }

    /**
     * Clear UARTLCR_H's BRK bit.
     *
     * Send break. If this bit is set to 1, a low-level is continually output
     * on the UARTTXD output, after completing transmission of the current
     * character. For the proper execution of the break command, the software
     * must set this bit for at least two complete frames. For normal use, this
     * bit must be cleared to 0.
     */
    inline void clear_UARTLCR_H_BRK() volatile
    {
        UARTLCR_H &= ~(1u << 0u);
    }

    /**
     * Toggle UARTLCR_H's BRK bit.
     *
     * Send break. If this bit is set to 1, a low-level is continually output
     * on the UARTTXD output, after completing transmission of the current
     * character. For the proper execution of the break command, the software
     * must set this bit for at least two complete frames. For normal use, this
     * bit must be cleared to 0.
     */
    inline void toggle_UARTLCR_H_BRK() volatile
    {
        UARTLCR_H ^= 1u << 0u;
    }

    /**
     * Get UARTLCR_H's PEN bit.
     *
     * Parity enable: 0 = parity is disabled and no parity bit added to the
     * data frame 1 = parity checking and generation is enabled.
     */
    inline bool get_UARTLCR_H_PEN() volatile
    {
        return UARTLCR_H & (1u << 1u);
    }

    /**
     * Set UARTLCR_H's PEN bit.
     *
     * Parity enable: 0 = parity is disabled and no parity bit added to the
     * data frame 1 = parity checking and generation is enabled.
     */
    inline void set_UARTLCR_H_PEN() volatile
    {
        UARTLCR_H |= 1u << 1u;
    }

    /**
     * Clear UARTLCR_H's PEN bit.
     *
     * Parity enable: 0 = parity is disabled and no parity bit added to the
     * data frame 1 = parity checking and generation is enabled.
     */
    inline void clear_UARTLCR_H_PEN() volatile
    {
        UARTLCR_H &= ~(1u << 1u);
    }

    /**
     * Toggle UARTLCR_H's PEN bit.
     *
     * Parity enable: 0 = parity is disabled and no parity bit added to the
     * data frame 1 = parity checking and generation is enabled.
     */
    inline void toggle_UARTLCR_H_PEN() volatile
    {
        UARTLCR_H ^= 1u << 1u;
    }

    /**
     * Get UARTLCR_H's EPS bit.
     *
     * Even parity select. Controls the type of parity the UART uses during
     * transmission and reception: 0 = odd parity. The UART generates or checks
     * for an odd number of 1s in the data and parity bits. 1 = even parity.
     * The UART generates or checks for an even number of 1s in the data and
     * parity bits. This bit has no effect when the PEN bit disables parity
     * checking and generation.
     */
    inline bool get_UARTLCR_H_EPS() volatile
    {
        return UARTLCR_H & (1u << 2u);
    }

    /**
     * Set UARTLCR_H's EPS bit.
     *
     * Even parity select. Controls the type of parity the UART uses during
     * transmission and reception: 0 = odd parity. The UART generates or checks
     * for an odd number of 1s in the data and parity bits. 1 = even parity.
     * The UART generates or checks for an even number of 1s in the data and
     * parity bits. This bit has no effect when the PEN bit disables parity
     * checking and generation.
     */
    inline void set_UARTLCR_H_EPS() volatile
    {
        UARTLCR_H |= 1u << 2u;
    }

    /**
     * Clear UARTLCR_H's EPS bit.
     *
     * Even parity select. Controls the type of parity the UART uses during
     * transmission and reception: 0 = odd parity. The UART generates or checks
     * for an odd number of 1s in the data and parity bits. 1 = even parity.
     * The UART generates or checks for an even number of 1s in the data and
     * parity bits. This bit has no effect when the PEN bit disables parity
     * checking and generation.
     */
    inline void clear_UARTLCR_H_EPS() volatile
    {
        UARTLCR_H &= ~(1u << 2u);
    }

    /**
     * Toggle UARTLCR_H's EPS bit.
     *
     * Even parity select. Controls the type of parity the UART uses during
     * transmission and reception: 0 = odd parity. The UART generates or checks
     * for an odd number of 1s in the data and parity bits. 1 = even parity.
     * The UART generates or checks for an even number of 1s in the data and
     * parity bits. This bit has no effect when the PEN bit disables parity
     * checking and generation.
     */
    inline void toggle_UARTLCR_H_EPS() volatile
    {
        UARTLCR_H ^= 1u << 2u;
    }

    /**
     * Get UARTLCR_H's STP2 bit.
     *
     * Two stop bits select. If this bit is set to 1, two stop bits are
     * transmitted at the end of the frame. The receive logic does not check
     * for two stop bits being received.
     */
    inline bool get_UARTLCR_H_STP2() volatile
    {
        return UARTLCR_H & (1u << 3u);
    }

    /**
     * Set UARTLCR_H's STP2 bit.
     *
     * Two stop bits select. If this bit is set to 1, two stop bits are
     * transmitted at the end of the frame. The receive logic does not check
     * for two stop bits being received.
     */
    inline void set_UARTLCR_H_STP2() volatile
    {
        UARTLCR_H |= 1u << 3u;
    }

    /**
     * Clear UARTLCR_H's STP2 bit.
     *
     * Two stop bits select. If this bit is set to 1, two stop bits are
     * transmitted at the end of the frame. The receive logic does not check
     * for two stop bits being received.
     */
    inline void clear_UARTLCR_H_STP2() volatile
    {
        UARTLCR_H &= ~(1u << 3u);
    }

    /**
     * Toggle UARTLCR_H's STP2 bit.
     *
     * Two stop bits select. If this bit is set to 1, two stop bits are
     * transmitted at the end of the frame. The receive logic does not check
     * for two stop bits being received.
     */
    inline void toggle_UARTLCR_H_STP2() volatile
    {
        UARTLCR_H ^= 1u << 3u;
    }

    /**
     * Get UARTLCR_H's FEN bit.
     *
     * Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs
     * become 1-byte-deep holding registers 1 = transmit and receive FIFO
     * buffers are enabled (FIFO mode).
     */
    inline bool get_UARTLCR_H_FEN() volatile
    {
        return UARTLCR_H & (1u << 4u);
    }

    /**
     * Set UARTLCR_H's FEN bit.
     *
     * Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs
     * become 1-byte-deep holding registers 1 = transmit and receive FIFO
     * buffers are enabled (FIFO mode).
     */
    inline void set_UARTLCR_H_FEN() volatile
    {
        UARTLCR_H |= 1u << 4u;
    }

    /**
     * Clear UARTLCR_H's FEN bit.
     *
     * Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs
     * become 1-byte-deep holding registers 1 = transmit and receive FIFO
     * buffers are enabled (FIFO mode).
     */
    inline void clear_UARTLCR_H_FEN() volatile
    {
        UARTLCR_H &= ~(1u << 4u);
    }

    /**
     * Toggle UARTLCR_H's FEN bit.
     *
     * Enable FIFOs: 0 = FIFOs are disabled (character mode) that is, the FIFOs
     * become 1-byte-deep holding registers 1 = transmit and receive FIFO
     * buffers are enabled (FIFO mode).
     */
    inline void toggle_UARTLCR_H_FEN() volatile
    {
        UARTLCR_H ^= 1u << 4u;
    }

    /**
     * Get UARTLCR_H's WLEN field.
     *
     * Word length. These bits indicate the number of data bits transmitted or
     * received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits
     * b00 = 5 bits.
     */
    inline uint8_t get_UARTLCR_H_WLEN() volatile
    {
        return (UARTLCR_H >> 5u) & 0b11u;
    }

    /**
     * Set UARTLCR_H's WLEN field.
     *
     * Word length. These bits indicate the number of data bits transmitted or
     * received in a frame as follows: b11 = 8 bits b10 = 7 bits b01 = 6 bits
     * b00 = 5 bits.
     */
    inline void set_UARTLCR_H_WLEN(uint8_t value) volatile
    {
        uint32_t curr = UARTLCR_H;

        curr &= ~(0b11u << 5u);
        curr |= (value & 0b11u) << 5u;

        UARTLCR_H = curr;
    }

    /**
     * Get UARTLCR_H's SPS bit.
     *
     * Stick parity select. 0 = stick parity is disabled 1 = either: * if the
     * EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if
     * the EPS bit is 1 then the parity bit is transmitted and checked as a 0.
     * This bit has no effect when the PEN bit disables parity checking and
     * generation.
     */
    inline bool get_UARTLCR_H_SPS() volatile
    {
        return UARTLCR_H & (1u << 7u);
    }

    /**
     * Set UARTLCR_H's SPS bit.
     *
     * Stick parity select. 0 = stick parity is disabled 1 = either: * if the
     * EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if
     * the EPS bit is 1 then the parity bit is transmitted and checked as a 0.
     * This bit has no effect when the PEN bit disables parity checking and
     * generation.
     */
    inline void set_UARTLCR_H_SPS() volatile
    {
        UARTLCR_H |= 1u << 7u;
    }

    /**
     * Clear UARTLCR_H's SPS bit.
     *
     * Stick parity select. 0 = stick parity is disabled 1 = either: * if the
     * EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if
     * the EPS bit is 1 then the parity bit is transmitted and checked as a 0.
     * This bit has no effect when the PEN bit disables parity checking and
     * generation.
     */
    inline void clear_UARTLCR_H_SPS() volatile
    {
        UARTLCR_H &= ~(1u << 7u);
    }

    /**
     * Toggle UARTLCR_H's SPS bit.
     *
     * Stick parity select. 0 = stick parity is disabled 1 = either: * if the
     * EPS bit is 0 then the parity bit is transmitted and checked as a 1 * if
     * the EPS bit is 1 then the parity bit is transmitted and checked as a 0.
     * This bit has no effect when the PEN bit disables parity checking and
     * generation.
     */
    inline void toggle_UARTLCR_H_SPS() volatile
    {
        UARTLCR_H ^= 1u << 7u;
    }

    /**
     * Get all of UARTLCR_H's bit fields.
     *
     * (read-write) Line Control Register, UARTLCR_H
     */
    inline void get_UARTLCR_H(bool &BRK, bool &PEN, bool &EPS, bool &STP2,
                              bool &FEN, uint8_t &WLEN, bool &SPS) volatile
    {
        uint32_t curr = UARTLCR_H;

        BRK = curr & (1u << 0u);
        PEN = curr & (1u << 1u);
        EPS = curr & (1u << 2u);
        STP2 = curr & (1u << 3u);
        FEN = curr & (1u << 4u);
        WLEN = (curr >> 5u) & 0b11u;
        SPS = curr & (1u << 7u);
    }

    /**
     * Set all of UARTLCR_H's bit fields.
     *
     * (read-write) Line Control Register, UARTLCR_H
     */
    inline void set_UARTLCR_H(bool BRK, bool PEN, bool EPS, bool STP2,
                              bool FEN, uint8_t WLEN, bool SPS) volatile
    {
        uint32_t curr = UARTLCR_H;

        curr &= ~(0b1u << 0u);
        curr |= (BRK & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PEN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (EPS & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (STP2 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (FEN & 0b1u) << 4u;
        curr &= ~(0b11u << 5u);
        curr |= (WLEN & 0b11u) << 5u;
        curr &= ~(0b1u << 7u);
        curr |= (SPS & 0b1u) << 7u;

        UARTLCR_H = curr;
    }

    /**
     * Get UARTCR's UARTEN bit.
     *
     * UART enable: 0 = UART is disabled. If the UART is disabled in the middle
     * of transmission or reception, it completes the current character before
     * stopping. 1 = the UART is enabled. Data transmission and reception
     * occurs for either UART signals or SIR signals depending on the setting
     * of the SIREN bit.
     */
    inline bool get_UARTCR_UARTEN() volatile
    {
        return UARTCR & (1u << 0u);
    }

    /**
     * Set UARTCR's UARTEN bit.
     *
     * UART enable: 0 = UART is disabled. If the UART is disabled in the middle
     * of transmission or reception, it completes the current character before
     * stopping. 1 = the UART is enabled. Data transmission and reception
     * occurs for either UART signals or SIR signals depending on the setting
     * of the SIREN bit.
     */
    inline void set_UARTCR_UARTEN() volatile
    {
        UARTCR |= 1u << 0u;
    }

    /**
     * Clear UARTCR's UARTEN bit.
     *
     * UART enable: 0 = UART is disabled. If the UART is disabled in the middle
     * of transmission or reception, it completes the current character before
     * stopping. 1 = the UART is enabled. Data transmission and reception
     * occurs for either UART signals or SIR signals depending on the setting
     * of the SIREN bit.
     */
    inline void clear_UARTCR_UARTEN() volatile
    {
        UARTCR &= ~(1u << 0u);
    }

    /**
     * Toggle UARTCR's UARTEN bit.
     *
     * UART enable: 0 = UART is disabled. If the UART is disabled in the middle
     * of transmission or reception, it completes the current character before
     * stopping. 1 = the UART is enabled. Data transmission and reception
     * occurs for either UART signals or SIR signals depending on the setting
     * of the SIREN bit.
     */
    inline void toggle_UARTCR_UARTEN() volatile
    {
        UARTCR ^= 1u << 0u;
    }

    /**
     * Get UARTCR's SIREN bit.
     *
     * SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no
     * light pulse generated), and signal transitions on SIRIN have no effect.
     * 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on
     * nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal
     * transitions on UARTRXD or modem status inputs have no effect. This bit
     * has no effect if the UARTEN bit disables the UART.
     */
    inline bool get_UARTCR_SIREN() volatile
    {
        return UARTCR & (1u << 1u);
    }

    /**
     * Set UARTCR's SIREN bit.
     *
     * SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no
     * light pulse generated), and signal transitions on SIRIN have no effect.
     * 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on
     * nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal
     * transitions on UARTRXD or modem status inputs have no effect. This bit
     * has no effect if the UARTEN bit disables the UART.
     */
    inline void set_UARTCR_SIREN() volatile
    {
        UARTCR |= 1u << 1u;
    }

    /**
     * Clear UARTCR's SIREN bit.
     *
     * SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no
     * light pulse generated), and signal transitions on SIRIN have no effect.
     * 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on
     * nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal
     * transitions on UARTRXD or modem status inputs have no effect. This bit
     * has no effect if the UARTEN bit disables the UART.
     */
    inline void clear_UARTCR_SIREN() volatile
    {
        UARTCR &= ~(1u << 1u);
    }

    /**
     * Toggle UARTCR's SIREN bit.
     *
     * SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains LOW (no
     * light pulse generated), and signal transitions on SIRIN have no effect.
     * 1 = IrDA SIR ENDEC is enabled. Data is transmitted and received on
     * nSIROUT and SIRIN. UARTTXD remains HIGH, in the marking state. Signal
     * transitions on UARTRXD or modem status inputs have no effect. This bit
     * has no effect if the UARTEN bit disables the UART.
     */
    inline void toggle_UARTCR_SIREN() volatile
    {
        UARTCR ^= 1u << 1u;
    }

    /**
     * Get UARTCR's SIRLP bit.
     *
     * SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If
     * this bit is cleared to 0, low-level bits are transmitted as an active
     * high pulse with a width of 3 / 16th of the bit period. If this bit is
     * set to 1, low-level bits are transmitted with a pulse width that is 3
     * times the period of the IrLPBaud16 input signal, regardless of the
     * selected bit rate. Setting this bit uses less power, but might reduce
     * transmission distances.
     */
    inline bool get_UARTCR_SIRLP() volatile
    {
        return UARTCR & (1u << 2u);
    }

    /**
     * Set UARTCR's SIRLP bit.
     *
     * SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If
     * this bit is cleared to 0, low-level bits are transmitted as an active
     * high pulse with a width of 3 / 16th of the bit period. If this bit is
     * set to 1, low-level bits are transmitted with a pulse width that is 3
     * times the period of the IrLPBaud16 input signal, regardless of the
     * selected bit rate. Setting this bit uses less power, but might reduce
     * transmission distances.
     */
    inline void set_UARTCR_SIRLP() volatile
    {
        UARTCR |= 1u << 2u;
    }

    /**
     * Clear UARTCR's SIRLP bit.
     *
     * SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If
     * this bit is cleared to 0, low-level bits are transmitted as an active
     * high pulse with a width of 3 / 16th of the bit period. If this bit is
     * set to 1, low-level bits are transmitted with a pulse width that is 3
     * times the period of the IrLPBaud16 input signal, regardless of the
     * selected bit rate. Setting this bit uses less power, but might reduce
     * transmission distances.
     */
    inline void clear_UARTCR_SIRLP() volatile
    {
        UARTCR &= ~(1u << 2u);
    }

    /**
     * Toggle UARTCR's SIRLP bit.
     *
     * SIR low-power IrDA mode. This bit selects the IrDA encoding mode. If
     * this bit is cleared to 0, low-level bits are transmitted as an active
     * high pulse with a width of 3 / 16th of the bit period. If this bit is
     * set to 1, low-level bits are transmitted with a pulse width that is 3
     * times the period of the IrLPBaud16 input signal, regardless of the
     * selected bit rate. Setting this bit uses less power, but might reduce
     * transmission distances.
     */
    inline void toggle_UARTCR_SIRLP() volatile
    {
        UARTCR ^= 1u << 2u;
    }

    /**
     * Get UARTCR's LBE bit.
     *
     * Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1
     * and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1,
     * then the nSIROUT path is inverted, and fed through to the SIRIN path.
     * The SIRTEST bit in the test register must be set to 1 to override the
     * normal half-duplex SIR operation. This must be the requirement for
     * accessing the test registers during normal operation, and SIRTEST must
     * be cleared to 0 when loopback testing is finished. This feature reduces
     * the amount of external coupling required during system test. If this bit
     * is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed
     * through to the UARTRXD path. In either SIR mode or UART mode, when this
     * bit is set, the modem outputs are also fed through to the modem inputs.
     * This bit is cleared to 0 on reset, to disable loopback.
     */
    inline bool get_UARTCR_LBE() volatile
    {
        return UARTCR & (1u << 7u);
    }

    /**
     * Set UARTCR's LBE bit.
     *
     * Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1
     * and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1,
     * then the nSIROUT path is inverted, and fed through to the SIRIN path.
     * The SIRTEST bit in the test register must be set to 1 to override the
     * normal half-duplex SIR operation. This must be the requirement for
     * accessing the test registers during normal operation, and SIRTEST must
     * be cleared to 0 when loopback testing is finished. This feature reduces
     * the amount of external coupling required during system test. If this bit
     * is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed
     * through to the UARTRXD path. In either SIR mode or UART mode, when this
     * bit is set, the modem outputs are also fed through to the modem inputs.
     * This bit is cleared to 0 on reset, to disable loopback.
     */
    inline void set_UARTCR_LBE() volatile
    {
        UARTCR |= 1u << 7u;
    }

    /**
     * Clear UARTCR's LBE bit.
     *
     * Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1
     * and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1,
     * then the nSIROUT path is inverted, and fed through to the SIRIN path.
     * The SIRTEST bit in the test register must be set to 1 to override the
     * normal half-duplex SIR operation. This must be the requirement for
     * accessing the test registers during normal operation, and SIRTEST must
     * be cleared to 0 when loopback testing is finished. This feature reduces
     * the amount of external coupling required during system test. If this bit
     * is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed
     * through to the UARTRXD path. In either SIR mode or UART mode, when this
     * bit is set, the modem outputs are also fed through to the modem inputs.
     * This bit is cleared to 0 on reset, to disable loopback.
     */
    inline void clear_UARTCR_LBE() volatile
    {
        UARTCR &= ~(1u << 7u);
    }

    /**
     * Toggle UARTCR's LBE bit.
     *
     * Loopback enable. If this bit is set to 1 and the SIREN bit is set to 1
     * and the SIRTEST bit in the Test Control Register, UARTTCR is set to 1,
     * then the nSIROUT path is inverted, and fed through to the SIRIN path.
     * The SIRTEST bit in the test register must be set to 1 to override the
     * normal half-duplex SIR operation. This must be the requirement for
     * accessing the test registers during normal operation, and SIRTEST must
     * be cleared to 0 when loopback testing is finished. This feature reduces
     * the amount of external coupling required during system test. If this bit
     * is set to 1, and the SIRTEST bit is set to 0, the UARTTXD path is fed
     * through to the UARTRXD path. In either SIR mode or UART mode, when this
     * bit is set, the modem outputs are also fed through to the modem inputs.
     * This bit is cleared to 0 on reset, to disable loopback.
     */
    inline void toggle_UARTCR_LBE() volatile
    {
        UARTCR ^= 1u << 7u;
    }

    /**
     * Get UARTCR's TXE bit.
     *
     * Transmit enable. If this bit is set to 1, the transmit section of the
     * UART is enabled. Data transmission occurs for either UART signals, or
     * SIR signals depending on the setting of the SIREN bit. When the UART is
     * disabled in the middle of transmission, it completes the current
     * character before stopping.
     */
    inline bool get_UARTCR_TXE() volatile
    {
        return UARTCR & (1u << 8u);
    }

    /**
     * Set UARTCR's TXE bit.
     *
     * Transmit enable. If this bit is set to 1, the transmit section of the
     * UART is enabled. Data transmission occurs for either UART signals, or
     * SIR signals depending on the setting of the SIREN bit. When the UART is
     * disabled in the middle of transmission, it completes the current
     * character before stopping.
     */
    inline void set_UARTCR_TXE() volatile
    {
        UARTCR |= 1u << 8u;
    }

    /**
     * Clear UARTCR's TXE bit.
     *
     * Transmit enable. If this bit is set to 1, the transmit section of the
     * UART is enabled. Data transmission occurs for either UART signals, or
     * SIR signals depending on the setting of the SIREN bit. When the UART is
     * disabled in the middle of transmission, it completes the current
     * character before stopping.
     */
    inline void clear_UARTCR_TXE() volatile
    {
        UARTCR &= ~(1u << 8u);
    }

    /**
     * Toggle UARTCR's TXE bit.
     *
     * Transmit enable. If this bit is set to 1, the transmit section of the
     * UART is enabled. Data transmission occurs for either UART signals, or
     * SIR signals depending on the setting of the SIREN bit. When the UART is
     * disabled in the middle of transmission, it completes the current
     * character before stopping.
     */
    inline void toggle_UARTCR_TXE() volatile
    {
        UARTCR ^= 1u << 8u;
    }

    /**
     * Get UARTCR's RXE bit.
     *
     * Receive enable. If this bit is set to 1, the receive section of the UART
     * is enabled. Data reception occurs for either UART signals or SIR signals
     * depending on the setting of the SIREN bit. When the UART is disabled in
     * the middle of reception, it completes the current character before
     * stopping.
     */
    inline bool get_UARTCR_RXE() volatile
    {
        return UARTCR & (1u << 9u);
    }

    /**
     * Set UARTCR's RXE bit.
     *
     * Receive enable. If this bit is set to 1, the receive section of the UART
     * is enabled. Data reception occurs for either UART signals or SIR signals
     * depending on the setting of the SIREN bit. When the UART is disabled in
     * the middle of reception, it completes the current character before
     * stopping.
     */
    inline void set_UARTCR_RXE() volatile
    {
        UARTCR |= 1u << 9u;
    }

    /**
     * Clear UARTCR's RXE bit.
     *
     * Receive enable. If this bit is set to 1, the receive section of the UART
     * is enabled. Data reception occurs for either UART signals or SIR signals
     * depending on the setting of the SIREN bit. When the UART is disabled in
     * the middle of reception, it completes the current character before
     * stopping.
     */
    inline void clear_UARTCR_RXE() volatile
    {
        UARTCR &= ~(1u << 9u);
    }

    /**
     * Toggle UARTCR's RXE bit.
     *
     * Receive enable. If this bit is set to 1, the receive section of the UART
     * is enabled. Data reception occurs for either UART signals or SIR signals
     * depending on the setting of the SIREN bit. When the UART is disabled in
     * the middle of reception, it completes the current character before
     * stopping.
     */
    inline void toggle_UARTCR_RXE() volatile
    {
        UARTCR ^= 1u << 9u;
    }

    /**
     * Get UARTCR's DTR bit.
     *
     * Data transmit ready. This bit is the complement of the UART data
     * transmit ready, nUARTDTR, modem status output. That is, when the bit is
     * programmed to a 1 then nUARTDTR is LOW.
     */
    inline bool get_UARTCR_DTR() volatile
    {
        return UARTCR & (1u << 10u);
    }

    /**
     * Set UARTCR's DTR bit.
     *
     * Data transmit ready. This bit is the complement of the UART data
     * transmit ready, nUARTDTR, modem status output. That is, when the bit is
     * programmed to a 1 then nUARTDTR is LOW.
     */
    inline void set_UARTCR_DTR() volatile
    {
        UARTCR |= 1u << 10u;
    }

    /**
     * Clear UARTCR's DTR bit.
     *
     * Data transmit ready. This bit is the complement of the UART data
     * transmit ready, nUARTDTR, modem status output. That is, when the bit is
     * programmed to a 1 then nUARTDTR is LOW.
     */
    inline void clear_UARTCR_DTR() volatile
    {
        UARTCR &= ~(1u << 10u);
    }

    /**
     * Toggle UARTCR's DTR bit.
     *
     * Data transmit ready. This bit is the complement of the UART data
     * transmit ready, nUARTDTR, modem status output. That is, when the bit is
     * programmed to a 1 then nUARTDTR is LOW.
     */
    inline void toggle_UARTCR_DTR() volatile
    {
        UARTCR ^= 1u << 10u;
    }

    /**
     * Get UARTCR's RTS bit.
     *
     * Request to send. This bit is the complement of the UART request to send,
     * nUARTRTS, modem status output. That is, when the bit is programmed to a
     * 1 then nUARTRTS is LOW.
     */
    inline bool get_UARTCR_RTS() volatile
    {
        return UARTCR & (1u << 11u);
    }

    /**
     * Set UARTCR's RTS bit.
     *
     * Request to send. This bit is the complement of the UART request to send,
     * nUARTRTS, modem status output. That is, when the bit is programmed to a
     * 1 then nUARTRTS is LOW.
     */
    inline void set_UARTCR_RTS() volatile
    {
        UARTCR |= 1u << 11u;
    }

    /**
     * Clear UARTCR's RTS bit.
     *
     * Request to send. This bit is the complement of the UART request to send,
     * nUARTRTS, modem status output. That is, when the bit is programmed to a
     * 1 then nUARTRTS is LOW.
     */
    inline void clear_UARTCR_RTS() volatile
    {
        UARTCR &= ~(1u << 11u);
    }

    /**
     * Toggle UARTCR's RTS bit.
     *
     * Request to send. This bit is the complement of the UART request to send,
     * nUARTRTS, modem status output. That is, when the bit is programmed to a
     * 1 then nUARTRTS is LOW.
     */
    inline void toggle_UARTCR_RTS() volatile
    {
        UARTCR ^= 1u << 11u;
    }

    /**
     * Get UARTCR's OUT1 bit.
     *
     * This bit is the complement of the UART Out1 (nUARTOut1) modem status
     * output. That is, when the bit is programmed to a 1 the output is 0. For
     * DTE this can be used as Data Carrier Detect (DCD).
     */
    inline bool get_UARTCR_OUT1() volatile
    {
        return UARTCR & (1u << 12u);
    }

    /**
     * Set UARTCR's OUT1 bit.
     *
     * This bit is the complement of the UART Out1 (nUARTOut1) modem status
     * output. That is, when the bit is programmed to a 1 the output is 0. For
     * DTE this can be used as Data Carrier Detect (DCD).
     */
    inline void set_UARTCR_OUT1() volatile
    {
        UARTCR |= 1u << 12u;
    }

    /**
     * Clear UARTCR's OUT1 bit.
     *
     * This bit is the complement of the UART Out1 (nUARTOut1) modem status
     * output. That is, when the bit is programmed to a 1 the output is 0. For
     * DTE this can be used as Data Carrier Detect (DCD).
     */
    inline void clear_UARTCR_OUT1() volatile
    {
        UARTCR &= ~(1u << 12u);
    }

    /**
     * Toggle UARTCR's OUT1 bit.
     *
     * This bit is the complement of the UART Out1 (nUARTOut1) modem status
     * output. That is, when the bit is programmed to a 1 the output is 0. For
     * DTE this can be used as Data Carrier Detect (DCD).
     */
    inline void toggle_UARTCR_OUT1() volatile
    {
        UARTCR ^= 1u << 12u;
    }

    /**
     * Get UARTCR's OUT2 bit.
     *
     * This bit is the complement of the UART Out2 (nUARTOut2) modem status
     * output. That is, when the bit is programmed to a 1, the output is 0. For
     * DTE this can be used as Ring Indicator (RI).
     */
    inline bool get_UARTCR_OUT2() volatile
    {
        return UARTCR & (1u << 13u);
    }

    /**
     * Set UARTCR's OUT2 bit.
     *
     * This bit is the complement of the UART Out2 (nUARTOut2) modem status
     * output. That is, when the bit is programmed to a 1, the output is 0. For
     * DTE this can be used as Ring Indicator (RI).
     */
    inline void set_UARTCR_OUT2() volatile
    {
        UARTCR |= 1u << 13u;
    }

    /**
     * Clear UARTCR's OUT2 bit.
     *
     * This bit is the complement of the UART Out2 (nUARTOut2) modem status
     * output. That is, when the bit is programmed to a 1, the output is 0. For
     * DTE this can be used as Ring Indicator (RI).
     */
    inline void clear_UARTCR_OUT2() volatile
    {
        UARTCR &= ~(1u << 13u);
    }

    /**
     * Toggle UARTCR's OUT2 bit.
     *
     * This bit is the complement of the UART Out2 (nUARTOut2) modem status
     * output. That is, when the bit is programmed to a 1, the output is 0. For
     * DTE this can be used as Ring Indicator (RI).
     */
    inline void toggle_UARTCR_OUT2() volatile
    {
        UARTCR ^= 1u << 13u;
    }

    /**
     * Get UARTCR's RTSEN bit.
     *
     * RTS hardware flow control enable. If this bit is set to 1, RTS hardware
     * flow control is enabled. Data is only requested when there is space in
     * the receive FIFO for it to be received.
     */
    inline bool get_UARTCR_RTSEN() volatile
    {
        return UARTCR & (1u << 14u);
    }

    /**
     * Set UARTCR's RTSEN bit.
     *
     * RTS hardware flow control enable. If this bit is set to 1, RTS hardware
     * flow control is enabled. Data is only requested when there is space in
     * the receive FIFO for it to be received.
     */
    inline void set_UARTCR_RTSEN() volatile
    {
        UARTCR |= 1u << 14u;
    }

    /**
     * Clear UARTCR's RTSEN bit.
     *
     * RTS hardware flow control enable. If this bit is set to 1, RTS hardware
     * flow control is enabled. Data is only requested when there is space in
     * the receive FIFO for it to be received.
     */
    inline void clear_UARTCR_RTSEN() volatile
    {
        UARTCR &= ~(1u << 14u);
    }

    /**
     * Toggle UARTCR's RTSEN bit.
     *
     * RTS hardware flow control enable. If this bit is set to 1, RTS hardware
     * flow control is enabled. Data is only requested when there is space in
     * the receive FIFO for it to be received.
     */
    inline void toggle_UARTCR_RTSEN() volatile
    {
        UARTCR ^= 1u << 14u;
    }

    /**
     * Get UARTCR's CTSEN bit.
     *
     * CTS hardware flow control enable. If this bit is set to 1, CTS hardware
     * flow control is enabled. Data is only transmitted when the nUARTCTS
     * signal is asserted.
     */
    inline bool get_UARTCR_CTSEN() volatile
    {
        return UARTCR & (1u << 15u);
    }

    /**
     * Set UARTCR's CTSEN bit.
     *
     * CTS hardware flow control enable. If this bit is set to 1, CTS hardware
     * flow control is enabled. Data is only transmitted when the nUARTCTS
     * signal is asserted.
     */
    inline void set_UARTCR_CTSEN() volatile
    {
        UARTCR |= 1u << 15u;
    }

    /**
     * Clear UARTCR's CTSEN bit.
     *
     * CTS hardware flow control enable. If this bit is set to 1, CTS hardware
     * flow control is enabled. Data is only transmitted when the nUARTCTS
     * signal is asserted.
     */
    inline void clear_UARTCR_CTSEN() volatile
    {
        UARTCR &= ~(1u << 15u);
    }

    /**
     * Toggle UARTCR's CTSEN bit.
     *
     * CTS hardware flow control enable. If this bit is set to 1, CTS hardware
     * flow control is enabled. Data is only transmitted when the nUARTCTS
     * signal is asserted.
     */
    inline void toggle_UARTCR_CTSEN() volatile
    {
        UARTCR ^= 1u << 15u;
    }

    /**
     * Get all of UARTCR's bit fields.
     *
     * (read-write) Control Register, UARTCR
     */
    inline void get_UARTCR(bool &UARTEN, bool &SIREN, bool &SIRLP, bool &LBE,
                           bool &TXE, bool &RXE, bool &DTR, bool &RTS,
                           bool &OUT1, bool &OUT2, bool &RTSEN,
                           bool &CTSEN) volatile
    {
        uint32_t curr = UARTCR;

        UARTEN = curr & (1u << 0u);
        SIREN = curr & (1u << 1u);
        SIRLP = curr & (1u << 2u);
        LBE = curr & (1u << 7u);
        TXE = curr & (1u << 8u);
        RXE = curr & (1u << 9u);
        DTR = curr & (1u << 10u);
        RTS = curr & (1u << 11u);
        OUT1 = curr & (1u << 12u);
        OUT2 = curr & (1u << 13u);
        RTSEN = curr & (1u << 14u);
        CTSEN = curr & (1u << 15u);
    }

    /**
     * Set all of UARTCR's bit fields.
     *
     * (read-write) Control Register, UARTCR
     */
    inline void set_UARTCR(bool UARTEN, bool SIREN, bool SIRLP, bool LBE,
                           bool TXE, bool RXE, bool DTR, bool RTS, bool OUT1,
                           bool OUT2, bool RTSEN, bool CTSEN) volatile
    {
        uint32_t curr = UARTCR;

        curr &= ~(0b1u << 0u);
        curr |= (UARTEN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SIREN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SIRLP & 0b1u) << 2u;
        curr &= ~(0b1u << 7u);
        curr |= (LBE & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (TXE & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (RXE & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (DTR & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (RTS & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (OUT1 & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (OUT2 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (RTSEN & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (CTSEN & 0b1u) << 15u;

        UARTCR = curr;
    }

    /**
     * Get UARTIFLS's TXIFLSEL field.
     *
     * Transmit interrupt FIFO level select. The trigger points for the
     * transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8
     * full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO
     * becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 =
     * Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
     */
    inline uint8_t get_UARTIFLS_TXIFLSEL() volatile
    {
        return (UARTIFLS >> 0u) & 0b111u;
    }

    /**
     * Set UARTIFLS's TXIFLSEL field.
     *
     * Transmit interrupt FIFO level select. The trigger points for the
     * transmit interrupt are as follows: b000 = Transmit FIFO becomes <= 1 / 8
     * full b001 = Transmit FIFO becomes <= 1 / 4 full b010 = Transmit FIFO
     * becomes <= 1 / 2 full b011 = Transmit FIFO becomes <= 3 / 4 full b100 =
     * Transmit FIFO becomes <= 7 / 8 full b101-b111 = reserved.
     */
    inline void set_UARTIFLS_TXIFLSEL(uint8_t value) volatile
    {
        uint32_t curr = UARTIFLS;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        UARTIFLS = curr;
    }

    /**
     * Get UARTIFLS's RXIFLSEL field.
     *
     * Receive interrupt FIFO level select. The trigger points for the receive
     * interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001
     * = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 /
     * 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO
     * becomes >= 7 / 8 full b101-b111 = reserved.
     */
    inline uint8_t get_UARTIFLS_RXIFLSEL() volatile
    {
        return (UARTIFLS >> 3u) & 0b111u;
    }

    /**
     * Set UARTIFLS's RXIFLSEL field.
     *
     * Receive interrupt FIFO level select. The trigger points for the receive
     * interrupt are as follows: b000 = Receive FIFO becomes >= 1 / 8 full b001
     * = Receive FIFO becomes >= 1 / 4 full b010 = Receive FIFO becomes >= 1 /
     * 2 full b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive FIFO
     * becomes >= 7 / 8 full b101-b111 = reserved.
     */
    inline void set_UARTIFLS_RXIFLSEL(uint8_t value) volatile
    {
        uint32_t curr = UARTIFLS;

        curr &= ~(0b111u << 3u);
        curr |= (value & 0b111u) << 3u;

        UARTIFLS = curr;
    }

    /**
     * Get all of UARTIFLS's bit fields.
     *
     * (read-write) Interrupt FIFO Level Select Register, UARTIFLS
     */
    inline void get_UARTIFLS(uint8_t &TXIFLSEL, uint8_t &RXIFLSEL) volatile
    {
        uint32_t curr = UARTIFLS;

        TXIFLSEL = (curr >> 0u) & 0b111u;
        RXIFLSEL = (curr >> 3u) & 0b111u;
    }

    /**
     * Set all of UARTIFLS's bit fields.
     *
     * (read-write) Interrupt FIFO Level Select Register, UARTIFLS
     */
    inline void set_UARTIFLS(uint8_t TXIFLSEL, uint8_t RXIFLSEL) volatile
    {
        uint32_t curr = UARTIFLS;

        curr &= ~(0b111u << 0u);
        curr |= (TXIFLSEL & 0b111u) << 0u;
        curr &= ~(0b111u << 3u);
        curr |= (RXIFLSEL & 0b111u) << 3u;

        UARTIFLS = curr;
    }

    /**
     * Get UARTIMSC's RIMIM bit.
     *
     * nUARTRI modem interrupt mask. A read returns the current mask for the
     * UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_RIMIM() volatile
    {
        return UARTIMSC & (1u << 0u);
    }

    /**
     * Set UARTIMSC's RIMIM bit.
     *
     * nUARTRI modem interrupt mask. A read returns the current mask for the
     * UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_RIMIM() volatile
    {
        UARTIMSC |= 1u << 0u;
    }

    /**
     * Clear UARTIMSC's RIMIM bit.
     *
     * nUARTRI modem interrupt mask. A read returns the current mask for the
     * UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_RIMIM() volatile
    {
        UARTIMSC &= ~(1u << 0u);
    }

    /**
     * Toggle UARTIMSC's RIMIM bit.
     *
     * nUARTRI modem interrupt mask. A read returns the current mask for the
     * UARTRIINTR interrupt. On a write of 1, the mask of the UARTRIINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_RIMIM() volatile
    {
        UARTIMSC ^= 1u << 0u;
    }

    /**
     * Get UARTIMSC's CTSMIM bit.
     *
     * nUARTCTS modem interrupt mask. A read returns the current mask for the
     * UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_CTSMIM() volatile
    {
        return UARTIMSC & (1u << 1u);
    }

    /**
     * Set UARTIMSC's CTSMIM bit.
     *
     * nUARTCTS modem interrupt mask. A read returns the current mask for the
     * UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_CTSMIM() volatile
    {
        UARTIMSC |= 1u << 1u;
    }

    /**
     * Clear UARTIMSC's CTSMIM bit.
     *
     * nUARTCTS modem interrupt mask. A read returns the current mask for the
     * UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_CTSMIM() volatile
    {
        UARTIMSC &= ~(1u << 1u);
    }

    /**
     * Toggle UARTIMSC's CTSMIM bit.
     *
     * nUARTCTS modem interrupt mask. A read returns the current mask for the
     * UARTCTSINTR interrupt. On a write of 1, the mask of the UARTCTSINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_CTSMIM() volatile
    {
        UARTIMSC ^= 1u << 1u;
    }

    /**
     * Get UARTIMSC's DCDMIM bit.
     *
     * nUARTDCD modem interrupt mask. A read returns the current mask for the
     * UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_DCDMIM() volatile
    {
        return UARTIMSC & (1u << 2u);
    }

    /**
     * Set UARTIMSC's DCDMIM bit.
     *
     * nUARTDCD modem interrupt mask. A read returns the current mask for the
     * UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_DCDMIM() volatile
    {
        UARTIMSC |= 1u << 2u;
    }

    /**
     * Clear UARTIMSC's DCDMIM bit.
     *
     * nUARTDCD modem interrupt mask. A read returns the current mask for the
     * UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_DCDMIM() volatile
    {
        UARTIMSC &= ~(1u << 2u);
    }

    /**
     * Toggle UARTIMSC's DCDMIM bit.
     *
     * nUARTDCD modem interrupt mask. A read returns the current mask for the
     * UARTDCDINTR interrupt. On a write of 1, the mask of the UARTDCDINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_DCDMIM() volatile
    {
        UARTIMSC ^= 1u << 2u;
    }

    /**
     * Get UARTIMSC's DSRMIM bit.
     *
     * nUARTDSR modem interrupt mask. A read returns the current mask for the
     * UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_DSRMIM() volatile
    {
        return UARTIMSC & (1u << 3u);
    }

    /**
     * Set UARTIMSC's DSRMIM bit.
     *
     * nUARTDSR modem interrupt mask. A read returns the current mask for the
     * UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_DSRMIM() volatile
    {
        UARTIMSC |= 1u << 3u;
    }

    /**
     * Clear UARTIMSC's DSRMIM bit.
     *
     * nUARTDSR modem interrupt mask. A read returns the current mask for the
     * UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_DSRMIM() volatile
    {
        UARTIMSC &= ~(1u << 3u);
    }

    /**
     * Toggle UARTIMSC's DSRMIM bit.
     *
     * nUARTDSR modem interrupt mask. A read returns the current mask for the
     * UARTDSRINTR interrupt. On a write of 1, the mask of the UARTDSRINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_DSRMIM() volatile
    {
        UARTIMSC ^= 1u << 3u;
    }

    /**
     * Get UARTIMSC's RXIM bit.
     *
     * Receive interrupt mask. A read returns the current mask for the
     * UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_RXIM() volatile
    {
        return UARTIMSC & (1u << 4u);
    }

    /**
     * Set UARTIMSC's RXIM bit.
     *
     * Receive interrupt mask. A read returns the current mask for the
     * UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_RXIM() volatile
    {
        UARTIMSC |= 1u << 4u;
    }

    /**
     * Clear UARTIMSC's RXIM bit.
     *
     * Receive interrupt mask. A read returns the current mask for the
     * UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_RXIM() volatile
    {
        UARTIMSC &= ~(1u << 4u);
    }

    /**
     * Toggle UARTIMSC's RXIM bit.
     *
     * Receive interrupt mask. A read returns the current mask for the
     * UARTRXINTR interrupt. On a write of 1, the mask of the UARTRXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_RXIM() volatile
    {
        UARTIMSC ^= 1u << 4u;
    }

    /**
     * Get UARTIMSC's TXIM bit.
     *
     * Transmit interrupt mask. A read returns the current mask for the
     * UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_TXIM() volatile
    {
        return UARTIMSC & (1u << 5u);
    }

    /**
     * Set UARTIMSC's TXIM bit.
     *
     * Transmit interrupt mask. A read returns the current mask for the
     * UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_TXIM() volatile
    {
        UARTIMSC |= 1u << 5u;
    }

    /**
     * Clear UARTIMSC's TXIM bit.
     *
     * Transmit interrupt mask. A read returns the current mask for the
     * UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_TXIM() volatile
    {
        UARTIMSC &= ~(1u << 5u);
    }

    /**
     * Toggle UARTIMSC's TXIM bit.
     *
     * Transmit interrupt mask. A read returns the current mask for the
     * UARTTXINTR interrupt. On a write of 1, the mask of the UARTTXINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_TXIM() volatile
    {
        UARTIMSC ^= 1u << 5u;
    }

    /**
     * Get UARTIMSC's RTIM bit.
     *
     * Receive timeout interrupt mask. A read returns the current mask for the
     * UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_RTIM() volatile
    {
        return UARTIMSC & (1u << 6u);
    }

    /**
     * Set UARTIMSC's RTIM bit.
     *
     * Receive timeout interrupt mask. A read returns the current mask for the
     * UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_RTIM() volatile
    {
        UARTIMSC |= 1u << 6u;
    }

    /**
     * Clear UARTIMSC's RTIM bit.
     *
     * Receive timeout interrupt mask. A read returns the current mask for the
     * UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_RTIM() volatile
    {
        UARTIMSC &= ~(1u << 6u);
    }

    /**
     * Toggle UARTIMSC's RTIM bit.
     *
     * Receive timeout interrupt mask. A read returns the current mask for the
     * UARTRTINTR interrupt. On a write of 1, the mask of the UARTRTINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_RTIM() volatile
    {
        UARTIMSC ^= 1u << 6u;
    }

    /**
     * Get UARTIMSC's FEIM bit.
     *
     * Framing error interrupt mask. A read returns the current mask for the
     * UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_FEIM() volatile
    {
        return UARTIMSC & (1u << 7u);
    }

    /**
     * Set UARTIMSC's FEIM bit.
     *
     * Framing error interrupt mask. A read returns the current mask for the
     * UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_FEIM() volatile
    {
        UARTIMSC |= 1u << 7u;
    }

    /**
     * Clear UARTIMSC's FEIM bit.
     *
     * Framing error interrupt mask. A read returns the current mask for the
     * UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_FEIM() volatile
    {
        UARTIMSC &= ~(1u << 7u);
    }

    /**
     * Toggle UARTIMSC's FEIM bit.
     *
     * Framing error interrupt mask. A read returns the current mask for the
     * UARTFEINTR interrupt. On a write of 1, the mask of the UARTFEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_FEIM() volatile
    {
        UARTIMSC ^= 1u << 7u;
    }

    /**
     * Get UARTIMSC's PEIM bit.
     *
     * Parity error interrupt mask. A read returns the current mask for the
     * UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_PEIM() volatile
    {
        return UARTIMSC & (1u << 8u);
    }

    /**
     * Set UARTIMSC's PEIM bit.
     *
     * Parity error interrupt mask. A read returns the current mask for the
     * UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_PEIM() volatile
    {
        UARTIMSC |= 1u << 8u;
    }

    /**
     * Clear UARTIMSC's PEIM bit.
     *
     * Parity error interrupt mask. A read returns the current mask for the
     * UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_PEIM() volatile
    {
        UARTIMSC &= ~(1u << 8u);
    }

    /**
     * Toggle UARTIMSC's PEIM bit.
     *
     * Parity error interrupt mask. A read returns the current mask for the
     * UARTPEINTR interrupt. On a write of 1, the mask of the UARTPEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_PEIM() volatile
    {
        UARTIMSC ^= 1u << 8u;
    }

    /**
     * Get UARTIMSC's BEIM bit.
     *
     * Break error interrupt mask. A read returns the current mask for the
     * UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_BEIM() volatile
    {
        return UARTIMSC & (1u << 9u);
    }

    /**
     * Set UARTIMSC's BEIM bit.
     *
     * Break error interrupt mask. A read returns the current mask for the
     * UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_BEIM() volatile
    {
        UARTIMSC |= 1u << 9u;
    }

    /**
     * Clear UARTIMSC's BEIM bit.
     *
     * Break error interrupt mask. A read returns the current mask for the
     * UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_BEIM() volatile
    {
        UARTIMSC &= ~(1u << 9u);
    }

    /**
     * Toggle UARTIMSC's BEIM bit.
     *
     * Break error interrupt mask. A read returns the current mask for the
     * UARTBEINTR interrupt. On a write of 1, the mask of the UARTBEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_BEIM() volatile
    {
        UARTIMSC ^= 1u << 9u;
    }

    /**
     * Get UARTIMSC's OEIM bit.
     *
     * Overrun error interrupt mask. A read returns the current mask for the
     * UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline bool get_UARTIMSC_OEIM() volatile
    {
        return UARTIMSC & (1u << 10u);
    }

    /**
     * Set UARTIMSC's OEIM bit.
     *
     * Overrun error interrupt mask. A read returns the current mask for the
     * UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void set_UARTIMSC_OEIM() volatile
    {
        UARTIMSC |= 1u << 10u;
    }

    /**
     * Clear UARTIMSC's OEIM bit.
     *
     * Overrun error interrupt mask. A read returns the current mask for the
     * UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void clear_UARTIMSC_OEIM() volatile
    {
        UARTIMSC &= ~(1u << 10u);
    }

    /**
     * Toggle UARTIMSC's OEIM bit.
     *
     * Overrun error interrupt mask. A read returns the current mask for the
     * UARTOEINTR interrupt. On a write of 1, the mask of the UARTOEINTR
     * interrupt is set. A write of 0 clears the mask.
     */
    inline void toggle_UARTIMSC_OEIM() volatile
    {
        UARTIMSC ^= 1u << 10u;
    }

    /**
     * Get all of UARTIMSC's bit fields.
     *
     * (read-write) Interrupt Mask Set/Clear Register, UARTIMSC
     */
    inline void get_UARTIMSC(bool &RIMIM, bool &CTSMIM, bool &DCDMIM,
                             bool &DSRMIM, bool &RXIM, bool &TXIM, bool &RTIM,
                             bool &FEIM, bool &PEIM, bool &BEIM,
                             bool &OEIM) volatile
    {
        uint32_t curr = UARTIMSC;

        RIMIM = curr & (1u << 0u);
        CTSMIM = curr & (1u << 1u);
        DCDMIM = curr & (1u << 2u);
        DSRMIM = curr & (1u << 3u);
        RXIM = curr & (1u << 4u);
        TXIM = curr & (1u << 5u);
        RTIM = curr & (1u << 6u);
        FEIM = curr & (1u << 7u);
        PEIM = curr & (1u << 8u);
        BEIM = curr & (1u << 9u);
        OEIM = curr & (1u << 10u);
    }

    /**
     * Set all of UARTIMSC's bit fields.
     *
     * (read-write) Interrupt Mask Set/Clear Register, UARTIMSC
     */
    inline void set_UARTIMSC(bool RIMIM, bool CTSMIM, bool DCDMIM, bool DSRMIM,
                             bool RXIM, bool TXIM, bool RTIM, bool FEIM,
                             bool PEIM, bool BEIM, bool OEIM) volatile
    {
        uint32_t curr = UARTIMSC;

        curr &= ~(0b1u << 0u);
        curr |= (RIMIM & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CTSMIM & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (DCDMIM & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (DSRMIM & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (RXIM & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (TXIM & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (RTIM & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (FEIM & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (PEIM & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (BEIM & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (OEIM & 0b1u) << 10u;

        UARTIMSC = curr;
    }

    /**
     * Get UARTRIS's RIRMIS bit.
     *
     * nUARTRI modem interrupt status. Returns the raw interrupt state of the
     * UARTRIINTR interrupt.
     */
    inline bool get_UARTRIS_RIRMIS() volatile
    {
        return UARTRIS & (1u << 0u);
    }

    /**
     * Get UARTRIS's CTSRMIS bit.
     *
     * nUARTCTS modem interrupt status. Returns the raw interrupt state of the
     * UARTCTSINTR interrupt.
     */
    inline bool get_UARTRIS_CTSRMIS() volatile
    {
        return UARTRIS & (1u << 1u);
    }

    /**
     * Get UARTRIS's DCDRMIS bit.
     *
     * nUARTDCD modem interrupt status. Returns the raw interrupt state of the
     * UARTDCDINTR interrupt.
     */
    inline bool get_UARTRIS_DCDRMIS() volatile
    {
        return UARTRIS & (1u << 2u);
    }

    /**
     * Get UARTRIS's DSRRMIS bit.
     *
     * nUARTDSR modem interrupt status. Returns the raw interrupt state of the
     * UARTDSRINTR interrupt.
     */
    inline bool get_UARTRIS_DSRRMIS() volatile
    {
        return UARTRIS & (1u << 3u);
    }

    /**
     * Get UARTRIS's RXRIS bit.
     *
     * Receive interrupt status. Returns the raw interrupt state of the
     * UARTRXINTR interrupt.
     */
    inline bool get_UARTRIS_RXRIS() volatile
    {
        return UARTRIS & (1u << 4u);
    }

    /**
     * Get UARTRIS's TXRIS bit.
     *
     * Transmit interrupt status. Returns the raw interrupt state of the
     * UARTTXINTR interrupt.
     */
    inline bool get_UARTRIS_TXRIS() volatile
    {
        return UARTRIS & (1u << 5u);
    }

    /**
     * Get UARTRIS's RTRIS bit.
     *
     * Receive timeout interrupt status. Returns the raw interrupt state of the
     * UARTRTINTR interrupt. a
     */
    inline bool get_UARTRIS_RTRIS() volatile
    {
        return UARTRIS & (1u << 6u);
    }

    /**
     * Get UARTRIS's FERIS bit.
     *
     * Framing error interrupt status. Returns the raw interrupt state of the
     * UARTFEINTR interrupt.
     */
    inline bool get_UARTRIS_FERIS() volatile
    {
        return UARTRIS & (1u << 7u);
    }

    /**
     * Get UARTRIS's PERIS bit.
     *
     * Parity error interrupt status. Returns the raw interrupt state of the
     * UARTPEINTR interrupt.
     */
    inline bool get_UARTRIS_PERIS() volatile
    {
        return UARTRIS & (1u << 8u);
    }

    /**
     * Get UARTRIS's BERIS bit.
     *
     * Break error interrupt status. Returns the raw interrupt state of the
     * UARTBEINTR interrupt.
     */
    inline bool get_UARTRIS_BERIS() volatile
    {
        return UARTRIS & (1u << 9u);
    }

    /**
     * Get UARTRIS's OERIS bit.
     *
     * Overrun error interrupt status. Returns the raw interrupt state of the
     * UARTOEINTR interrupt.
     */
    inline bool get_UARTRIS_OERIS() volatile
    {
        return UARTRIS & (1u << 10u);
    }

    /**
     * Get all of UARTRIS's bit fields.
     *
     * (read-only) Raw Interrupt Status Register, UARTRIS
     */
    inline void get_UARTRIS(bool &RIRMIS, bool &CTSRMIS, bool &DCDRMIS,
                            bool &DSRRMIS, bool &RXRIS, bool &TXRIS,
                            bool &RTRIS, bool &FERIS, bool &PERIS, bool &BERIS,
                            bool &OERIS) volatile
    {
        uint32_t curr = UARTRIS;

        RIRMIS = curr & (1u << 0u);
        CTSRMIS = curr & (1u << 1u);
        DCDRMIS = curr & (1u << 2u);
        DSRRMIS = curr & (1u << 3u);
        RXRIS = curr & (1u << 4u);
        TXRIS = curr & (1u << 5u);
        RTRIS = curr & (1u << 6u);
        FERIS = curr & (1u << 7u);
        PERIS = curr & (1u << 8u);
        BERIS = curr & (1u << 9u);
        OERIS = curr & (1u << 10u);
    }

    /**
     * Get UARTMIS's RIMMIS bit.
     *
     * nUARTRI modem masked interrupt status. Returns the masked interrupt
     * state of the UARTRIINTR interrupt.
     */
    inline bool get_UARTMIS_RIMMIS() volatile
    {
        return UARTMIS & (1u << 0u);
    }

    /**
     * Get UARTMIS's CTSMMIS bit.
     *
     * nUARTCTS modem masked interrupt status. Returns the masked interrupt
     * state of the UARTCTSINTR interrupt.
     */
    inline bool get_UARTMIS_CTSMMIS() volatile
    {
        return UARTMIS & (1u << 1u);
    }

    /**
     * Get UARTMIS's DCDMMIS bit.
     *
     * nUARTDCD modem masked interrupt status. Returns the masked interrupt
     * state of the UARTDCDINTR interrupt.
     */
    inline bool get_UARTMIS_DCDMMIS() volatile
    {
        return UARTMIS & (1u << 2u);
    }

    /**
     * Get UARTMIS's DSRMMIS bit.
     *
     * nUARTDSR modem masked interrupt status. Returns the masked interrupt
     * state of the UARTDSRINTR interrupt.
     */
    inline bool get_UARTMIS_DSRMMIS() volatile
    {
        return UARTMIS & (1u << 3u);
    }

    /**
     * Get UARTMIS's RXMIS bit.
     *
     * Receive masked interrupt status. Returns the masked interrupt state of
     * the UARTRXINTR interrupt.
     */
    inline bool get_UARTMIS_RXMIS() volatile
    {
        return UARTMIS & (1u << 4u);
    }

    /**
     * Get UARTMIS's TXMIS bit.
     *
     * Transmit masked interrupt status. Returns the masked interrupt state of
     * the UARTTXINTR interrupt.
     */
    inline bool get_UARTMIS_TXMIS() volatile
    {
        return UARTMIS & (1u << 5u);
    }

    /**
     * Get UARTMIS's RTMIS bit.
     *
     * Receive timeout masked interrupt status. Returns the masked interrupt
     * state of the UARTRTINTR interrupt.
     */
    inline bool get_UARTMIS_RTMIS() volatile
    {
        return UARTMIS & (1u << 6u);
    }

    /**
     * Get UARTMIS's FEMIS bit.
     *
     * Framing error masked interrupt status. Returns the masked interrupt
     * state of the UARTFEINTR interrupt.
     */
    inline bool get_UARTMIS_FEMIS() volatile
    {
        return UARTMIS & (1u << 7u);
    }

    /**
     * Get UARTMIS's PEMIS bit.
     *
     * Parity error masked interrupt status. Returns the masked interrupt state
     * of the UARTPEINTR interrupt.
     */
    inline bool get_UARTMIS_PEMIS() volatile
    {
        return UARTMIS & (1u << 8u);
    }

    /**
     * Get UARTMIS's BEMIS bit.
     *
     * Break error masked interrupt status. Returns the masked interrupt state
     * of the UARTBEINTR interrupt.
     */
    inline bool get_UARTMIS_BEMIS() volatile
    {
        return UARTMIS & (1u << 9u);
    }

    /**
     * Get UARTMIS's OEMIS bit.
     *
     * Overrun error masked interrupt status. Returns the masked interrupt
     * state of the UARTOEINTR interrupt.
     */
    inline bool get_UARTMIS_OEMIS() volatile
    {
        return UARTMIS & (1u << 10u);
    }

    /**
     * Get all of UARTMIS's bit fields.
     *
     * (read-only) Masked Interrupt Status Register, UARTMIS
     */
    inline void get_UARTMIS(bool &RIMMIS, bool &CTSMMIS, bool &DCDMMIS,
                            bool &DSRMMIS, bool &RXMIS, bool &TXMIS,
                            bool &RTMIS, bool &FEMIS, bool &PEMIS, bool &BEMIS,
                            bool &OEMIS) volatile
    {
        uint32_t curr = UARTMIS;

        RIMMIS = curr & (1u << 0u);
        CTSMMIS = curr & (1u << 1u);
        DCDMMIS = curr & (1u << 2u);
        DSRMMIS = curr & (1u << 3u);
        RXMIS = curr & (1u << 4u);
        TXMIS = curr & (1u << 5u);
        RTMIS = curr & (1u << 6u);
        FEMIS = curr & (1u << 7u);
        PEMIS = curr & (1u << 8u);
        BEMIS = curr & (1u << 9u);
        OEMIS = curr & (1u << 10u);
    }

    /**
     * Get UARTICR's RIMIC bit.
     *
     * nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
     */
    inline bool get_UARTICR_RIMIC() volatile
    {
        return UARTICR & (1u << 0u);
    }

    /**
     * Set UARTICR's RIMIC bit.
     *
     * nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
     */
    inline void set_UARTICR_RIMIC() volatile
    {
        UARTICR |= 1u << 0u;
    }

    /**
     * Clear UARTICR's RIMIC bit.
     *
     * nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
     */
    inline void clear_UARTICR_RIMIC() volatile
    {
        UARTICR &= ~(1u << 0u);
    }

    /**
     * Toggle UARTICR's RIMIC bit.
     *
     * nUARTRI modem interrupt clear. Clears the UARTRIINTR interrupt.
     */
    inline void toggle_UARTICR_RIMIC() volatile
    {
        UARTICR ^= 1u << 0u;
    }

    /**
     * Get UARTICR's CTSMIC bit.
     *
     * nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
     */
    inline bool get_UARTICR_CTSMIC() volatile
    {
        return UARTICR & (1u << 1u);
    }

    /**
     * Set UARTICR's CTSMIC bit.
     *
     * nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
     */
    inline void set_UARTICR_CTSMIC() volatile
    {
        UARTICR |= 1u << 1u;
    }

    /**
     * Clear UARTICR's CTSMIC bit.
     *
     * nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
     */
    inline void clear_UARTICR_CTSMIC() volatile
    {
        UARTICR &= ~(1u << 1u);
    }

    /**
     * Toggle UARTICR's CTSMIC bit.
     *
     * nUARTCTS modem interrupt clear. Clears the UARTCTSINTR interrupt.
     */
    inline void toggle_UARTICR_CTSMIC() volatile
    {
        UARTICR ^= 1u << 1u;
    }

    /**
     * Get UARTICR's DCDMIC bit.
     *
     * nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
     */
    inline bool get_UARTICR_DCDMIC() volatile
    {
        return UARTICR & (1u << 2u);
    }

    /**
     * Set UARTICR's DCDMIC bit.
     *
     * nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
     */
    inline void set_UARTICR_DCDMIC() volatile
    {
        UARTICR |= 1u << 2u;
    }

    /**
     * Clear UARTICR's DCDMIC bit.
     *
     * nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
     */
    inline void clear_UARTICR_DCDMIC() volatile
    {
        UARTICR &= ~(1u << 2u);
    }

    /**
     * Toggle UARTICR's DCDMIC bit.
     *
     * nUARTDCD modem interrupt clear. Clears the UARTDCDINTR interrupt.
     */
    inline void toggle_UARTICR_DCDMIC() volatile
    {
        UARTICR ^= 1u << 2u;
    }

    /**
     * Get UARTICR's DSRMIC bit.
     *
     * nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
     */
    inline bool get_UARTICR_DSRMIC() volatile
    {
        return UARTICR & (1u << 3u);
    }

    /**
     * Set UARTICR's DSRMIC bit.
     *
     * nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
     */
    inline void set_UARTICR_DSRMIC() volatile
    {
        UARTICR |= 1u << 3u;
    }

    /**
     * Clear UARTICR's DSRMIC bit.
     *
     * nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
     */
    inline void clear_UARTICR_DSRMIC() volatile
    {
        UARTICR &= ~(1u << 3u);
    }

    /**
     * Toggle UARTICR's DSRMIC bit.
     *
     * nUARTDSR modem interrupt clear. Clears the UARTDSRINTR interrupt.
     */
    inline void toggle_UARTICR_DSRMIC() volatile
    {
        UARTICR ^= 1u << 3u;
    }

    /**
     * Get UARTICR's RXIC bit.
     *
     * Receive interrupt clear. Clears the UARTRXINTR interrupt.
     */
    inline bool get_UARTICR_RXIC() volatile
    {
        return UARTICR & (1u << 4u);
    }

    /**
     * Set UARTICR's RXIC bit.
     *
     * Receive interrupt clear. Clears the UARTRXINTR interrupt.
     */
    inline void set_UARTICR_RXIC() volatile
    {
        UARTICR |= 1u << 4u;
    }

    /**
     * Clear UARTICR's RXIC bit.
     *
     * Receive interrupt clear. Clears the UARTRXINTR interrupt.
     */
    inline void clear_UARTICR_RXIC() volatile
    {
        UARTICR &= ~(1u << 4u);
    }

    /**
     * Toggle UARTICR's RXIC bit.
     *
     * Receive interrupt clear. Clears the UARTRXINTR interrupt.
     */
    inline void toggle_UARTICR_RXIC() volatile
    {
        UARTICR ^= 1u << 4u;
    }

    /**
     * Get UARTICR's TXIC bit.
     *
     * Transmit interrupt clear. Clears the UARTTXINTR interrupt.
     */
    inline bool get_UARTICR_TXIC() volatile
    {
        return UARTICR & (1u << 5u);
    }

    /**
     * Set UARTICR's TXIC bit.
     *
     * Transmit interrupt clear. Clears the UARTTXINTR interrupt.
     */
    inline void set_UARTICR_TXIC() volatile
    {
        UARTICR |= 1u << 5u;
    }

    /**
     * Clear UARTICR's TXIC bit.
     *
     * Transmit interrupt clear. Clears the UARTTXINTR interrupt.
     */
    inline void clear_UARTICR_TXIC() volatile
    {
        UARTICR &= ~(1u << 5u);
    }

    /**
     * Toggle UARTICR's TXIC bit.
     *
     * Transmit interrupt clear. Clears the UARTTXINTR interrupt.
     */
    inline void toggle_UARTICR_TXIC() volatile
    {
        UARTICR ^= 1u << 5u;
    }

    /**
     * Get UARTICR's RTIC bit.
     *
     * Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
     */
    inline bool get_UARTICR_RTIC() volatile
    {
        return UARTICR & (1u << 6u);
    }

    /**
     * Set UARTICR's RTIC bit.
     *
     * Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
     */
    inline void set_UARTICR_RTIC() volatile
    {
        UARTICR |= 1u << 6u;
    }

    /**
     * Clear UARTICR's RTIC bit.
     *
     * Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
     */
    inline void clear_UARTICR_RTIC() volatile
    {
        UARTICR &= ~(1u << 6u);
    }

    /**
     * Toggle UARTICR's RTIC bit.
     *
     * Receive timeout interrupt clear. Clears the UARTRTINTR interrupt.
     */
    inline void toggle_UARTICR_RTIC() volatile
    {
        UARTICR ^= 1u << 6u;
    }

    /**
     * Get UARTICR's FEIC bit.
     *
     * Framing error interrupt clear. Clears the UARTFEINTR interrupt.
     */
    inline bool get_UARTICR_FEIC() volatile
    {
        return UARTICR & (1u << 7u);
    }

    /**
     * Set UARTICR's FEIC bit.
     *
     * Framing error interrupt clear. Clears the UARTFEINTR interrupt.
     */
    inline void set_UARTICR_FEIC() volatile
    {
        UARTICR |= 1u << 7u;
    }

    /**
     * Clear UARTICR's FEIC bit.
     *
     * Framing error interrupt clear. Clears the UARTFEINTR interrupt.
     */
    inline void clear_UARTICR_FEIC() volatile
    {
        UARTICR &= ~(1u << 7u);
    }

    /**
     * Toggle UARTICR's FEIC bit.
     *
     * Framing error interrupt clear. Clears the UARTFEINTR interrupt.
     */
    inline void toggle_UARTICR_FEIC() volatile
    {
        UARTICR ^= 1u << 7u;
    }

    /**
     * Get UARTICR's PEIC bit.
     *
     * Parity error interrupt clear. Clears the UARTPEINTR interrupt.
     */
    inline bool get_UARTICR_PEIC() volatile
    {
        return UARTICR & (1u << 8u);
    }

    /**
     * Set UARTICR's PEIC bit.
     *
     * Parity error interrupt clear. Clears the UARTPEINTR interrupt.
     */
    inline void set_UARTICR_PEIC() volatile
    {
        UARTICR |= 1u << 8u;
    }

    /**
     * Clear UARTICR's PEIC bit.
     *
     * Parity error interrupt clear. Clears the UARTPEINTR interrupt.
     */
    inline void clear_UARTICR_PEIC() volatile
    {
        UARTICR &= ~(1u << 8u);
    }

    /**
     * Toggle UARTICR's PEIC bit.
     *
     * Parity error interrupt clear. Clears the UARTPEINTR interrupt.
     */
    inline void toggle_UARTICR_PEIC() volatile
    {
        UARTICR ^= 1u << 8u;
    }

    /**
     * Get UARTICR's BEIC bit.
     *
     * Break error interrupt clear. Clears the UARTBEINTR interrupt.
     */
    inline bool get_UARTICR_BEIC() volatile
    {
        return UARTICR & (1u << 9u);
    }

    /**
     * Set UARTICR's BEIC bit.
     *
     * Break error interrupt clear. Clears the UARTBEINTR interrupt.
     */
    inline void set_UARTICR_BEIC() volatile
    {
        UARTICR |= 1u << 9u;
    }

    /**
     * Clear UARTICR's BEIC bit.
     *
     * Break error interrupt clear. Clears the UARTBEINTR interrupt.
     */
    inline void clear_UARTICR_BEIC() volatile
    {
        UARTICR &= ~(1u << 9u);
    }

    /**
     * Toggle UARTICR's BEIC bit.
     *
     * Break error interrupt clear. Clears the UARTBEINTR interrupt.
     */
    inline void toggle_UARTICR_BEIC() volatile
    {
        UARTICR ^= 1u << 9u;
    }

    /**
     * Get UARTICR's OEIC bit.
     *
     * Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
     */
    inline bool get_UARTICR_OEIC() volatile
    {
        return UARTICR & (1u << 10u);
    }

    /**
     * Set UARTICR's OEIC bit.
     *
     * Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
     */
    inline void set_UARTICR_OEIC() volatile
    {
        UARTICR |= 1u << 10u;
    }

    /**
     * Clear UARTICR's OEIC bit.
     *
     * Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
     */
    inline void clear_UARTICR_OEIC() volatile
    {
        UARTICR &= ~(1u << 10u);
    }

    /**
     * Toggle UARTICR's OEIC bit.
     *
     * Overrun error interrupt clear. Clears the UARTOEINTR interrupt.
     */
    inline void toggle_UARTICR_OEIC() volatile
    {
        UARTICR ^= 1u << 10u;
    }

    /**
     * Get all of UARTICR's bit fields.
     *
     * (read-write) Interrupt Clear Register, UARTICR
     */
    inline void get_UARTICR(bool &RIMIC, bool &CTSMIC, bool &DCDMIC,
                            bool &DSRMIC, bool &RXIC, bool &TXIC, bool &RTIC,
                            bool &FEIC, bool &PEIC, bool &BEIC,
                            bool &OEIC) volatile
    {
        uint32_t curr = UARTICR;

        RIMIC = curr & (1u << 0u);
        CTSMIC = curr & (1u << 1u);
        DCDMIC = curr & (1u << 2u);
        DSRMIC = curr & (1u << 3u);
        RXIC = curr & (1u << 4u);
        TXIC = curr & (1u << 5u);
        RTIC = curr & (1u << 6u);
        FEIC = curr & (1u << 7u);
        PEIC = curr & (1u << 8u);
        BEIC = curr & (1u << 9u);
        OEIC = curr & (1u << 10u);
    }

    /**
     * Set all of UARTICR's bit fields.
     *
     * (read-write) Interrupt Clear Register, UARTICR
     */
    inline void set_UARTICR(bool RIMIC, bool CTSMIC, bool DCDMIC, bool DSRMIC,
                            bool RXIC, bool TXIC, bool RTIC, bool FEIC,
                            bool PEIC, bool BEIC, bool OEIC) volatile
    {
        uint32_t curr = UARTICR;

        curr &= ~(0b1u << 0u);
        curr |= (RIMIC & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CTSMIC & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (DCDMIC & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (DSRMIC & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (RXIC & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (TXIC & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (RTIC & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (FEIC & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (PEIC & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (BEIC & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (OEIC & 0b1u) << 10u;

        UARTICR = curr;
    }

    /**
     * Get UARTDMACR's RXDMAE bit.
     *
     * Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
     * enabled.
     */
    inline bool get_UARTDMACR_RXDMAE() volatile
    {
        return UARTDMACR & (1u << 0u);
    }

    /**
     * Set UARTDMACR's RXDMAE bit.
     *
     * Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
     * enabled.
     */
    inline void set_UARTDMACR_RXDMAE() volatile
    {
        UARTDMACR |= 1u << 0u;
    }

    /**
     * Clear UARTDMACR's RXDMAE bit.
     *
     * Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
     * enabled.
     */
    inline void clear_UARTDMACR_RXDMAE() volatile
    {
        UARTDMACR &= ~(1u << 0u);
    }

    /**
     * Toggle UARTDMACR's RXDMAE bit.
     *
     * Receive DMA enable. If this bit is set to 1, DMA for the receive FIFO is
     * enabled.
     */
    inline void toggle_UARTDMACR_RXDMAE() volatile
    {
        UARTDMACR ^= 1u << 0u;
    }

    /**
     * Get UARTDMACR's TXDMAE bit.
     *
     * Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO
     * is enabled.
     */
    inline bool get_UARTDMACR_TXDMAE() volatile
    {
        return UARTDMACR & (1u << 1u);
    }

    /**
     * Set UARTDMACR's TXDMAE bit.
     *
     * Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO
     * is enabled.
     */
    inline void set_UARTDMACR_TXDMAE() volatile
    {
        UARTDMACR |= 1u << 1u;
    }

    /**
     * Clear UARTDMACR's TXDMAE bit.
     *
     * Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO
     * is enabled.
     */
    inline void clear_UARTDMACR_TXDMAE() volatile
    {
        UARTDMACR &= ~(1u << 1u);
    }

    /**
     * Toggle UARTDMACR's TXDMAE bit.
     *
     * Transmit DMA enable. If this bit is set to 1, DMA for the transmit FIFO
     * is enabled.
     */
    inline void toggle_UARTDMACR_TXDMAE() volatile
    {
        UARTDMACR ^= 1u << 1u;
    }

    /**
     * Get UARTDMACR's DMAONERR bit.
     *
     * DMA on error. If this bit is set to 1, the DMA receive request outputs,
     * UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error
     * interrupt is asserted.
     */
    inline bool get_UARTDMACR_DMAONERR() volatile
    {
        return UARTDMACR & (1u << 2u);
    }

    /**
     * Set UARTDMACR's DMAONERR bit.
     *
     * DMA on error. If this bit is set to 1, the DMA receive request outputs,
     * UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error
     * interrupt is asserted.
     */
    inline void set_UARTDMACR_DMAONERR() volatile
    {
        UARTDMACR |= 1u << 2u;
    }

    /**
     * Clear UARTDMACR's DMAONERR bit.
     *
     * DMA on error. If this bit is set to 1, the DMA receive request outputs,
     * UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error
     * interrupt is asserted.
     */
    inline void clear_UARTDMACR_DMAONERR() volatile
    {
        UARTDMACR &= ~(1u << 2u);
    }

    /**
     * Toggle UARTDMACR's DMAONERR bit.
     *
     * DMA on error. If this bit is set to 1, the DMA receive request outputs,
     * UARTRXDMASREQ or UARTRXDMABREQ, are disabled when the UART error
     * interrupt is asserted.
     */
    inline void toggle_UARTDMACR_DMAONERR() volatile
    {
        UARTDMACR ^= 1u << 2u;
    }

    /**
     * Get all of UARTDMACR's bit fields.
     *
     * (read-write) DMA Control Register, UARTDMACR
     */
    inline void get_UARTDMACR(bool &RXDMAE, bool &TXDMAE,
                              bool &DMAONERR) volatile
    {
        uint32_t curr = UARTDMACR;

        RXDMAE = curr & (1u << 0u);
        TXDMAE = curr & (1u << 1u);
        DMAONERR = curr & (1u << 2u);
    }

    /**
     * Set all of UARTDMACR's bit fields.
     *
     * (read-write) DMA Control Register, UARTDMACR
     */
    inline void set_UARTDMACR(bool RXDMAE, bool TXDMAE, bool DMAONERR) volatile
    {
        uint32_t curr = UARTDMACR;

        curr &= ~(0b1u << 0u);
        curr |= (RXDMAE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TXDMAE & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (DMAONERR & 0b1u) << 2u;

        UARTDMACR = curr;
    }

    /**
     * Get UARTPERIPHID0's PARTNUMBER0 field.
     *
     * These bits read back as 0x11
     */
    inline uint8_t get_UARTPERIPHID0_PARTNUMBER0() volatile
    {
        return (UARTPERIPHID0 >> 0u) & 0b11111111u;
    }

    /**
     * Get UARTPERIPHID1's PARTNUMBER1 field.
     *
     * These bits read back as 0x0
     */
    inline uint8_t get_UARTPERIPHID1_PARTNUMBER1() volatile
    {
        return (UARTPERIPHID1 >> 0u) & 0b1111u;
    }

    /**
     * Get UARTPERIPHID1's DESIGNER0 field.
     *
     * These bits read back as 0x1
     */
    inline uint8_t get_UARTPERIPHID1_DESIGNER0() volatile
    {
        return (UARTPERIPHID1 >> 4u) & 0b1111u;
    }

    /**
     * Get all of UARTPERIPHID1's bit fields.
     *
     * (read-only) UARTPeriphID1 Register
     */
    inline void get_UARTPERIPHID1(uint8_t &PARTNUMBER1,
                                  uint8_t &DESIGNER0) volatile
    {
        uint32_t curr = UARTPERIPHID1;

        PARTNUMBER1 = (curr >> 0u) & 0b1111u;
        DESIGNER0 = (curr >> 4u) & 0b1111u;
    }

    /**
     * Get UARTPERIPHID2's DESIGNER1 field.
     *
     * These bits read back as 0x4
     */
    inline uint8_t get_UARTPERIPHID2_DESIGNER1() volatile
    {
        return (UARTPERIPHID2 >> 0u) & 0b1111u;
    }

    /**
     * Get UARTPERIPHID2's REVISION field.
     *
     * This field depends on the revision of the UART: r1p0 0x0 r1p1 0x1 r1p3
     * 0x2 r1p4 0x2 r1p5 0x3
     */
    inline uint8_t get_UARTPERIPHID2_REVISION() volatile
    {
        return (UARTPERIPHID2 >> 4u) & 0b1111u;
    }

    /**
     * Get all of UARTPERIPHID2's bit fields.
     *
     * (read-only) UARTPeriphID2 Register
     */
    inline void get_UARTPERIPHID2(uint8_t &DESIGNER1,
                                  uint8_t &REVISION) volatile
    {
        uint32_t curr = UARTPERIPHID2;

        DESIGNER1 = (curr >> 0u) & 0b1111u;
        REVISION = (curr >> 4u) & 0b1111u;
    }

    /**
     * Get UARTPERIPHID3's CONFIGURATION field.
     *
     * These bits read back as 0x00
     */
    inline uint8_t get_UARTPERIPHID3_CONFIGURATION() volatile
    {
        return (UARTPERIPHID3 >> 0u) & 0b11111111u;
    }

    /**
     * Get UARTPCELLID0's UARTPCELLID0 field.
     *
     * These bits read back as 0x0D
     */
    inline uint8_t get_UARTPCELLID0_UARTPCELLID0() volatile
    {
        return (UARTPCELLID0 >> 0u) & 0b11111111u;
    }

    /**
     * Get UARTPCELLID1's UARTPCELLID1 field.
     *
     * These bits read back as 0xF0
     */
    inline uint8_t get_UARTPCELLID1_UARTPCELLID1() volatile
    {
        return (UARTPCELLID1 >> 0u) & 0b11111111u;
    }

    /**
     * Get UARTPCELLID2's UARTPCELLID2 field.
     *
     * These bits read back as 0x05
     */
    inline uint8_t get_UARTPCELLID2_UARTPCELLID2() volatile
    {
        return (UARTPCELLID2 >> 0u) & 0b11111111u;
    }

    /**
     * Get UARTPCELLID3's UARTPCELLID3 field.
     *
     * These bits read back as 0xB1
     */
    inline uint8_t get_UARTPCELLID3_UARTPCELLID3() volatile
    {
        return (UARTPCELLID3 >> 0u) & 0b11111111u;
    }
};

static_assert(sizeof(uart0) == uart0::size);

static volatile uart0 *const UART0 = reinterpret_cast<uart0 *>(0x40034000);

static volatile uart0 *const UART1 = reinterpret_cast<uart0 *>(0x40038000);

}; // namespace RP2040
