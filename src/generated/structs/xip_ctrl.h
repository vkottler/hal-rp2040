/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

/**
 * QSPI flash execute-in-place block
 */
struct [[gnu::packed]] xip_ctrl
{
    /* Constant attributes. */
    static constexpr std::size_t size = 32; /*!< xip_ctrl's size in bytes. */

    /* Fields. */
    uint32_t CTRL;            /*!< (read-write) Cache control */
    uint32_t FLUSH;           /*!< (read-write) Cache Flush control */
    const uint32_t STAT = {}; /*!< (read-only) Cache Status */
    uint32_t CTR_HIT;         /*!< (read-write) Cache Hit counter\n
                A 32 bit saturating counter that increments upon each cache hit,\n
                i.e. when an XIP access is serviced directly from cached data.\n
                Write any value to clear. */
    uint32_t CTR_ACC;         /*!< (read-write) Cache Access counter\n
                A 32 bit saturating counter that increments upon each XIP access,\n
                whether the cache is hit or not. This includes noncacheable accesses.\n
                Write any value to clear. */
    uint32_t STREAM_ADDR;     /*!< (read-write) FIFO stream address */
    uint32_t STREAM_CTR;      /*!< (read-write) FIFO stream control */
    uint32_t
        STREAM_FIFO; /*!< (read-write) FIFO stream data\n
       Streamed data is buffered here, for retrieval by the system DMA.\n
       This FIFO can also be accessed via the XIP_AUX slave, to avoid
       exposing\n     the DMA to bus stalls caused by other XIP traffic. */

    /* Methods. */

    /**
     * Get CTRL's EN bit.
     *
     * When 1, enable the cache. When the cache is disabled, all XIP accesses\n
     *                 will go straight to the flash, without querying the
     * cache. When enabled,\n cacheable XIP accesses will query the cache, and
     * the flash will\n not be accessed if the tag matches and the valid bit is
     * set.\n\n If the cache is enabled, cache-as-SRAM accesses have no effect
     * on the\n cache data RAM, and will produce a bus error response.
     */
    inline bool get_CTRL_EN() volatile
    {
        return CTRL & (1u << 0u);
    }

    /**
     * Set CTRL's EN bit.
     *
     * When 1, enable the cache. When the cache is disabled, all XIP accesses\n
     *                 will go straight to the flash, without querying the
     * cache. When enabled,\n cacheable XIP accesses will query the cache, and
     * the flash will\n not be accessed if the tag matches and the valid bit is
     * set.\n\n If the cache is enabled, cache-as-SRAM accesses have no effect
     * on the\n cache data RAM, and will produce a bus error response.
     */
    inline void set_CTRL_EN() volatile
    {
        CTRL |= 1u << 0u;
    }

    /**
     * Clear CTRL's EN bit.
     *
     * When 1, enable the cache. When the cache is disabled, all XIP accesses\n
     *                 will go straight to the flash, without querying the
     * cache. When enabled,\n cacheable XIP accesses will query the cache, and
     * the flash will\n not be accessed if the tag matches and the valid bit is
     * set.\n\n If the cache is enabled, cache-as-SRAM accesses have no effect
     * on the\n cache data RAM, and will produce a bus error response.
     */
    inline void clear_CTRL_EN() volatile
    {
        CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CTRL's EN bit.
     *
     * When 1, enable the cache. When the cache is disabled, all XIP accesses\n
     *                 will go straight to the flash, without querying the
     * cache. When enabled,\n cacheable XIP accesses will query the cache, and
     * the flash will\n not be accessed if the tag matches and the valid bit is
     * set.\n\n If the cache is enabled, cache-as-SRAM accesses have no effect
     * on the\n cache data RAM, and will produce a bus error response.
     */
    inline void toggle_CTRL_EN() volatile
    {
        CTRL ^= 1u << 0u;
    }

    /**
     * Get CTRL's ERR_BADWRITE bit.
     *
     * When 1, writes to any alias other than 0x0 (caching, allocating)\n
     *                 will produce a bus fault. When 0, these writes are
     * silently ignored.\n In either case, writes to the 0x0 alias will
     * deallocate on tag match,\n as usual.
     */
    inline bool get_CTRL_ERR_BADWRITE() volatile
    {
        return CTRL & (1u << 1u);
    }

    /**
     * Set CTRL's ERR_BADWRITE bit.
     *
     * When 1, writes to any alias other than 0x0 (caching, allocating)\n
     *                 will produce a bus fault. When 0, these writes are
     * silently ignored.\n In either case, writes to the 0x0 alias will
     * deallocate on tag match,\n as usual.
     */
    inline void set_CTRL_ERR_BADWRITE() volatile
    {
        CTRL |= 1u << 1u;
    }

    /**
     * Clear CTRL's ERR_BADWRITE bit.
     *
     * When 1, writes to any alias other than 0x0 (caching, allocating)\n
     *                 will produce a bus fault. When 0, these writes are
     * silently ignored.\n In either case, writes to the 0x0 alias will
     * deallocate on tag match,\n as usual.
     */
    inline void clear_CTRL_ERR_BADWRITE() volatile
    {
        CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle CTRL's ERR_BADWRITE bit.
     *
     * When 1, writes to any alias other than 0x0 (caching, allocating)\n
     *                 will produce a bus fault. When 0, these writes are
     * silently ignored.\n In either case, writes to the 0x0 alias will
     * deallocate on tag match,\n as usual.
     */
    inline void toggle_CTRL_ERR_BADWRITE() volatile
    {
        CTRL ^= 1u << 1u;
    }

    /**
     * Get CTRL's POWER_DOWN bit.
     *
     * When 1, the cache memories are powered down. They retain state,\n
     *                 but can not be accessed. This reduces static power
     * dissipation.\n Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache
     * cannot\n be enabled when powered down.\n Cache-as-SRAM accesses will
     * produce a bus error response when\n the cache is powered down.
     */
    inline bool get_CTRL_POWER_DOWN() volatile
    {
        return CTRL & (1u << 3u);
    }

    /**
     * Set CTRL's POWER_DOWN bit.
     *
     * When 1, the cache memories are powered down. They retain state,\n
     *                 but can not be accessed. This reduces static power
     * dissipation.\n Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache
     * cannot\n be enabled when powered down.\n Cache-as-SRAM accesses will
     * produce a bus error response when\n the cache is powered down.
     */
    inline void set_CTRL_POWER_DOWN() volatile
    {
        CTRL |= 1u << 3u;
    }

    /**
     * Clear CTRL's POWER_DOWN bit.
     *
     * When 1, the cache memories are powered down. They retain state,\n
     *                 but can not be accessed. This reduces static power
     * dissipation.\n Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache
     * cannot\n be enabled when powered down.\n Cache-as-SRAM accesses will
     * produce a bus error response when\n the cache is powered down.
     */
    inline void clear_CTRL_POWER_DOWN() volatile
    {
        CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle CTRL's POWER_DOWN bit.
     *
     * When 1, the cache memories are powered down. They retain state,\n
     *                 but can not be accessed. This reduces static power
     * dissipation.\n Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache
     * cannot\n be enabled when powered down.\n Cache-as-SRAM accesses will
     * produce a bus error response when\n the cache is powered down.
     */
    inline void toggle_CTRL_POWER_DOWN() volatile
    {
        CTRL ^= 1u << 3u;
    }

    /**
     * Get all of CTRL's bit fields.
     *
     * (read-write) Cache control
     */
    inline void get_CTRL(bool &EN, bool &ERR_BADWRITE,
                         bool &POWER_DOWN) volatile
    {
        uint32_t curr = CTRL;

        EN = curr & (1u << 0u);
        ERR_BADWRITE = curr & (1u << 1u);
        POWER_DOWN = curr & (1u << 3u);
    }

    /**
     * Set all of CTRL's bit fields.
     *
     * (read-write) Cache control
     */
    inline void set_CTRL(bool EN, bool ERR_BADWRITE, bool POWER_DOWN) volatile
    {
        uint32_t curr = CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (ERR_BADWRITE & 0b1u) << 1u;
        curr &= ~(0b1u << 3u);
        curr |= (POWER_DOWN & 0b1u) << 3u;

        CTRL = curr;
    }

    /**
     * Get FLUSH's FLUSH bit.
     *
     * Write 1 to flush the cache. This clears the tag memory, but\n
     *                 the data memory retains its contents. (This means
     * cache-as-SRAM\n contents is not affected by flush or reset.)\n Reading
     * will hold the bus (stall the processor) until the flush\n completes.
     * Alternatively STAT can be polled until completion.
     */
    inline bool get_FLUSH_FLUSH() volatile
    {
        return FLUSH & (1u << 0u);
    }

    /**
     * Set FLUSH's FLUSH bit.
     *
     * Write 1 to flush the cache. This clears the tag memory, but\n
     *                 the data memory retains its contents. (This means
     * cache-as-SRAM\n contents is not affected by flush or reset.)\n Reading
     * will hold the bus (stall the processor) until the flush\n completes.
     * Alternatively STAT can be polled until completion.
     */
    inline void set_FLUSH_FLUSH() volatile
    {
        FLUSH |= 1u << 0u;
    }

    /**
     * Clear FLUSH's FLUSH bit.
     *
     * Write 1 to flush the cache. This clears the tag memory, but\n
     *                 the data memory retains its contents. (This means
     * cache-as-SRAM\n contents is not affected by flush or reset.)\n Reading
     * will hold the bus (stall the processor) until the flush\n completes.
     * Alternatively STAT can be polled until completion.
     */
    inline void clear_FLUSH_FLUSH() volatile
    {
        FLUSH &= ~(1u << 0u);
    }

    /**
     * Toggle FLUSH's FLUSH bit.
     *
     * Write 1 to flush the cache. This clears the tag memory, but\n
     *                 the data memory retains its contents. (This means
     * cache-as-SRAM\n contents is not affected by flush or reset.)\n Reading
     * will hold the bus (stall the processor) until the flush\n completes.
     * Alternatively STAT can be polled until completion.
     */
    inline void toggle_FLUSH_FLUSH() volatile
    {
        FLUSH ^= 1u << 0u;
    }

    /**
     * Get STAT's FLUSH_READY bit.
     *
     * Reads as 0 while a cache flush is in progress, and 1 otherwise.\n
     *                 The cache is flushed whenever the XIP block is reset,
     * and also\n when requested via the FLUSH register.
     */
    inline bool get_STAT_FLUSH_READY() volatile
    {
        return STAT & (1u << 0u);
    }

    /**
     * Get STAT's FIFO_EMPTY bit.
     *
     * When 1, indicates the XIP streaming FIFO is completely empty.
     */
    inline bool get_STAT_FIFO_EMPTY() volatile
    {
        return STAT & (1u << 1u);
    }

    /**
     * Get STAT's FIFO_FULL bit.
     *
     * When 1, indicates the XIP streaming FIFO is completely full.\n
     *                 The streaming FIFO is 2 entries deep, so the full and
     * empty\n flag allow its level to be ascertained.
     */
    inline bool get_STAT_FIFO_FULL() volatile
    {
        return STAT & (1u << 2u);
    }

    /**
     * Get all of STAT's bit fields.
     *
     * (read-only) Cache Status
     */
    inline void get_STAT(bool &FLUSH_READY, bool &FIFO_EMPTY,
                         bool &FIFO_FULL) volatile
    {
        uint32_t curr = STAT;

        FLUSH_READY = curr & (1u << 0u);
        FIFO_EMPTY = curr & (1u << 1u);
        FIFO_FULL = curr & (1u << 2u);
    }

    /**
     * Get STREAM_ADDR's STREAM_ADDR field.
     *
     * The address of the next word to be streamed from flash to the streaming
     * FIFO.\n Increments automatically after each flash access.\n Write the
     * initial access address here before starting a streaming read.
     */
    inline uint32_t get_STREAM_ADDR_STREAM_ADDR() volatile
    {
        return (STREAM_ADDR >> 2u) & 0b111111111111111111111111111111u;
    }

    /**
     * Set STREAM_ADDR's STREAM_ADDR field.
     *
     * The address of the next word to be streamed from flash to the streaming
     * FIFO.\n Increments automatically after each flash access.\n Write the
     * initial access address here before starting a streaming read.
     */
    inline void set_STREAM_ADDR_STREAM_ADDR(uint32_t value) volatile
    {
        uint32_t curr = STREAM_ADDR;

        curr &= ~(0b111111111111111111111111111111u << 2u);
        curr |= (value & 0b111111111111111111111111111111u) << 2u;

        STREAM_ADDR = curr;
    }

    /**
     * Get STREAM_CTR's STREAM_CTR field.
     *
     * Write a nonzero value to start a streaming read. This will then\n
     *                 progress in the background, using flash idle cycles to
     * transfer\n a linear data block from flash to the streaming FIFO.\n
     *                 Decrements automatically (1 at a time) as the stream\n
     *                 progresses, and halts on reaching 0.\n
     *                 Write 0 to halt an in-progress stream, and discard any
     * in-flight\n read, so that a new stream can immediately be started
     * (after\n draining the FIFO and reinitialising STREAM_ADDR)
     */
    inline uint32_t get_STREAM_CTR_STREAM_CTR() volatile
    {
        return (STREAM_CTR >> 0u) & 0b1111111111111111111111u;
    }

    /**
     * Set STREAM_CTR's STREAM_CTR field.
     *
     * Write a nonzero value to start a streaming read. This will then\n
     *                 progress in the background, using flash idle cycles to
     * transfer\n a linear data block from flash to the streaming FIFO.\n
     *                 Decrements automatically (1 at a time) as the stream\n
     *                 progresses, and halts on reaching 0.\n
     *                 Write 0 to halt an in-progress stream, and discard any
     * in-flight\n read, so that a new stream can immediately be started
     * (after\n draining the FIFO and reinitialising STREAM_ADDR)
     */
    inline void set_STREAM_CTR_STREAM_CTR(uint32_t value) volatile
    {
        uint32_t curr = STREAM_CTR;

        curr &= ~(0b1111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111u) << 0u;

        STREAM_CTR = curr;
    }
};

static_assert(sizeof(xip_ctrl) == xip_ctrl::size);

static volatile xip_ctrl *const XIP_CTRL =
    reinterpret_cast<xip_ctrl *>(0x14000000);

}; // namespace RP2040
