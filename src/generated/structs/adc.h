/**
 * \file
 * \brief Generated by ifgen (3.1.1).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

/**
 * Control and data interface to SAR ADC
 */
struct [[gnu::packed]] adc
{
    /* Constant attributes. */
    static constexpr std::size_t size = 36; /*!< adc's size in bytes. */

    /* Fields. */
    uint32_t CS; /*!< (read-write) ADC Control and Status */
    const uint32_t RESULT =
        {};       /*!< (read-only) Result of most recent ADC conversion */
    uint32_t FCS; /*!< (read-write) FIFO control and status */
    const uint32_t FIFO = {}; /*!< (read-only) Conversion result FIFO */
    uint32_t DIV; /*!< (read-write) Clock divider. If non-zero, CS_START_MANY
  will start conversions\n at regular intervals rather than back-to-back.\n The
  divider is reset when either of these fields are written.\n Total period is 1
  + INT + FRAC / 256 */
    const uint32_t INTR = {}; /*!< (read-only) Raw Interrupts */
    uint32_t INTE;            /*!< (read-write) Interrupt Enable */
    uint32_t INTF;            /*!< (read-write) Interrupt Force */
    const uint32_t INTS =
        {}; /*!< (read-only) Interrupt status after masking & forcing */

    /* Methods. */

    /**
     * Get CS's EN bit.
     */
    inline bool get_CS_EN() volatile
    {
        return CS & (1u << 0u);
    }

    /**
     * Set CS's EN bit.
     */
    inline void set_CS_EN() volatile
    {
        CS |= 1u << 0u;
    }

    /**
     * Clear CS's EN bit.
     */
    inline void clear_CS_EN() volatile
    {
        CS &= ~(1u << 0u);
    }

    /**
     * Toggle CS's EN bit.
     */
    inline void toggle_CS_EN() volatile
    {
        CS ^= 1u << 0u;
    }

    /**
     * Get CS's TS_EN bit.
     */
    inline bool get_CS_TS_EN() volatile
    {
        return CS & (1u << 1u);
    }

    /**
     * Set CS's TS_EN bit.
     */
    inline void set_CS_TS_EN() volatile
    {
        CS |= 1u << 1u;
    }

    /**
     * Clear CS's TS_EN bit.
     */
    inline void clear_CS_TS_EN() volatile
    {
        CS &= ~(1u << 1u);
    }

    /**
     * Toggle CS's TS_EN bit.
     */
    inline void toggle_CS_TS_EN() volatile
    {
        CS ^= 1u << 1u;
    }

    /**
     * Get CS's START_ONCE bit.
     */
    inline bool get_CS_START_ONCE() volatile
    {
        return CS & (1u << 2u);
    }

    /**
     * Set CS's START_ONCE bit.
     */
    inline void set_CS_START_ONCE() volatile
    {
        CS |= 1u << 2u;
    }

    /**
     * Clear CS's START_ONCE bit.
     */
    inline void clear_CS_START_ONCE() volatile
    {
        CS &= ~(1u << 2u);
    }

    /**
     * Toggle CS's START_ONCE bit.
     */
    inline void toggle_CS_START_ONCE() volatile
    {
        CS ^= 1u << 2u;
    }

    /**
     * Get CS's START_MANY bit.
     */
    inline bool get_CS_START_MANY() volatile
    {
        return CS & (1u << 3u);
    }

    /**
     * Set CS's START_MANY bit.
     */
    inline void set_CS_START_MANY() volatile
    {
        CS |= 1u << 3u;
    }

    /**
     * Clear CS's START_MANY bit.
     */
    inline void clear_CS_START_MANY() volatile
    {
        CS &= ~(1u << 3u);
    }

    /**
     * Toggle CS's START_MANY bit.
     */
    inline void toggle_CS_START_MANY() volatile
    {
        CS ^= 1u << 3u;
    }

    /**
     * Get CS's READY bit.
     */
    inline bool get_CS_READY() volatile
    {
        return CS & (1u << 8u);
    }

    /**
     * Get CS's ERR bit.
     */
    inline bool get_CS_ERR() volatile
    {
        return CS & (1u << 9u);
    }

    /**
     * Get CS's ERR_STICKY bit.
     */
    inline bool get_CS_ERR_STICKY() volatile
    {
        return CS & (1u << 10u);
    }

    /**
     * Set CS's ERR_STICKY bit.
     */
    inline void set_CS_ERR_STICKY() volatile
    {
        CS |= 1u << 10u;
    }

    /**
     * Clear CS's ERR_STICKY bit.
     */
    inline void clear_CS_ERR_STICKY() volatile
    {
        CS &= ~(1u << 10u);
    }

    /**
     * Toggle CS's ERR_STICKY bit.
     */
    inline void toggle_CS_ERR_STICKY() volatile
    {
        CS ^= 1u << 10u;
    }

    /**
     * Get CS's AINSEL field.
     */
    inline uint8_t get_CS_AINSEL() volatile
    {
        return (CS >> 12u) & 0b111u;
    }

    /**
     * Set CS's AINSEL field.
     */
    inline void set_CS_AINSEL(uint8_t value) volatile
    {
        uint32_t curr = CS;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        CS = curr;
    }

    /**
     * Get CS's RROBIN field.
     */
    inline uint8_t get_CS_RROBIN() volatile
    {
        return (CS >> 16u) & 0b11111u;
    }

    /**
     * Set CS's RROBIN field.
     */
    inline void set_CS_RROBIN(uint8_t value) volatile
    {
        uint32_t curr = CS;

        curr &= ~(0b11111u << 16u);
        curr |= (value & 0b11111u) << 16u;

        CS = curr;
    }

    /**
     * Get all of CS's bit fields.
     */
    inline void get_CS(bool &EN, bool &TS_EN, bool &START_ONCE,
                       bool &START_MANY, bool &READY, bool &ERR,
                       bool &ERR_STICKY, uint8_t &AINSEL,
                       uint8_t &RROBIN) volatile
    {
        uint32_t curr = CS;

        EN = curr & (1u << 0u);
        TS_EN = curr & (1u << 1u);
        START_ONCE = curr & (1u << 2u);
        START_MANY = curr & (1u << 3u);
        READY = curr & (1u << 8u);
        ERR = curr & (1u << 9u);
        ERR_STICKY = curr & (1u << 10u);
        AINSEL = (curr >> 12u) & 0b111u;
        RROBIN = (curr >> 16u) & 0b11111u;
    }

    /**
     * Set all of CS's bit fields.
     */
    inline void set_CS(bool EN, bool TS_EN, bool START_ONCE, bool START_MANY,
                       bool ERR_STICKY, uint8_t AINSEL,
                       uint8_t RROBIN) volatile
    {
        uint32_t curr = CS;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TS_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (START_ONCE & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (START_MANY & 0b1u) << 3u;
        curr &= ~(0b1u << 10u);
        curr |= (ERR_STICKY & 0b1u) << 10u;
        curr &= ~(0b111u << 12u);
        curr |= (AINSEL & 0b111u) << 12u;
        curr &= ~(0b11111u << 16u);
        curr |= (RROBIN & 0b11111u) << 16u;

        CS = curr;
    }

    /**
     * Get RESULT's RESULT field.
     */
    inline uint16_t get_RESULT_RESULT() volatile
    {
        return (RESULT >> 0u) & 0b111111111111u;
    }

    /**
     * Get FCS's EN bit.
     */
    inline bool get_FCS_EN() volatile
    {
        return FCS & (1u << 0u);
    }

    /**
     * Set FCS's EN bit.
     */
    inline void set_FCS_EN() volatile
    {
        FCS |= 1u << 0u;
    }

    /**
     * Clear FCS's EN bit.
     */
    inline void clear_FCS_EN() volatile
    {
        FCS &= ~(1u << 0u);
    }

    /**
     * Toggle FCS's EN bit.
     */
    inline void toggle_FCS_EN() volatile
    {
        FCS ^= 1u << 0u;
    }

    /**
     * Get FCS's SHIFT bit.
     */
    inline bool get_FCS_SHIFT() volatile
    {
        return FCS & (1u << 1u);
    }

    /**
     * Set FCS's SHIFT bit.
     */
    inline void set_FCS_SHIFT() volatile
    {
        FCS |= 1u << 1u;
    }

    /**
     * Clear FCS's SHIFT bit.
     */
    inline void clear_FCS_SHIFT() volatile
    {
        FCS &= ~(1u << 1u);
    }

    /**
     * Toggle FCS's SHIFT bit.
     */
    inline void toggle_FCS_SHIFT() volatile
    {
        FCS ^= 1u << 1u;
    }

    /**
     * Get FCS's ERR bit.
     */
    inline bool get_FCS_ERR() volatile
    {
        return FCS & (1u << 2u);
    }

    /**
     * Set FCS's ERR bit.
     */
    inline void set_FCS_ERR() volatile
    {
        FCS |= 1u << 2u;
    }

    /**
     * Clear FCS's ERR bit.
     */
    inline void clear_FCS_ERR() volatile
    {
        FCS &= ~(1u << 2u);
    }

    /**
     * Toggle FCS's ERR bit.
     */
    inline void toggle_FCS_ERR() volatile
    {
        FCS ^= 1u << 2u;
    }

    /**
     * Get FCS's DREQ_EN bit.
     */
    inline bool get_FCS_DREQ_EN() volatile
    {
        return FCS & (1u << 3u);
    }

    /**
     * Set FCS's DREQ_EN bit.
     */
    inline void set_FCS_DREQ_EN() volatile
    {
        FCS |= 1u << 3u;
    }

    /**
     * Clear FCS's DREQ_EN bit.
     */
    inline void clear_FCS_DREQ_EN() volatile
    {
        FCS &= ~(1u << 3u);
    }

    /**
     * Toggle FCS's DREQ_EN bit.
     */
    inline void toggle_FCS_DREQ_EN() volatile
    {
        FCS ^= 1u << 3u;
    }

    /**
     * Get FCS's EMPTY bit.
     */
    inline bool get_FCS_EMPTY() volatile
    {
        return FCS & (1u << 8u);
    }

    /**
     * Get FCS's FULL bit.
     */
    inline bool get_FCS_FULL() volatile
    {
        return FCS & (1u << 9u);
    }

    /**
     * Get FCS's UNDER bit.
     */
    inline bool get_FCS_UNDER() volatile
    {
        return FCS & (1u << 10u);
    }

    /**
     * Set FCS's UNDER bit.
     */
    inline void set_FCS_UNDER() volatile
    {
        FCS |= 1u << 10u;
    }

    /**
     * Clear FCS's UNDER bit.
     */
    inline void clear_FCS_UNDER() volatile
    {
        FCS &= ~(1u << 10u);
    }

    /**
     * Toggle FCS's UNDER bit.
     */
    inline void toggle_FCS_UNDER() volatile
    {
        FCS ^= 1u << 10u;
    }

    /**
     * Get FCS's OVER bit.
     */
    inline bool get_FCS_OVER() volatile
    {
        return FCS & (1u << 11u);
    }

    /**
     * Set FCS's OVER bit.
     */
    inline void set_FCS_OVER() volatile
    {
        FCS |= 1u << 11u;
    }

    /**
     * Clear FCS's OVER bit.
     */
    inline void clear_FCS_OVER() volatile
    {
        FCS &= ~(1u << 11u);
    }

    /**
     * Toggle FCS's OVER bit.
     */
    inline void toggle_FCS_OVER() volatile
    {
        FCS ^= 1u << 11u;
    }

    /**
     * Get FCS's LEVEL field.
     */
    inline uint8_t get_FCS_LEVEL() volatile
    {
        return (FCS >> 16u) & 0b1111u;
    }

    /**
     * Get FCS's THRESH field.
     */
    inline uint8_t get_FCS_THRESH() volatile
    {
        return (FCS >> 24u) & 0b1111u;
    }

    /**
     * Set FCS's THRESH field.
     */
    inline void set_FCS_THRESH(uint8_t value) volatile
    {
        uint32_t curr = FCS;

        curr &= ~(0b1111u << 24u);
        curr |= (value & 0b1111u) << 24u;

        FCS = curr;
    }

    /**
     * Get all of FCS's bit fields.
     */
    inline void get_FCS(bool &EN, bool &SHIFT, bool &ERR, bool &DREQ_EN,
                        bool &EMPTY, bool &FULL, bool &UNDER, bool &OVER,
                        uint8_t &LEVEL, uint8_t &THRESH) volatile
    {
        uint32_t curr = FCS;

        EN = curr & (1u << 0u);
        SHIFT = curr & (1u << 1u);
        ERR = curr & (1u << 2u);
        DREQ_EN = curr & (1u << 3u);
        EMPTY = curr & (1u << 8u);
        FULL = curr & (1u << 9u);
        UNDER = curr & (1u << 10u);
        OVER = curr & (1u << 11u);
        LEVEL = (curr >> 16u) & 0b1111u;
        THRESH = (curr >> 24u) & 0b1111u;
    }

    /**
     * Set all of FCS's bit fields.
     */
    inline void set_FCS(bool EN, bool SHIFT, bool ERR, bool DREQ_EN,
                        bool UNDER, bool OVER, uint8_t THRESH) volatile
    {
        uint32_t curr = FCS;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SHIFT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (ERR & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (DREQ_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 10u);
        curr |= (UNDER & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (OVER & 0b1u) << 11u;
        curr &= ~(0b1111u << 24u);
        curr |= (THRESH & 0b1111u) << 24u;

        FCS = curr;
    }

    /**
     * Get FIFO's VAL field.
     */
    inline uint16_t get_FIFO_VAL() volatile
    {
        return (FIFO >> 0u) & 0b111111111111u;
    }

    /**
     * Get FIFO's ERR bit.
     */
    inline bool get_FIFO_ERR() volatile
    {
        return FIFO & (1u << 15u);
    }

    /**
     * Get all of FIFO's bit fields.
     */
    inline void get_FIFO(uint16_t &VAL, bool &ERR) volatile
    {
        uint32_t curr = FIFO;

        VAL = (curr >> 0u) & 0b111111111111u;
        ERR = curr & (1u << 15u);
    }

    /**
     * Get DIV's FRAC field.
     */
    inline uint8_t get_DIV_FRAC() volatile
    {
        return (DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set DIV's FRAC field.
     */
    inline void set_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        DIV = curr;
    }

    /**
     * Get DIV's INT field.
     */
    inline uint16_t get_DIV_INT() volatile
    {
        return (DIV >> 8u) & 0b1111111111111111u;
    }

    /**
     * Set DIV's INT field.
     */
    inline void set_DIV_INT(uint16_t value) volatile
    {
        uint32_t curr = DIV;

        curr &= ~(0b1111111111111111u << 8u);
        curr |= (value & 0b1111111111111111u) << 8u;

        DIV = curr;
    }

    /**
     * Get all of DIV's bit fields.
     */
    inline void get_DIV(uint8_t &FRAC, uint16_t &INT) volatile
    {
        uint32_t curr = DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b1111111111111111u;
    }

    /**
     * Set all of DIV's bit fields.
     */
    inline void set_DIV(uint8_t FRAC, uint16_t INT) volatile
    {
        uint32_t curr = DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b1111111111111111u << 8u);
        curr |= (INT & 0b1111111111111111u) << 8u;

        DIV = curr;
    }

    /**
     * Get INTR's FIFO bit.
     */
    inline bool get_INTR_FIFO() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Get INTE's FIFO bit.
     */
    inline bool get_INTE_FIFO() volatile
    {
        return INTE & (1u << 0u);
    }

    /**
     * Set INTE's FIFO bit.
     */
    inline void set_INTE_FIFO() volatile
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's FIFO bit.
     */
    inline void clear_INTE_FIFO() volatile
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's FIFO bit.
     */
    inline void toggle_INTE_FIFO() volatile
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get INTF's FIFO bit.
     */
    inline bool get_INTF_FIFO() volatile
    {
        return INTF & (1u << 0u);
    }

    /**
     * Set INTF's FIFO bit.
     */
    inline void set_INTF_FIFO() volatile
    {
        INTF |= 1u << 0u;
    }

    /**
     * Clear INTF's FIFO bit.
     */
    inline void clear_INTF_FIFO() volatile
    {
        INTF &= ~(1u << 0u);
    }

    /**
     * Toggle INTF's FIFO bit.
     */
    inline void toggle_INTF_FIFO() volatile
    {
        INTF ^= 1u << 0u;
    }

    /**
     * Get INTS's FIFO bit.
     */
    inline bool get_INTS_FIFO() volatile
    {
        return INTS & (1u << 0u);
    }
};

static_assert(sizeof(adc) == adc::size);

static volatile adc *const ADC = reinterpret_cast<adc *>(0x4004c000);

}; // namespace RP2040
