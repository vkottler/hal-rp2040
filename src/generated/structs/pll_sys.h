/**
 * \file
 * \brief Generated by ifgen (3.1.2).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] pll_sys
{
    /* Constant attributes. */
    static constexpr std::size_t size = 16; /*!< pll_sys's size in bytes. */

    /* Fields. */
    uint32_t CS;        /*!< (read-write) Control and Status\n
                GENERAL CONSTRAINTS:\n
                Reference clock frequency min=5MHz, max=800MHz\n
                Feedback divider min=16, max=320\n
                VCO frequency min=750MHz, max=1600MHz */
    uint32_t PWR;       /*!< (read-write) Controls the PLL power modes. */
    uint32_t FBDIV_INT; /*!< (read-write) Feedback divisor\n
                (note: this PLL does not support fractional division) */
    uint32_t PRIM; /*!< (read-write) Controls the PLL post dividers for the
           primary output\n (note: this PLL does not have a secondary output)\n
           the primary output is driven from VCO divided by postdiv1*postdiv2
         */

    /* Methods. */

    /**
     * Get CS's REFDIV field.
     */
    inline uint8_t get_CS_REFDIV() volatile
    {
        return (CS >> 0u) & 0b111111u;
    }

    /**
     * Set CS's REFDIV field.
     */
    inline void set_CS_REFDIV(uint8_t value) volatile
    {
        uint32_t curr = CS;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CS = curr;
    }

    /**
     * Get CS's BYPASS bit.
     */
    inline bool get_CS_BYPASS() volatile
    {
        return CS & (1u << 8u);
    }

    /**
     * Set CS's BYPASS bit.
     */
    inline void set_CS_BYPASS() volatile
    {
        CS |= 1u << 8u;
    }

    /**
     * Clear CS's BYPASS bit.
     */
    inline void clear_CS_BYPASS() volatile
    {
        CS &= ~(1u << 8u);
    }

    /**
     * Toggle CS's BYPASS bit.
     */
    inline void toggle_CS_BYPASS() volatile
    {
        CS ^= 1u << 8u;
    }

    /**
     * Get CS's LOCK bit.
     */
    inline bool get_CS_LOCK() volatile
    {
        return CS & (1u << 31u);
    }

    /**
     * Get all of CS's bit fields.
     */
    inline void get_CS(uint8_t &REFDIV, bool &BYPASS, bool &LOCK) volatile
    {
        uint32_t curr = CS;

        REFDIV = (curr >> 0u) & 0b111111u;
        BYPASS = curr & (1u << 8u);
        LOCK = curr & (1u << 31u);
    }

    /**
     * Set all of CS's bit fields.
     */
    inline void set_CS(uint8_t REFDIV, bool BYPASS) volatile
    {
        uint32_t curr = CS;

        curr &= ~(0b111111u << 0u);
        curr |= (REFDIV & 0b111111u) << 0u;
        curr &= ~(0b1u << 8u);
        curr |= (BYPASS & 0b1u) << 8u;

        CS = curr;
    }

    /**
     * Get PWR's PD bit.
     */
    inline bool get_PWR_PD() volatile
    {
        return PWR & (1u << 0u);
    }

    /**
     * Set PWR's PD bit.
     */
    inline void set_PWR_PD() volatile
    {
        PWR |= 1u << 0u;
    }

    /**
     * Clear PWR's PD bit.
     */
    inline void clear_PWR_PD() volatile
    {
        PWR &= ~(1u << 0u);
    }

    /**
     * Toggle PWR's PD bit.
     */
    inline void toggle_PWR_PD() volatile
    {
        PWR ^= 1u << 0u;
    }

    /**
     * Get PWR's DSMPD bit.
     */
    inline bool get_PWR_DSMPD() volatile
    {
        return PWR & (1u << 2u);
    }

    /**
     * Set PWR's DSMPD bit.
     */
    inline void set_PWR_DSMPD() volatile
    {
        PWR |= 1u << 2u;
    }

    /**
     * Clear PWR's DSMPD bit.
     */
    inline void clear_PWR_DSMPD() volatile
    {
        PWR &= ~(1u << 2u);
    }

    /**
     * Toggle PWR's DSMPD bit.
     */
    inline void toggle_PWR_DSMPD() volatile
    {
        PWR ^= 1u << 2u;
    }

    /**
     * Get PWR's POSTDIVPD bit.
     */
    inline bool get_PWR_POSTDIVPD() volatile
    {
        return PWR & (1u << 3u);
    }

    /**
     * Set PWR's POSTDIVPD bit.
     */
    inline void set_PWR_POSTDIVPD() volatile
    {
        PWR |= 1u << 3u;
    }

    /**
     * Clear PWR's POSTDIVPD bit.
     */
    inline void clear_PWR_POSTDIVPD() volatile
    {
        PWR &= ~(1u << 3u);
    }

    /**
     * Toggle PWR's POSTDIVPD bit.
     */
    inline void toggle_PWR_POSTDIVPD() volatile
    {
        PWR ^= 1u << 3u;
    }

    /**
     * Get PWR's VCOPD bit.
     */
    inline bool get_PWR_VCOPD() volatile
    {
        return PWR & (1u << 5u);
    }

    /**
     * Set PWR's VCOPD bit.
     */
    inline void set_PWR_VCOPD() volatile
    {
        PWR |= 1u << 5u;
    }

    /**
     * Clear PWR's VCOPD bit.
     */
    inline void clear_PWR_VCOPD() volatile
    {
        PWR &= ~(1u << 5u);
    }

    /**
     * Toggle PWR's VCOPD bit.
     */
    inline void toggle_PWR_VCOPD() volatile
    {
        PWR ^= 1u << 5u;
    }

    /**
     * Get all of PWR's bit fields.
     */
    inline void get_PWR(bool &PD, bool &DSMPD, bool &POSTDIVPD,
                        bool &VCOPD) volatile
    {
        uint32_t curr = PWR;

        PD = curr & (1u << 0u);
        DSMPD = curr & (1u << 2u);
        POSTDIVPD = curr & (1u << 3u);
        VCOPD = curr & (1u << 5u);
    }

    /**
     * Set all of PWR's bit fields.
     */
    inline void set_PWR(bool PD, bool DSMPD, bool POSTDIVPD,
                        bool VCOPD) volatile
    {
        uint32_t curr = PWR;

        curr &= ~(0b1u << 0u);
        curr |= (PD & 0b1u) << 0u;
        curr &= ~(0b1u << 2u);
        curr |= (DSMPD & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (POSTDIVPD & 0b1u) << 3u;
        curr &= ~(0b1u << 5u);
        curr |= (VCOPD & 0b1u) << 5u;

        PWR = curr;
    }

    /**
     * Get FBDIV_INT's FBDIV_INT field.
     */
    inline uint16_t get_FBDIV_INT_FBDIV_INT() volatile
    {
        return (FBDIV_INT >> 0u) & 0b111111111111u;
    }

    /**
     * Set FBDIV_INT's FBDIV_INT field.
     */
    inline void set_FBDIV_INT_FBDIV_INT(uint16_t value) volatile
    {
        uint32_t curr = FBDIV_INT;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        FBDIV_INT = curr;
    }

    /**
     * Get PRIM's POSTDIV2 field.
     */
    inline uint8_t get_PRIM_POSTDIV2() volatile
    {
        return (PRIM >> 12u) & 0b111u;
    }

    /**
     * Set PRIM's POSTDIV2 field.
     */
    inline void set_PRIM_POSTDIV2(uint8_t value) volatile
    {
        uint32_t curr = PRIM;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        PRIM = curr;
    }

    /**
     * Get PRIM's POSTDIV1 field.
     */
    inline uint8_t get_PRIM_POSTDIV1() volatile
    {
        return (PRIM >> 16u) & 0b111u;
    }

    /**
     * Set PRIM's POSTDIV1 field.
     */
    inline void set_PRIM_POSTDIV1(uint8_t value) volatile
    {
        uint32_t curr = PRIM;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        PRIM = curr;
    }

    /**
     * Get all of PRIM's bit fields.
     */
    inline void get_PRIM(uint8_t &POSTDIV2, uint8_t &POSTDIV1) volatile
    {
        uint32_t curr = PRIM;

        POSTDIV2 = (curr >> 12u) & 0b111u;
        POSTDIV1 = (curr >> 16u) & 0b111u;
    }

    /**
     * Set all of PRIM's bit fields.
     */
    inline void set_PRIM(uint8_t POSTDIV2, uint8_t POSTDIV1) volatile
    {
        uint32_t curr = PRIM;

        curr &= ~(0b111u << 12u);
        curr |= (POSTDIV2 & 0b111u) << 12u;
        curr &= ~(0b111u << 16u);
        curr |= (POSTDIV1 & 0b111u) << 16u;

        PRIM = curr;
    }
};

static_assert(sizeof(pll_sys) == pll_sys::size);

static volatile pll_sys *const PLL_SYS =
    reinterpret_cast<pll_sys *>(0x40028000);

static volatile pll_sys *const PLL_USB =
    reinterpret_cast<pll_sys *>(0x4002c000);

}; // namespace RP2040
