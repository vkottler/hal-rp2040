/**
 * \file
 * \brief Generated by ifgen (3.0.1).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] pll_sys
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;       /*!< pll_sys's identifier. */
    static constexpr std::size_t size = 16; /*!< pll_sys's size in bytes. */

    /* Fields. */
    uint32_t CS;        /*!< (read-write) Control and Status\n
                GENERAL CONSTRAINTS:\n
                Reference clock frequency min=5MHz, max=800MHz\n
                Feedback divider min=16, max=320\n
                VCO frequency min=750MHz, max=1600MHz */
    uint32_t PWR;       /*!< (read-write) Controls the PLL power modes. */
    uint32_t FBDIV_INT; /*!< (read-write) Feedback divisor\n
                (note: this PLL does not support fractional division) */
    uint32_t PRIM; /*!< (read-write) Controls the PLL post dividers for the
           primary output\n (note: this PLL does not have a secondary output)\n
           the primary output is driven from VCO divided by postdiv1*postdiv2
         */

    /* Methods. */

    /**
     * Get CS's REFDIV field.
     */
    uint8_t get_CS_REFDIV()
    {
        return (CS >> 0u) & 0b111111u;
    }

    /**
     * Set CS's REFDIV field.
     */
    inline void set_CS_REFDIV(uint8_t value)
    {
        uint32_t curr = CS;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CS = curr;
    }

    /**
     * Get CS's BYPASS bit.
     */
    bool get_CS_BYPASS()
    {
        return CS & (1u << 8u);
    }

    /**
     * Set CS's BYPASS bit.
     */
    inline void set_CS_BYPASS()
    {
        CS |= 1u << 8u;
    }

    /**
     * Clear CS's BYPASS bit.
     */
    inline void clear_CS_BYPASS()
    {
        CS &= ~(1u << 8u);
    }

    /**
     * Toggle CS's BYPASS bit.
     */
    inline void toggle_CS_BYPASS()
    {
        CS ^= 1u << 8u;
    }

    /**
     * Get CS's LOCK bit.
     */
    bool get_CS_LOCK()
    {
        return CS & (1u << 31u);
    }

    /**
     * Get PWR's PD bit.
     */
    bool get_PWR_PD()
    {
        return PWR & (1u << 0u);
    }

    /**
     * Set PWR's PD bit.
     */
    inline void set_PWR_PD()
    {
        PWR |= 1u << 0u;
    }

    /**
     * Clear PWR's PD bit.
     */
    inline void clear_PWR_PD()
    {
        PWR &= ~(1u << 0u);
    }

    /**
     * Toggle PWR's PD bit.
     */
    inline void toggle_PWR_PD()
    {
        PWR ^= 1u << 0u;
    }

    /**
     * Get PWR's DSMPD bit.
     */
    bool get_PWR_DSMPD()
    {
        return PWR & (1u << 2u);
    }

    /**
     * Set PWR's DSMPD bit.
     */
    inline void set_PWR_DSMPD()
    {
        PWR |= 1u << 2u;
    }

    /**
     * Clear PWR's DSMPD bit.
     */
    inline void clear_PWR_DSMPD()
    {
        PWR &= ~(1u << 2u);
    }

    /**
     * Toggle PWR's DSMPD bit.
     */
    inline void toggle_PWR_DSMPD()
    {
        PWR ^= 1u << 2u;
    }

    /**
     * Get PWR's POSTDIVPD bit.
     */
    bool get_PWR_POSTDIVPD()
    {
        return PWR & (1u << 3u);
    }

    /**
     * Set PWR's POSTDIVPD bit.
     */
    inline void set_PWR_POSTDIVPD()
    {
        PWR |= 1u << 3u;
    }

    /**
     * Clear PWR's POSTDIVPD bit.
     */
    inline void clear_PWR_POSTDIVPD()
    {
        PWR &= ~(1u << 3u);
    }

    /**
     * Toggle PWR's POSTDIVPD bit.
     */
    inline void toggle_PWR_POSTDIVPD()
    {
        PWR ^= 1u << 3u;
    }

    /**
     * Get PWR's VCOPD bit.
     */
    bool get_PWR_VCOPD()
    {
        return PWR & (1u << 5u);
    }

    /**
     * Set PWR's VCOPD bit.
     */
    inline void set_PWR_VCOPD()
    {
        PWR |= 1u << 5u;
    }

    /**
     * Clear PWR's VCOPD bit.
     */
    inline void clear_PWR_VCOPD()
    {
        PWR &= ~(1u << 5u);
    }

    /**
     * Toggle PWR's VCOPD bit.
     */
    inline void toggle_PWR_VCOPD()
    {
        PWR ^= 1u << 5u;
    }

    /**
     * Get FBDIV_INT's FBDIV_INT field.
     */
    uint16_t get_FBDIV_INT_FBDIV_INT()
    {
        return (FBDIV_INT >> 0u) & 0b111111111111u;
    }

    /**
     * Set FBDIV_INT's FBDIV_INT field.
     */
    inline void set_FBDIV_INT_FBDIV_INT(uint16_t value)
    {
        uint32_t curr = FBDIV_INT;

        curr &= ~(0b111111111111u << 0u);
        curr |= (value & 0b111111111111u) << 0u;

        FBDIV_INT = curr;
    }

    /**
     * Get PRIM's POSTDIV2 field.
     */
    uint8_t get_PRIM_POSTDIV2()
    {
        return (PRIM >> 12u) & 0b111u;
    }

    /**
     * Set PRIM's POSTDIV2 field.
     */
    inline void set_PRIM_POSTDIV2(uint8_t value)
    {
        uint32_t curr = PRIM;

        curr &= ~(0b111u << 12u);
        curr |= (value & 0b111u) << 12u;

        PRIM = curr;
    }

    /**
     * Get PRIM's POSTDIV1 field.
     */
    uint8_t get_PRIM_POSTDIV1()
    {
        return (PRIM >> 16u) & 0b111u;
    }

    /**
     * Set PRIM's POSTDIV1 field.
     */
    inline void set_PRIM_POSTDIV1(uint8_t value)
    {
        uint32_t curr = PRIM;

        curr &= ~(0b111u << 16u);
        curr |= (value & 0b111u) << 16u;

        PRIM = curr;
    }
};

static_assert(sizeof(pll_sys) == pll_sys::size);

static volatile pll_sys *const PLL_SYS =
    reinterpret_cast<pll_sys *>(0x40028000);

static volatile pll_sys *const PLL_USB =
    reinterpret_cast<pll_sys *>(0x4002c000);

}; // namespace RP2040
