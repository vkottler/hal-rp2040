/**
 * \file
 * \brief Generated by ifgen (3.1.4).
 */
#pragma once

#include "../enums/DMA_CH0_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH0_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH0_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH10_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH10_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH10_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH11_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH11_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH11_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH1_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH1_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH1_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH2_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH2_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH2_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH3_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH3_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH3_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH4_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH4_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH4_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH5_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH5_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH5_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH6_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH6_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH6_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH7_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH7_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH7_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH8_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH8_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH8_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_CH9_CTRL_TRIG_DATA_SIZE.h"
#include "../enums/DMA_CH9_CTRL_TRIG_RING_SIZE.h"
#include "../enums/DMA_CH9_CTRL_TRIG_TREQ_SEL.h"
#include "../enums/DMA_SNIFF_CTRL_CALC.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * DMA with separate read and write masters
 */
struct [[gnu::packed]] dma
{
    /* Constant attributes. */
    static constexpr std::size_t size = 2760; /*!< dma's size in bytes. */

    /* Fields. */
    uint32_t CH0_READ_ADDR;   /*!< (read-write) DMA Channel 0 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH0_WRITE_ADDR;  /*!< (read-write) DMA Channel 0 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH0_TRANS_COUNT; /*!< (read-write) DMA Channel 0 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH0_CTRL_TRIG; /*!< (read-write) DMA Channel 0 Control and Status */
    uint32_t
        CH0_AL1_CTRL; /*!< (read-write) Alias for channel 0 CTRL register */
    uint32_t CH0_AL1_READ_ADDR; /*!< (read-write) Alias for channel 0 READ_ADDR
                                   register */
    uint32_t CH0_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 0
                                          WRITE_ADDR register */
    uint32_t CH0_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 0
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH0_AL2_CTRL; /*!< (read-write) Alias for channel 0 CTRL register */
    uint32_t CH0_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 0
                                     TRANS_COUNT register */
    uint32_t CH0_AL2_READ_ADDR; /*!< (read-write) Alias for channel 0 READ_ADDR
                                   register */
    uint32_t CH0_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 0
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH0_AL3_CTRL; /*!< (read-write) Alias for channel 0 CTRL register */
    uint32_t CH0_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 0
                                        WRITE_ADDR register */
    uint32_t CH0_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 0
                                        TRANS_COUNT register */
    uint32_t CH0_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 0
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH1_READ_ADDR;   /*!< (read-write) DMA Channel 1 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH1_WRITE_ADDR;  /*!< (read-write) DMA Channel 1 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH1_TRANS_COUNT; /*!< (read-write) DMA Channel 1 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH1_CTRL_TRIG; /*!< (read-write) DMA Channel 1 Control and Status */
    uint32_t
        CH1_AL1_CTRL; /*!< (read-write) Alias for channel 1 CTRL register */
    uint32_t CH1_AL1_READ_ADDR; /*!< (read-write) Alias for channel 1 READ_ADDR
                                   register */
    uint32_t CH1_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 1
                                          WRITE_ADDR register */
    uint32_t CH1_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 1
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH1_AL2_CTRL; /*!< (read-write) Alias for channel 1 CTRL register */
    uint32_t CH1_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 1
                                     TRANS_COUNT register */
    uint32_t CH1_AL2_READ_ADDR; /*!< (read-write) Alias for channel 1 READ_ADDR
                                   register */
    uint32_t CH1_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 1
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH1_AL3_CTRL; /*!< (read-write) Alias for channel 1 CTRL register */
    uint32_t CH1_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 1
                                        WRITE_ADDR register */
    uint32_t CH1_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 1
                                        TRANS_COUNT register */
    uint32_t CH1_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 1
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH2_READ_ADDR;   /*!< (read-write) DMA Channel 2 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH2_WRITE_ADDR;  /*!< (read-write) DMA Channel 2 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH2_TRANS_COUNT; /*!< (read-write) DMA Channel 2 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH2_CTRL_TRIG; /*!< (read-write) DMA Channel 2 Control and Status */
    uint32_t
        CH2_AL1_CTRL; /*!< (read-write) Alias for channel 2 CTRL register */
    uint32_t CH2_AL1_READ_ADDR; /*!< (read-write) Alias for channel 2 READ_ADDR
                                   register */
    uint32_t CH2_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 2
                                          WRITE_ADDR register */
    uint32_t CH2_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 2
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH2_AL2_CTRL; /*!< (read-write) Alias for channel 2 CTRL register */
    uint32_t CH2_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 2
                                     TRANS_COUNT register */
    uint32_t CH2_AL2_READ_ADDR; /*!< (read-write) Alias for channel 2 READ_ADDR
                                   register */
    uint32_t CH2_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 2
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH2_AL3_CTRL; /*!< (read-write) Alias for channel 2 CTRL register */
    uint32_t CH2_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 2
                                        WRITE_ADDR register */
    uint32_t CH2_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 2
                                        TRANS_COUNT register */
    uint32_t CH2_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 2
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH3_READ_ADDR;   /*!< (read-write) DMA Channel 3 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH3_WRITE_ADDR;  /*!< (read-write) DMA Channel 3 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH3_TRANS_COUNT; /*!< (read-write) DMA Channel 3 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH3_CTRL_TRIG; /*!< (read-write) DMA Channel 3 Control and Status */
    uint32_t
        CH3_AL1_CTRL; /*!< (read-write) Alias for channel 3 CTRL register */
    uint32_t CH3_AL1_READ_ADDR; /*!< (read-write) Alias for channel 3 READ_ADDR
                                   register */
    uint32_t CH3_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 3
                                          WRITE_ADDR register */
    uint32_t CH3_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 3
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH3_AL2_CTRL; /*!< (read-write) Alias for channel 3 CTRL register */
    uint32_t CH3_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 3
                                     TRANS_COUNT register */
    uint32_t CH3_AL2_READ_ADDR; /*!< (read-write) Alias for channel 3 READ_ADDR
                                   register */
    uint32_t CH3_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 3
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH3_AL3_CTRL; /*!< (read-write) Alias for channel 3 CTRL register */
    uint32_t CH3_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 3
                                        WRITE_ADDR register */
    uint32_t CH3_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 3
                                        TRANS_COUNT register */
    uint32_t CH3_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 3
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH4_READ_ADDR;   /*!< (read-write) DMA Channel 4 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH4_WRITE_ADDR;  /*!< (read-write) DMA Channel 4 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH4_TRANS_COUNT; /*!< (read-write) DMA Channel 4 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH4_CTRL_TRIG; /*!< (read-write) DMA Channel 4 Control and Status */
    uint32_t
        CH4_AL1_CTRL; /*!< (read-write) Alias for channel 4 CTRL register */
    uint32_t CH4_AL1_READ_ADDR; /*!< (read-write) Alias for channel 4 READ_ADDR
                                   register */
    uint32_t CH4_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 4
                                          WRITE_ADDR register */
    uint32_t CH4_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 4
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH4_AL2_CTRL; /*!< (read-write) Alias for channel 4 CTRL register */
    uint32_t CH4_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 4
                                     TRANS_COUNT register */
    uint32_t CH4_AL2_READ_ADDR; /*!< (read-write) Alias for channel 4 READ_ADDR
                                   register */
    uint32_t CH4_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 4
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH4_AL3_CTRL; /*!< (read-write) Alias for channel 4 CTRL register */
    uint32_t CH4_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 4
                                        WRITE_ADDR register */
    uint32_t CH4_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 4
                                        TRANS_COUNT register */
    uint32_t CH4_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 4
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH5_READ_ADDR;   /*!< (read-write) DMA Channel 5 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH5_WRITE_ADDR;  /*!< (read-write) DMA Channel 5 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH5_TRANS_COUNT; /*!< (read-write) DMA Channel 5 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH5_CTRL_TRIG; /*!< (read-write) DMA Channel 5 Control and Status */
    uint32_t
        CH5_AL1_CTRL; /*!< (read-write) Alias for channel 5 CTRL register */
    uint32_t CH5_AL1_READ_ADDR; /*!< (read-write) Alias for channel 5 READ_ADDR
                                   register */
    uint32_t CH5_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 5
                                          WRITE_ADDR register */
    uint32_t CH5_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 5
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH5_AL2_CTRL; /*!< (read-write) Alias for channel 5 CTRL register */
    uint32_t CH5_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 5
                                     TRANS_COUNT register */
    uint32_t CH5_AL2_READ_ADDR; /*!< (read-write) Alias for channel 5 READ_ADDR
                                   register */
    uint32_t CH5_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 5
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH5_AL3_CTRL; /*!< (read-write) Alias for channel 5 CTRL register */
    uint32_t CH5_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 5
                                        WRITE_ADDR register */
    uint32_t CH5_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 5
                                        TRANS_COUNT register */
    uint32_t CH5_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 5
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH6_READ_ADDR;   /*!< (read-write) DMA Channel 6 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH6_WRITE_ADDR;  /*!< (read-write) DMA Channel 6 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH6_TRANS_COUNT; /*!< (read-write) DMA Channel 6 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH6_CTRL_TRIG; /*!< (read-write) DMA Channel 6 Control and Status */
    uint32_t
        CH6_AL1_CTRL; /*!< (read-write) Alias for channel 6 CTRL register */
    uint32_t CH6_AL1_READ_ADDR; /*!< (read-write) Alias for channel 6 READ_ADDR
                                   register */
    uint32_t CH6_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 6
                                          WRITE_ADDR register */
    uint32_t CH6_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 6
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH6_AL2_CTRL; /*!< (read-write) Alias for channel 6 CTRL register */
    uint32_t CH6_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 6
                                     TRANS_COUNT register */
    uint32_t CH6_AL2_READ_ADDR; /*!< (read-write) Alias for channel 6 READ_ADDR
                                   register */
    uint32_t CH6_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 6
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH6_AL3_CTRL; /*!< (read-write) Alias for channel 6 CTRL register */
    uint32_t CH6_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 6
                                        WRITE_ADDR register */
    uint32_t CH6_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 6
                                        TRANS_COUNT register */
    uint32_t CH6_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 6
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH7_READ_ADDR;   /*!< (read-write) DMA Channel 7 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH7_WRITE_ADDR;  /*!< (read-write) DMA Channel 7 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH7_TRANS_COUNT; /*!< (read-write) DMA Channel 7 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH7_CTRL_TRIG; /*!< (read-write) DMA Channel 7 Control and Status */
    uint32_t
        CH7_AL1_CTRL; /*!< (read-write) Alias for channel 7 CTRL register */
    uint32_t CH7_AL1_READ_ADDR; /*!< (read-write) Alias for channel 7 READ_ADDR
                                   register */
    uint32_t CH7_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 7
                                          WRITE_ADDR register */
    uint32_t CH7_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 7
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH7_AL2_CTRL; /*!< (read-write) Alias for channel 7 CTRL register */
    uint32_t CH7_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 7
                                     TRANS_COUNT register */
    uint32_t CH7_AL2_READ_ADDR; /*!< (read-write) Alias for channel 7 READ_ADDR
                                   register */
    uint32_t CH7_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 7
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH7_AL3_CTRL; /*!< (read-write) Alias for channel 7 CTRL register */
    uint32_t CH7_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 7
                                        WRITE_ADDR register */
    uint32_t CH7_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 7
                                        TRANS_COUNT register */
    uint32_t CH7_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 7
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH8_READ_ADDR;   /*!< (read-write) DMA Channel 8 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH8_WRITE_ADDR;  /*!< (read-write) DMA Channel 8 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH8_TRANS_COUNT; /*!< (read-write) DMA Channel 8 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH8_CTRL_TRIG; /*!< (read-write) DMA Channel 8 Control and Status */
    uint32_t
        CH8_AL1_CTRL; /*!< (read-write) Alias for channel 8 CTRL register */
    uint32_t CH8_AL1_READ_ADDR; /*!< (read-write) Alias for channel 8 READ_ADDR
                                   register */
    uint32_t CH8_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 8
                                          WRITE_ADDR register */
    uint32_t CH8_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 8
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH8_AL2_CTRL; /*!< (read-write) Alias for channel 8 CTRL register */
    uint32_t CH8_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 8
                                     TRANS_COUNT register */
    uint32_t CH8_AL2_READ_ADDR; /*!< (read-write) Alias for channel 8 READ_ADDR
                                   register */
    uint32_t CH8_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 8
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH8_AL3_CTRL; /*!< (read-write) Alias for channel 8 CTRL register */
    uint32_t CH8_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 8
                                        WRITE_ADDR register */
    uint32_t CH8_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 8
                                        TRANS_COUNT register */
    uint32_t CH8_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 8
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH9_READ_ADDR;   /*!< (read-write) DMA Channel 9 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH9_WRITE_ADDR;  /*!< (read-write) DMA Channel 9 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH9_TRANS_COUNT; /*!< (read-write) DMA Channel 9 Transfer Count\n
Program the number of bus transfers a channel will perform before halting. Note
that, if transfers are larger than one byte in size, this is not equal to the
number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the channel is
active, reading this register shows the number of transfers remaining, updating
automatically each time a write transfer completes.\n\n Writing this register
sets the RELOAD value for the transfer counter. Each time this channel is
triggered, the RELOAD value is copied into the live transfer counter. The
channel can be started multiple times, and will perform the same number of
transfers each time, as programmed by most recent write.\n\n The RELOAD value
can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a trigger, the
written value is used immediately as the length of the new transfer sequence,
as well as being written to RELOAD. */
    uint32_t
        CH9_CTRL_TRIG; /*!< (read-write) DMA Channel 9 Control and Status */
    uint32_t
        CH9_AL1_CTRL; /*!< (read-write) Alias for channel 9 CTRL register */
    uint32_t CH9_AL1_READ_ADDR; /*!< (read-write) Alias for channel 9 READ_ADDR
                                   register */
    uint32_t CH9_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 9
                                          WRITE_ADDR register */
    uint32_t CH9_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 9
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH9_AL2_CTRL; /*!< (read-write) Alias for channel 9 CTRL register */
    uint32_t CH9_AL2_TRANS_COUNT; /*!< (read-write) Alias for channel 9
                                     TRANS_COUNT register */
    uint32_t CH9_AL2_READ_ADDR; /*!< (read-write) Alias for channel 9 READ_ADDR
                                   register */
    uint32_t CH9_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 9
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH9_AL3_CTRL; /*!< (read-write) Alias for channel 9 CTRL register */
    uint32_t CH9_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 9
                                        WRITE_ADDR register */
    uint32_t CH9_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 9
                                        TRANS_COUNT register */
    uint32_t CH9_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 9
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH10_READ_ADDR;   /*!< (read-write) DMA Channel 10 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH10_WRITE_ADDR;  /*!< (read-write) DMA Channel 10 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH10_TRANS_COUNT; /*!< (read-write) DMA Channel 10 Transfer
Count\n Program the number of bus transfers a channel will perform before
halting. Note that, if transfers are larger than one byte in size, this is not
equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the
channel is active, reading this register shows the number of transfers
remaining, updating automatically each time a write transfer completes.\n\n
Writing this register sets the RELOAD value for the transfer counter. Each time
this channel is triggered, the RELOAD value is copied into the live transfer
counter. The channel can be started multiple times, and will perform the same
number of transfers each time, as programmed by most recent write.\n\n The
RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
trigger, the written value is used immediately as the length of the new
transfer sequence, as well as being written to RELOAD. */
    uint32_t
        CH10_CTRL_TRIG; /*!< (read-write) DMA Channel 10 Control and Status */
    uint32_t
        CH10_AL1_CTRL; /*!< (read-write) Alias for channel 10 CTRL register */
    uint32_t CH10_AL1_READ_ADDR;        /*!< (read-write) Alias for channel 10
                                           READ_ADDR register */
    uint32_t CH10_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 10
                                           WRITE_ADDR register */
    uint32_t CH10_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 10
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH10_AL2_CTRL; /*!< (read-write) Alias for channel 10 CTRL register */
    uint32_t CH10_AL2_TRANS_COUNT;     /*!< (read-write) Alias for channel 10
                                          TRANS_COUNT register */
    uint32_t CH10_AL2_READ_ADDR;       /*!< (read-write) Alias for channel 10
                                          READ_ADDR register */
    uint32_t CH10_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 10
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH10_AL3_CTRL; /*!< (read-write) Alias for channel 10 CTRL register */
    uint32_t CH10_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 10
                                         WRITE_ADDR register */
    uint32_t CH10_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 10
                                         TRANS_COUNT register */
    uint32_t CH10_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 10
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t CH11_READ_ADDR;   /*!< (read-write) DMA Channel 11 Read Address
  pointer\n   This register updates automatically each time a read completes. The
  current value is the next address to be read by this channel. */
    uint32_t CH11_WRITE_ADDR;  /*!< (read-write) DMA Channel 11 Write Address
 pointer\n  This register updates automatically each time a write completes. The
 current value is the next address to be written by this channel. */
    uint32_t CH11_TRANS_COUNT; /*!< (read-write) DMA Channel 11 Transfer
Count\n Program the number of bus transfers a channel will perform before
halting. Note that, if transfers are larger than one byte in size, this is not
equal to the number of bytes transferred (see CTRL_DATA_SIZE).\n\n When the
channel is active, reading this register shows the number of transfers
remaining, updating automatically each time a write transfer completes.\n\n
Writing this register sets the RELOAD value for the transfer counter. Each time
this channel is triggered, the RELOAD value is copied into the live transfer
counter. The channel can be started multiple times, and will perform the same
number of transfers each time, as programmed by most recent write.\n\n The
RELOAD value can be observed at CHx_DBG_TCR. If TRANS_COUNT is used as a
trigger, the written value is used immediately as the length of the new
transfer sequence, as well as being written to RELOAD. */
    uint32_t
        CH11_CTRL_TRIG; /*!< (read-write) DMA Channel 11 Control and Status */
    uint32_t
        CH11_AL1_CTRL; /*!< (read-write) Alias for channel 11 CTRL register */
    uint32_t CH11_AL1_READ_ADDR;        /*!< (read-write) Alias for channel 11
                                           READ_ADDR register */
    uint32_t CH11_AL1_WRITE_ADDR;       /*!< (read-write) Alias for channel 11
                                           WRITE_ADDR register */
    uint32_t CH11_AL1_TRANS_COUNT_TRIG; /*!< (read-write) Alias for channel 11
TRANS_COUNT register\n This is a trigger register (0xc). Writing a nonzero
value will\n reload the channel counter and start the channel. */
    uint32_t
        CH11_AL2_CTRL; /*!< (read-write) Alias for channel 11 CTRL register */
    uint32_t CH11_AL2_TRANS_COUNT;     /*!< (read-write) Alias for channel 11
                                          TRANS_COUNT register */
    uint32_t CH11_AL2_READ_ADDR;       /*!< (read-write) Alias for channel 11
                                          READ_ADDR register */
    uint32_t CH11_AL2_WRITE_ADDR_TRIG; /*!< (read-write) Alias for channel 11
WRITE_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    uint32_t
        CH11_AL3_CTRL; /*!< (read-write) Alias for channel 11 CTRL register */
    uint32_t CH11_AL3_WRITE_ADDR;     /*!< (read-write) Alias for channel 11
                                         WRITE_ADDR register */
    uint32_t CH11_AL3_TRANS_COUNT;    /*!< (read-write) Alias for channel 11
                                         TRANS_COUNT register */
    uint32_t CH11_AL3_READ_ADDR_TRIG; /*!< (read-write) Alias for channel 11
READ_ADDR register\n This is a trigger register (0xc). Writing a nonzero value
will\n reload the channel counter and start the channel. */
    static constexpr std::size_t reserved_padding0_length = 64;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t INTR;  /*!< (read-write) Interrupt Status (raw) */
    uint32_t INTE0; /*!< (read-write) Interrupt Enables for IRQ 0 */
    uint32_t INTF0; /*!< (read-write) Force Interrupts */
    uint32_t INTS0; /*!< (read-write) Interrupt Status for IRQ 0 */
    const uint32_t reserved_padding1 = {};
    uint32_t INTE1;  /*!< (read-write) Interrupt Enables for IRQ 1 */
    uint32_t INTF1;  /*!< (read-write) Force Interrupts for IRQ 1 */
    uint32_t INTS1;  /*!< (read-write) Interrupt Status (masked) for IRQ 1 */
    uint32_t TIMER0; /*!< (read-write) Pacing (X/Y) Fractional Timer\n
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t TIMER1; /*!< (read-write) Pacing (X/Y) Fractional Timer\n
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t TIMER2; /*!< (read-write) Pacing (X/Y) Fractional Timer\n
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t TIMER3; /*!< (read-write) Pacing (X/Y) Fractional Timer\n
The pacing timer produces TREQ assertions at a rate set by ((X/Y) * sys_clk).
This equation is evaluated every sys_clk cycles and therefore can only generate
TREQs at a rate of 1 per sys_clk (i.e. permanent TREQ) or less. */
    uint32_t MULTI_CHAN_TRIGGER; /*!< (read-write) Trigger one or more channels
                                    simultaneously */
    uint32_t SNIFF_CTRL;         /*!< (read-write) Sniffer Control */
    uint32_t SNIFF_DATA;         /*!< (read-write) Data accumulator for sniff
        hardware\n         Write an initial seed value here before starting a DMA
        transfer on         the channel indicated by SNIFF_CTRL_DMACH. The hardware
        will update         this         register each time it observes a read from the
        indicated channel. Once the         channel completes, the final result can be
        read         from this register. */
    const uint32_t reserved_padding2 = {};
    const uint32_t FIFO_LEVELS =
        {};              /*!< (read-only) Debug RAF, WAF, TDF levels */
    uint32_t CHAN_ABORT; /*!< (read-write) Abort an in-progress transfer
                            sequence on one or more channels */
    const uint32_t N_CHANNELS =
        {}; /*!< (read-only) The number of channels this DMA instance is
               equipped with. This DMA supports up to 16 hardware channels, but
               can be configured with as few as one, to minimise silicon area.
             */
    static constexpr std::size_t reserved_padding3_length = 237;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t
        CH0_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH0_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding4_length = 14;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t
        CH1_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH1_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding5_length = 14;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t
        CH2_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH2_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding6_length = 14;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    uint32_t
        CH3_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH3_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding7_length = 14;
    const uint32_t reserved_padding7[reserved_padding7_length] = {};
    uint32_t
        CH4_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH4_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding8_length = 14;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    uint32_t
        CH5_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH5_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding9_length = 14;
    const uint32_t reserved_padding9[reserved_padding9_length] = {};
    uint32_t
        CH6_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH6_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding10_length = 14;
    const uint32_t reserved_padding10[reserved_padding10_length] = {};
    uint32_t
        CH7_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH7_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding11_length = 14;
    const uint32_t reserved_padding11[reserved_padding11_length] = {};
    uint32_t
        CH8_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH8_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding12_length = 14;
    const uint32_t reserved_padding12[reserved_padding12_length] = {};
    uint32_t
        CH9_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                           how many accesses the DMA expects it can perform on
                           the peripheral without overflow/underflow. Write any
                           value: clears the counter, and cause channel to
                           re-initiate DREQ handshake. */
    uint32_t
        CH9_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                        value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding13_length = 14;
    const uint32_t reserved_padding13[reserved_padding13_length] = {};
    uint32_t
        CH10_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                            how many accesses the DMA expects it can perform on
                            the peripheral without overflow/underflow. Write
                            any value: clears the counter, and cause channel to
                            re-initiate DREQ handshake. */
    uint32_t
        CH10_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                         value, i.e. the length of the next transfer */
    static constexpr std::size_t reserved_padding14_length = 14;
    const uint32_t reserved_padding14[reserved_padding14_length] = {};
    uint32_t
        CH11_DBG_CTDREQ; /*!< (read-write) Read: get channel DREQ counter (i.e.
                            how many accesses the DMA expects it can perform on
                            the peripheral without overflow/underflow. Write
                            any value: clears the counter, and cause channel to
                            re-initiate DREQ handshake. */
    uint32_t
        CH11_DBG_TCR; /*!< (read-write) Read to get channel TRANS_COUNT reload
                         value, i.e. the length of the next transfer */

    /* Methods. */

    /**
     * Get CH0_CTRL_TRIG's EN bit.
     */
    inline bool get_CH0_CTRL_TRIG_EN() volatile
    {
        return CH0_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH0_CTRL_TRIG's EN bit.
     */
    inline void set_CH0_CTRL_TRIG_EN() volatile
    {
        CH0_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH0_CTRL_TRIG's EN bit.
     */
    inline void clear_CH0_CTRL_TRIG_EN() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH0_CTRL_TRIG_EN() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH0_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH0_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH0_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH0_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH0_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH0_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH0_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH0_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH0_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH0_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH0_CTRL_TRIG_DATA_SIZE get_CH0_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH0_CTRL_TRIG_DATA_SIZE((CH0_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH0_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH0_CTRL_TRIG_DATA_SIZE(
        DMA_CH0_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH0_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH0_CTRL_TRIG = curr;
    }

    /**
     * Get CH0_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH0_CTRL_TRIG_INCR_READ() volatile
    {
        return CH0_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH0_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH0_CTRL_TRIG_INCR_READ() volatile
    {
        CH0_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH0_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH0_CTRL_TRIG_INCR_READ() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH0_CTRL_TRIG_INCR_READ() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH0_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH0_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH0_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH0_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH0_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH0_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH0_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH0_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH0_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH0_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH0_CTRL_TRIG_RING_SIZE get_CH0_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH0_CTRL_TRIG_RING_SIZE((CH0_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH0_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH0_CTRL_TRIG_RING_SIZE(
        DMA_CH0_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH0_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH0_CTRL_TRIG = curr;
    }

    /**
     * Get CH0_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH0_CTRL_TRIG_RING_SEL() volatile
    {
        return CH0_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH0_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH0_CTRL_TRIG_RING_SEL() volatile
    {
        CH0_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH0_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH0_CTRL_TRIG_RING_SEL() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH0_CTRL_TRIG_RING_SEL() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH0_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH0_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH0_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH0_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH0_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH0_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH0_CTRL_TRIG = curr;
    }

    /**
     * Get CH0_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH0_CTRL_TRIG_TREQ_SEL get_CH0_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH0_CTRL_TRIG_TREQ_SEL((CH0_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH0_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH0_CTRL_TRIG_TREQ_SEL(
        DMA_CH0_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH0_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH0_CTRL_TRIG = curr;
    }

    /**
     * Get CH0_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH0_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH0_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH0_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH0_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH0_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH0_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH0_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH0_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH0_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH0_CTRL_TRIG_BSWAP() volatile
    {
        return CH0_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH0_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH0_CTRL_TRIG_BSWAP() volatile
    {
        CH0_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH0_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH0_CTRL_TRIG_BSWAP() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH0_CTRL_TRIG_BSWAP() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH0_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH0_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH0_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH0_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH0_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH0_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH0_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH0_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH0_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH0_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH0_CTRL_TRIG_BUSY() volatile
    {
        return CH0_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH0_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH0_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH0_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH0_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH0_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH0_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH0_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH0_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH0_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH0_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH0_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH0_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH0_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH0_CTRL_TRIG_READ_ERROR() volatile
    {
        CH0_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH0_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH0_CTRL_TRIG_READ_ERROR() volatile
    {
        CH0_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH0_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH0_CTRL_TRIG_READ_ERROR() volatile
    {
        CH0_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH0_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH0_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH0_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH0_CTRL_TRIG's bit fields.
     */
    inline void get_CH0_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH0_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH0_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH0_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH0_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH0_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH0_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH0_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH0_CTRL_TRIG's bit fields.
     */
    inline void set_CH0_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH0_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH0_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH0_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH0_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH0_CTRL_TRIG = curr;
    }

    /**
     * Get CH1_CTRL_TRIG's EN bit.
     */
    inline bool get_CH1_CTRL_TRIG_EN() volatile
    {
        return CH1_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH1_CTRL_TRIG's EN bit.
     */
    inline void set_CH1_CTRL_TRIG_EN() volatile
    {
        CH1_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH1_CTRL_TRIG's EN bit.
     */
    inline void clear_CH1_CTRL_TRIG_EN() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH1_CTRL_TRIG_EN() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH1_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH1_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH1_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH1_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH1_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH1_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH1_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH1_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH1_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH1_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH1_CTRL_TRIG_DATA_SIZE get_CH1_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH1_CTRL_TRIG_DATA_SIZE((CH1_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH1_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH1_CTRL_TRIG_DATA_SIZE(
        DMA_CH1_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH1_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH1_CTRL_TRIG = curr;
    }

    /**
     * Get CH1_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH1_CTRL_TRIG_INCR_READ() volatile
    {
        return CH1_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH1_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH1_CTRL_TRIG_INCR_READ() volatile
    {
        CH1_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH1_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH1_CTRL_TRIG_INCR_READ() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH1_CTRL_TRIG_INCR_READ() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH1_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH1_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH1_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH1_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH1_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH1_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH1_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH1_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH1_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH1_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH1_CTRL_TRIG_RING_SIZE get_CH1_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH1_CTRL_TRIG_RING_SIZE((CH1_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH1_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH1_CTRL_TRIG_RING_SIZE(
        DMA_CH1_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH1_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH1_CTRL_TRIG = curr;
    }

    /**
     * Get CH1_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH1_CTRL_TRIG_RING_SEL() volatile
    {
        return CH1_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH1_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH1_CTRL_TRIG_RING_SEL() volatile
    {
        CH1_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH1_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH1_CTRL_TRIG_RING_SEL() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH1_CTRL_TRIG_RING_SEL() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH1_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH1_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH1_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH1_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH1_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH1_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH1_CTRL_TRIG = curr;
    }

    /**
     * Get CH1_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH1_CTRL_TRIG_TREQ_SEL get_CH1_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH1_CTRL_TRIG_TREQ_SEL((CH1_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH1_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH1_CTRL_TRIG_TREQ_SEL(
        DMA_CH1_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH1_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH1_CTRL_TRIG = curr;
    }

    /**
     * Get CH1_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH1_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH1_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH1_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH1_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH1_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH1_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH1_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH1_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH1_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH1_CTRL_TRIG_BSWAP() volatile
    {
        return CH1_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH1_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH1_CTRL_TRIG_BSWAP() volatile
    {
        CH1_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH1_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH1_CTRL_TRIG_BSWAP() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH1_CTRL_TRIG_BSWAP() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH1_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH1_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH1_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH1_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH1_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH1_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH1_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH1_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH1_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH1_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH1_CTRL_TRIG_BUSY() volatile
    {
        return CH1_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH1_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH1_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH1_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH1_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH1_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH1_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH1_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH1_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH1_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH1_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH1_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH1_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH1_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH1_CTRL_TRIG_READ_ERROR() volatile
    {
        CH1_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH1_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH1_CTRL_TRIG_READ_ERROR() volatile
    {
        CH1_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH1_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH1_CTRL_TRIG_READ_ERROR() volatile
    {
        CH1_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH1_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH1_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH1_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH1_CTRL_TRIG's bit fields.
     */
    inline void get_CH1_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH1_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH1_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH1_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH1_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH1_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH1_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH1_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH1_CTRL_TRIG's bit fields.
     */
    inline void set_CH1_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH1_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH1_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH1_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH1_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH1_CTRL_TRIG = curr;
    }

    /**
     * Get CH2_CTRL_TRIG's EN bit.
     */
    inline bool get_CH2_CTRL_TRIG_EN() volatile
    {
        return CH2_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH2_CTRL_TRIG's EN bit.
     */
    inline void set_CH2_CTRL_TRIG_EN() volatile
    {
        CH2_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH2_CTRL_TRIG's EN bit.
     */
    inline void clear_CH2_CTRL_TRIG_EN() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH2_CTRL_TRIG_EN() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH2_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH2_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH2_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH2_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH2_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH2_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH2_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH2_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH2_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH2_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH2_CTRL_TRIG_DATA_SIZE get_CH2_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH2_CTRL_TRIG_DATA_SIZE((CH2_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH2_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH2_CTRL_TRIG_DATA_SIZE(
        DMA_CH2_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH2_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH2_CTRL_TRIG = curr;
    }

    /**
     * Get CH2_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH2_CTRL_TRIG_INCR_READ() volatile
    {
        return CH2_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH2_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH2_CTRL_TRIG_INCR_READ() volatile
    {
        CH2_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH2_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH2_CTRL_TRIG_INCR_READ() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH2_CTRL_TRIG_INCR_READ() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH2_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH2_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH2_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH2_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH2_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH2_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH2_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH2_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH2_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH2_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH2_CTRL_TRIG_RING_SIZE get_CH2_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH2_CTRL_TRIG_RING_SIZE((CH2_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH2_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH2_CTRL_TRIG_RING_SIZE(
        DMA_CH2_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH2_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH2_CTRL_TRIG = curr;
    }

    /**
     * Get CH2_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH2_CTRL_TRIG_RING_SEL() volatile
    {
        return CH2_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH2_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH2_CTRL_TRIG_RING_SEL() volatile
    {
        CH2_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH2_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH2_CTRL_TRIG_RING_SEL() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH2_CTRL_TRIG_RING_SEL() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH2_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH2_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH2_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH2_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH2_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH2_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH2_CTRL_TRIG = curr;
    }

    /**
     * Get CH2_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH2_CTRL_TRIG_TREQ_SEL get_CH2_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH2_CTRL_TRIG_TREQ_SEL((CH2_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH2_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH2_CTRL_TRIG_TREQ_SEL(
        DMA_CH2_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH2_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH2_CTRL_TRIG = curr;
    }

    /**
     * Get CH2_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH2_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH2_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH2_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH2_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH2_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH2_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH2_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH2_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH2_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH2_CTRL_TRIG_BSWAP() volatile
    {
        return CH2_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH2_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH2_CTRL_TRIG_BSWAP() volatile
    {
        CH2_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH2_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH2_CTRL_TRIG_BSWAP() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH2_CTRL_TRIG_BSWAP() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH2_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH2_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH2_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH2_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH2_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH2_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH2_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH2_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH2_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH2_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH2_CTRL_TRIG_BUSY() volatile
    {
        return CH2_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH2_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH2_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH2_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH2_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH2_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH2_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH2_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH2_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH2_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH2_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH2_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH2_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH2_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH2_CTRL_TRIG_READ_ERROR() volatile
    {
        CH2_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH2_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH2_CTRL_TRIG_READ_ERROR() volatile
    {
        CH2_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH2_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH2_CTRL_TRIG_READ_ERROR() volatile
    {
        CH2_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH2_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH2_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH2_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH2_CTRL_TRIG's bit fields.
     */
    inline void get_CH2_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH2_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH2_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH2_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH2_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH2_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH2_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH2_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH2_CTRL_TRIG's bit fields.
     */
    inline void set_CH2_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH2_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH2_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH2_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH2_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH2_CTRL_TRIG = curr;
    }

    /**
     * Get CH3_CTRL_TRIG's EN bit.
     */
    inline bool get_CH3_CTRL_TRIG_EN() volatile
    {
        return CH3_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH3_CTRL_TRIG's EN bit.
     */
    inline void set_CH3_CTRL_TRIG_EN() volatile
    {
        CH3_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH3_CTRL_TRIG's EN bit.
     */
    inline void clear_CH3_CTRL_TRIG_EN() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH3_CTRL_TRIG_EN() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH3_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH3_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH3_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH3_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH3_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH3_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH3_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH3_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH3_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH3_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH3_CTRL_TRIG_DATA_SIZE get_CH3_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH3_CTRL_TRIG_DATA_SIZE((CH3_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH3_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH3_CTRL_TRIG_DATA_SIZE(
        DMA_CH3_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH3_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH3_CTRL_TRIG = curr;
    }

    /**
     * Get CH3_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH3_CTRL_TRIG_INCR_READ() volatile
    {
        return CH3_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH3_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH3_CTRL_TRIG_INCR_READ() volatile
    {
        CH3_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH3_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH3_CTRL_TRIG_INCR_READ() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH3_CTRL_TRIG_INCR_READ() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH3_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH3_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH3_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH3_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH3_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH3_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH3_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH3_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH3_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH3_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH3_CTRL_TRIG_RING_SIZE get_CH3_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH3_CTRL_TRIG_RING_SIZE((CH3_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH3_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH3_CTRL_TRIG_RING_SIZE(
        DMA_CH3_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH3_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH3_CTRL_TRIG = curr;
    }

    /**
     * Get CH3_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH3_CTRL_TRIG_RING_SEL() volatile
    {
        return CH3_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH3_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH3_CTRL_TRIG_RING_SEL() volatile
    {
        CH3_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH3_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH3_CTRL_TRIG_RING_SEL() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH3_CTRL_TRIG_RING_SEL() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH3_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH3_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH3_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH3_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH3_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH3_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH3_CTRL_TRIG = curr;
    }

    /**
     * Get CH3_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH3_CTRL_TRIG_TREQ_SEL get_CH3_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH3_CTRL_TRIG_TREQ_SEL((CH3_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH3_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH3_CTRL_TRIG_TREQ_SEL(
        DMA_CH3_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH3_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH3_CTRL_TRIG = curr;
    }

    /**
     * Get CH3_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH3_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH3_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH3_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH3_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH3_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH3_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH3_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH3_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH3_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH3_CTRL_TRIG_BSWAP() volatile
    {
        return CH3_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH3_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH3_CTRL_TRIG_BSWAP() volatile
    {
        CH3_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH3_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH3_CTRL_TRIG_BSWAP() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH3_CTRL_TRIG_BSWAP() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH3_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH3_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH3_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH3_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH3_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH3_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH3_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH3_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH3_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH3_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH3_CTRL_TRIG_BUSY() volatile
    {
        return CH3_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH3_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH3_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH3_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH3_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH3_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH3_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH3_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH3_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH3_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH3_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH3_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH3_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH3_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH3_CTRL_TRIG_READ_ERROR() volatile
    {
        CH3_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH3_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH3_CTRL_TRIG_READ_ERROR() volatile
    {
        CH3_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH3_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH3_CTRL_TRIG_READ_ERROR() volatile
    {
        CH3_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH3_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH3_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH3_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH3_CTRL_TRIG's bit fields.
     */
    inline void get_CH3_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH3_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH3_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH3_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH3_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH3_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH3_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH3_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH3_CTRL_TRIG's bit fields.
     */
    inline void set_CH3_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH3_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH3_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH3_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH3_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH3_CTRL_TRIG = curr;
    }

    /**
     * Get CH4_CTRL_TRIG's EN bit.
     */
    inline bool get_CH4_CTRL_TRIG_EN() volatile
    {
        return CH4_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH4_CTRL_TRIG's EN bit.
     */
    inline void set_CH4_CTRL_TRIG_EN() volatile
    {
        CH4_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH4_CTRL_TRIG's EN bit.
     */
    inline void clear_CH4_CTRL_TRIG_EN() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH4_CTRL_TRIG_EN() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH4_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH4_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH4_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH4_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH4_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH4_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH4_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH4_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH4_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH4_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH4_CTRL_TRIG_DATA_SIZE get_CH4_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH4_CTRL_TRIG_DATA_SIZE((CH4_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH4_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH4_CTRL_TRIG_DATA_SIZE(
        DMA_CH4_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH4_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH4_CTRL_TRIG = curr;
    }

    /**
     * Get CH4_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH4_CTRL_TRIG_INCR_READ() volatile
    {
        return CH4_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH4_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH4_CTRL_TRIG_INCR_READ() volatile
    {
        CH4_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH4_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH4_CTRL_TRIG_INCR_READ() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH4_CTRL_TRIG_INCR_READ() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH4_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH4_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH4_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH4_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH4_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH4_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH4_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH4_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH4_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH4_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH4_CTRL_TRIG_RING_SIZE get_CH4_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH4_CTRL_TRIG_RING_SIZE((CH4_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH4_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH4_CTRL_TRIG_RING_SIZE(
        DMA_CH4_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH4_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH4_CTRL_TRIG = curr;
    }

    /**
     * Get CH4_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH4_CTRL_TRIG_RING_SEL() volatile
    {
        return CH4_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH4_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH4_CTRL_TRIG_RING_SEL() volatile
    {
        CH4_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH4_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH4_CTRL_TRIG_RING_SEL() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH4_CTRL_TRIG_RING_SEL() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH4_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH4_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH4_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH4_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH4_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH4_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH4_CTRL_TRIG = curr;
    }

    /**
     * Get CH4_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH4_CTRL_TRIG_TREQ_SEL get_CH4_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH4_CTRL_TRIG_TREQ_SEL((CH4_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH4_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH4_CTRL_TRIG_TREQ_SEL(
        DMA_CH4_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH4_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH4_CTRL_TRIG = curr;
    }

    /**
     * Get CH4_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH4_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH4_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH4_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH4_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH4_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH4_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH4_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH4_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH4_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH4_CTRL_TRIG_BSWAP() volatile
    {
        return CH4_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH4_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH4_CTRL_TRIG_BSWAP() volatile
    {
        CH4_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH4_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH4_CTRL_TRIG_BSWAP() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH4_CTRL_TRIG_BSWAP() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH4_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH4_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH4_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH4_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH4_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH4_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH4_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH4_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH4_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH4_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH4_CTRL_TRIG_BUSY() volatile
    {
        return CH4_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH4_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH4_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH4_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH4_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH4_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH4_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH4_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH4_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH4_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH4_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH4_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH4_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH4_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH4_CTRL_TRIG_READ_ERROR() volatile
    {
        CH4_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH4_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH4_CTRL_TRIG_READ_ERROR() volatile
    {
        CH4_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH4_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH4_CTRL_TRIG_READ_ERROR() volatile
    {
        CH4_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH4_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH4_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH4_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH4_CTRL_TRIG's bit fields.
     */
    inline void get_CH4_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH4_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH4_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH4_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH4_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH4_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH4_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH4_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH4_CTRL_TRIG's bit fields.
     */
    inline void set_CH4_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH4_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH4_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH4_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH4_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH4_CTRL_TRIG = curr;
    }

    /**
     * Get CH5_CTRL_TRIG's EN bit.
     */
    inline bool get_CH5_CTRL_TRIG_EN() volatile
    {
        return CH5_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH5_CTRL_TRIG's EN bit.
     */
    inline void set_CH5_CTRL_TRIG_EN() volatile
    {
        CH5_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH5_CTRL_TRIG's EN bit.
     */
    inline void clear_CH5_CTRL_TRIG_EN() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH5_CTRL_TRIG_EN() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH5_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH5_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH5_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH5_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH5_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH5_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH5_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH5_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH5_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH5_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH5_CTRL_TRIG_DATA_SIZE get_CH5_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH5_CTRL_TRIG_DATA_SIZE((CH5_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH5_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH5_CTRL_TRIG_DATA_SIZE(
        DMA_CH5_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH5_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH5_CTRL_TRIG = curr;
    }

    /**
     * Get CH5_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH5_CTRL_TRIG_INCR_READ() volatile
    {
        return CH5_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH5_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH5_CTRL_TRIG_INCR_READ() volatile
    {
        CH5_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH5_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH5_CTRL_TRIG_INCR_READ() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH5_CTRL_TRIG_INCR_READ() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH5_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH5_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH5_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH5_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH5_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH5_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH5_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH5_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH5_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH5_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH5_CTRL_TRIG_RING_SIZE get_CH5_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH5_CTRL_TRIG_RING_SIZE((CH5_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH5_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH5_CTRL_TRIG_RING_SIZE(
        DMA_CH5_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH5_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH5_CTRL_TRIG = curr;
    }

    /**
     * Get CH5_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH5_CTRL_TRIG_RING_SEL() volatile
    {
        return CH5_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH5_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH5_CTRL_TRIG_RING_SEL() volatile
    {
        CH5_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH5_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH5_CTRL_TRIG_RING_SEL() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH5_CTRL_TRIG_RING_SEL() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH5_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH5_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH5_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH5_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH5_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH5_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH5_CTRL_TRIG = curr;
    }

    /**
     * Get CH5_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH5_CTRL_TRIG_TREQ_SEL get_CH5_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH5_CTRL_TRIG_TREQ_SEL((CH5_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH5_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH5_CTRL_TRIG_TREQ_SEL(
        DMA_CH5_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH5_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH5_CTRL_TRIG = curr;
    }

    /**
     * Get CH5_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH5_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH5_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH5_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH5_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH5_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH5_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH5_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH5_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH5_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH5_CTRL_TRIG_BSWAP() volatile
    {
        return CH5_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH5_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH5_CTRL_TRIG_BSWAP() volatile
    {
        CH5_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH5_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH5_CTRL_TRIG_BSWAP() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH5_CTRL_TRIG_BSWAP() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH5_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH5_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH5_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH5_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH5_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH5_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH5_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH5_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH5_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH5_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH5_CTRL_TRIG_BUSY() volatile
    {
        return CH5_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH5_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH5_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH5_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH5_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH5_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH5_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH5_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH5_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH5_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH5_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH5_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH5_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH5_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH5_CTRL_TRIG_READ_ERROR() volatile
    {
        CH5_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH5_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH5_CTRL_TRIG_READ_ERROR() volatile
    {
        CH5_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH5_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH5_CTRL_TRIG_READ_ERROR() volatile
    {
        CH5_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH5_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH5_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH5_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH5_CTRL_TRIG's bit fields.
     */
    inline void get_CH5_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH5_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH5_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH5_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH5_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH5_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH5_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH5_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH5_CTRL_TRIG's bit fields.
     */
    inline void set_CH5_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH5_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH5_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH5_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH5_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH5_CTRL_TRIG = curr;
    }

    /**
     * Get CH6_CTRL_TRIG's EN bit.
     */
    inline bool get_CH6_CTRL_TRIG_EN() volatile
    {
        return CH6_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH6_CTRL_TRIG's EN bit.
     */
    inline void set_CH6_CTRL_TRIG_EN() volatile
    {
        CH6_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH6_CTRL_TRIG's EN bit.
     */
    inline void clear_CH6_CTRL_TRIG_EN() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH6_CTRL_TRIG_EN() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH6_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH6_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH6_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH6_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH6_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH6_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH6_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH6_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH6_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH6_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH6_CTRL_TRIG_DATA_SIZE get_CH6_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH6_CTRL_TRIG_DATA_SIZE((CH6_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH6_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH6_CTRL_TRIG_DATA_SIZE(
        DMA_CH6_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH6_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH6_CTRL_TRIG = curr;
    }

    /**
     * Get CH6_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH6_CTRL_TRIG_INCR_READ() volatile
    {
        return CH6_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH6_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH6_CTRL_TRIG_INCR_READ() volatile
    {
        CH6_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH6_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH6_CTRL_TRIG_INCR_READ() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH6_CTRL_TRIG_INCR_READ() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH6_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH6_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH6_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH6_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH6_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH6_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH6_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH6_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH6_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH6_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH6_CTRL_TRIG_RING_SIZE get_CH6_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH6_CTRL_TRIG_RING_SIZE((CH6_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH6_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH6_CTRL_TRIG_RING_SIZE(
        DMA_CH6_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH6_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH6_CTRL_TRIG = curr;
    }

    /**
     * Get CH6_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH6_CTRL_TRIG_RING_SEL() volatile
    {
        return CH6_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH6_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH6_CTRL_TRIG_RING_SEL() volatile
    {
        CH6_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH6_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH6_CTRL_TRIG_RING_SEL() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH6_CTRL_TRIG_RING_SEL() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH6_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH6_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH6_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH6_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH6_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH6_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH6_CTRL_TRIG = curr;
    }

    /**
     * Get CH6_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH6_CTRL_TRIG_TREQ_SEL get_CH6_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH6_CTRL_TRIG_TREQ_SEL((CH6_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH6_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH6_CTRL_TRIG_TREQ_SEL(
        DMA_CH6_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH6_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH6_CTRL_TRIG = curr;
    }

    /**
     * Get CH6_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH6_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH6_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH6_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH6_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH6_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH6_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH6_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH6_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH6_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH6_CTRL_TRIG_BSWAP() volatile
    {
        return CH6_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH6_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH6_CTRL_TRIG_BSWAP() volatile
    {
        CH6_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH6_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH6_CTRL_TRIG_BSWAP() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH6_CTRL_TRIG_BSWAP() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH6_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH6_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH6_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH6_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH6_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH6_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH6_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH6_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH6_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH6_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH6_CTRL_TRIG_BUSY() volatile
    {
        return CH6_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH6_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH6_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH6_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH6_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH6_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH6_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH6_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH6_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH6_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH6_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH6_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH6_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH6_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH6_CTRL_TRIG_READ_ERROR() volatile
    {
        CH6_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH6_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH6_CTRL_TRIG_READ_ERROR() volatile
    {
        CH6_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH6_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH6_CTRL_TRIG_READ_ERROR() volatile
    {
        CH6_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH6_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH6_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH6_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH6_CTRL_TRIG's bit fields.
     */
    inline void get_CH6_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH6_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH6_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH6_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH6_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH6_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH6_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH6_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH6_CTRL_TRIG's bit fields.
     */
    inline void set_CH6_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH6_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH6_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH6_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH6_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH6_CTRL_TRIG = curr;
    }

    /**
     * Get CH7_CTRL_TRIG's EN bit.
     */
    inline bool get_CH7_CTRL_TRIG_EN() volatile
    {
        return CH7_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH7_CTRL_TRIG's EN bit.
     */
    inline void set_CH7_CTRL_TRIG_EN() volatile
    {
        CH7_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH7_CTRL_TRIG's EN bit.
     */
    inline void clear_CH7_CTRL_TRIG_EN() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH7_CTRL_TRIG_EN() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH7_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH7_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH7_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH7_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH7_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH7_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH7_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH7_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH7_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH7_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH7_CTRL_TRIG_DATA_SIZE get_CH7_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH7_CTRL_TRIG_DATA_SIZE((CH7_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH7_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH7_CTRL_TRIG_DATA_SIZE(
        DMA_CH7_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH7_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH7_CTRL_TRIG = curr;
    }

    /**
     * Get CH7_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH7_CTRL_TRIG_INCR_READ() volatile
    {
        return CH7_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH7_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH7_CTRL_TRIG_INCR_READ() volatile
    {
        CH7_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH7_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH7_CTRL_TRIG_INCR_READ() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH7_CTRL_TRIG_INCR_READ() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH7_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH7_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH7_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH7_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH7_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH7_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH7_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH7_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH7_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH7_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH7_CTRL_TRIG_RING_SIZE get_CH7_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH7_CTRL_TRIG_RING_SIZE((CH7_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH7_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH7_CTRL_TRIG_RING_SIZE(
        DMA_CH7_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH7_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH7_CTRL_TRIG = curr;
    }

    /**
     * Get CH7_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH7_CTRL_TRIG_RING_SEL() volatile
    {
        return CH7_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH7_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH7_CTRL_TRIG_RING_SEL() volatile
    {
        CH7_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH7_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH7_CTRL_TRIG_RING_SEL() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH7_CTRL_TRIG_RING_SEL() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH7_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH7_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH7_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH7_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH7_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH7_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH7_CTRL_TRIG = curr;
    }

    /**
     * Get CH7_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH7_CTRL_TRIG_TREQ_SEL get_CH7_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH7_CTRL_TRIG_TREQ_SEL((CH7_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH7_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH7_CTRL_TRIG_TREQ_SEL(
        DMA_CH7_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH7_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH7_CTRL_TRIG = curr;
    }

    /**
     * Get CH7_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH7_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH7_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH7_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH7_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH7_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH7_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH7_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH7_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH7_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH7_CTRL_TRIG_BSWAP() volatile
    {
        return CH7_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH7_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH7_CTRL_TRIG_BSWAP() volatile
    {
        CH7_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH7_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH7_CTRL_TRIG_BSWAP() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH7_CTRL_TRIG_BSWAP() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH7_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH7_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH7_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH7_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH7_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH7_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH7_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH7_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH7_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH7_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH7_CTRL_TRIG_BUSY() volatile
    {
        return CH7_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH7_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH7_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH7_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH7_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH7_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH7_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH7_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH7_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH7_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH7_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH7_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH7_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH7_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH7_CTRL_TRIG_READ_ERROR() volatile
    {
        CH7_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH7_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH7_CTRL_TRIG_READ_ERROR() volatile
    {
        CH7_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH7_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH7_CTRL_TRIG_READ_ERROR() volatile
    {
        CH7_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH7_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH7_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH7_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH7_CTRL_TRIG's bit fields.
     */
    inline void get_CH7_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH7_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH7_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH7_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH7_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH7_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH7_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH7_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH7_CTRL_TRIG's bit fields.
     */
    inline void set_CH7_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH7_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH7_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH7_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH7_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH7_CTRL_TRIG = curr;
    }

    /**
     * Get CH8_CTRL_TRIG's EN bit.
     */
    inline bool get_CH8_CTRL_TRIG_EN() volatile
    {
        return CH8_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH8_CTRL_TRIG's EN bit.
     */
    inline void set_CH8_CTRL_TRIG_EN() volatile
    {
        CH8_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH8_CTRL_TRIG's EN bit.
     */
    inline void clear_CH8_CTRL_TRIG_EN() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH8_CTRL_TRIG_EN() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH8_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH8_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH8_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH8_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH8_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH8_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH8_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH8_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH8_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH8_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH8_CTRL_TRIG_DATA_SIZE get_CH8_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH8_CTRL_TRIG_DATA_SIZE((CH8_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH8_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH8_CTRL_TRIG_DATA_SIZE(
        DMA_CH8_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH8_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH8_CTRL_TRIG = curr;
    }

    /**
     * Get CH8_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH8_CTRL_TRIG_INCR_READ() volatile
    {
        return CH8_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH8_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH8_CTRL_TRIG_INCR_READ() volatile
    {
        CH8_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH8_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH8_CTRL_TRIG_INCR_READ() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH8_CTRL_TRIG_INCR_READ() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH8_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH8_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH8_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH8_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH8_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH8_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH8_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH8_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH8_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH8_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH8_CTRL_TRIG_RING_SIZE get_CH8_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH8_CTRL_TRIG_RING_SIZE((CH8_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH8_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH8_CTRL_TRIG_RING_SIZE(
        DMA_CH8_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH8_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH8_CTRL_TRIG = curr;
    }

    /**
     * Get CH8_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH8_CTRL_TRIG_RING_SEL() volatile
    {
        return CH8_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH8_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH8_CTRL_TRIG_RING_SEL() volatile
    {
        CH8_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH8_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH8_CTRL_TRIG_RING_SEL() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH8_CTRL_TRIG_RING_SEL() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH8_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH8_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH8_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH8_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH8_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH8_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH8_CTRL_TRIG = curr;
    }

    /**
     * Get CH8_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH8_CTRL_TRIG_TREQ_SEL get_CH8_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH8_CTRL_TRIG_TREQ_SEL((CH8_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH8_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH8_CTRL_TRIG_TREQ_SEL(
        DMA_CH8_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH8_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH8_CTRL_TRIG = curr;
    }

    /**
     * Get CH8_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH8_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH8_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH8_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH8_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH8_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH8_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH8_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH8_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH8_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH8_CTRL_TRIG_BSWAP() volatile
    {
        return CH8_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH8_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH8_CTRL_TRIG_BSWAP() volatile
    {
        CH8_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH8_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH8_CTRL_TRIG_BSWAP() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH8_CTRL_TRIG_BSWAP() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH8_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH8_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH8_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH8_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH8_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH8_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH8_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH8_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH8_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH8_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH8_CTRL_TRIG_BUSY() volatile
    {
        return CH8_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH8_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH8_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH8_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH8_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH8_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH8_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH8_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH8_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH8_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH8_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH8_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH8_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH8_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH8_CTRL_TRIG_READ_ERROR() volatile
    {
        CH8_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH8_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH8_CTRL_TRIG_READ_ERROR() volatile
    {
        CH8_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH8_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH8_CTRL_TRIG_READ_ERROR() volatile
    {
        CH8_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH8_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH8_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH8_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH8_CTRL_TRIG's bit fields.
     */
    inline void get_CH8_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH8_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH8_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH8_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH8_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH8_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH8_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH8_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH8_CTRL_TRIG's bit fields.
     */
    inline void set_CH8_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH8_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH8_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH8_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH8_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH8_CTRL_TRIG = curr;
    }

    /**
     * Get CH9_CTRL_TRIG's EN bit.
     */
    inline bool get_CH9_CTRL_TRIG_EN() volatile
    {
        return CH9_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH9_CTRL_TRIG's EN bit.
     */
    inline void set_CH9_CTRL_TRIG_EN() volatile
    {
        CH9_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH9_CTRL_TRIG's EN bit.
     */
    inline void clear_CH9_CTRL_TRIG_EN() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH9_CTRL_TRIG_EN() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH9_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH9_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH9_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH9_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH9_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH9_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH9_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH9_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH9_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH9_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH9_CTRL_TRIG_DATA_SIZE get_CH9_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH9_CTRL_TRIG_DATA_SIZE((CH9_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH9_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH9_CTRL_TRIG_DATA_SIZE(
        DMA_CH9_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH9_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH9_CTRL_TRIG = curr;
    }

    /**
     * Get CH9_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH9_CTRL_TRIG_INCR_READ() volatile
    {
        return CH9_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH9_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH9_CTRL_TRIG_INCR_READ() volatile
    {
        CH9_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH9_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH9_CTRL_TRIG_INCR_READ() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH9_CTRL_TRIG_INCR_READ() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH9_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH9_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH9_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH9_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH9_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH9_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH9_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH9_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH9_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH9_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH9_CTRL_TRIG_RING_SIZE get_CH9_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH9_CTRL_TRIG_RING_SIZE((CH9_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH9_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH9_CTRL_TRIG_RING_SIZE(
        DMA_CH9_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH9_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH9_CTRL_TRIG = curr;
    }

    /**
     * Get CH9_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH9_CTRL_TRIG_RING_SEL() volatile
    {
        return CH9_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH9_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH9_CTRL_TRIG_RING_SEL() volatile
    {
        CH9_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH9_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH9_CTRL_TRIG_RING_SEL() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH9_CTRL_TRIG_RING_SEL() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH9_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH9_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH9_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH9_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH9_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH9_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH9_CTRL_TRIG = curr;
    }

    /**
     * Get CH9_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH9_CTRL_TRIG_TREQ_SEL get_CH9_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH9_CTRL_TRIG_TREQ_SEL((CH9_CTRL_TRIG >> 15u) & 0b111111u);
    }

    /**
     * Set CH9_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH9_CTRL_TRIG_TREQ_SEL(
        DMA_CH9_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH9_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH9_CTRL_TRIG = curr;
    }

    /**
     * Get CH9_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH9_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH9_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH9_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH9_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH9_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH9_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH9_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH9_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH9_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH9_CTRL_TRIG_BSWAP() volatile
    {
        return CH9_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH9_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH9_CTRL_TRIG_BSWAP() volatile
    {
        CH9_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH9_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH9_CTRL_TRIG_BSWAP() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH9_CTRL_TRIG_BSWAP() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH9_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH9_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH9_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH9_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH9_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH9_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH9_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH9_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH9_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH9_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH9_CTRL_TRIG_BUSY() volatile
    {
        return CH9_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH9_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH9_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH9_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH9_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH9_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH9_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH9_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH9_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH9_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH9_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH9_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH9_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH9_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH9_CTRL_TRIG_READ_ERROR() volatile
    {
        CH9_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH9_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH9_CTRL_TRIG_READ_ERROR() volatile
    {
        CH9_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH9_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH9_CTRL_TRIG_READ_ERROR() volatile
    {
        CH9_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH9_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH9_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH9_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH9_CTRL_TRIG's bit fields.
     */
    inline void get_CH9_CTRL_TRIG(bool &EN, bool &HIGH_PRIORITY,
                                  DMA_CH9_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
                                  bool &INCR_READ, bool &INCR_WRITE,
                                  DMA_CH9_CTRL_TRIG_RING_SIZE &RING_SIZE,
                                  bool &RING_SEL, uint8_t &CHAIN_TO,
                                  DMA_CH9_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
                                  bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN,
                                  bool &BUSY, bool &WRITE_ERROR,
                                  bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH9_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH9_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH9_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH9_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH9_CTRL_TRIG's bit fields.
     */
    inline void set_CH9_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                  DMA_CH9_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                  bool INCR_READ, bool INCR_WRITE,
                                  DMA_CH9_CTRL_TRIG_RING_SIZE RING_SIZE,
                                  bool RING_SEL, uint8_t CHAIN_TO,
                                  DMA_CH9_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                  bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                  bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH9_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH9_CTRL_TRIG = curr;
    }

    /**
     * Get CH10_CTRL_TRIG's EN bit.
     */
    inline bool get_CH10_CTRL_TRIG_EN() volatile
    {
        return CH10_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH10_CTRL_TRIG's EN bit.
     */
    inline void set_CH10_CTRL_TRIG_EN() volatile
    {
        CH10_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH10_CTRL_TRIG's EN bit.
     */
    inline void clear_CH10_CTRL_TRIG_EN() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH10_CTRL_TRIG_EN() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH10_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH10_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH10_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH10_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH10_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH10_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH10_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH10_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH10_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH10_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH10_CTRL_TRIG_DATA_SIZE get_CH10_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH10_CTRL_TRIG_DATA_SIZE((CH10_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH10_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH10_CTRL_TRIG_DATA_SIZE(
        DMA_CH10_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH10_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH10_CTRL_TRIG = curr;
    }

    /**
     * Get CH10_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH10_CTRL_TRIG_INCR_READ() volatile
    {
        return CH10_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH10_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH10_CTRL_TRIG_INCR_READ() volatile
    {
        CH10_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH10_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH10_CTRL_TRIG_INCR_READ() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH10_CTRL_TRIG_INCR_READ() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH10_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH10_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH10_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH10_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH10_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH10_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH10_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH10_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH10_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH10_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH10_CTRL_TRIG_RING_SIZE get_CH10_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH10_CTRL_TRIG_RING_SIZE((CH10_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH10_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH10_CTRL_TRIG_RING_SIZE(
        DMA_CH10_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH10_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH10_CTRL_TRIG = curr;
    }

    /**
     * Get CH10_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH10_CTRL_TRIG_RING_SEL() volatile
    {
        return CH10_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH10_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH10_CTRL_TRIG_RING_SEL() volatile
    {
        CH10_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH10_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH10_CTRL_TRIG_RING_SEL() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH10_CTRL_TRIG_RING_SEL() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH10_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH10_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH10_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH10_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH10_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH10_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH10_CTRL_TRIG = curr;
    }

    /**
     * Get CH10_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH10_CTRL_TRIG_TREQ_SEL get_CH10_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH10_CTRL_TRIG_TREQ_SEL((CH10_CTRL_TRIG >> 15u) &
                                           0b111111u);
    }

    /**
     * Set CH10_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH10_CTRL_TRIG_TREQ_SEL(
        DMA_CH10_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH10_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH10_CTRL_TRIG = curr;
    }

    /**
     * Get CH10_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH10_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH10_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH10_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH10_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH10_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH10_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH10_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH10_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH10_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH10_CTRL_TRIG_BSWAP() volatile
    {
        return CH10_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH10_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH10_CTRL_TRIG_BSWAP() volatile
    {
        CH10_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH10_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH10_CTRL_TRIG_BSWAP() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH10_CTRL_TRIG_BSWAP() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH10_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH10_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH10_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH10_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH10_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH10_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH10_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH10_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH10_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH10_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH10_CTRL_TRIG_BUSY() volatile
    {
        return CH10_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH10_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH10_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH10_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH10_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH10_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH10_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH10_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH10_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH10_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH10_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH10_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH10_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH10_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH10_CTRL_TRIG_READ_ERROR() volatile
    {
        CH10_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH10_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH10_CTRL_TRIG_READ_ERROR() volatile
    {
        CH10_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH10_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH10_CTRL_TRIG_READ_ERROR() volatile
    {
        CH10_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH10_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH10_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH10_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH10_CTRL_TRIG's bit fields.
     */
    inline void get_CH10_CTRL_TRIG(
        bool &EN, bool &HIGH_PRIORITY, DMA_CH10_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
        bool &INCR_READ, bool &INCR_WRITE,
        DMA_CH10_CTRL_TRIG_RING_SIZE &RING_SIZE, bool &RING_SEL,
        uint8_t &CHAIN_TO, DMA_CH10_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
        bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN, bool &BUSY,
        bool &WRITE_ERROR, bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH10_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH10_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH10_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH10_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH10_CTRL_TRIG's bit fields.
     */
    inline void set_CH10_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                   DMA_CH10_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                   bool INCR_READ, bool INCR_WRITE,
                                   DMA_CH10_CTRL_TRIG_RING_SIZE RING_SIZE,
                                   bool RING_SEL, uint8_t CHAIN_TO,
                                   DMA_CH10_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                   bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                   bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH10_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH10_CTRL_TRIG = curr;
    }

    /**
     * Get CH11_CTRL_TRIG's EN bit.
     */
    inline bool get_CH11_CTRL_TRIG_EN() volatile
    {
        return CH11_CTRL_TRIG & (1u << 0u);
    }

    /**
     * Set CH11_CTRL_TRIG's EN bit.
     */
    inline void set_CH11_CTRL_TRIG_EN() volatile
    {
        CH11_CTRL_TRIG |= 1u << 0u;
    }

    /**
     * Clear CH11_CTRL_TRIG's EN bit.
     */
    inline void clear_CH11_CTRL_TRIG_EN() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 0u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's EN bit.
     */
    inline void toggle_CH11_CTRL_TRIG_EN() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 0u;
    }

    /**
     * Get CH11_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline bool get_CH11_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        return CH11_CTRL_TRIG & (1u << 1u);
    }

    /**
     * Set CH11_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void set_CH11_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH11_CTRL_TRIG |= 1u << 1u;
    }

    /**
     * Clear CH11_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void clear_CH11_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 1u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's HIGH_PRIORITY bit.
     */
    inline void toggle_CH11_CTRL_TRIG_HIGH_PRIORITY() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 1u;
    }

    /**
     * Get CH11_CTRL_TRIG's DATA_SIZE field.
     */
    inline DMA_CH11_CTRL_TRIG_DATA_SIZE get_CH11_CTRL_TRIG_DATA_SIZE() volatile
    {
        return DMA_CH11_CTRL_TRIG_DATA_SIZE((CH11_CTRL_TRIG >> 2u) & 0b11u);
    }

    /**
     * Set CH11_CTRL_TRIG's DATA_SIZE field.
     */
    inline void set_CH11_CTRL_TRIG_DATA_SIZE(
        DMA_CH11_CTRL_TRIG_DATA_SIZE value) volatile
    {
        uint32_t curr = CH11_CTRL_TRIG;

        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(value) & 0b11u) << 2u;

        CH11_CTRL_TRIG = curr;
    }

    /**
     * Get CH11_CTRL_TRIG's INCR_READ bit.
     */
    inline bool get_CH11_CTRL_TRIG_INCR_READ() volatile
    {
        return CH11_CTRL_TRIG & (1u << 4u);
    }

    /**
     * Set CH11_CTRL_TRIG's INCR_READ bit.
     */
    inline void set_CH11_CTRL_TRIG_INCR_READ() volatile
    {
        CH11_CTRL_TRIG |= 1u << 4u;
    }

    /**
     * Clear CH11_CTRL_TRIG's INCR_READ bit.
     */
    inline void clear_CH11_CTRL_TRIG_INCR_READ() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 4u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's INCR_READ bit.
     */
    inline void toggle_CH11_CTRL_TRIG_INCR_READ() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 4u;
    }

    /**
     * Get CH11_CTRL_TRIG's INCR_WRITE bit.
     */
    inline bool get_CH11_CTRL_TRIG_INCR_WRITE() volatile
    {
        return CH11_CTRL_TRIG & (1u << 5u);
    }

    /**
     * Set CH11_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void set_CH11_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH11_CTRL_TRIG |= 1u << 5u;
    }

    /**
     * Clear CH11_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void clear_CH11_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 5u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's INCR_WRITE bit.
     */
    inline void toggle_CH11_CTRL_TRIG_INCR_WRITE() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 5u;
    }

    /**
     * Get CH11_CTRL_TRIG's RING_SIZE field.
     */
    inline DMA_CH11_CTRL_TRIG_RING_SIZE get_CH11_CTRL_TRIG_RING_SIZE() volatile
    {
        return DMA_CH11_CTRL_TRIG_RING_SIZE((CH11_CTRL_TRIG >> 6u) & 0b1111u);
    }

    /**
     * Set CH11_CTRL_TRIG's RING_SIZE field.
     */
    inline void set_CH11_CTRL_TRIG_RING_SIZE(
        DMA_CH11_CTRL_TRIG_RING_SIZE value) volatile
    {
        uint32_t curr = CH11_CTRL_TRIG;

        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(value) & 0b1111u) << 6u;

        CH11_CTRL_TRIG = curr;
    }

    /**
     * Get CH11_CTRL_TRIG's RING_SEL bit.
     */
    inline bool get_CH11_CTRL_TRIG_RING_SEL() volatile
    {
        return CH11_CTRL_TRIG & (1u << 10u);
    }

    /**
     * Set CH11_CTRL_TRIG's RING_SEL bit.
     */
    inline void set_CH11_CTRL_TRIG_RING_SEL() volatile
    {
        CH11_CTRL_TRIG |= 1u << 10u;
    }

    /**
     * Clear CH11_CTRL_TRIG's RING_SEL bit.
     */
    inline void clear_CH11_CTRL_TRIG_RING_SEL() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 10u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's RING_SEL bit.
     */
    inline void toggle_CH11_CTRL_TRIG_RING_SEL() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 10u;
    }

    /**
     * Get CH11_CTRL_TRIG's CHAIN_TO field.
     */
    inline uint8_t get_CH11_CTRL_TRIG_CHAIN_TO() volatile
    {
        return (CH11_CTRL_TRIG >> 11u) & 0b1111u;
    }

    /**
     * Set CH11_CTRL_TRIG's CHAIN_TO field.
     */
    inline void set_CH11_CTRL_TRIG_CHAIN_TO(uint8_t value) volatile
    {
        uint32_t curr = CH11_CTRL_TRIG;

        curr &= ~(0b1111u << 11u);
        curr |= (value & 0b1111u) << 11u;

        CH11_CTRL_TRIG = curr;
    }

    /**
     * Get CH11_CTRL_TRIG's TREQ_SEL field.
     */
    inline DMA_CH11_CTRL_TRIG_TREQ_SEL get_CH11_CTRL_TRIG_TREQ_SEL() volatile
    {
        return DMA_CH11_CTRL_TRIG_TREQ_SEL((CH11_CTRL_TRIG >> 15u) &
                                           0b111111u);
    }

    /**
     * Set CH11_CTRL_TRIG's TREQ_SEL field.
     */
    inline void set_CH11_CTRL_TRIG_TREQ_SEL(
        DMA_CH11_CTRL_TRIG_TREQ_SEL value) volatile
    {
        uint32_t curr = CH11_CTRL_TRIG;

        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(value) & 0b111111u) << 15u;

        CH11_CTRL_TRIG = curr;
    }

    /**
     * Get CH11_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline bool get_CH11_CTRL_TRIG_IRQ_QUIET() volatile
    {
        return CH11_CTRL_TRIG & (1u << 21u);
    }

    /**
     * Set CH11_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void set_CH11_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH11_CTRL_TRIG |= 1u << 21u;
    }

    /**
     * Clear CH11_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void clear_CH11_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 21u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's IRQ_QUIET bit.
     */
    inline void toggle_CH11_CTRL_TRIG_IRQ_QUIET() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 21u;
    }

    /**
     * Get CH11_CTRL_TRIG's BSWAP bit.
     */
    inline bool get_CH11_CTRL_TRIG_BSWAP() volatile
    {
        return CH11_CTRL_TRIG & (1u << 22u);
    }

    /**
     * Set CH11_CTRL_TRIG's BSWAP bit.
     */
    inline void set_CH11_CTRL_TRIG_BSWAP() volatile
    {
        CH11_CTRL_TRIG |= 1u << 22u;
    }

    /**
     * Clear CH11_CTRL_TRIG's BSWAP bit.
     */
    inline void clear_CH11_CTRL_TRIG_BSWAP() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 22u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's BSWAP bit.
     */
    inline void toggle_CH11_CTRL_TRIG_BSWAP() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 22u;
    }

    /**
     * Get CH11_CTRL_TRIG's SNIFF_EN bit.
     */
    inline bool get_CH11_CTRL_TRIG_SNIFF_EN() volatile
    {
        return CH11_CTRL_TRIG & (1u << 23u);
    }

    /**
     * Set CH11_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void set_CH11_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH11_CTRL_TRIG |= 1u << 23u;
    }

    /**
     * Clear CH11_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void clear_CH11_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 23u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's SNIFF_EN bit.
     */
    inline void toggle_CH11_CTRL_TRIG_SNIFF_EN() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 23u;
    }

    /**
     * Get CH11_CTRL_TRIG's BUSY bit.
     */
    inline bool get_CH11_CTRL_TRIG_BUSY() volatile
    {
        return CH11_CTRL_TRIG & (1u << 24u);
    }

    /**
     * Get CH11_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline bool get_CH11_CTRL_TRIG_WRITE_ERROR() volatile
    {
        return CH11_CTRL_TRIG & (1u << 29u);
    }

    /**
     * Set CH11_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void set_CH11_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH11_CTRL_TRIG |= 1u << 29u;
    }

    /**
     * Clear CH11_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void clear_CH11_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 29u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's WRITE_ERROR bit.
     */
    inline void toggle_CH11_CTRL_TRIG_WRITE_ERROR() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 29u;
    }

    /**
     * Get CH11_CTRL_TRIG's READ_ERROR bit.
     */
    inline bool get_CH11_CTRL_TRIG_READ_ERROR() volatile
    {
        return CH11_CTRL_TRIG & (1u << 30u);
    }

    /**
     * Set CH11_CTRL_TRIG's READ_ERROR bit.
     */
    inline void set_CH11_CTRL_TRIG_READ_ERROR() volatile
    {
        CH11_CTRL_TRIG |= 1u << 30u;
    }

    /**
     * Clear CH11_CTRL_TRIG's READ_ERROR bit.
     */
    inline void clear_CH11_CTRL_TRIG_READ_ERROR() volatile
    {
        CH11_CTRL_TRIG &= ~(1u << 30u);
    }

    /**
     * Toggle CH11_CTRL_TRIG's READ_ERROR bit.
     */
    inline void toggle_CH11_CTRL_TRIG_READ_ERROR() volatile
    {
        CH11_CTRL_TRIG ^= 1u << 30u;
    }

    /**
     * Get CH11_CTRL_TRIG's AHB_ERROR bit.
     */
    inline bool get_CH11_CTRL_TRIG_AHB_ERROR() volatile
    {
        return CH11_CTRL_TRIG & (1u << 31u);
    }

    /**
     * Get all of CH11_CTRL_TRIG's bit fields.
     */
    inline void get_CH11_CTRL_TRIG(
        bool &EN, bool &HIGH_PRIORITY, DMA_CH11_CTRL_TRIG_DATA_SIZE &DATA_SIZE,
        bool &INCR_READ, bool &INCR_WRITE,
        DMA_CH11_CTRL_TRIG_RING_SIZE &RING_SIZE, bool &RING_SEL,
        uint8_t &CHAIN_TO, DMA_CH11_CTRL_TRIG_TREQ_SEL &TREQ_SEL,
        bool &IRQ_QUIET, bool &BSWAP, bool &SNIFF_EN, bool &BUSY,
        bool &WRITE_ERROR, bool &READ_ERROR, bool &AHB_ERROR) volatile
    {
        uint32_t curr = CH11_CTRL_TRIG;

        EN = curr & (1u << 0u);
        HIGH_PRIORITY = curr & (1u << 1u);
        DATA_SIZE = DMA_CH11_CTRL_TRIG_DATA_SIZE((curr >> 2u) & 0b11u);
        INCR_READ = curr & (1u << 4u);
        INCR_WRITE = curr & (1u << 5u);
        RING_SIZE = DMA_CH11_CTRL_TRIG_RING_SIZE((curr >> 6u) & 0b1111u);
        RING_SEL = curr & (1u << 10u);
        CHAIN_TO = (curr >> 11u) & 0b1111u;
        TREQ_SEL = DMA_CH11_CTRL_TRIG_TREQ_SEL((curr >> 15u) & 0b111111u);
        IRQ_QUIET = curr & (1u << 21u);
        BSWAP = curr & (1u << 22u);
        SNIFF_EN = curr & (1u << 23u);
        BUSY = curr & (1u << 24u);
        WRITE_ERROR = curr & (1u << 29u);
        READ_ERROR = curr & (1u << 30u);
        AHB_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of CH11_CTRL_TRIG's bit fields.
     */
    inline void set_CH11_CTRL_TRIG(bool EN, bool HIGH_PRIORITY,
                                   DMA_CH11_CTRL_TRIG_DATA_SIZE DATA_SIZE,
                                   bool INCR_READ, bool INCR_WRITE,
                                   DMA_CH11_CTRL_TRIG_RING_SIZE RING_SIZE,
                                   bool RING_SEL, uint8_t CHAIN_TO,
                                   DMA_CH11_CTRL_TRIG_TREQ_SEL TREQ_SEL,
                                   bool IRQ_QUIET, bool BSWAP, bool SNIFF_EN,
                                   bool WRITE_ERROR, bool READ_ERROR) volatile
    {
        uint32_t curr = CH11_CTRL_TRIG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIGH_PRIORITY & 0b1u) << 1u;
        curr &= ~(0b11u << 2u);
        curr |= (std::to_underlying(DATA_SIZE) & 0b11u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (INCR_READ & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (INCR_WRITE & 0b1u) << 5u;
        curr &= ~(0b1111u << 6u);
        curr |= (std::to_underlying(RING_SIZE) & 0b1111u) << 6u;
        curr &= ~(0b1u << 10u);
        curr |= (RING_SEL & 0b1u) << 10u;
        curr &= ~(0b1111u << 11u);
        curr |= (CHAIN_TO & 0b1111u) << 11u;
        curr &= ~(0b111111u << 15u);
        curr |= (std::to_underlying(TREQ_SEL) & 0b111111u) << 15u;
        curr &= ~(0b1u << 21u);
        curr |= (IRQ_QUIET & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (BSWAP & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (SNIFF_EN & 0b1u) << 23u;
        curr &= ~(0b1u << 29u);
        curr |= (WRITE_ERROR & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (READ_ERROR & 0b1u) << 30u;

        CH11_CTRL_TRIG = curr;
    }

    /**
     * Get INTR's INTR field.
     */
    inline uint16_t get_INTR_INTR() volatile
    {
        return (INTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTR's INTR field.
     */
    inline void set_INTR_INTR(uint16_t value) volatile
    {
        uint32_t curr = INTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTR = curr;
    }

    /**
     * Get INTE0's INTE0 field.
     */
    inline uint16_t get_INTE0_INTE0() volatile
    {
        return (INTE0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTE0's INTE0 field.
     */
    inline void set_INTE0_INTE0(uint16_t value) volatile
    {
        uint32_t curr = INTE0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTE0 = curr;
    }

    /**
     * Get INTF0's INTF0 field.
     */
    inline uint16_t get_INTF0_INTF0() volatile
    {
        return (INTF0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTF0's INTF0 field.
     */
    inline void set_INTF0_INTF0(uint16_t value) volatile
    {
        uint32_t curr = INTF0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTF0 = curr;
    }

    /**
     * Get INTS0's INTS0 field.
     */
    inline uint16_t get_INTS0_INTS0() volatile
    {
        return (INTS0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTS0's INTS0 field.
     */
    inline void set_INTS0_INTS0(uint16_t value) volatile
    {
        uint32_t curr = INTS0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTS0 = curr;
    }

    /**
     * Get INTE1's INTE1 field.
     */
    inline uint16_t get_INTE1_INTE1() volatile
    {
        return (INTE1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTE1's INTE1 field.
     */
    inline void set_INTE1_INTE1(uint16_t value) volatile
    {
        uint32_t curr = INTE1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTE1 = curr;
    }

    /**
     * Get INTF1's INTF1 field.
     */
    inline uint16_t get_INTF1_INTF1() volatile
    {
        return (INTF1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTF1's INTF1 field.
     */
    inline void set_INTF1_INTF1(uint16_t value) volatile
    {
        uint32_t curr = INTF1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTF1 = curr;
    }

    /**
     * Get INTS1's INTS1 field.
     */
    inline uint16_t get_INTS1_INTS1() volatile
    {
        return (INTS1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set INTS1's INTS1 field.
     */
    inline void set_INTS1_INTS1(uint16_t value) volatile
    {
        uint32_t curr = INTS1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        INTS1 = curr;
    }

    /**
     * Get TIMER0's Y field.
     */
    inline uint16_t get_TIMER0_Y() volatile
    {
        return (TIMER0 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER0's Y field.
     */
    inline void set_TIMER0_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER0 = curr;
    }

    /**
     * Get TIMER0's X field.
     */
    inline uint16_t get_TIMER0_X() volatile
    {
        return (TIMER0 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER0's X field.
     */
    inline void set_TIMER0_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TIMER0 = curr;
    }

    /**
     * Get all of TIMER0's bit fields.
     */
    inline void get_TIMER0(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER0;

        Y = (curr >> 0u) & 0b1111111111111111u;
        X = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of TIMER0's bit fields.
     */
    inline void set_TIMER0(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER0;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Y & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (X & 0b1111111111111111u) << 16u;

        TIMER0 = curr;
    }

    /**
     * Get TIMER1's Y field.
     */
    inline uint16_t get_TIMER1_Y() volatile
    {
        return (TIMER1 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER1's Y field.
     */
    inline void set_TIMER1_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER1 = curr;
    }

    /**
     * Get TIMER1's X field.
     */
    inline uint16_t get_TIMER1_X() volatile
    {
        return (TIMER1 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER1's X field.
     */
    inline void set_TIMER1_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TIMER1 = curr;
    }

    /**
     * Get all of TIMER1's bit fields.
     */
    inline void get_TIMER1(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER1;

        Y = (curr >> 0u) & 0b1111111111111111u;
        X = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of TIMER1's bit fields.
     */
    inline void set_TIMER1(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER1;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Y & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (X & 0b1111111111111111u) << 16u;

        TIMER1 = curr;
    }

    /**
     * Get TIMER2's Y field.
     */
    inline uint16_t get_TIMER2_Y() volatile
    {
        return (TIMER2 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER2's Y field.
     */
    inline void set_TIMER2_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER2 = curr;
    }

    /**
     * Get TIMER2's X field.
     */
    inline uint16_t get_TIMER2_X() volatile
    {
        return (TIMER2 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER2's X field.
     */
    inline void set_TIMER2_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER2;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TIMER2 = curr;
    }

    /**
     * Get all of TIMER2's bit fields.
     */
    inline void get_TIMER2(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER2;

        Y = (curr >> 0u) & 0b1111111111111111u;
        X = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of TIMER2's bit fields.
     */
    inline void set_TIMER2(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER2;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Y & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (X & 0b1111111111111111u) << 16u;

        TIMER2 = curr;
    }

    /**
     * Get TIMER3's Y field.
     */
    inline uint16_t get_TIMER3_Y() volatile
    {
        return (TIMER3 >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER3's Y field.
     */
    inline void set_TIMER3_Y(uint16_t value) volatile
    {
        uint32_t curr = TIMER3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        TIMER3 = curr;
    }

    /**
     * Get TIMER3's X field.
     */
    inline uint16_t get_TIMER3_X() volatile
    {
        return (TIMER3 >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set TIMER3's X field.
     */
    inline void set_TIMER3_X(uint16_t value) volatile
    {
        uint32_t curr = TIMER3;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        TIMER3 = curr;
    }

    /**
     * Get all of TIMER3's bit fields.
     */
    inline void get_TIMER3(uint16_t &Y, uint16_t &X) volatile
    {
        uint32_t curr = TIMER3;

        Y = (curr >> 0u) & 0b1111111111111111u;
        X = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of TIMER3's bit fields.
     */
    inline void set_TIMER3(uint16_t Y, uint16_t X) volatile
    {
        uint32_t curr = TIMER3;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (Y & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (X & 0b1111111111111111u) << 16u;

        TIMER3 = curr;
    }

    /**
     * Get MULTI_CHAN_TRIGGER's MULTI_CHAN_TRIGGER field.
     */
    inline uint16_t get_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER() volatile
    {
        return (MULTI_CHAN_TRIGGER >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set MULTI_CHAN_TRIGGER's MULTI_CHAN_TRIGGER field.
     */
    inline void set_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER(
        uint16_t value) volatile
    {
        uint32_t curr = MULTI_CHAN_TRIGGER;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        MULTI_CHAN_TRIGGER = curr;
    }

    /**
     * Get SNIFF_CTRL's EN bit.
     */
    inline bool get_SNIFF_CTRL_EN() volatile
    {
        return SNIFF_CTRL & (1u << 0u);
    }

    /**
     * Set SNIFF_CTRL's EN bit.
     */
    inline void set_SNIFF_CTRL_EN() volatile
    {
        SNIFF_CTRL |= 1u << 0u;
    }

    /**
     * Clear SNIFF_CTRL's EN bit.
     */
    inline void clear_SNIFF_CTRL_EN() volatile
    {
        SNIFF_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle SNIFF_CTRL's EN bit.
     */
    inline void toggle_SNIFF_CTRL_EN() volatile
    {
        SNIFF_CTRL ^= 1u << 0u;
    }

    /**
     * Get SNIFF_CTRL's DMACH field.
     */
    inline uint8_t get_SNIFF_CTRL_DMACH() volatile
    {
        return (SNIFF_CTRL >> 1u) & 0b1111u;
    }

    /**
     * Set SNIFF_CTRL's DMACH field.
     */
    inline void set_SNIFF_CTRL_DMACH(uint8_t value) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        curr &= ~(0b1111u << 1u);
        curr |= (value & 0b1111u) << 1u;

        SNIFF_CTRL = curr;
    }

    /**
     * Get SNIFF_CTRL's CALC field.
     */
    inline DMA_SNIFF_CTRL_CALC get_SNIFF_CTRL_CALC() volatile
    {
        return DMA_SNIFF_CTRL_CALC((SNIFF_CTRL >> 5u) & 0b1111u);
    }

    /**
     * Set SNIFF_CTRL's CALC field.
     */
    inline void set_SNIFF_CTRL_CALC(DMA_SNIFF_CTRL_CALC value) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        SNIFF_CTRL = curr;
    }

    /**
     * Get SNIFF_CTRL's BSWAP bit.
     */
    inline bool get_SNIFF_CTRL_BSWAP() volatile
    {
        return SNIFF_CTRL & (1u << 9u);
    }

    /**
     * Set SNIFF_CTRL's BSWAP bit.
     */
    inline void set_SNIFF_CTRL_BSWAP() volatile
    {
        SNIFF_CTRL |= 1u << 9u;
    }

    /**
     * Clear SNIFF_CTRL's BSWAP bit.
     */
    inline void clear_SNIFF_CTRL_BSWAP() volatile
    {
        SNIFF_CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle SNIFF_CTRL's BSWAP bit.
     */
    inline void toggle_SNIFF_CTRL_BSWAP() volatile
    {
        SNIFF_CTRL ^= 1u << 9u;
    }

    /**
     * Get SNIFF_CTRL's OUT_REV bit.
     */
    inline bool get_SNIFF_CTRL_OUT_REV() volatile
    {
        return SNIFF_CTRL & (1u << 10u);
    }

    /**
     * Set SNIFF_CTRL's OUT_REV bit.
     */
    inline void set_SNIFF_CTRL_OUT_REV() volatile
    {
        SNIFF_CTRL |= 1u << 10u;
    }

    /**
     * Clear SNIFF_CTRL's OUT_REV bit.
     */
    inline void clear_SNIFF_CTRL_OUT_REV() volatile
    {
        SNIFF_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle SNIFF_CTRL's OUT_REV bit.
     */
    inline void toggle_SNIFF_CTRL_OUT_REV() volatile
    {
        SNIFF_CTRL ^= 1u << 10u;
    }

    /**
     * Get SNIFF_CTRL's OUT_INV bit.
     */
    inline bool get_SNIFF_CTRL_OUT_INV() volatile
    {
        return SNIFF_CTRL & (1u << 11u);
    }

    /**
     * Set SNIFF_CTRL's OUT_INV bit.
     */
    inline void set_SNIFF_CTRL_OUT_INV() volatile
    {
        SNIFF_CTRL |= 1u << 11u;
    }

    /**
     * Clear SNIFF_CTRL's OUT_INV bit.
     */
    inline void clear_SNIFF_CTRL_OUT_INV() volatile
    {
        SNIFF_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle SNIFF_CTRL's OUT_INV bit.
     */
    inline void toggle_SNIFF_CTRL_OUT_INV() volatile
    {
        SNIFF_CTRL ^= 1u << 11u;
    }

    /**
     * Get all of SNIFF_CTRL's bit fields.
     */
    inline void get_SNIFF_CTRL(bool &EN, uint8_t &DMACH,
                               DMA_SNIFF_CTRL_CALC &CALC, bool &BSWAP,
                               bool &OUT_REV, bool &OUT_INV) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        EN = curr & (1u << 0u);
        DMACH = (curr >> 1u) & 0b1111u;
        CALC = DMA_SNIFF_CTRL_CALC((curr >> 5u) & 0b1111u);
        BSWAP = curr & (1u << 9u);
        OUT_REV = curr & (1u << 10u);
        OUT_INV = curr & (1u << 11u);
    }

    /**
     * Set all of SNIFF_CTRL's bit fields.
     */
    inline void set_SNIFF_CTRL(bool EN, uint8_t DMACH,
                               DMA_SNIFF_CTRL_CALC CALC, bool BSWAP,
                               bool OUT_REV, bool OUT_INV) volatile
    {
        uint32_t curr = SNIFF_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1111u << 1u);
        curr |= (DMACH & 0b1111u) << 1u;
        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(CALC) & 0b1111u) << 5u;
        curr &= ~(0b1u << 9u);
        curr |= (BSWAP & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (OUT_REV & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (OUT_INV & 0b1u) << 11u;

        SNIFF_CTRL = curr;
    }

    /**
     * Get FIFO_LEVELS's TDF_LVL field.
     */
    inline uint8_t get_FIFO_LEVELS_TDF_LVL() volatile
    {
        return (FIFO_LEVELS >> 0u) & 0b11111111u;
    }

    /**
     * Get FIFO_LEVELS's WAF_LVL field.
     */
    inline uint8_t get_FIFO_LEVELS_WAF_LVL() volatile
    {
        return (FIFO_LEVELS >> 8u) & 0b11111111u;
    }

    /**
     * Get FIFO_LEVELS's RAF_LVL field.
     */
    inline uint8_t get_FIFO_LEVELS_RAF_LVL() volatile
    {
        return (FIFO_LEVELS >> 16u) & 0b11111111u;
    }

    /**
     * Get all of FIFO_LEVELS's bit fields.
     */
    inline void get_FIFO_LEVELS(uint8_t &TDF_LVL, uint8_t &WAF_LVL,
                                uint8_t &RAF_LVL) volatile
    {
        uint32_t curr = FIFO_LEVELS;

        TDF_LVL = (curr >> 0u) & 0b11111111u;
        WAF_LVL = (curr >> 8u) & 0b11111111u;
        RAF_LVL = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Get CHAN_ABORT's CHAN_ABORT field.
     */
    inline uint16_t get_CHAN_ABORT_CHAN_ABORT() volatile
    {
        return (CHAN_ABORT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CHAN_ABORT's CHAN_ABORT field.
     */
    inline void set_CHAN_ABORT_CHAN_ABORT(uint16_t value) volatile
    {
        uint32_t curr = CHAN_ABORT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CHAN_ABORT = curr;
    }

    /**
     * Get N_CHANNELS's N_CHANNELS field.
     */
    inline uint8_t get_N_CHANNELS_N_CHANNELS() volatile
    {
        return (N_CHANNELS >> 0u) & 0b11111u;
    }

    /**
     * Get CH0_DBG_CTDREQ's CH0_DBG_CTDREQ field.
     */
    inline uint8_t get_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ() volatile
    {
        return (CH0_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH0_DBG_CTDREQ's CH0_DBG_CTDREQ field.
     */
    inline void set_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH0_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH0_DBG_CTDREQ = curr;
    }

    /**
     * Get CH1_DBG_CTDREQ's CH1_DBG_CTDREQ field.
     */
    inline uint8_t get_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ() volatile
    {
        return (CH1_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH1_DBG_CTDREQ's CH1_DBG_CTDREQ field.
     */
    inline void set_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH1_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH1_DBG_CTDREQ = curr;
    }

    /**
     * Get CH2_DBG_CTDREQ's CH2_DBG_CTDREQ field.
     */
    inline uint8_t get_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ() volatile
    {
        return (CH2_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH2_DBG_CTDREQ's CH2_DBG_CTDREQ field.
     */
    inline void set_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH2_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH2_DBG_CTDREQ = curr;
    }

    /**
     * Get CH3_DBG_CTDREQ's CH3_DBG_CTDREQ field.
     */
    inline uint8_t get_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ() volatile
    {
        return (CH3_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH3_DBG_CTDREQ's CH3_DBG_CTDREQ field.
     */
    inline void set_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH3_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH3_DBG_CTDREQ = curr;
    }

    /**
     * Get CH4_DBG_CTDREQ's CH4_DBG_CTDREQ field.
     */
    inline uint8_t get_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ() volatile
    {
        return (CH4_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH4_DBG_CTDREQ's CH4_DBG_CTDREQ field.
     */
    inline void set_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH4_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH4_DBG_CTDREQ = curr;
    }

    /**
     * Get CH5_DBG_CTDREQ's CH5_DBG_CTDREQ field.
     */
    inline uint8_t get_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ() volatile
    {
        return (CH5_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH5_DBG_CTDREQ's CH5_DBG_CTDREQ field.
     */
    inline void set_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH5_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH5_DBG_CTDREQ = curr;
    }

    /**
     * Get CH6_DBG_CTDREQ's CH6_DBG_CTDREQ field.
     */
    inline uint8_t get_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ() volatile
    {
        return (CH6_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH6_DBG_CTDREQ's CH6_DBG_CTDREQ field.
     */
    inline void set_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH6_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH6_DBG_CTDREQ = curr;
    }

    /**
     * Get CH7_DBG_CTDREQ's CH7_DBG_CTDREQ field.
     */
    inline uint8_t get_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ() volatile
    {
        return (CH7_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH7_DBG_CTDREQ's CH7_DBG_CTDREQ field.
     */
    inline void set_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH7_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH7_DBG_CTDREQ = curr;
    }

    /**
     * Get CH8_DBG_CTDREQ's CH8_DBG_CTDREQ field.
     */
    inline uint8_t get_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ() volatile
    {
        return (CH8_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH8_DBG_CTDREQ's CH8_DBG_CTDREQ field.
     */
    inline void set_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH8_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH8_DBG_CTDREQ = curr;
    }

    /**
     * Get CH9_DBG_CTDREQ's CH9_DBG_CTDREQ field.
     */
    inline uint8_t get_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ() volatile
    {
        return (CH9_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH9_DBG_CTDREQ's CH9_DBG_CTDREQ field.
     */
    inline void set_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH9_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH9_DBG_CTDREQ = curr;
    }

    /**
     * Get CH10_DBG_CTDREQ's CH10_DBG_CTDREQ field.
     */
    inline uint8_t get_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ() volatile
    {
        return (CH10_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH10_DBG_CTDREQ's CH10_DBG_CTDREQ field.
     */
    inline void set_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH10_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH10_DBG_CTDREQ = curr;
    }

    /**
     * Get CH11_DBG_CTDREQ's CH11_DBG_CTDREQ field.
     */
    inline uint8_t get_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ() volatile
    {
        return (CH11_DBG_CTDREQ >> 0u) & 0b111111u;
    }

    /**
     * Set CH11_DBG_CTDREQ's CH11_DBG_CTDREQ field.
     */
    inline void set_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ(uint8_t value) volatile
    {
        uint32_t curr = CH11_DBG_CTDREQ;

        curr &= ~(0b111111u << 0u);
        curr |= (value & 0b111111u) << 0u;

        CH11_DBG_CTDREQ = curr;
    }
};

static_assert(sizeof(dma) == dma::size);

static volatile dma *const DMA = reinterpret_cast<dma *>(0x50000000);

}; // namespace RP2040
