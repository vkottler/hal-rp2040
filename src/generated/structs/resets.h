/**
 * \file
 * \brief Generated by ifgen (3.1.2).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] resets
{
    /* Constant attributes. */
    static constexpr std::size_t size = 12; /*!< resets's size in bytes. */

    /* Fields. */
    uint32_t RESET; /*!< (read-write) Reset control. If a bit is set it means
                       the peripheral is in reset. 0 means the peripheral's
                       reset is deasserted. */
    uint32_t WDSEL; /*!< (read-write) Watchdog select. If a bit is set then the
                       watchdog will reset this peripheral when the watchdog
                       fires. */
    const uint32_t RESET_DONE =
        {}; /*!< (read-only) Reset done. If a bit is set then a reset done
               signal has been returned by the peripheral. This indicates that
               the peripheral's registers are ready to be accessed. */

    /* Methods. */

    /**
     * Get RESET's adc bit.
     */
    inline bool get_RESET_adc() volatile
    {
        return RESET & (1u << 0u);
    }

    /**
     * Set RESET's adc bit.
     */
    inline void set_RESET_adc() volatile
    {
        RESET |= 1u << 0u;
    }

    /**
     * Clear RESET's adc bit.
     */
    inline void clear_RESET_adc() volatile
    {
        RESET &= ~(1u << 0u);
    }

    /**
     * Toggle RESET's adc bit.
     */
    inline void toggle_RESET_adc() volatile
    {
        RESET ^= 1u << 0u;
    }

    /**
     * Get RESET's busctrl bit.
     */
    inline bool get_RESET_busctrl() volatile
    {
        return RESET & (1u << 1u);
    }

    /**
     * Set RESET's busctrl bit.
     */
    inline void set_RESET_busctrl() volatile
    {
        RESET |= 1u << 1u;
    }

    /**
     * Clear RESET's busctrl bit.
     */
    inline void clear_RESET_busctrl() volatile
    {
        RESET &= ~(1u << 1u);
    }

    /**
     * Toggle RESET's busctrl bit.
     */
    inline void toggle_RESET_busctrl() volatile
    {
        RESET ^= 1u << 1u;
    }

    /**
     * Get RESET's dma bit.
     */
    inline bool get_RESET_dma() volatile
    {
        return RESET & (1u << 2u);
    }

    /**
     * Set RESET's dma bit.
     */
    inline void set_RESET_dma() volatile
    {
        RESET |= 1u << 2u;
    }

    /**
     * Clear RESET's dma bit.
     */
    inline void clear_RESET_dma() volatile
    {
        RESET &= ~(1u << 2u);
    }

    /**
     * Toggle RESET's dma bit.
     */
    inline void toggle_RESET_dma() volatile
    {
        RESET ^= 1u << 2u;
    }

    /**
     * Get RESET's i2c0 bit.
     */
    inline bool get_RESET_i2c0() volatile
    {
        return RESET & (1u << 3u);
    }

    /**
     * Set RESET's i2c0 bit.
     */
    inline void set_RESET_i2c0() volatile
    {
        RESET |= 1u << 3u;
    }

    /**
     * Clear RESET's i2c0 bit.
     */
    inline void clear_RESET_i2c0() volatile
    {
        RESET &= ~(1u << 3u);
    }

    /**
     * Toggle RESET's i2c0 bit.
     */
    inline void toggle_RESET_i2c0() volatile
    {
        RESET ^= 1u << 3u;
    }

    /**
     * Get RESET's i2c1 bit.
     */
    inline bool get_RESET_i2c1() volatile
    {
        return RESET & (1u << 4u);
    }

    /**
     * Set RESET's i2c1 bit.
     */
    inline void set_RESET_i2c1() volatile
    {
        RESET |= 1u << 4u;
    }

    /**
     * Clear RESET's i2c1 bit.
     */
    inline void clear_RESET_i2c1() volatile
    {
        RESET &= ~(1u << 4u);
    }

    /**
     * Toggle RESET's i2c1 bit.
     */
    inline void toggle_RESET_i2c1() volatile
    {
        RESET ^= 1u << 4u;
    }

    /**
     * Get RESET's io_bank0 bit.
     */
    inline bool get_RESET_io_bank0() volatile
    {
        return RESET & (1u << 5u);
    }

    /**
     * Set RESET's io_bank0 bit.
     */
    inline void set_RESET_io_bank0() volatile
    {
        RESET |= 1u << 5u;
    }

    /**
     * Clear RESET's io_bank0 bit.
     */
    inline void clear_RESET_io_bank0() volatile
    {
        RESET &= ~(1u << 5u);
    }

    /**
     * Toggle RESET's io_bank0 bit.
     */
    inline void toggle_RESET_io_bank0() volatile
    {
        RESET ^= 1u << 5u;
    }

    /**
     * Get RESET's io_qspi bit.
     */
    inline bool get_RESET_io_qspi() volatile
    {
        return RESET & (1u << 6u);
    }

    /**
     * Set RESET's io_qspi bit.
     */
    inline void set_RESET_io_qspi() volatile
    {
        RESET |= 1u << 6u;
    }

    /**
     * Clear RESET's io_qspi bit.
     */
    inline void clear_RESET_io_qspi() volatile
    {
        RESET &= ~(1u << 6u);
    }

    /**
     * Toggle RESET's io_qspi bit.
     */
    inline void toggle_RESET_io_qspi() volatile
    {
        RESET ^= 1u << 6u;
    }

    /**
     * Get RESET's jtag bit.
     */
    inline bool get_RESET_jtag() volatile
    {
        return RESET & (1u << 7u);
    }

    /**
     * Set RESET's jtag bit.
     */
    inline void set_RESET_jtag() volatile
    {
        RESET |= 1u << 7u;
    }

    /**
     * Clear RESET's jtag bit.
     */
    inline void clear_RESET_jtag() volatile
    {
        RESET &= ~(1u << 7u);
    }

    /**
     * Toggle RESET's jtag bit.
     */
    inline void toggle_RESET_jtag() volatile
    {
        RESET ^= 1u << 7u;
    }

    /**
     * Get RESET's pads_bank0 bit.
     */
    inline bool get_RESET_pads_bank0() volatile
    {
        return RESET & (1u << 8u);
    }

    /**
     * Set RESET's pads_bank0 bit.
     */
    inline void set_RESET_pads_bank0() volatile
    {
        RESET |= 1u << 8u;
    }

    /**
     * Clear RESET's pads_bank0 bit.
     */
    inline void clear_RESET_pads_bank0() volatile
    {
        RESET &= ~(1u << 8u);
    }

    /**
     * Toggle RESET's pads_bank0 bit.
     */
    inline void toggle_RESET_pads_bank0() volatile
    {
        RESET ^= 1u << 8u;
    }

    /**
     * Get RESET's pads_qspi bit.
     */
    inline bool get_RESET_pads_qspi() volatile
    {
        return RESET & (1u << 9u);
    }

    /**
     * Set RESET's pads_qspi bit.
     */
    inline void set_RESET_pads_qspi() volatile
    {
        RESET |= 1u << 9u;
    }

    /**
     * Clear RESET's pads_qspi bit.
     */
    inline void clear_RESET_pads_qspi() volatile
    {
        RESET &= ~(1u << 9u);
    }

    /**
     * Toggle RESET's pads_qspi bit.
     */
    inline void toggle_RESET_pads_qspi() volatile
    {
        RESET ^= 1u << 9u;
    }

    /**
     * Get RESET's pio0 bit.
     */
    inline bool get_RESET_pio0() volatile
    {
        return RESET & (1u << 10u);
    }

    /**
     * Set RESET's pio0 bit.
     */
    inline void set_RESET_pio0() volatile
    {
        RESET |= 1u << 10u;
    }

    /**
     * Clear RESET's pio0 bit.
     */
    inline void clear_RESET_pio0() volatile
    {
        RESET &= ~(1u << 10u);
    }

    /**
     * Toggle RESET's pio0 bit.
     */
    inline void toggle_RESET_pio0() volatile
    {
        RESET ^= 1u << 10u;
    }

    /**
     * Get RESET's pio1 bit.
     */
    inline bool get_RESET_pio1() volatile
    {
        return RESET & (1u << 11u);
    }

    /**
     * Set RESET's pio1 bit.
     */
    inline void set_RESET_pio1() volatile
    {
        RESET |= 1u << 11u;
    }

    /**
     * Clear RESET's pio1 bit.
     */
    inline void clear_RESET_pio1() volatile
    {
        RESET &= ~(1u << 11u);
    }

    /**
     * Toggle RESET's pio1 bit.
     */
    inline void toggle_RESET_pio1() volatile
    {
        RESET ^= 1u << 11u;
    }

    /**
     * Get RESET's pll_sys bit.
     */
    inline bool get_RESET_pll_sys() volatile
    {
        return RESET & (1u << 12u);
    }

    /**
     * Set RESET's pll_sys bit.
     */
    inline void set_RESET_pll_sys() volatile
    {
        RESET |= 1u << 12u;
    }

    /**
     * Clear RESET's pll_sys bit.
     */
    inline void clear_RESET_pll_sys() volatile
    {
        RESET &= ~(1u << 12u);
    }

    /**
     * Toggle RESET's pll_sys bit.
     */
    inline void toggle_RESET_pll_sys() volatile
    {
        RESET ^= 1u << 12u;
    }

    /**
     * Get RESET's pll_usb bit.
     */
    inline bool get_RESET_pll_usb() volatile
    {
        return RESET & (1u << 13u);
    }

    /**
     * Set RESET's pll_usb bit.
     */
    inline void set_RESET_pll_usb() volatile
    {
        RESET |= 1u << 13u;
    }

    /**
     * Clear RESET's pll_usb bit.
     */
    inline void clear_RESET_pll_usb() volatile
    {
        RESET &= ~(1u << 13u);
    }

    /**
     * Toggle RESET's pll_usb bit.
     */
    inline void toggle_RESET_pll_usb() volatile
    {
        RESET ^= 1u << 13u;
    }

    /**
     * Get RESET's pwm bit.
     */
    inline bool get_RESET_pwm() volatile
    {
        return RESET & (1u << 14u);
    }

    /**
     * Set RESET's pwm bit.
     */
    inline void set_RESET_pwm() volatile
    {
        RESET |= 1u << 14u;
    }

    /**
     * Clear RESET's pwm bit.
     */
    inline void clear_RESET_pwm() volatile
    {
        RESET &= ~(1u << 14u);
    }

    /**
     * Toggle RESET's pwm bit.
     */
    inline void toggle_RESET_pwm() volatile
    {
        RESET ^= 1u << 14u;
    }

    /**
     * Get RESET's rtc bit.
     */
    inline bool get_RESET_rtc() volatile
    {
        return RESET & (1u << 15u);
    }

    /**
     * Set RESET's rtc bit.
     */
    inline void set_RESET_rtc() volatile
    {
        RESET |= 1u << 15u;
    }

    /**
     * Clear RESET's rtc bit.
     */
    inline void clear_RESET_rtc() volatile
    {
        RESET &= ~(1u << 15u);
    }

    /**
     * Toggle RESET's rtc bit.
     */
    inline void toggle_RESET_rtc() volatile
    {
        RESET ^= 1u << 15u;
    }

    /**
     * Get RESET's spi0 bit.
     */
    inline bool get_RESET_spi0() volatile
    {
        return RESET & (1u << 16u);
    }

    /**
     * Set RESET's spi0 bit.
     */
    inline void set_RESET_spi0() volatile
    {
        RESET |= 1u << 16u;
    }

    /**
     * Clear RESET's spi0 bit.
     */
    inline void clear_RESET_spi0() volatile
    {
        RESET &= ~(1u << 16u);
    }

    /**
     * Toggle RESET's spi0 bit.
     */
    inline void toggle_RESET_spi0() volatile
    {
        RESET ^= 1u << 16u;
    }

    /**
     * Get RESET's spi1 bit.
     */
    inline bool get_RESET_spi1() volatile
    {
        return RESET & (1u << 17u);
    }

    /**
     * Set RESET's spi1 bit.
     */
    inline void set_RESET_spi1() volatile
    {
        RESET |= 1u << 17u;
    }

    /**
     * Clear RESET's spi1 bit.
     */
    inline void clear_RESET_spi1() volatile
    {
        RESET &= ~(1u << 17u);
    }

    /**
     * Toggle RESET's spi1 bit.
     */
    inline void toggle_RESET_spi1() volatile
    {
        RESET ^= 1u << 17u;
    }

    /**
     * Get RESET's syscfg bit.
     */
    inline bool get_RESET_syscfg() volatile
    {
        return RESET & (1u << 18u);
    }

    /**
     * Set RESET's syscfg bit.
     */
    inline void set_RESET_syscfg() volatile
    {
        RESET |= 1u << 18u;
    }

    /**
     * Clear RESET's syscfg bit.
     */
    inline void clear_RESET_syscfg() volatile
    {
        RESET &= ~(1u << 18u);
    }

    /**
     * Toggle RESET's syscfg bit.
     */
    inline void toggle_RESET_syscfg() volatile
    {
        RESET ^= 1u << 18u;
    }

    /**
     * Get RESET's sysinfo bit.
     */
    inline bool get_RESET_sysinfo() volatile
    {
        return RESET & (1u << 19u);
    }

    /**
     * Set RESET's sysinfo bit.
     */
    inline void set_RESET_sysinfo() volatile
    {
        RESET |= 1u << 19u;
    }

    /**
     * Clear RESET's sysinfo bit.
     */
    inline void clear_RESET_sysinfo() volatile
    {
        RESET &= ~(1u << 19u);
    }

    /**
     * Toggle RESET's sysinfo bit.
     */
    inline void toggle_RESET_sysinfo() volatile
    {
        RESET ^= 1u << 19u;
    }

    /**
     * Get RESET's tbman bit.
     */
    inline bool get_RESET_tbman() volatile
    {
        return RESET & (1u << 20u);
    }

    /**
     * Set RESET's tbman bit.
     */
    inline void set_RESET_tbman() volatile
    {
        RESET |= 1u << 20u;
    }

    /**
     * Clear RESET's tbman bit.
     */
    inline void clear_RESET_tbman() volatile
    {
        RESET &= ~(1u << 20u);
    }

    /**
     * Toggle RESET's tbman bit.
     */
    inline void toggle_RESET_tbman() volatile
    {
        RESET ^= 1u << 20u;
    }

    /**
     * Get RESET's timer bit.
     */
    inline bool get_RESET_timer() volatile
    {
        return RESET & (1u << 21u);
    }

    /**
     * Set RESET's timer bit.
     */
    inline void set_RESET_timer() volatile
    {
        RESET |= 1u << 21u;
    }

    /**
     * Clear RESET's timer bit.
     */
    inline void clear_RESET_timer() volatile
    {
        RESET &= ~(1u << 21u);
    }

    /**
     * Toggle RESET's timer bit.
     */
    inline void toggle_RESET_timer() volatile
    {
        RESET ^= 1u << 21u;
    }

    /**
     * Get RESET's uart0 bit.
     */
    inline bool get_RESET_uart0() volatile
    {
        return RESET & (1u << 22u);
    }

    /**
     * Set RESET's uart0 bit.
     */
    inline void set_RESET_uart0() volatile
    {
        RESET |= 1u << 22u;
    }

    /**
     * Clear RESET's uart0 bit.
     */
    inline void clear_RESET_uart0() volatile
    {
        RESET &= ~(1u << 22u);
    }

    /**
     * Toggle RESET's uart0 bit.
     */
    inline void toggle_RESET_uart0() volatile
    {
        RESET ^= 1u << 22u;
    }

    /**
     * Get RESET's uart1 bit.
     */
    inline bool get_RESET_uart1() volatile
    {
        return RESET & (1u << 23u);
    }

    /**
     * Set RESET's uart1 bit.
     */
    inline void set_RESET_uart1() volatile
    {
        RESET |= 1u << 23u;
    }

    /**
     * Clear RESET's uart1 bit.
     */
    inline void clear_RESET_uart1() volatile
    {
        RESET &= ~(1u << 23u);
    }

    /**
     * Toggle RESET's uart1 bit.
     */
    inline void toggle_RESET_uart1() volatile
    {
        RESET ^= 1u << 23u;
    }

    /**
     * Get RESET's usbctrl bit.
     */
    inline bool get_RESET_usbctrl() volatile
    {
        return RESET & (1u << 24u);
    }

    /**
     * Set RESET's usbctrl bit.
     */
    inline void set_RESET_usbctrl() volatile
    {
        RESET |= 1u << 24u;
    }

    /**
     * Clear RESET's usbctrl bit.
     */
    inline void clear_RESET_usbctrl() volatile
    {
        RESET &= ~(1u << 24u);
    }

    /**
     * Toggle RESET's usbctrl bit.
     */
    inline void toggle_RESET_usbctrl() volatile
    {
        RESET ^= 1u << 24u;
    }

    /**
     * Get all of RESET's bit fields.
     */
    inline void get_RESET(bool &adc, bool &busctrl, bool &dma, bool &i2c0,
                          bool &i2c1, bool &io_bank0, bool &io_qspi,
                          bool &jtag, bool &pads_bank0, bool &pads_qspi,
                          bool &pio0, bool &pio1, bool &pll_sys, bool &pll_usb,
                          bool &pwm, bool &rtc, bool &spi0, bool &spi1,
                          bool &syscfg, bool &sysinfo, bool &tbman,
                          bool &timer, bool &uart0, bool &uart1,
                          bool &usbctrl) volatile
    {
        uint32_t curr = RESET;

        adc = curr & (1u << 0u);
        busctrl = curr & (1u << 1u);
        dma = curr & (1u << 2u);
        i2c0 = curr & (1u << 3u);
        i2c1 = curr & (1u << 4u);
        io_bank0 = curr & (1u << 5u);
        io_qspi = curr & (1u << 6u);
        jtag = curr & (1u << 7u);
        pads_bank0 = curr & (1u << 8u);
        pads_qspi = curr & (1u << 9u);
        pio0 = curr & (1u << 10u);
        pio1 = curr & (1u << 11u);
        pll_sys = curr & (1u << 12u);
        pll_usb = curr & (1u << 13u);
        pwm = curr & (1u << 14u);
        rtc = curr & (1u << 15u);
        spi0 = curr & (1u << 16u);
        spi1 = curr & (1u << 17u);
        syscfg = curr & (1u << 18u);
        sysinfo = curr & (1u << 19u);
        tbman = curr & (1u << 20u);
        timer = curr & (1u << 21u);
        uart0 = curr & (1u << 22u);
        uart1 = curr & (1u << 23u);
        usbctrl = curr & (1u << 24u);
    }

    /**
     * Set all of RESET's bit fields.
     */
    inline void set_RESET(bool adc, bool busctrl, bool dma, bool i2c0,
                          bool i2c1, bool io_bank0, bool io_qspi, bool jtag,
                          bool pads_bank0, bool pads_qspi, bool pio0,
                          bool pio1, bool pll_sys, bool pll_usb, bool pwm,
                          bool rtc, bool spi0, bool spi1, bool syscfg,
                          bool sysinfo, bool tbman, bool timer, bool uart0,
                          bool uart1, bool usbctrl) volatile
    {
        uint32_t curr = RESET;

        curr &= ~(0b1u << 0u);
        curr |= (adc & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (busctrl & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (dma & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (i2c0 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (i2c1 & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (io_bank0 & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (io_qspi & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (jtag & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (pads_bank0 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (pads_qspi & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (pio0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (pio1 & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (pll_sys & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (pll_usb & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (pwm & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (rtc & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (spi0 & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (spi1 & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (syscfg & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (sysinfo & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (tbman & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (timer & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (uart0 & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (uart1 & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (usbctrl & 0b1u) << 24u;

        RESET = curr;
    }

    /**
     * Get WDSEL's adc bit.
     */
    inline bool get_WDSEL_adc() volatile
    {
        return WDSEL & (1u << 0u);
    }

    /**
     * Set WDSEL's adc bit.
     */
    inline void set_WDSEL_adc() volatile
    {
        WDSEL |= 1u << 0u;
    }

    /**
     * Clear WDSEL's adc bit.
     */
    inline void clear_WDSEL_adc() volatile
    {
        WDSEL &= ~(1u << 0u);
    }

    /**
     * Toggle WDSEL's adc bit.
     */
    inline void toggle_WDSEL_adc() volatile
    {
        WDSEL ^= 1u << 0u;
    }

    /**
     * Get WDSEL's busctrl bit.
     */
    inline bool get_WDSEL_busctrl() volatile
    {
        return WDSEL & (1u << 1u);
    }

    /**
     * Set WDSEL's busctrl bit.
     */
    inline void set_WDSEL_busctrl() volatile
    {
        WDSEL |= 1u << 1u;
    }

    /**
     * Clear WDSEL's busctrl bit.
     */
    inline void clear_WDSEL_busctrl() volatile
    {
        WDSEL &= ~(1u << 1u);
    }

    /**
     * Toggle WDSEL's busctrl bit.
     */
    inline void toggle_WDSEL_busctrl() volatile
    {
        WDSEL ^= 1u << 1u;
    }

    /**
     * Get WDSEL's dma bit.
     */
    inline bool get_WDSEL_dma() volatile
    {
        return WDSEL & (1u << 2u);
    }

    /**
     * Set WDSEL's dma bit.
     */
    inline void set_WDSEL_dma() volatile
    {
        WDSEL |= 1u << 2u;
    }

    /**
     * Clear WDSEL's dma bit.
     */
    inline void clear_WDSEL_dma() volatile
    {
        WDSEL &= ~(1u << 2u);
    }

    /**
     * Toggle WDSEL's dma bit.
     */
    inline void toggle_WDSEL_dma() volatile
    {
        WDSEL ^= 1u << 2u;
    }

    /**
     * Get WDSEL's i2c0 bit.
     */
    inline bool get_WDSEL_i2c0() volatile
    {
        return WDSEL & (1u << 3u);
    }

    /**
     * Set WDSEL's i2c0 bit.
     */
    inline void set_WDSEL_i2c0() volatile
    {
        WDSEL |= 1u << 3u;
    }

    /**
     * Clear WDSEL's i2c0 bit.
     */
    inline void clear_WDSEL_i2c0() volatile
    {
        WDSEL &= ~(1u << 3u);
    }

    /**
     * Toggle WDSEL's i2c0 bit.
     */
    inline void toggle_WDSEL_i2c0() volatile
    {
        WDSEL ^= 1u << 3u;
    }

    /**
     * Get WDSEL's i2c1 bit.
     */
    inline bool get_WDSEL_i2c1() volatile
    {
        return WDSEL & (1u << 4u);
    }

    /**
     * Set WDSEL's i2c1 bit.
     */
    inline void set_WDSEL_i2c1() volatile
    {
        WDSEL |= 1u << 4u;
    }

    /**
     * Clear WDSEL's i2c1 bit.
     */
    inline void clear_WDSEL_i2c1() volatile
    {
        WDSEL &= ~(1u << 4u);
    }

    /**
     * Toggle WDSEL's i2c1 bit.
     */
    inline void toggle_WDSEL_i2c1() volatile
    {
        WDSEL ^= 1u << 4u;
    }

    /**
     * Get WDSEL's io_bank0 bit.
     */
    inline bool get_WDSEL_io_bank0() volatile
    {
        return WDSEL & (1u << 5u);
    }

    /**
     * Set WDSEL's io_bank0 bit.
     */
    inline void set_WDSEL_io_bank0() volatile
    {
        WDSEL |= 1u << 5u;
    }

    /**
     * Clear WDSEL's io_bank0 bit.
     */
    inline void clear_WDSEL_io_bank0() volatile
    {
        WDSEL &= ~(1u << 5u);
    }

    /**
     * Toggle WDSEL's io_bank0 bit.
     */
    inline void toggle_WDSEL_io_bank0() volatile
    {
        WDSEL ^= 1u << 5u;
    }

    /**
     * Get WDSEL's io_qspi bit.
     */
    inline bool get_WDSEL_io_qspi() volatile
    {
        return WDSEL & (1u << 6u);
    }

    /**
     * Set WDSEL's io_qspi bit.
     */
    inline void set_WDSEL_io_qspi() volatile
    {
        WDSEL |= 1u << 6u;
    }

    /**
     * Clear WDSEL's io_qspi bit.
     */
    inline void clear_WDSEL_io_qspi() volatile
    {
        WDSEL &= ~(1u << 6u);
    }

    /**
     * Toggle WDSEL's io_qspi bit.
     */
    inline void toggle_WDSEL_io_qspi() volatile
    {
        WDSEL ^= 1u << 6u;
    }

    /**
     * Get WDSEL's jtag bit.
     */
    inline bool get_WDSEL_jtag() volatile
    {
        return WDSEL & (1u << 7u);
    }

    /**
     * Set WDSEL's jtag bit.
     */
    inline void set_WDSEL_jtag() volatile
    {
        WDSEL |= 1u << 7u;
    }

    /**
     * Clear WDSEL's jtag bit.
     */
    inline void clear_WDSEL_jtag() volatile
    {
        WDSEL &= ~(1u << 7u);
    }

    /**
     * Toggle WDSEL's jtag bit.
     */
    inline void toggle_WDSEL_jtag() volatile
    {
        WDSEL ^= 1u << 7u;
    }

    /**
     * Get WDSEL's pads_bank0 bit.
     */
    inline bool get_WDSEL_pads_bank0() volatile
    {
        return WDSEL & (1u << 8u);
    }

    /**
     * Set WDSEL's pads_bank0 bit.
     */
    inline void set_WDSEL_pads_bank0() volatile
    {
        WDSEL |= 1u << 8u;
    }

    /**
     * Clear WDSEL's pads_bank0 bit.
     */
    inline void clear_WDSEL_pads_bank0() volatile
    {
        WDSEL &= ~(1u << 8u);
    }

    /**
     * Toggle WDSEL's pads_bank0 bit.
     */
    inline void toggle_WDSEL_pads_bank0() volatile
    {
        WDSEL ^= 1u << 8u;
    }

    /**
     * Get WDSEL's pads_qspi bit.
     */
    inline bool get_WDSEL_pads_qspi() volatile
    {
        return WDSEL & (1u << 9u);
    }

    /**
     * Set WDSEL's pads_qspi bit.
     */
    inline void set_WDSEL_pads_qspi() volatile
    {
        WDSEL |= 1u << 9u;
    }

    /**
     * Clear WDSEL's pads_qspi bit.
     */
    inline void clear_WDSEL_pads_qspi() volatile
    {
        WDSEL &= ~(1u << 9u);
    }

    /**
     * Toggle WDSEL's pads_qspi bit.
     */
    inline void toggle_WDSEL_pads_qspi() volatile
    {
        WDSEL ^= 1u << 9u;
    }

    /**
     * Get WDSEL's pio0 bit.
     */
    inline bool get_WDSEL_pio0() volatile
    {
        return WDSEL & (1u << 10u);
    }

    /**
     * Set WDSEL's pio0 bit.
     */
    inline void set_WDSEL_pio0() volatile
    {
        WDSEL |= 1u << 10u;
    }

    /**
     * Clear WDSEL's pio0 bit.
     */
    inline void clear_WDSEL_pio0() volatile
    {
        WDSEL &= ~(1u << 10u);
    }

    /**
     * Toggle WDSEL's pio0 bit.
     */
    inline void toggle_WDSEL_pio0() volatile
    {
        WDSEL ^= 1u << 10u;
    }

    /**
     * Get WDSEL's pio1 bit.
     */
    inline bool get_WDSEL_pio1() volatile
    {
        return WDSEL & (1u << 11u);
    }

    /**
     * Set WDSEL's pio1 bit.
     */
    inline void set_WDSEL_pio1() volatile
    {
        WDSEL |= 1u << 11u;
    }

    /**
     * Clear WDSEL's pio1 bit.
     */
    inline void clear_WDSEL_pio1() volatile
    {
        WDSEL &= ~(1u << 11u);
    }

    /**
     * Toggle WDSEL's pio1 bit.
     */
    inline void toggle_WDSEL_pio1() volatile
    {
        WDSEL ^= 1u << 11u;
    }

    /**
     * Get WDSEL's pll_sys bit.
     */
    inline bool get_WDSEL_pll_sys() volatile
    {
        return WDSEL & (1u << 12u);
    }

    /**
     * Set WDSEL's pll_sys bit.
     */
    inline void set_WDSEL_pll_sys() volatile
    {
        WDSEL |= 1u << 12u;
    }

    /**
     * Clear WDSEL's pll_sys bit.
     */
    inline void clear_WDSEL_pll_sys() volatile
    {
        WDSEL &= ~(1u << 12u);
    }

    /**
     * Toggle WDSEL's pll_sys bit.
     */
    inline void toggle_WDSEL_pll_sys() volatile
    {
        WDSEL ^= 1u << 12u;
    }

    /**
     * Get WDSEL's pll_usb bit.
     */
    inline bool get_WDSEL_pll_usb() volatile
    {
        return WDSEL & (1u << 13u);
    }

    /**
     * Set WDSEL's pll_usb bit.
     */
    inline void set_WDSEL_pll_usb() volatile
    {
        WDSEL |= 1u << 13u;
    }

    /**
     * Clear WDSEL's pll_usb bit.
     */
    inline void clear_WDSEL_pll_usb() volatile
    {
        WDSEL &= ~(1u << 13u);
    }

    /**
     * Toggle WDSEL's pll_usb bit.
     */
    inline void toggle_WDSEL_pll_usb() volatile
    {
        WDSEL ^= 1u << 13u;
    }

    /**
     * Get WDSEL's pwm bit.
     */
    inline bool get_WDSEL_pwm() volatile
    {
        return WDSEL & (1u << 14u);
    }

    /**
     * Set WDSEL's pwm bit.
     */
    inline void set_WDSEL_pwm() volatile
    {
        WDSEL |= 1u << 14u;
    }

    /**
     * Clear WDSEL's pwm bit.
     */
    inline void clear_WDSEL_pwm() volatile
    {
        WDSEL &= ~(1u << 14u);
    }

    /**
     * Toggle WDSEL's pwm bit.
     */
    inline void toggle_WDSEL_pwm() volatile
    {
        WDSEL ^= 1u << 14u;
    }

    /**
     * Get WDSEL's rtc bit.
     */
    inline bool get_WDSEL_rtc() volatile
    {
        return WDSEL & (1u << 15u);
    }

    /**
     * Set WDSEL's rtc bit.
     */
    inline void set_WDSEL_rtc() volatile
    {
        WDSEL |= 1u << 15u;
    }

    /**
     * Clear WDSEL's rtc bit.
     */
    inline void clear_WDSEL_rtc() volatile
    {
        WDSEL &= ~(1u << 15u);
    }

    /**
     * Toggle WDSEL's rtc bit.
     */
    inline void toggle_WDSEL_rtc() volatile
    {
        WDSEL ^= 1u << 15u;
    }

    /**
     * Get WDSEL's spi0 bit.
     */
    inline bool get_WDSEL_spi0() volatile
    {
        return WDSEL & (1u << 16u);
    }

    /**
     * Set WDSEL's spi0 bit.
     */
    inline void set_WDSEL_spi0() volatile
    {
        WDSEL |= 1u << 16u;
    }

    /**
     * Clear WDSEL's spi0 bit.
     */
    inline void clear_WDSEL_spi0() volatile
    {
        WDSEL &= ~(1u << 16u);
    }

    /**
     * Toggle WDSEL's spi0 bit.
     */
    inline void toggle_WDSEL_spi0() volatile
    {
        WDSEL ^= 1u << 16u;
    }

    /**
     * Get WDSEL's spi1 bit.
     */
    inline bool get_WDSEL_spi1() volatile
    {
        return WDSEL & (1u << 17u);
    }

    /**
     * Set WDSEL's spi1 bit.
     */
    inline void set_WDSEL_spi1() volatile
    {
        WDSEL |= 1u << 17u;
    }

    /**
     * Clear WDSEL's spi1 bit.
     */
    inline void clear_WDSEL_spi1() volatile
    {
        WDSEL &= ~(1u << 17u);
    }

    /**
     * Toggle WDSEL's spi1 bit.
     */
    inline void toggle_WDSEL_spi1() volatile
    {
        WDSEL ^= 1u << 17u;
    }

    /**
     * Get WDSEL's syscfg bit.
     */
    inline bool get_WDSEL_syscfg() volatile
    {
        return WDSEL & (1u << 18u);
    }

    /**
     * Set WDSEL's syscfg bit.
     */
    inline void set_WDSEL_syscfg() volatile
    {
        WDSEL |= 1u << 18u;
    }

    /**
     * Clear WDSEL's syscfg bit.
     */
    inline void clear_WDSEL_syscfg() volatile
    {
        WDSEL &= ~(1u << 18u);
    }

    /**
     * Toggle WDSEL's syscfg bit.
     */
    inline void toggle_WDSEL_syscfg() volatile
    {
        WDSEL ^= 1u << 18u;
    }

    /**
     * Get WDSEL's sysinfo bit.
     */
    inline bool get_WDSEL_sysinfo() volatile
    {
        return WDSEL & (1u << 19u);
    }

    /**
     * Set WDSEL's sysinfo bit.
     */
    inline void set_WDSEL_sysinfo() volatile
    {
        WDSEL |= 1u << 19u;
    }

    /**
     * Clear WDSEL's sysinfo bit.
     */
    inline void clear_WDSEL_sysinfo() volatile
    {
        WDSEL &= ~(1u << 19u);
    }

    /**
     * Toggle WDSEL's sysinfo bit.
     */
    inline void toggle_WDSEL_sysinfo() volatile
    {
        WDSEL ^= 1u << 19u;
    }

    /**
     * Get WDSEL's tbman bit.
     */
    inline bool get_WDSEL_tbman() volatile
    {
        return WDSEL & (1u << 20u);
    }

    /**
     * Set WDSEL's tbman bit.
     */
    inline void set_WDSEL_tbman() volatile
    {
        WDSEL |= 1u << 20u;
    }

    /**
     * Clear WDSEL's tbman bit.
     */
    inline void clear_WDSEL_tbman() volatile
    {
        WDSEL &= ~(1u << 20u);
    }

    /**
     * Toggle WDSEL's tbman bit.
     */
    inline void toggle_WDSEL_tbman() volatile
    {
        WDSEL ^= 1u << 20u;
    }

    /**
     * Get WDSEL's timer bit.
     */
    inline bool get_WDSEL_timer() volatile
    {
        return WDSEL & (1u << 21u);
    }

    /**
     * Set WDSEL's timer bit.
     */
    inline void set_WDSEL_timer() volatile
    {
        WDSEL |= 1u << 21u;
    }

    /**
     * Clear WDSEL's timer bit.
     */
    inline void clear_WDSEL_timer() volatile
    {
        WDSEL &= ~(1u << 21u);
    }

    /**
     * Toggle WDSEL's timer bit.
     */
    inline void toggle_WDSEL_timer() volatile
    {
        WDSEL ^= 1u << 21u;
    }

    /**
     * Get WDSEL's uart0 bit.
     */
    inline bool get_WDSEL_uart0() volatile
    {
        return WDSEL & (1u << 22u);
    }

    /**
     * Set WDSEL's uart0 bit.
     */
    inline void set_WDSEL_uart0() volatile
    {
        WDSEL |= 1u << 22u;
    }

    /**
     * Clear WDSEL's uart0 bit.
     */
    inline void clear_WDSEL_uart0() volatile
    {
        WDSEL &= ~(1u << 22u);
    }

    /**
     * Toggle WDSEL's uart0 bit.
     */
    inline void toggle_WDSEL_uart0() volatile
    {
        WDSEL ^= 1u << 22u;
    }

    /**
     * Get WDSEL's uart1 bit.
     */
    inline bool get_WDSEL_uart1() volatile
    {
        return WDSEL & (1u << 23u);
    }

    /**
     * Set WDSEL's uart1 bit.
     */
    inline void set_WDSEL_uart1() volatile
    {
        WDSEL |= 1u << 23u;
    }

    /**
     * Clear WDSEL's uart1 bit.
     */
    inline void clear_WDSEL_uart1() volatile
    {
        WDSEL &= ~(1u << 23u);
    }

    /**
     * Toggle WDSEL's uart1 bit.
     */
    inline void toggle_WDSEL_uart1() volatile
    {
        WDSEL ^= 1u << 23u;
    }

    /**
     * Get WDSEL's usbctrl bit.
     */
    inline bool get_WDSEL_usbctrl() volatile
    {
        return WDSEL & (1u << 24u);
    }

    /**
     * Set WDSEL's usbctrl bit.
     */
    inline void set_WDSEL_usbctrl() volatile
    {
        WDSEL |= 1u << 24u;
    }

    /**
     * Clear WDSEL's usbctrl bit.
     */
    inline void clear_WDSEL_usbctrl() volatile
    {
        WDSEL &= ~(1u << 24u);
    }

    /**
     * Toggle WDSEL's usbctrl bit.
     */
    inline void toggle_WDSEL_usbctrl() volatile
    {
        WDSEL ^= 1u << 24u;
    }

    /**
     * Get all of WDSEL's bit fields.
     */
    inline void get_WDSEL(bool &adc, bool &busctrl, bool &dma, bool &i2c0,
                          bool &i2c1, bool &io_bank0, bool &io_qspi,
                          bool &jtag, bool &pads_bank0, bool &pads_qspi,
                          bool &pio0, bool &pio1, bool &pll_sys, bool &pll_usb,
                          bool &pwm, bool &rtc, bool &spi0, bool &spi1,
                          bool &syscfg, bool &sysinfo, bool &tbman,
                          bool &timer, bool &uart0, bool &uart1,
                          bool &usbctrl) volatile
    {
        uint32_t curr = WDSEL;

        adc = curr & (1u << 0u);
        busctrl = curr & (1u << 1u);
        dma = curr & (1u << 2u);
        i2c0 = curr & (1u << 3u);
        i2c1 = curr & (1u << 4u);
        io_bank0 = curr & (1u << 5u);
        io_qspi = curr & (1u << 6u);
        jtag = curr & (1u << 7u);
        pads_bank0 = curr & (1u << 8u);
        pads_qspi = curr & (1u << 9u);
        pio0 = curr & (1u << 10u);
        pio1 = curr & (1u << 11u);
        pll_sys = curr & (1u << 12u);
        pll_usb = curr & (1u << 13u);
        pwm = curr & (1u << 14u);
        rtc = curr & (1u << 15u);
        spi0 = curr & (1u << 16u);
        spi1 = curr & (1u << 17u);
        syscfg = curr & (1u << 18u);
        sysinfo = curr & (1u << 19u);
        tbman = curr & (1u << 20u);
        timer = curr & (1u << 21u);
        uart0 = curr & (1u << 22u);
        uart1 = curr & (1u << 23u);
        usbctrl = curr & (1u << 24u);
    }

    /**
     * Set all of WDSEL's bit fields.
     */
    inline void set_WDSEL(bool adc, bool busctrl, bool dma, bool i2c0,
                          bool i2c1, bool io_bank0, bool io_qspi, bool jtag,
                          bool pads_bank0, bool pads_qspi, bool pio0,
                          bool pio1, bool pll_sys, bool pll_usb, bool pwm,
                          bool rtc, bool spi0, bool spi1, bool syscfg,
                          bool sysinfo, bool tbman, bool timer, bool uart0,
                          bool uart1, bool usbctrl) volatile
    {
        uint32_t curr = WDSEL;

        curr &= ~(0b1u << 0u);
        curr |= (adc & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (busctrl & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (dma & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (i2c0 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (i2c1 & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (io_bank0 & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (io_qspi & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (jtag & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (pads_bank0 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (pads_qspi & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (pio0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (pio1 & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (pll_sys & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (pll_usb & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (pwm & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (rtc & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (spi0 & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (spi1 & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (syscfg & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (sysinfo & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (tbman & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (timer & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (uart0 & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (uart1 & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (usbctrl & 0b1u) << 24u;

        WDSEL = curr;
    }

    /**
     * Get RESET_DONE's adc bit.
     */
    inline bool get_RESET_DONE_adc() volatile
    {
        return RESET_DONE & (1u << 0u);
    }

    /**
     * Get RESET_DONE's busctrl bit.
     */
    inline bool get_RESET_DONE_busctrl() volatile
    {
        return RESET_DONE & (1u << 1u);
    }

    /**
     * Get RESET_DONE's dma bit.
     */
    inline bool get_RESET_DONE_dma() volatile
    {
        return RESET_DONE & (1u << 2u);
    }

    /**
     * Get RESET_DONE's i2c0 bit.
     */
    inline bool get_RESET_DONE_i2c0() volatile
    {
        return RESET_DONE & (1u << 3u);
    }

    /**
     * Get RESET_DONE's i2c1 bit.
     */
    inline bool get_RESET_DONE_i2c1() volatile
    {
        return RESET_DONE & (1u << 4u);
    }

    /**
     * Get RESET_DONE's io_bank0 bit.
     */
    inline bool get_RESET_DONE_io_bank0() volatile
    {
        return RESET_DONE & (1u << 5u);
    }

    /**
     * Get RESET_DONE's io_qspi bit.
     */
    inline bool get_RESET_DONE_io_qspi() volatile
    {
        return RESET_DONE & (1u << 6u);
    }

    /**
     * Get RESET_DONE's jtag bit.
     */
    inline bool get_RESET_DONE_jtag() volatile
    {
        return RESET_DONE & (1u << 7u);
    }

    /**
     * Get RESET_DONE's pads_bank0 bit.
     */
    inline bool get_RESET_DONE_pads_bank0() volatile
    {
        return RESET_DONE & (1u << 8u);
    }

    /**
     * Get RESET_DONE's pads_qspi bit.
     */
    inline bool get_RESET_DONE_pads_qspi() volatile
    {
        return RESET_DONE & (1u << 9u);
    }

    /**
     * Get RESET_DONE's pio0 bit.
     */
    inline bool get_RESET_DONE_pio0() volatile
    {
        return RESET_DONE & (1u << 10u);
    }

    /**
     * Get RESET_DONE's pio1 bit.
     */
    inline bool get_RESET_DONE_pio1() volatile
    {
        return RESET_DONE & (1u << 11u);
    }

    /**
     * Get RESET_DONE's pll_sys bit.
     */
    inline bool get_RESET_DONE_pll_sys() volatile
    {
        return RESET_DONE & (1u << 12u);
    }

    /**
     * Get RESET_DONE's pll_usb bit.
     */
    inline bool get_RESET_DONE_pll_usb() volatile
    {
        return RESET_DONE & (1u << 13u);
    }

    /**
     * Get RESET_DONE's pwm bit.
     */
    inline bool get_RESET_DONE_pwm() volatile
    {
        return RESET_DONE & (1u << 14u);
    }

    /**
     * Get RESET_DONE's rtc bit.
     */
    inline bool get_RESET_DONE_rtc() volatile
    {
        return RESET_DONE & (1u << 15u);
    }

    /**
     * Get RESET_DONE's spi0 bit.
     */
    inline bool get_RESET_DONE_spi0() volatile
    {
        return RESET_DONE & (1u << 16u);
    }

    /**
     * Get RESET_DONE's spi1 bit.
     */
    inline bool get_RESET_DONE_spi1() volatile
    {
        return RESET_DONE & (1u << 17u);
    }

    /**
     * Get RESET_DONE's syscfg bit.
     */
    inline bool get_RESET_DONE_syscfg() volatile
    {
        return RESET_DONE & (1u << 18u);
    }

    /**
     * Get RESET_DONE's sysinfo bit.
     */
    inline bool get_RESET_DONE_sysinfo() volatile
    {
        return RESET_DONE & (1u << 19u);
    }

    /**
     * Get RESET_DONE's tbman bit.
     */
    inline bool get_RESET_DONE_tbman() volatile
    {
        return RESET_DONE & (1u << 20u);
    }

    /**
     * Get RESET_DONE's timer bit.
     */
    inline bool get_RESET_DONE_timer() volatile
    {
        return RESET_DONE & (1u << 21u);
    }

    /**
     * Get RESET_DONE's uart0 bit.
     */
    inline bool get_RESET_DONE_uart0() volatile
    {
        return RESET_DONE & (1u << 22u);
    }

    /**
     * Get RESET_DONE's uart1 bit.
     */
    inline bool get_RESET_DONE_uart1() volatile
    {
        return RESET_DONE & (1u << 23u);
    }

    /**
     * Get RESET_DONE's usbctrl bit.
     */
    inline bool get_RESET_DONE_usbctrl() volatile
    {
        return RESET_DONE & (1u << 24u);
    }

    /**
     * Get all of RESET_DONE's bit fields.
     */
    inline void get_RESET_DONE(bool &adc, bool &busctrl, bool &dma, bool &i2c0,
                               bool &i2c1, bool &io_bank0, bool &io_qspi,
                               bool &jtag, bool &pads_bank0, bool &pads_qspi,
                               bool &pio0, bool &pio1, bool &pll_sys,
                               bool &pll_usb, bool &pwm, bool &rtc, bool &spi0,
                               bool &spi1, bool &syscfg, bool &sysinfo,
                               bool &tbman, bool &timer, bool &uart0,
                               bool &uart1, bool &usbctrl) volatile
    {
        uint32_t curr = RESET_DONE;

        adc = curr & (1u << 0u);
        busctrl = curr & (1u << 1u);
        dma = curr & (1u << 2u);
        i2c0 = curr & (1u << 3u);
        i2c1 = curr & (1u << 4u);
        io_bank0 = curr & (1u << 5u);
        io_qspi = curr & (1u << 6u);
        jtag = curr & (1u << 7u);
        pads_bank0 = curr & (1u << 8u);
        pads_qspi = curr & (1u << 9u);
        pio0 = curr & (1u << 10u);
        pio1 = curr & (1u << 11u);
        pll_sys = curr & (1u << 12u);
        pll_usb = curr & (1u << 13u);
        pwm = curr & (1u << 14u);
        rtc = curr & (1u << 15u);
        spi0 = curr & (1u << 16u);
        spi1 = curr & (1u << 17u);
        syscfg = curr & (1u << 18u);
        sysinfo = curr & (1u << 19u);
        tbman = curr & (1u << 20u);
        timer = curr & (1u << 21u);
        uart0 = curr & (1u << 22u);
        uart1 = curr & (1u << 23u);
        usbctrl = curr & (1u << 24u);
    }
};

static_assert(sizeof(resets) == resets::size);

static volatile resets *const RESETS = reinterpret_cast<resets *>(0x4000c000);

}; // namespace RP2040
