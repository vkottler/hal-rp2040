/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE.h"
#include "../enums/USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET.h"
#include "../enums/USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * DPRAM layout for USB device.
 */
struct [[gnu::packed]] usbctrl_dpram
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        256; /*!< usbctrl_dpram's size in bytes. */

    /* Fields. */
    uint32_t SETUP_PACKET_LOW;  /*!< (read-write) Bytes 0-3 of the SETUP packet
                                   from the host. */
    uint32_t SETUP_PACKET_HIGH; /*!< (read-write) Bytes 4-7 of the setup packet
                                   from the host. */
    uint32_t EP1_IN_CONTROL;
    uint32_t EP1_OUT_CONTROL;
    uint32_t EP2_IN_CONTROL;
    uint32_t EP2_OUT_CONTROL;
    uint32_t EP3_IN_CONTROL;
    uint32_t EP3_OUT_CONTROL;
    uint32_t EP4_IN_CONTROL;
    uint32_t EP4_OUT_CONTROL;
    uint32_t EP5_IN_CONTROL;
    uint32_t EP5_OUT_CONTROL;
    uint32_t EP6_IN_CONTROL;
    uint32_t EP6_OUT_CONTROL;
    uint32_t EP7_IN_CONTROL;
    uint32_t EP7_OUT_CONTROL;
    uint32_t EP8_IN_CONTROL;
    uint32_t EP8_OUT_CONTROL;
    uint32_t EP9_IN_CONTROL;
    uint32_t EP9_OUT_CONTROL;
    uint32_t EP10_IN_CONTROL;
    uint32_t EP10_OUT_CONTROL;
    uint32_t EP11_IN_CONTROL;
    uint32_t EP11_OUT_CONTROL;
    uint32_t EP12_IN_CONTROL;
    uint32_t EP12_OUT_CONTROL;
    uint32_t EP13_IN_CONTROL;
    uint32_t EP13_OUT_CONTROL;
    uint32_t EP14_IN_CONTROL;
    uint32_t EP14_OUT_CONTROL;
    uint32_t EP15_IN_CONTROL;
    uint32_t EP15_OUT_CONTROL;
    uint32_t EP0_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP0_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP1_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP1_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP2_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP2_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP3_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP3_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP4_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP4_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP5_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP5_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP6_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP6_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP7_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP7_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP8_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP8_OUT_BUFFER_CONTROL;     /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
              valid if the endpoint is in double buffered mode. */
    uint32_t EP9_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
              buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
              Fields ending in a _0 are for buffer 0. Buffer 1 controls are
              only valid if the endpoint is in double buffered mode. */
    uint32_t
        EP9_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP10_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP10_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
           buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
           Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
           valid if the endpoint is in double buffered mode. */
    uint32_t
        EP11_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP11_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
           buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
           Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
           valid if the endpoint is in double buffered mode. */
    uint32_t
        EP12_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP12_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
           buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
           Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
           valid if the endpoint is in double buffered mode. */
    uint32_t
        EP13_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP13_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
           buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
           Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
           valid if the endpoint is in double buffered mode. */
    uint32_t
        EP14_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP14_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
           buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
           Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
           valid if the endpoint is in double buffered mode. */
    uint32_t
        EP15_IN_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
          buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
          Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
          valid if the endpoint is in double buffered mode. */
    uint32_t
        EP15_OUT_BUFFER_CONTROL; /*!< (read-write) Buffer control for both
           buffers of an endpoint. Fields ending in a _1 are for buffer 1.\n
           Fields ending in a _0 are for buffer 0. Buffer 1 controls are only
           valid if the endpoint is in double buffered mode. */

    /* Methods. */

    /**
     * Get SETUP_PACKET_LOW's BMREQUESTTYPE field.
     */
    inline uint8_t get_SETUP_PACKET_LOW_BMREQUESTTYPE() volatile
    {
        return (SETUP_PACKET_LOW >> 0u) & 0b11111111u;
    }

    /**
     * Set SETUP_PACKET_LOW's BMREQUESTTYPE field.
     */
    inline void set_SETUP_PACKET_LOW_BMREQUESTTYPE(uint8_t value) volatile
    {
        uint32_t curr = SETUP_PACKET_LOW;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        SETUP_PACKET_LOW = curr;
    }

    /**
     * Get SETUP_PACKET_LOW's BREQUEST field.
     */
    inline uint8_t get_SETUP_PACKET_LOW_BREQUEST() volatile
    {
        return (SETUP_PACKET_LOW >> 8u) & 0b11111111u;
    }

    /**
     * Set SETUP_PACKET_LOW's BREQUEST field.
     */
    inline void set_SETUP_PACKET_LOW_BREQUEST(uint8_t value) volatile
    {
        uint32_t curr = SETUP_PACKET_LOW;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        SETUP_PACKET_LOW = curr;
    }

    /**
     * Get SETUP_PACKET_LOW's WVALUE field.
     */
    inline uint16_t get_SETUP_PACKET_LOW_WVALUE() volatile
    {
        return (SETUP_PACKET_LOW >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SETUP_PACKET_LOW's WVALUE field.
     */
    inline void set_SETUP_PACKET_LOW_WVALUE(uint16_t value) volatile
    {
        uint32_t curr = SETUP_PACKET_LOW;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SETUP_PACKET_LOW = curr;
    }

    /**
     * Get all of SETUP_PACKET_LOW's bit fields.
     *
     * (read-write) Bytes 0-3 of the SETUP packet from the host.
     */
    inline void get_SETUP_PACKET_LOW(uint8_t &BMREQUESTTYPE, uint8_t &BREQUEST,
                                     uint16_t &WVALUE) volatile
    {
        uint32_t curr = SETUP_PACKET_LOW;

        BMREQUESTTYPE = (curr >> 0u) & 0b11111111u;
        BREQUEST = (curr >> 8u) & 0b11111111u;
        WVALUE = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of SETUP_PACKET_LOW's bit fields.
     *
     * (read-write) Bytes 0-3 of the SETUP packet from the host.
     */
    inline void set_SETUP_PACKET_LOW(uint8_t BMREQUESTTYPE, uint8_t BREQUEST,
                                     uint16_t WVALUE) volatile
    {
        uint32_t curr = SETUP_PACKET_LOW;

        curr &= ~(0b11111111u << 0u);
        curr |= (BMREQUESTTYPE & 0b11111111u) << 0u;
        curr &= ~(0b11111111u << 8u);
        curr |= (BREQUEST & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (WVALUE & 0b1111111111111111u) << 16u;

        SETUP_PACKET_LOW = curr;
    }

    /**
     * Get SETUP_PACKET_HIGH's WINDEX field.
     */
    inline uint16_t get_SETUP_PACKET_HIGH_WINDEX() volatile
    {
        return (SETUP_PACKET_HIGH >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set SETUP_PACKET_HIGH's WINDEX field.
     */
    inline void set_SETUP_PACKET_HIGH_WINDEX(uint16_t value) volatile
    {
        uint32_t curr = SETUP_PACKET_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        SETUP_PACKET_HIGH = curr;
    }

    /**
     * Get SETUP_PACKET_HIGH's WLENGTH field.
     */
    inline uint16_t get_SETUP_PACKET_HIGH_WLENGTH() volatile
    {
        return (SETUP_PACKET_HIGH >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set SETUP_PACKET_HIGH's WLENGTH field.
     */
    inline void set_SETUP_PACKET_HIGH_WLENGTH(uint16_t value) volatile
    {
        uint32_t curr = SETUP_PACKET_HIGH;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        SETUP_PACKET_HIGH = curr;
    }

    /**
     * Get all of SETUP_PACKET_HIGH's bit fields.
     *
     * (read-write) Bytes 4-7 of the setup packet from the host.
     */
    inline void get_SETUP_PACKET_HIGH(uint16_t &WINDEX,
                                      uint16_t &WLENGTH) volatile
    {
        uint32_t curr = SETUP_PACKET_HIGH;

        WINDEX = (curr >> 0u) & 0b1111111111111111u;
        WLENGTH = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of SETUP_PACKET_HIGH's bit fields.
     *
     * (read-write) Bytes 4-7 of the setup packet from the host.
     */
    inline void set_SETUP_PACKET_HIGH(uint16_t WINDEX,
                                      uint16_t WLENGTH) volatile
    {
        uint32_t curr = SETUP_PACKET_HIGH;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (WINDEX & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (WLENGTH & 0b1111111111111111u) << 16u;

        SETUP_PACKET_HIGH = curr;
    }

    /**
     * Get EP1_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP1_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP1_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP1_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP1_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP1_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP1_IN_CONTROL = curr;
    }

    /**
     * Get EP1_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP1_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP1_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP1_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP1_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP1_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP1_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP1_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP1_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP1_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP1_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP1_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP1_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP1_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP1_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP1_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP1_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP1_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP1_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP1_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP1_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP1_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP1_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP1_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP1_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE
    get_EP1_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE(
            (EP1_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP1_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP1_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP1_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP1_IN_CONTROL = curr;
    }

    /**
     * Get EP1_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP1_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP1_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP1_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP1_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP1_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP1_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP1_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP1_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP1_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP1_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP1_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP1_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP1_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP1_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP1_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP1_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP1_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP1_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP1_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP1_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP1_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP1_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP1_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP1_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP1_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP1_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP1_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP1_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP1_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP1_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP1_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP1_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP1_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP1_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP1_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP1_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP1_IN_CONTROL_ENABLE() volatile
    {
        return EP1_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP1_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP1_IN_CONTROL_ENABLE() volatile
    {
        EP1_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP1_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP1_IN_CONTROL_ENABLE() volatile
    {
        EP1_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP1_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP1_IN_CONTROL_ENABLE() volatile
    {
        EP1_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP1_IN_CONTROL's bit fields.
     */
    inline void get_EP1_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP1_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP1_IN_CONTROL's bit fields.
     */
    inline void set_EP1_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP1_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP1_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP1_IN_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP1_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP1_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP1_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP1_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP1_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP1_OUT_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP1_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP1_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP1_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP1_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP1_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP1_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP1_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP1_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP1_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP1_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP1_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP1_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP1_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP1_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP1_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP1_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP1_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP1_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP1_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP1_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP1_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP1_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP1_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP1_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE
    get_EP1_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE(
            (EP1_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP1_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP1_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP1_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP1_OUT_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP1_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP1_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP1_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP1_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP1_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP1_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP1_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP1_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP1_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP1_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP1_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP1_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP1_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP1_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP1_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP1_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP1_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP1_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP1_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP1_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP1_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP1_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP1_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP1_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP1_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP1_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP1_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP1_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP1_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP1_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP1_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP1_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP1_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP1_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP1_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP1_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP1_OUT_CONTROL_ENABLE() volatile
    {
        return EP1_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP1_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP1_OUT_CONTROL_ENABLE() volatile
    {
        EP1_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP1_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP1_OUT_CONTROL_ENABLE() volatile
    {
        EP1_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP1_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP1_OUT_CONTROL_ENABLE() volatile
    {
        EP1_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP1_OUT_CONTROL's bit fields.
     */
    inline void get_EP1_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP1_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP1_OUT_CONTROL's bit fields.
     */
    inline void set_EP1_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP1_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP1_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP1_OUT_CONTROL = curr;
    }

    /**
     * Get EP2_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP2_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP2_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP2_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP2_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP2_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP2_IN_CONTROL = curr;
    }

    /**
     * Get EP2_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP2_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP2_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP2_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP2_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP2_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP2_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP2_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP2_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP2_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP2_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP2_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP2_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP2_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP2_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP2_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP2_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP2_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP2_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP2_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP2_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP2_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP2_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP2_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP2_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE
    get_EP2_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE(
            (EP2_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP2_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP2_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP2_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP2_IN_CONTROL = curr;
    }

    /**
     * Get EP2_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP2_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP2_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP2_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP2_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP2_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP2_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP2_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP2_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP2_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP2_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP2_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP2_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP2_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP2_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP2_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP2_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP2_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP2_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP2_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP2_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP2_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP2_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP2_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP2_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP2_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP2_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP2_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP2_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP2_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP2_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP2_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP2_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP2_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP2_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP2_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP2_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP2_IN_CONTROL_ENABLE() volatile
    {
        return EP2_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP2_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP2_IN_CONTROL_ENABLE() volatile
    {
        EP2_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP2_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP2_IN_CONTROL_ENABLE() volatile
    {
        EP2_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP2_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP2_IN_CONTROL_ENABLE() volatile
    {
        EP2_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP2_IN_CONTROL's bit fields.
     */
    inline void get_EP2_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP2_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP2_IN_CONTROL's bit fields.
     */
    inline void set_EP2_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP2_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP2_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP2_IN_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP2_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP2_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP2_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP2_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP2_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP2_OUT_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP2_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP2_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP2_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP2_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP2_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP2_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP2_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP2_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP2_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP2_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP2_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP2_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP2_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP2_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP2_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP2_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP2_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP2_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP2_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP2_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP2_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP2_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP2_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP2_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE
    get_EP2_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE(
            (EP2_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP2_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP2_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP2_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP2_OUT_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP2_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP2_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP2_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP2_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP2_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP2_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP2_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP2_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP2_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP2_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP2_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP2_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP2_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP2_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP2_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP2_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP2_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP2_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP2_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP2_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP2_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP2_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP2_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP2_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP2_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP2_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP2_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP2_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP2_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP2_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP2_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP2_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP2_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP2_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP2_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP2_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP2_OUT_CONTROL_ENABLE() volatile
    {
        return EP2_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP2_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP2_OUT_CONTROL_ENABLE() volatile
    {
        EP2_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP2_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP2_OUT_CONTROL_ENABLE() volatile
    {
        EP2_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP2_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP2_OUT_CONTROL_ENABLE() volatile
    {
        EP2_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP2_OUT_CONTROL's bit fields.
     */
    inline void get_EP2_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP2_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP2_OUT_CONTROL's bit fields.
     */
    inline void set_EP2_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP2_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP2_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP2_OUT_CONTROL = curr;
    }

    /**
     * Get EP3_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP3_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP3_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP3_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP3_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP3_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP3_IN_CONTROL = curr;
    }

    /**
     * Get EP3_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP3_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP3_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP3_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP3_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP3_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP3_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP3_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP3_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP3_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP3_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP3_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP3_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP3_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP3_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP3_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP3_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP3_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP3_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP3_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP3_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP3_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP3_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP3_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP3_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE
    get_EP3_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE(
            (EP3_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP3_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP3_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP3_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP3_IN_CONTROL = curr;
    }

    /**
     * Get EP3_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP3_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP3_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP3_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP3_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP3_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP3_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP3_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP3_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP3_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP3_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP3_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP3_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP3_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP3_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP3_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP3_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP3_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP3_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP3_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP3_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP3_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP3_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP3_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP3_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP3_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP3_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP3_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP3_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP3_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP3_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP3_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP3_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP3_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP3_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP3_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP3_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP3_IN_CONTROL_ENABLE() volatile
    {
        return EP3_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP3_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP3_IN_CONTROL_ENABLE() volatile
    {
        EP3_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP3_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP3_IN_CONTROL_ENABLE() volatile
    {
        EP3_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP3_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP3_IN_CONTROL_ENABLE() volatile
    {
        EP3_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP3_IN_CONTROL's bit fields.
     */
    inline void get_EP3_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP3_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP3_IN_CONTROL's bit fields.
     */
    inline void set_EP3_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP3_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP3_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP3_IN_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP3_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP3_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP3_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP3_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP3_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP3_OUT_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP3_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP3_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP3_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP3_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP3_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP3_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP3_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP3_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP3_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP3_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP3_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP3_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP3_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP3_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP3_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP3_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP3_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP3_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP3_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP3_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP3_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP3_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP3_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP3_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE
    get_EP3_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE(
            (EP3_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP3_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP3_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP3_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP3_OUT_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP3_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP3_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP3_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP3_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP3_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP3_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP3_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP3_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP3_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP3_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP3_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP3_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP3_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP3_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP3_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP3_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP3_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP3_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP3_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP3_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP3_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP3_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP3_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP3_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP3_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP3_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP3_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP3_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP3_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP3_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP3_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP3_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP3_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP3_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP3_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP3_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP3_OUT_CONTROL_ENABLE() volatile
    {
        return EP3_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP3_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP3_OUT_CONTROL_ENABLE() volatile
    {
        EP3_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP3_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP3_OUT_CONTROL_ENABLE() volatile
    {
        EP3_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP3_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP3_OUT_CONTROL_ENABLE() volatile
    {
        EP3_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP3_OUT_CONTROL's bit fields.
     */
    inline void get_EP3_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP3_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP3_OUT_CONTROL's bit fields.
     */
    inline void set_EP3_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP3_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP3_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP3_OUT_CONTROL = curr;
    }

    /**
     * Get EP4_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP4_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP4_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP4_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP4_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP4_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP4_IN_CONTROL = curr;
    }

    /**
     * Get EP4_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP4_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP4_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP4_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP4_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP4_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP4_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP4_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP4_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP4_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP4_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP4_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP4_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP4_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP4_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP4_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP4_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP4_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP4_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP4_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP4_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP4_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP4_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP4_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP4_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE
    get_EP4_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE(
            (EP4_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP4_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP4_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP4_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP4_IN_CONTROL = curr;
    }

    /**
     * Get EP4_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP4_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP4_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP4_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP4_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP4_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP4_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP4_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP4_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP4_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP4_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP4_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP4_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP4_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP4_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP4_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP4_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP4_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP4_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP4_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP4_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP4_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP4_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP4_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP4_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP4_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP4_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP4_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP4_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP4_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP4_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP4_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP4_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP4_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP4_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP4_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP4_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP4_IN_CONTROL_ENABLE() volatile
    {
        return EP4_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP4_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP4_IN_CONTROL_ENABLE() volatile
    {
        EP4_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP4_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP4_IN_CONTROL_ENABLE() volatile
    {
        EP4_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP4_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP4_IN_CONTROL_ENABLE() volatile
    {
        EP4_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP4_IN_CONTROL's bit fields.
     */
    inline void get_EP4_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP4_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP4_IN_CONTROL's bit fields.
     */
    inline void set_EP4_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP4_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP4_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP4_IN_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP4_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP4_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP4_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP4_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP4_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP4_OUT_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP4_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP4_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP4_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP4_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP4_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP4_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP4_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP4_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP4_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP4_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP4_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP4_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP4_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP4_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP4_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP4_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP4_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP4_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP4_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP4_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP4_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP4_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP4_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP4_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE
    get_EP4_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE(
            (EP4_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP4_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP4_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP4_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP4_OUT_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP4_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP4_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP4_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP4_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP4_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP4_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP4_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP4_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP4_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP4_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP4_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP4_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP4_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP4_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP4_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP4_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP4_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP4_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP4_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP4_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP4_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP4_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP4_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP4_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP4_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP4_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP4_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP4_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP4_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP4_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP4_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP4_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP4_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP4_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP4_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP4_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP4_OUT_CONTROL_ENABLE() volatile
    {
        return EP4_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP4_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP4_OUT_CONTROL_ENABLE() volatile
    {
        EP4_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP4_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP4_OUT_CONTROL_ENABLE() volatile
    {
        EP4_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP4_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP4_OUT_CONTROL_ENABLE() volatile
    {
        EP4_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP4_OUT_CONTROL's bit fields.
     */
    inline void get_EP4_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP4_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP4_OUT_CONTROL's bit fields.
     */
    inline void set_EP4_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP4_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP4_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP4_OUT_CONTROL = curr;
    }

    /**
     * Get EP5_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP5_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP5_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP5_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP5_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP5_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP5_IN_CONTROL = curr;
    }

    /**
     * Get EP5_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP5_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP5_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP5_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP5_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP5_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP5_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP5_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP5_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP5_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP5_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP5_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP5_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP5_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP5_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP5_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP5_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP5_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP5_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP5_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP5_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP5_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP5_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP5_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP5_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE
    get_EP5_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE(
            (EP5_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP5_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP5_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP5_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP5_IN_CONTROL = curr;
    }

    /**
     * Get EP5_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP5_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP5_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP5_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP5_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP5_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP5_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP5_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP5_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP5_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP5_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP5_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP5_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP5_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP5_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP5_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP5_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP5_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP5_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP5_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP5_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP5_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP5_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP5_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP5_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP5_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP5_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP5_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP5_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP5_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP5_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP5_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP5_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP5_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP5_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP5_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP5_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP5_IN_CONTROL_ENABLE() volatile
    {
        return EP5_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP5_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP5_IN_CONTROL_ENABLE() volatile
    {
        EP5_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP5_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP5_IN_CONTROL_ENABLE() volatile
    {
        EP5_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP5_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP5_IN_CONTROL_ENABLE() volatile
    {
        EP5_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP5_IN_CONTROL's bit fields.
     */
    inline void get_EP5_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP5_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP5_IN_CONTROL's bit fields.
     */
    inline void set_EP5_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP5_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP5_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP5_IN_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP5_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP5_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP5_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP5_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP5_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP5_OUT_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP5_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP5_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP5_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP5_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP5_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP5_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP5_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP5_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP5_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP5_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP5_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP5_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP5_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP5_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP5_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP5_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP5_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP5_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP5_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP5_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP5_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP5_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP5_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP5_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE
    get_EP5_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE(
            (EP5_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP5_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP5_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP5_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP5_OUT_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP5_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP5_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP5_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP5_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP5_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP5_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP5_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP5_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP5_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP5_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP5_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP5_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP5_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP5_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP5_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP5_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP5_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP5_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP5_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP5_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP5_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP5_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP5_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP5_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP5_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP5_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP5_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP5_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP5_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP5_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP5_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP5_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP5_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP5_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP5_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP5_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP5_OUT_CONTROL_ENABLE() volatile
    {
        return EP5_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP5_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP5_OUT_CONTROL_ENABLE() volatile
    {
        EP5_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP5_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP5_OUT_CONTROL_ENABLE() volatile
    {
        EP5_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP5_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP5_OUT_CONTROL_ENABLE() volatile
    {
        EP5_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP5_OUT_CONTROL's bit fields.
     */
    inline void get_EP5_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP5_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP5_OUT_CONTROL's bit fields.
     */
    inline void set_EP5_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP5_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP5_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP5_OUT_CONTROL = curr;
    }

    /**
     * Get EP6_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP6_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP6_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP6_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP6_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP6_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP6_IN_CONTROL = curr;
    }

    /**
     * Get EP6_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP6_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP6_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP6_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP6_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP6_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP6_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP6_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP6_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP6_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP6_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP6_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP6_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP6_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP6_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP6_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP6_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP6_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP6_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP6_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP6_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP6_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP6_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP6_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP6_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE
    get_EP6_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE(
            (EP6_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP6_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP6_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP6_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP6_IN_CONTROL = curr;
    }

    /**
     * Get EP6_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP6_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP6_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP6_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP6_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP6_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP6_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP6_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP6_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP6_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP6_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP6_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP6_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP6_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP6_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP6_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP6_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP6_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP6_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP6_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP6_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP6_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP6_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP6_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP6_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP6_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP6_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP6_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP6_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP6_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP6_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP6_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP6_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP6_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP6_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP6_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP6_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP6_IN_CONTROL_ENABLE() volatile
    {
        return EP6_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP6_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP6_IN_CONTROL_ENABLE() volatile
    {
        EP6_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP6_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP6_IN_CONTROL_ENABLE() volatile
    {
        EP6_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP6_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP6_IN_CONTROL_ENABLE() volatile
    {
        EP6_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP6_IN_CONTROL's bit fields.
     */
    inline void get_EP6_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP6_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP6_IN_CONTROL's bit fields.
     */
    inline void set_EP6_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP6_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP6_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP6_IN_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP6_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP6_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP6_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP6_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP6_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP6_OUT_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP6_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP6_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP6_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP6_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP6_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP6_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP6_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP6_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP6_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP6_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP6_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP6_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP6_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP6_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP6_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP6_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP6_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP6_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP6_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP6_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP6_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP6_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP6_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP6_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE
    get_EP6_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE(
            (EP6_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP6_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP6_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP6_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP6_OUT_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP6_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP6_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP6_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP6_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP6_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP6_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP6_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP6_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP6_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP6_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP6_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP6_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP6_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP6_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP6_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP6_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP6_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP6_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP6_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP6_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP6_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP6_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP6_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP6_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP6_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP6_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP6_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP6_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP6_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP6_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP6_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP6_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP6_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP6_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP6_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP6_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP6_OUT_CONTROL_ENABLE() volatile
    {
        return EP6_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP6_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP6_OUT_CONTROL_ENABLE() volatile
    {
        EP6_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP6_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP6_OUT_CONTROL_ENABLE() volatile
    {
        EP6_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP6_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP6_OUT_CONTROL_ENABLE() volatile
    {
        EP6_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP6_OUT_CONTROL's bit fields.
     */
    inline void get_EP6_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP6_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP6_OUT_CONTROL's bit fields.
     */
    inline void set_EP6_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP6_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP6_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP6_OUT_CONTROL = curr;
    }

    /**
     * Get EP7_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP7_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP7_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP7_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP7_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP7_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP7_IN_CONTROL = curr;
    }

    /**
     * Get EP7_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP7_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP7_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP7_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP7_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP7_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP7_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP7_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP7_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP7_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP7_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP7_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP7_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP7_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP7_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP7_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP7_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP7_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP7_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP7_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP7_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP7_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP7_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP7_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP7_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE
    get_EP7_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE(
            (EP7_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP7_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP7_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP7_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP7_IN_CONTROL = curr;
    }

    /**
     * Get EP7_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP7_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP7_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP7_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP7_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP7_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP7_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP7_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP7_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP7_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP7_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP7_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP7_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP7_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP7_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP7_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP7_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP7_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP7_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP7_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP7_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP7_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP7_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP7_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP7_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP7_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP7_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP7_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP7_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP7_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP7_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP7_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP7_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP7_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP7_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP7_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP7_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP7_IN_CONTROL_ENABLE() volatile
    {
        return EP7_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP7_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP7_IN_CONTROL_ENABLE() volatile
    {
        EP7_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP7_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP7_IN_CONTROL_ENABLE() volatile
    {
        EP7_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP7_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP7_IN_CONTROL_ENABLE() volatile
    {
        EP7_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP7_IN_CONTROL's bit fields.
     */
    inline void get_EP7_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP7_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP7_IN_CONTROL's bit fields.
     */
    inline void set_EP7_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP7_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP7_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP7_IN_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP7_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP7_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP7_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP7_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP7_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP7_OUT_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP7_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP7_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP7_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP7_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP7_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP7_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP7_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP7_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP7_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP7_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP7_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP7_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP7_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP7_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP7_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP7_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP7_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP7_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP7_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP7_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP7_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP7_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP7_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP7_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE
    get_EP7_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE(
            (EP7_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP7_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP7_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP7_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP7_OUT_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP7_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP7_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP7_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP7_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP7_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP7_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP7_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP7_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP7_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP7_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP7_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP7_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP7_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP7_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP7_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP7_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP7_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP7_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP7_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP7_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP7_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP7_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP7_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP7_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP7_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP7_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP7_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP7_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP7_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP7_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP7_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP7_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP7_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP7_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP7_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP7_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP7_OUT_CONTROL_ENABLE() volatile
    {
        return EP7_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP7_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP7_OUT_CONTROL_ENABLE() volatile
    {
        EP7_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP7_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP7_OUT_CONTROL_ENABLE() volatile
    {
        EP7_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP7_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP7_OUT_CONTROL_ENABLE() volatile
    {
        EP7_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP7_OUT_CONTROL's bit fields.
     */
    inline void get_EP7_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP7_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP7_OUT_CONTROL's bit fields.
     */
    inline void set_EP7_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP7_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP7_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP7_OUT_CONTROL = curr;
    }

    /**
     * Get EP8_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP8_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP8_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP8_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP8_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP8_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP8_IN_CONTROL = curr;
    }

    /**
     * Get EP8_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP8_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP8_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP8_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP8_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP8_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP8_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP8_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP8_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP8_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP8_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP8_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP8_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP8_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP8_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP8_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP8_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP8_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP8_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP8_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP8_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP8_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP8_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP8_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP8_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE
    get_EP8_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE(
            (EP8_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP8_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP8_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP8_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP8_IN_CONTROL = curr;
    }

    /**
     * Get EP8_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP8_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP8_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP8_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP8_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP8_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP8_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP8_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP8_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP8_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP8_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP8_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP8_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP8_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP8_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP8_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP8_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP8_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP8_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP8_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP8_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP8_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP8_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP8_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP8_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP8_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP8_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP8_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP8_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP8_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP8_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP8_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP8_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP8_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP8_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP8_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP8_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP8_IN_CONTROL_ENABLE() volatile
    {
        return EP8_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP8_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP8_IN_CONTROL_ENABLE() volatile
    {
        EP8_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP8_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP8_IN_CONTROL_ENABLE() volatile
    {
        EP8_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP8_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP8_IN_CONTROL_ENABLE() volatile
    {
        EP8_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP8_IN_CONTROL's bit fields.
     */
    inline void get_EP8_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP8_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP8_IN_CONTROL's bit fields.
     */
    inline void set_EP8_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP8_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP8_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP8_IN_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP8_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP8_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP8_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP8_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP8_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP8_OUT_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP8_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP8_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP8_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP8_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP8_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP8_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP8_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP8_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP8_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP8_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP8_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP8_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP8_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP8_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP8_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP8_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP8_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP8_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP8_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP8_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP8_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP8_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP8_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP8_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE
    get_EP8_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE(
            (EP8_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP8_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP8_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP8_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP8_OUT_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP8_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP8_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP8_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP8_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP8_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP8_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP8_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP8_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP8_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP8_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP8_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP8_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP8_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP8_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP8_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP8_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP8_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP8_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP8_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP8_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP8_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP8_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP8_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP8_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP8_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP8_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP8_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP8_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP8_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP8_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP8_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP8_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP8_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP8_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP8_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP8_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP8_OUT_CONTROL_ENABLE() volatile
    {
        return EP8_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP8_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP8_OUT_CONTROL_ENABLE() volatile
    {
        EP8_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP8_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP8_OUT_CONTROL_ENABLE() volatile
    {
        EP8_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP8_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP8_OUT_CONTROL_ENABLE() volatile
    {
        EP8_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP8_OUT_CONTROL's bit fields.
     */
    inline void get_EP8_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP8_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP8_OUT_CONTROL's bit fields.
     */
    inline void set_EP8_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP8_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP8_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP8_OUT_CONTROL = curr;
    }

    /**
     * Get EP9_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP9_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP9_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP9_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP9_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP9_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP9_IN_CONTROL = curr;
    }

    /**
     * Get EP9_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP9_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP9_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP9_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP9_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP9_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP9_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP9_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP9_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP9_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP9_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP9_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP9_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP9_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP9_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP9_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP9_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP9_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP9_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP9_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP9_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP9_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP9_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP9_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP9_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE
    get_EP9_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE(
            (EP9_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP9_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP9_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP9_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP9_IN_CONTROL = curr;
    }

    /**
     * Get EP9_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP9_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP9_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP9_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP9_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP9_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP9_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP9_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP9_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP9_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP9_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP9_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP9_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP9_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP9_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP9_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP9_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP9_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP9_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP9_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP9_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP9_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP9_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP9_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP9_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP9_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP9_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP9_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP9_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP9_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP9_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP9_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP9_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP9_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP9_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP9_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP9_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP9_IN_CONTROL_ENABLE() volatile
    {
        return EP9_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP9_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP9_IN_CONTROL_ENABLE() volatile
    {
        EP9_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP9_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP9_IN_CONTROL_ENABLE() volatile
    {
        EP9_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP9_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP9_IN_CONTROL_ENABLE() volatile
    {
        EP9_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP9_IN_CONTROL's bit fields.
     */
    inline void get_EP9_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP9_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP9_IN_CONTROL's bit fields.
     */
    inline void set_EP9_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP9_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP9_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP9_IN_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP9_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP9_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP9_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP9_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP9_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP9_OUT_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP9_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP9_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP9_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP9_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP9_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP9_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP9_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP9_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP9_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP9_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP9_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP9_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP9_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP9_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP9_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP9_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP9_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP9_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP9_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP9_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP9_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP9_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP9_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP9_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE
    get_EP9_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE(
            (EP9_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP9_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP9_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP9_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP9_OUT_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP9_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP9_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP9_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP9_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP9_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP9_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP9_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP9_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP9_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP9_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP9_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP9_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP9_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP9_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP9_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP9_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP9_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP9_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP9_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP9_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP9_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP9_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP9_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP9_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP9_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP9_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP9_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP9_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP9_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP9_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP9_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP9_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP9_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP9_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP9_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP9_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP9_OUT_CONTROL_ENABLE() volatile
    {
        return EP9_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP9_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP9_OUT_CONTROL_ENABLE() volatile
    {
        EP9_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP9_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP9_OUT_CONTROL_ENABLE() volatile
    {
        EP9_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP9_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP9_OUT_CONTROL_ENABLE() volatile
    {
        EP9_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP9_OUT_CONTROL's bit fields.
     */
    inline void get_EP9_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP9_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP9_OUT_CONTROL's bit fields.
     */
    inline void set_EP9_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP9_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP9_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP9_OUT_CONTROL = curr;
    }

    /**
     * Get EP10_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP10_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP10_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP10_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP10_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP10_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP10_IN_CONTROL = curr;
    }

    /**
     * Get EP10_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP10_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP10_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP10_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP10_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP10_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP10_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP10_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP10_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP10_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP10_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP10_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP10_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP10_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP10_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP10_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP10_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP10_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP10_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP10_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP10_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP10_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP10_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP10_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP10_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE
    get_EP10_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE(
            (EP10_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP10_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP10_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP10_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP10_IN_CONTROL = curr;
    }

    /**
     * Get EP10_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP10_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP10_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP10_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP10_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP10_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP10_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP10_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP10_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP10_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP10_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP10_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP10_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP10_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP10_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP10_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP10_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP10_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP10_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP10_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP10_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP10_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP10_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP10_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP10_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP10_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP10_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP10_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP10_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP10_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP10_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP10_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP10_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP10_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP10_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP10_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP10_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP10_IN_CONTROL_ENABLE() volatile
    {
        return EP10_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP10_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP10_IN_CONTROL_ENABLE() volatile
    {
        EP10_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP10_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP10_IN_CONTROL_ENABLE() volatile
    {
        EP10_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP10_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP10_IN_CONTROL_ENABLE() volatile
    {
        EP10_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP10_IN_CONTROL's bit fields.
     */
    inline void get_EP10_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP10_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP10_IN_CONTROL's bit fields.
     */
    inline void set_EP10_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP10_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP10_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP10_IN_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP10_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP10_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP10_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP10_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP10_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP10_OUT_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP10_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP10_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP10_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP10_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP10_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP10_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP10_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP10_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP10_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP10_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP10_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP10_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP10_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP10_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP10_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP10_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP10_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP10_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP10_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP10_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP10_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP10_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP10_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP10_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE
    get_EP10_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE(
            (EP10_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP10_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP10_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP10_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP10_OUT_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP10_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP10_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP10_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP10_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP10_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP10_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP10_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP10_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP10_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP10_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP10_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP10_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP10_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP10_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP10_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP10_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP10_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP10_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP10_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP10_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP10_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP10_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP10_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP10_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP10_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP10_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP10_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP10_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP10_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP10_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP10_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP10_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP10_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP10_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP10_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP10_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP10_OUT_CONTROL_ENABLE() volatile
    {
        return EP10_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP10_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP10_OUT_CONTROL_ENABLE() volatile
    {
        EP10_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP10_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP10_OUT_CONTROL_ENABLE() volatile
    {
        EP10_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP10_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP10_OUT_CONTROL_ENABLE() volatile
    {
        EP10_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP10_OUT_CONTROL's bit fields.
     */
    inline void get_EP10_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP10_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE = USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE(
            (curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP10_OUT_CONTROL's bit fields.
     */
    inline void set_EP10_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP10_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP10_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP10_OUT_CONTROL = curr;
    }

    /**
     * Get EP11_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP11_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP11_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP11_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP11_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP11_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP11_IN_CONTROL = curr;
    }

    /**
     * Get EP11_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP11_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP11_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP11_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP11_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP11_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP11_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP11_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP11_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP11_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP11_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP11_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP11_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP11_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP11_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP11_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP11_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP11_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP11_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP11_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP11_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP11_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP11_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP11_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP11_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE
    get_EP11_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE(
            (EP11_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP11_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP11_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP11_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP11_IN_CONTROL = curr;
    }

    /**
     * Get EP11_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP11_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP11_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP11_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP11_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP11_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP11_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP11_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP11_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP11_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP11_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP11_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP11_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP11_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP11_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP11_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP11_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP11_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP11_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP11_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP11_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP11_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP11_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP11_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP11_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP11_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP11_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP11_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP11_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP11_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP11_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP11_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP11_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP11_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP11_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP11_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP11_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP11_IN_CONTROL_ENABLE() volatile
    {
        return EP11_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP11_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP11_IN_CONTROL_ENABLE() volatile
    {
        EP11_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP11_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP11_IN_CONTROL_ENABLE() volatile
    {
        EP11_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP11_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP11_IN_CONTROL_ENABLE() volatile
    {
        EP11_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP11_IN_CONTROL's bit fields.
     */
    inline void get_EP11_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP11_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP11_IN_CONTROL's bit fields.
     */
    inline void set_EP11_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP11_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP11_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP11_IN_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP11_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP11_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP11_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP11_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP11_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP11_OUT_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP11_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP11_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP11_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP11_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP11_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP11_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP11_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP11_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP11_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP11_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP11_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP11_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP11_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP11_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP11_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP11_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP11_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP11_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP11_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP11_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP11_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP11_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP11_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP11_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE
    get_EP11_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE(
            (EP11_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP11_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP11_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP11_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP11_OUT_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP11_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP11_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP11_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP11_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP11_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP11_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP11_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP11_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP11_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP11_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP11_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP11_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP11_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP11_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP11_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP11_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP11_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP11_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP11_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP11_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP11_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP11_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP11_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP11_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP11_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP11_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP11_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP11_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP11_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP11_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP11_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP11_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP11_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP11_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP11_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP11_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP11_OUT_CONTROL_ENABLE() volatile
    {
        return EP11_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP11_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP11_OUT_CONTROL_ENABLE() volatile
    {
        EP11_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP11_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP11_OUT_CONTROL_ENABLE() volatile
    {
        EP11_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP11_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP11_OUT_CONTROL_ENABLE() volatile
    {
        EP11_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP11_OUT_CONTROL's bit fields.
     */
    inline void get_EP11_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP11_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE = USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE(
            (curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP11_OUT_CONTROL's bit fields.
     */
    inline void set_EP11_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP11_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP11_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP11_OUT_CONTROL = curr;
    }

    /**
     * Get EP12_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP12_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP12_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP12_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP12_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP12_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP12_IN_CONTROL = curr;
    }

    /**
     * Get EP12_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP12_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP12_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP12_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP12_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP12_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP12_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP12_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP12_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP12_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP12_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP12_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP12_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP12_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP12_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP12_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP12_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP12_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP12_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP12_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP12_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP12_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP12_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP12_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP12_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE
    get_EP12_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE(
            (EP12_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP12_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP12_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP12_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP12_IN_CONTROL = curr;
    }

    /**
     * Get EP12_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP12_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP12_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP12_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP12_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP12_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP12_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP12_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP12_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP12_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP12_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP12_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP12_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP12_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP12_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP12_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP12_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP12_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP12_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP12_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP12_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP12_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP12_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP12_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP12_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP12_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP12_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP12_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP12_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP12_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP12_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP12_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP12_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP12_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP12_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP12_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP12_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP12_IN_CONTROL_ENABLE() volatile
    {
        return EP12_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP12_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP12_IN_CONTROL_ENABLE() volatile
    {
        EP12_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP12_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP12_IN_CONTROL_ENABLE() volatile
    {
        EP12_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP12_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP12_IN_CONTROL_ENABLE() volatile
    {
        EP12_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP12_IN_CONTROL's bit fields.
     */
    inline void get_EP12_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP12_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP12_IN_CONTROL's bit fields.
     */
    inline void set_EP12_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP12_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP12_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP12_IN_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP12_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP12_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP12_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP12_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP12_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP12_OUT_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP12_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP12_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP12_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP12_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP12_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP12_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP12_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP12_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP12_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP12_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP12_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP12_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP12_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP12_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP12_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP12_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP12_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP12_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP12_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP12_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP12_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP12_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP12_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP12_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE
    get_EP12_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE(
            (EP12_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP12_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP12_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP12_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP12_OUT_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP12_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP12_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP12_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP12_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP12_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP12_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP12_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP12_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP12_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP12_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP12_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP12_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP12_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP12_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP12_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP12_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP12_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP12_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP12_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP12_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP12_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP12_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP12_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP12_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP12_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP12_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP12_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP12_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP12_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP12_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP12_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP12_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP12_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP12_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP12_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP12_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP12_OUT_CONTROL_ENABLE() volatile
    {
        return EP12_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP12_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP12_OUT_CONTROL_ENABLE() volatile
    {
        EP12_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP12_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP12_OUT_CONTROL_ENABLE() volatile
    {
        EP12_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP12_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP12_OUT_CONTROL_ENABLE() volatile
    {
        EP12_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP12_OUT_CONTROL's bit fields.
     */
    inline void get_EP12_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP12_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE = USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE(
            (curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP12_OUT_CONTROL's bit fields.
     */
    inline void set_EP12_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP12_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP12_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP12_OUT_CONTROL = curr;
    }

    /**
     * Get EP13_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP13_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP13_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP13_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP13_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP13_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP13_IN_CONTROL = curr;
    }

    /**
     * Get EP13_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP13_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP13_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP13_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP13_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP13_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP13_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP13_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP13_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP13_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP13_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP13_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP13_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP13_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP13_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP13_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP13_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP13_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP13_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP13_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP13_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP13_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP13_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP13_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP13_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE
    get_EP13_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE(
            (EP13_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP13_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP13_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP13_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP13_IN_CONTROL = curr;
    }

    /**
     * Get EP13_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP13_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP13_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP13_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP13_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP13_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP13_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP13_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP13_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP13_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP13_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP13_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP13_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP13_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP13_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP13_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP13_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP13_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP13_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP13_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP13_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP13_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP13_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP13_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP13_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP13_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP13_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP13_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP13_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP13_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP13_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP13_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP13_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP13_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP13_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP13_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP13_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP13_IN_CONTROL_ENABLE() volatile
    {
        return EP13_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP13_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP13_IN_CONTROL_ENABLE() volatile
    {
        EP13_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP13_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP13_IN_CONTROL_ENABLE() volatile
    {
        EP13_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP13_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP13_IN_CONTROL_ENABLE() volatile
    {
        EP13_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP13_IN_CONTROL's bit fields.
     */
    inline void get_EP13_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP13_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP13_IN_CONTROL's bit fields.
     */
    inline void set_EP13_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP13_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP13_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP13_IN_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP13_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP13_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP13_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP13_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP13_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP13_OUT_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP13_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP13_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP13_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP13_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP13_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP13_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP13_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP13_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP13_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP13_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP13_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP13_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP13_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP13_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP13_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP13_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP13_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP13_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP13_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP13_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP13_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP13_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP13_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP13_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE
    get_EP13_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE(
            (EP13_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP13_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP13_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP13_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP13_OUT_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP13_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP13_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP13_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP13_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP13_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP13_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP13_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP13_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP13_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP13_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP13_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP13_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP13_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP13_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP13_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP13_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP13_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP13_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP13_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP13_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP13_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP13_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP13_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP13_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP13_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP13_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP13_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP13_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP13_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP13_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP13_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP13_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP13_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP13_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP13_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP13_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP13_OUT_CONTROL_ENABLE() volatile
    {
        return EP13_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP13_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP13_OUT_CONTROL_ENABLE() volatile
    {
        EP13_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP13_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP13_OUT_CONTROL_ENABLE() volatile
    {
        EP13_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP13_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP13_OUT_CONTROL_ENABLE() volatile
    {
        EP13_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP13_OUT_CONTROL's bit fields.
     */
    inline void get_EP13_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP13_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE = USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE(
            (curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP13_OUT_CONTROL's bit fields.
     */
    inline void set_EP13_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP13_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP13_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP13_OUT_CONTROL = curr;
    }

    /**
     * Get EP14_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP14_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP14_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP14_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP14_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP14_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP14_IN_CONTROL = curr;
    }

    /**
     * Get EP14_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP14_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP14_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP14_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP14_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP14_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP14_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP14_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP14_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP14_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP14_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP14_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP14_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP14_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP14_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP14_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP14_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP14_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP14_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP14_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP14_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP14_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP14_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP14_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP14_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE
    get_EP14_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE(
            (EP14_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP14_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP14_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP14_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP14_IN_CONTROL = curr;
    }

    /**
     * Get EP14_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP14_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP14_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP14_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP14_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP14_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP14_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP14_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP14_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP14_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP14_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP14_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP14_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP14_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP14_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP14_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP14_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP14_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP14_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP14_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP14_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP14_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP14_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP14_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP14_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP14_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP14_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP14_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP14_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP14_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP14_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP14_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP14_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP14_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP14_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP14_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP14_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP14_IN_CONTROL_ENABLE() volatile
    {
        return EP14_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP14_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP14_IN_CONTROL_ENABLE() volatile
    {
        EP14_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP14_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP14_IN_CONTROL_ENABLE() volatile
    {
        EP14_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP14_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP14_IN_CONTROL_ENABLE() volatile
    {
        EP14_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP14_IN_CONTROL's bit fields.
     */
    inline void get_EP14_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP14_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP14_IN_CONTROL's bit fields.
     */
    inline void set_EP14_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP14_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP14_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP14_IN_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP14_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP14_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP14_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP14_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP14_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP14_OUT_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP14_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP14_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP14_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP14_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP14_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP14_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP14_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP14_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP14_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP14_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP14_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP14_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP14_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP14_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP14_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP14_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP14_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP14_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP14_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP14_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP14_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP14_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP14_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP14_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE
    get_EP14_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE(
            (EP14_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP14_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP14_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP14_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP14_OUT_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP14_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP14_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP14_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP14_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP14_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP14_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP14_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP14_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP14_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP14_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP14_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP14_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP14_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP14_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP14_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP14_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP14_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP14_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP14_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP14_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP14_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP14_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP14_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP14_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP14_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP14_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP14_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP14_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP14_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP14_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP14_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP14_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP14_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP14_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP14_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP14_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP14_OUT_CONTROL_ENABLE() volatile
    {
        return EP14_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP14_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP14_OUT_CONTROL_ENABLE() volatile
    {
        EP14_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP14_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP14_OUT_CONTROL_ENABLE() volatile
    {
        EP14_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP14_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP14_OUT_CONTROL_ENABLE() volatile
    {
        EP14_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP14_OUT_CONTROL's bit fields.
     */
    inline void get_EP14_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP14_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE = USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE(
            (curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP14_OUT_CONTROL's bit fields.
     */
    inline void set_EP14_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP14_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP14_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP14_OUT_CONTROL = curr;
    }

    /**
     * Get EP15_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP15_IN_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP15_IN_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP15_IN_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP15_IN_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP15_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP15_IN_CONTROL = curr;
    }

    /**
     * Get EP15_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP15_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP15_IN_CONTROL & (1u << 16u);
    }

    /**
     * Set EP15_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP15_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP15_IN_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP15_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP15_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP15_IN_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP15_IN_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP15_IN_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP15_IN_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP15_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP15_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP15_IN_CONTROL & (1u << 17u);
    }

    /**
     * Set EP15_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP15_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP15_IN_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP15_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP15_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP15_IN_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP15_IN_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP15_IN_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP15_IN_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP15_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE
    get_EP15_IN_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE(
            (EP15_IN_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP15_IN_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP15_IN_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP15_IN_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP15_IN_CONTROL = curr;
    }

    /**
     * Get EP15_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP15_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP15_IN_CONTROL & (1u << 28u);
    }

    /**
     * Set EP15_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP15_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP15_IN_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP15_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP15_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP15_IN_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP15_IN_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP15_IN_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP15_IN_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP15_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP15_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP15_IN_CONTROL & (1u << 29u);
    }

    /**
     * Set EP15_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP15_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP15_IN_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP15_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP15_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP15_IN_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP15_IN_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP15_IN_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP15_IN_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP15_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP15_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP15_IN_CONTROL & (1u << 30u);
    }

    /**
     * Set EP15_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP15_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP15_IN_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP15_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP15_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP15_IN_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP15_IN_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP15_IN_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP15_IN_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP15_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP15_IN_CONTROL_ENABLE() volatile
    {
        return EP15_IN_CONTROL & (1u << 31u);
    }

    /**
     * Set EP15_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP15_IN_CONTROL_ENABLE() volatile
    {
        EP15_IN_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP15_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP15_IN_CONTROL_ENABLE() volatile
    {
        EP15_IN_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP15_IN_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP15_IN_CONTROL_ENABLE() volatile
    {
        EP15_IN_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP15_IN_CONTROL's bit fields.
     */
    inline void get_EP15_IN_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP15_IN_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE =
            USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE((curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP15_IN_CONTROL's bit fields.
     */
    inline void set_EP15_IN_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP15_IN_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP15_IN_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP15_IN_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline uint16_t get_EP15_OUT_CONTROL_BUFFER_ADDRESS() volatile
    {
        return (EP15_OUT_CONTROL >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set EP15_OUT_CONTROL's BUFFER_ADDRESS field.
     *
     * 64 byte aligned buffer address for this EP (bits 0-5 are ignored).
     * Relative to the start of the DPRAM.
     */
    inline void set_EP15_OUT_CONTROL_BUFFER_ADDRESS(uint16_t value) volatile
    {
        uint32_t curr = EP15_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        EP15_OUT_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline bool get_EP15_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        return EP15_OUT_CONTROL & (1u << 16u);
    }

    /**
     * Set EP15_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void set_EP15_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP15_OUT_CONTROL |= 1u << 16u;
    }

    /**
     * Clear EP15_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void clear_EP15_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP15_OUT_CONTROL &= ~(1u << 16u);
    }

    /**
     * Toggle EP15_OUT_CONTROL's INTERRUPT_ON_NAK bit.
     *
     * Trigger an interrupt if a NAK is sent. Intended for debug only.
     */
    inline void toggle_EP15_OUT_CONTROL_INTERRUPT_ON_NAK() volatile
    {
        EP15_OUT_CONTROL ^= 1u << 16u;
    }

    /**
     * Get EP15_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline bool get_EP15_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        return EP15_OUT_CONTROL & (1u << 17u);
    }

    /**
     * Set EP15_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void set_EP15_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP15_OUT_CONTROL |= 1u << 17u;
    }

    /**
     * Clear EP15_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void clear_EP15_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP15_OUT_CONTROL &= ~(1u << 17u);
    }

    /**
     * Toggle EP15_OUT_CONTROL's INTERRUPT_ON_STALL bit.
     *
     * Trigger an interrupt if a STALL is sent. Intended for debug only.
     */
    inline void toggle_EP15_OUT_CONTROL_INTERRUPT_ON_STALL() volatile
    {
        EP15_OUT_CONTROL ^= 1u << 17u;
    }

    /**
     * Get EP15_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE
    get_EP15_OUT_CONTROL_ENDPOINT_TYPE() volatile
    {
        return USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE(
            (EP15_OUT_CONTROL >> 26u) & 0b11u);
    }

    /**
     * Set EP15_OUT_CONTROL's ENDPOINT_TYPE field.
     */
    inline void set_EP15_OUT_CONTROL_ENDPOINT_TYPE(
        USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE value) volatile
    {
        uint32_t curr = EP15_OUT_CONTROL;

        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(value) & 0b11u) << 26u;

        EP15_OUT_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline bool get_EP15_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        return EP15_OUT_CONTROL & (1u << 28u);
    }

    /**
     * Set EP15_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void set_EP15_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP15_OUT_CONTROL |= 1u << 28u;
    }

    /**
     * Clear EP15_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void clear_EP15_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP15_OUT_CONTROL &= ~(1u << 28u);
    }

    /**
     * Toggle EP15_OUT_CONTROL's INTERRUPT_PER_DOUBLE_BUFF bit.
     *
     * Trigger an interrupt each time both buffers are done. Only valid in
     * double buffered mode.
     */
    inline void toggle_EP15_OUT_CONTROL_INTERRUPT_PER_DOUBLE_BUFF() volatile
    {
        EP15_OUT_CONTROL ^= 1u << 28u;
    }

    /**
     * Get EP15_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline bool get_EP15_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        return EP15_OUT_CONTROL & (1u << 29u);
    }

    /**
     * Set EP15_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void set_EP15_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP15_OUT_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP15_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void clear_EP15_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP15_OUT_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP15_OUT_CONTROL's INTERRUPT_PER_BUFF bit.
     *
     * Trigger an interrupt each time a buffer is done.
     */
    inline void toggle_EP15_OUT_CONTROL_INTERRUPT_PER_BUFF() volatile
    {
        EP15_OUT_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP15_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline bool get_EP15_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        return EP15_OUT_CONTROL & (1u << 30u);
    }

    /**
     * Set EP15_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void set_EP15_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP15_OUT_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP15_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void clear_EP15_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP15_OUT_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP15_OUT_CONTROL's DOUBLE_BUFFERED bit.
     *
     * This endpoint is double buffered.
     */
    inline void toggle_EP15_OUT_CONTROL_DOUBLE_BUFFERED() volatile
    {
        EP15_OUT_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP15_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline bool get_EP15_OUT_CONTROL_ENABLE() volatile
    {
        return EP15_OUT_CONTROL & (1u << 31u);
    }

    /**
     * Set EP15_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void set_EP15_OUT_CONTROL_ENABLE() volatile
    {
        EP15_OUT_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP15_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void clear_EP15_OUT_CONTROL_ENABLE() volatile
    {
        EP15_OUT_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP15_OUT_CONTROL's ENABLE bit.
     *
     * Enable this endpoint. The device will not reply to any packets for this
     * endpoint if this bit is not set.
     */
    inline void toggle_EP15_OUT_CONTROL_ENABLE() volatile
    {
        EP15_OUT_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP15_OUT_CONTROL's bit fields.
     */
    inline void get_EP15_OUT_CONTROL(
        uint16_t &BUFFER_ADDRESS, bool &INTERRUPT_ON_NAK,
        bool &INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE &ENDPOINT_TYPE,
        bool &INTERRUPT_PER_DOUBLE_BUFF, bool &INTERRUPT_PER_BUFF,
        bool &DOUBLE_BUFFERED, bool &ENABLE) volatile
    {
        uint32_t curr = EP15_OUT_CONTROL;

        BUFFER_ADDRESS = (curr >> 0u) & 0b1111111111111111u;
        INTERRUPT_ON_NAK = curr & (1u << 16u);
        INTERRUPT_ON_STALL = curr & (1u << 17u);
        ENDPOINT_TYPE = USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE(
            (curr >> 26u) & 0b11u);
        INTERRUPT_PER_DOUBLE_BUFF = curr & (1u << 28u);
        INTERRUPT_PER_BUFF = curr & (1u << 29u);
        DOUBLE_BUFFERED = curr & (1u << 30u);
        ENABLE = curr & (1u << 31u);
    }

    /**
     * Set all of EP15_OUT_CONTROL's bit fields.
     */
    inline void set_EP15_OUT_CONTROL(
        uint16_t BUFFER_ADDRESS, bool INTERRUPT_ON_NAK,
        bool INTERRUPT_ON_STALL,
        USBCTRL_DPRAM_EP15_OUT_CONTROL_ENDPOINT_TYPE ENDPOINT_TYPE,
        bool INTERRUPT_PER_DOUBLE_BUFF, bool INTERRUPT_PER_BUFF,
        bool DOUBLE_BUFFERED, bool ENABLE) volatile
    {
        uint32_t curr = EP15_OUT_CONTROL;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (BUFFER_ADDRESS & 0b1111111111111111u) << 0u;
        curr &= ~(0b1u << 16u);
        curr |= (INTERRUPT_ON_NAK & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (INTERRUPT_ON_STALL & 0b1u) << 17u;
        curr &= ~(0b11u << 26u);
        curr |= (std::to_underlying(ENDPOINT_TYPE) & 0b11u) << 26u;
        curr &= ~(0b1u << 28u);
        curr |= (INTERRUPT_PER_DOUBLE_BUFF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (INTERRUPT_PER_BUFF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (DOUBLE_BUFFERED & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (ENABLE & 0b1u) << 31u;

        EP15_OUT_CONTROL = curr;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP0_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP0_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP0_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP0_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP0_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP0_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP0_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP0_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP0_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP0_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP0_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP0_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP0_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP0_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP0_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP0_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP0_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP0_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP0_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP0_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP0_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP0_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP0_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP0_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP0_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP0_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP0_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP0_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP0_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP0_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP0_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP0_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP0_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP0_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP0_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP0_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP0_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP0_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP0_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP0_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP0_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP0_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP0_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP0_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP0_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP0_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP0_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP0_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP0_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP0_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP0_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP0_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP0_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP0_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP0_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP0_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP0_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP0_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP0_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP0_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP1_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP1_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP1_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP1_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP1_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP1_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP1_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP1_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP1_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP1_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP1_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP1_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP1_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP1_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP1_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP1_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP1_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP1_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP1_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP1_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP1_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP1_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP1_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP1_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP1_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP1_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP1_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP1_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP1_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP1_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP1_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP1_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP1_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP1_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP1_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP1_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP1_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP1_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP1_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP1_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP1_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP1_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP1_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP1_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP1_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP1_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP1_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP1_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP1_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP1_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP1_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP1_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP1_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP1_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP1_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP1_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP1_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP1_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP1_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP1_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP2_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP2_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP2_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP2_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP2_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP2_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP2_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP2_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP2_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP2_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP2_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP2_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP2_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP2_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP2_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP2_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP2_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP2_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP2_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP2_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP2_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP2_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP2_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP2_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP2_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP2_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP2_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP2_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP2_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP2_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP2_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP2_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP2_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP2_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP2_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP2_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP2_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP2_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP2_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP2_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP2_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP2_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP2_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP2_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP2_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP2_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP2_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP2_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP2_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP2_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP2_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP2_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP2_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP2_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP2_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP2_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP2_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP2_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP2_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP2_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP3_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP3_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP3_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP3_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP3_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP3_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP3_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP3_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP3_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP3_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP3_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP3_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP3_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP3_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP3_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP3_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP3_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP3_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP3_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP3_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP3_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP3_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP3_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP3_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP3_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP3_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP3_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP3_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP3_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP3_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP3_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP3_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP3_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP3_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP3_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP3_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP3_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP3_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP3_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP3_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP3_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP3_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP3_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP3_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP3_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP3_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP3_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP3_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP3_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP3_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP3_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP3_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP3_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP3_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP3_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP3_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP3_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP3_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP3_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP3_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP4_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP4_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP4_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP4_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP4_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP4_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP4_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP4_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP4_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP4_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP4_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP4_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP4_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP4_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP4_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP4_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP4_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP4_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP4_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP4_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP4_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP4_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP4_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP4_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP4_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP4_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP4_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP4_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP4_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP4_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP4_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP4_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP4_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP4_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP4_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP4_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP4_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP4_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP4_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP4_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP4_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP4_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP4_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP4_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP4_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP4_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP4_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP4_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP4_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP4_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP4_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP4_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP4_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP4_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP4_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP4_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP4_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP4_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP4_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP4_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP5_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP5_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP5_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP5_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP5_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP5_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP5_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP5_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP5_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP5_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP5_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP5_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP5_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP5_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP5_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP5_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP5_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP5_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP5_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP5_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP5_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP5_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP5_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP5_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP5_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP5_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP5_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP5_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP5_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP5_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP5_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP5_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP5_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP5_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP5_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP5_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP5_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP5_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP5_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP5_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP5_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP5_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP5_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP5_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP5_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP5_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP5_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP5_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP5_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP5_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP5_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP5_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP5_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP5_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP5_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP5_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP5_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP5_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP5_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP5_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP6_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP6_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP6_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP6_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP6_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP6_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP6_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP6_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP6_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP6_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP6_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP6_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP6_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP6_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP6_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP6_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP6_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP6_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP6_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP6_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP6_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP6_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP6_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP6_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP6_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP6_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP6_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP6_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP6_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP6_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP6_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP6_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP6_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP6_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP6_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP6_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP6_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP6_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP6_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP6_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP6_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP6_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP6_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP6_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP6_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP6_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP6_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP6_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP6_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP6_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP6_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP6_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP6_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP6_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP6_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP6_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP6_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP6_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP6_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP6_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP7_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP7_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP7_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP7_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP7_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP7_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP7_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP7_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP7_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP7_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP7_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP7_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP7_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP7_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP7_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP7_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP7_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP7_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP7_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP7_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP7_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP7_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP7_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP7_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP7_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP7_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP7_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP7_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP7_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP7_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP7_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP7_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP7_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP7_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP7_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP7_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP7_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP7_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP7_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP7_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP7_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP7_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP7_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP7_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP7_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP7_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP7_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP7_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP7_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP7_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP7_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP7_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP7_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP7_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP7_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP7_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP7_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP7_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP7_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP7_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP8_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP8_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP8_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP8_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP8_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP8_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP8_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP8_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP8_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP8_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP8_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP8_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP8_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP8_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP8_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP8_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP8_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP8_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP8_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP8_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP8_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP8_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP8_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP8_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP8_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP8_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP8_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP8_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP8_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP8_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP8_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP8_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP8_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP8_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP8_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP8_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP8_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP8_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP8_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP8_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP8_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP8_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP8_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP8_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP8_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP8_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP8_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP8_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP8_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP8_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP8_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP8_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP8_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP8_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP8_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP8_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP8_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP8_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP8_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP8_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP9_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP9_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP9_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP9_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP9_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP9_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP9_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP9_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP9_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP9_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP9_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP9_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP9_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP9_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP9_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP9_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP9_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP9_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP9_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP9_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP9_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP9_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP9_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP9_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP9_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP9_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP9_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP9_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP9_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP9_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP9_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP9_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP9_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP9_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP9_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP9_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP9_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP9_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP9_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP9_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP9_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP9_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP9_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP9_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP9_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP9_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP9_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP9_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP9_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP9_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP9_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP9_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP9_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP9_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP9_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP9_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP9_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP9_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP9_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP9_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP10_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP10_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP10_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP10_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP10_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP10_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP10_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP10_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP10_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP10_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP10_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP10_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP10_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP10_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP10_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP10_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP10_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP10_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP10_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP10_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP10_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP10_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP10_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP10_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP10_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP10_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP10_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP10_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP10_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP10_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP10_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP10_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP10_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP10_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP10_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP10_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP10_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP10_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP10_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP10_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP10_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP10_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP10_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP10_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP10_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP10_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP10_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP10_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP10_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP10_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP10_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP10_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP10_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP10_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP10_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP10_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP10_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP10_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP10_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP10_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP11_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP11_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP11_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP11_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP11_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP11_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP11_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP11_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP11_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP11_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP11_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP11_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP11_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP11_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP11_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP11_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP11_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP11_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP11_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP11_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP11_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP11_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP11_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP11_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP11_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP11_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP11_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP11_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP11_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP11_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP11_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP11_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP11_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP11_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP11_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP11_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP11_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP11_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP11_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP11_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP11_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP11_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP11_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP11_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP11_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP11_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP11_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP11_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP11_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP11_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP11_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP11_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP11_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP11_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP11_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP11_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP11_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP11_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP11_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP11_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP12_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP12_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP12_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP12_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP12_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP12_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP12_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP12_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP12_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP12_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP12_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP12_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP12_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP12_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP12_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP12_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP12_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP12_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP12_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP12_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP12_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP12_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP12_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP12_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP12_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP12_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP12_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP12_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP12_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP12_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP12_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP12_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP12_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP12_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP12_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP12_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP12_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP12_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP12_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP12_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP12_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP12_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP12_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP12_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP12_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP12_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP12_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP12_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP12_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP12_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP12_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP12_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP12_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP12_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP12_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP12_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP12_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP12_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP12_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP12_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP13_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP13_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP13_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP13_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP13_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP13_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP13_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP13_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP13_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP13_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP13_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP13_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP13_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP13_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP13_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP13_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP13_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP13_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP13_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP13_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP13_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP13_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP13_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP13_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP13_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP13_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP13_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP13_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP13_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP13_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP13_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP13_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP13_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP13_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP13_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP13_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP13_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP13_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP13_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP13_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP13_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP13_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP13_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP13_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP13_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP13_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP13_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP13_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP13_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP13_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP13_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP13_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP13_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP13_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP13_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP13_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP13_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP13_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP13_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP13_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP14_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP14_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP14_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP14_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP14_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP14_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP14_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP14_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP14_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP14_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP14_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP14_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP14_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP14_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP14_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP14_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP14_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP14_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP14_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP14_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP14_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP14_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP14_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP14_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP14_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP14_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP14_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP14_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP14_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP14_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP14_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP14_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP14_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP14_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP14_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP14_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP14_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP14_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP14_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP14_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP14_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP14_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP14_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP14_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP14_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP14_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP14_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP14_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP14_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP14_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP14_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP14_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP14_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP14_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP14_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP14_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP14_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP14_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP14_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP14_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP15_IN_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP15_IN_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP15_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP15_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_STALL() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP15_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_STALL() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_RESET() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_RESET() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_PID_0() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_PID_0() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_LAST_0() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_FULL_0() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP15_IN_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP15_IN_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP15_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP15_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP15_IN_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP15_IN_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP15_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_PID_1() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_PID_1() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_LAST_1() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP15_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP15_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP15_IN_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP15_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP15_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP15_IN_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP15_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP15_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP15_IN_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP15_IN_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP15_IN_BUFFER_CONTROL_FULL_1() volatile
    {
        EP15_IN_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP15_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP15_IN_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP15_IN_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP15_IN_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP15_IN_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP15_IN_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP15_IN_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP15_IN_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline uint16_t get_EP15_OUT_BUFFER_CONTROL_LENGTH_0() volatile
    {
        return (EP15_OUT_BUFFER_CONTROL >> 0u) & 0b1111111111u;
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's LENGTH_0 field.
     *
     * The length of the data in buffer 0.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_LENGTH_0(uint16_t value) volatile
    {
        uint32_t curr = EP15_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        EP15_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 10u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 10u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 10u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's AVAILABLE_0 bit.
     *
     * Buffer 0 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_AVAILABLE_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 10u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_STALL() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 11u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 11u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 11u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's STALL bit.
     *
     * Reply with a stall (valid for both buffers).
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_STALL() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 11u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_RESET() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 12u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 12u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 12u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's RESET bit.
     *
     * Reset the buffer selector to buffer 0.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_RESET() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 12u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 13u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 13u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 13u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's PID_0 bit.
     *
     * The data pid of buffer 0.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_PID_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 13u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 14u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 14u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 14u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's LAST_0 bit.
     *
     * Buffer 0 is the last buffer of the transfer.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_LAST_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 14u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 15u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 15u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 15u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's FULL_0 bit.
     *
     * Buffer 0 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_FULL_0() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 15u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline uint16_t get_EP15_OUT_BUFFER_CONTROL_LENGTH_1() volatile
    {
        return (EP15_OUT_BUFFER_CONTROL >> 16u) & 0b1111111111u;
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's LENGTH_1 field.
     *
     * The length of the data in buffer 1.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_LENGTH_1(uint16_t value) volatile
    {
        uint32_t curr = EP15_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        EP15_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 26u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 26u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 26u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's AVAILABLE_1 bit.
     *
     * Buffer 1 is available. This bit is set to indicate the buffer can be
     * used by the controller. The controller clears the available bit when
     * writing the status back.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_AVAILABLE_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 26u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
    get_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET() volatile
    {
        return USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
            (EP15_OUT_BUFFER_CONTROL >> 27u) & 0b11u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's DOUBLE_BUFFER_ISO_OFFSET field.
     *
     * The number of bytes buffer 1 is offset from buffer 0 in Isochronous
     * mode. Only valid in double buffered mode for an Isochronous endpoint.\n
     *                 For a non Isochronous endpoint the offset is always 64
     * bytes.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
        USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            value) volatile
    {
        uint32_t curr = EP15_OUT_BUFFER_CONTROL;

        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(value) & 0b11u) << 27u;

        EP15_OUT_BUFFER_CONTROL = curr;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 29u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 29u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 29u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's PID_1 bit.
     *
     * The data pid of buffer 1.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_PID_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 29u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 30u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 30u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 30u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's LAST_1 bit.
     *
     * Buffer 1 is the last buffer of the transfer.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_LAST_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 30u;
    }

    /**
     * Get EP15_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline bool get_EP15_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        return EP15_OUT_BUFFER_CONTROL & (1u << 31u);
    }

    /**
     * Set EP15_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL |= 1u << 31u;
    }

    /**
     * Clear EP15_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void clear_EP15_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL &= ~(1u << 31u);
    }

    /**
     * Toggle EP15_OUT_BUFFER_CONTROL's FULL_1 bit.
     *
     * Buffer 1 is full. For an IN transfer (TX to the host) the bit is set to
     * indicate the data is valid. For an OUT transfer (RX from the host) this
     * bit should be left as a 0. The host will set it when it has filled the
     * buffer with data.
     */
    inline void toggle_EP15_OUT_BUFFER_CONTROL_FULL_1() volatile
    {
        EP15_OUT_BUFFER_CONTROL ^= 1u << 31u;
    }

    /**
     * Get all of EP15_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void get_EP15_OUT_BUFFER_CONTROL(
        uint16_t &LENGTH_0, bool &AVAILABLE_0, bool &STALL, bool &RESET,
        bool &PID_0, bool &LAST_0, bool &FULL_0, uint16_t &LENGTH_1,
        bool &AVAILABLE_1,
        USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            &DOUBLE_BUFFER_ISO_OFFSET,
        bool &PID_1, bool &LAST_1, bool &FULL_1) volatile
    {
        uint32_t curr = EP15_OUT_BUFFER_CONTROL;

        LENGTH_0 = (curr >> 0u) & 0b1111111111u;
        AVAILABLE_0 = curr & (1u << 10u);
        STALL = curr & (1u << 11u);
        RESET = curr & (1u << 12u);
        PID_0 = curr & (1u << 13u);
        LAST_0 = curr & (1u << 14u);
        FULL_0 = curr & (1u << 15u);
        LENGTH_1 = (curr >> 16u) & 0b1111111111u;
        AVAILABLE_1 = curr & (1u << 26u);
        DOUBLE_BUFFER_ISO_OFFSET =
            USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET(
                (curr >> 27u) & 0b11u);
        PID_1 = curr & (1u << 29u);
        LAST_1 = curr & (1u << 30u);
        FULL_1 = curr & (1u << 31u);
    }

    /**
     * Set all of EP15_OUT_BUFFER_CONTROL's bit fields.
     *
     * (read-write) Buffer control for both buffers of an endpoint. Fields
     * ending in a _1 are for buffer 1.\n Fields ending in a _0 are for buffer
     * 0. Buffer 1 controls are only valid if the endpoint is in double
     * buffered mode.
     */
    inline void set_EP15_OUT_BUFFER_CONTROL(
        uint16_t LENGTH_0, bool AVAILABLE_0, bool STALL, bool RESET,
        bool PID_0, bool LAST_0, bool FULL_0, uint16_t LENGTH_1,
        bool AVAILABLE_1,
        USBCTRL_DPRAM_EP15_OUT_BUFFER_CONTROL_DOUBLE_BUFFER_ISO_OFFSET
            DOUBLE_BUFFER_ISO_OFFSET,
        bool PID_1, bool LAST_1, bool FULL_1) volatile
    {
        uint32_t curr = EP15_OUT_BUFFER_CONTROL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (LENGTH_0 & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (AVAILABLE_0 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (STALL & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (PID_0 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (LAST_0 & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (FULL_0 & 0b1u) << 15u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (LENGTH_1 & 0b1111111111u) << 16u;
        curr &= ~(0b1u << 26u);
        curr |= (AVAILABLE_1 & 0b1u) << 26u;
        curr &= ~(0b11u << 27u);
        curr |= (std::to_underlying(DOUBLE_BUFFER_ISO_OFFSET) & 0b11u) << 27u;
        curr &= ~(0b1u << 29u);
        curr |= (PID_1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (LAST_1 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (FULL_1 & 0b1u) << 31u;

        EP15_OUT_BUFFER_CONTROL = curr;
    }
};

static_assert(sizeof(usbctrl_dpram) == usbctrl_dpram::size);

static volatile usbctrl_dpram *const USBCTRL_DPRAM =
    reinterpret_cast<usbctrl_dpram *>(0x50100000);

}; // namespace RP2040
