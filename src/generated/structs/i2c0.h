/**
 * \file
 * \brief Generated by ifgen (3.1.2).
 */
#pragma once

#include "../enums/I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL.h"
#include "../enums/I2C0_IC_CON_IC_10BITADDR_MASTER.h"
#include "../enums/I2C0_IC_CON_IC_10BITADDR_SLAVE.h"
#include "../enums/I2C0_IC_CON_IC_RESTART_EN.h"
#include "../enums/I2C0_IC_CON_IC_SLAVE_DISABLE.h"
#include "../enums/I2C0_IC_CON_MASTER_MODE.h"
#include "../enums/I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL.h"
#include "../enums/I2C0_IC_CON_SPEED.h"
#include "../enums/I2C0_IC_CON_STOP_DET_IFADDRESSED.h"
#include "../enums/I2C0_IC_CON_TX_EMPTY_CTRL.h"
#include "../enums/I2C0_IC_DATA_CMD_CMD.h"
#include "../enums/I2C0_IC_DATA_CMD_FIRST_DATA_BYTE.h"
#include "../enums/I2C0_IC_DATA_CMD_RESTART.h"
#include "../enums/I2C0_IC_DATA_CMD_STOP.h"
#include "../enums/I2C0_IC_DMA_CR_RDMAE.h"
#include "../enums/I2C0_IC_DMA_CR_TDMAE.h"
#include "../enums/I2C0_IC_ENABLE_ABORT.h"
#include "../enums/I2C0_IC_ENABLE_ENABLE.h"
#include "../enums/I2C0_IC_ENABLE_STATUS_IC_EN.h"
#include "../enums/I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY.h"
#include "../enums/I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST.h"
#include "../enums/I2C0_IC_ENABLE_TX_CMD_BLOCK.h"
#include "../enums/I2C0_IC_INTR_MASK_M_ACTIVITY.h"
#include "../enums/I2C0_IC_INTR_MASK_M_GEN_CALL.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RD_REQ.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RESTART_DET.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_DONE.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_FULL.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_OVER.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_UNDER.h"
#include "../enums/I2C0_IC_INTR_MASK_M_START_DET.h"
#include "../enums/I2C0_IC_INTR_MASK_M_STOP_DET.h"
#include "../enums/I2C0_IC_INTR_MASK_M_TX_ABRT.h"
#include "../enums/I2C0_IC_INTR_MASK_M_TX_EMPTY.h"
#include "../enums/I2C0_IC_INTR_MASK_M_TX_OVER.h"
#include "../enums/I2C0_IC_INTR_STAT_R_ACTIVITY.h"
#include "../enums/I2C0_IC_INTR_STAT_R_GEN_CALL.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RD_REQ.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RESTART_DET.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_DONE.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_FULL.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_OVER.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_UNDER.h"
#include "../enums/I2C0_IC_INTR_STAT_R_START_DET.h"
#include "../enums/I2C0_IC_INTR_STAT_R_STOP_DET.h"
#include "../enums/I2C0_IC_INTR_STAT_R_TX_ABRT.h"
#include "../enums/I2C0_IC_INTR_STAT_R_TX_EMPTY.h"
#include "../enums/I2C0_IC_INTR_STAT_R_TX_OVER.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_ACTIVITY.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_GEN_CALL.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RD_REQ.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RESTART_DET.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_DONE.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_FULL.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_OVER.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_UNDER.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_START_DET.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_STOP_DET.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_TX_ABRT.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_TX_EMPTY.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_TX_OVER.h"
#include "../enums/I2C0_IC_SLV_DATA_NACK_ONLY_NACK.h"
#include "../enums/I2C0_IC_STATUS_ACTIVITY.h"
#include "../enums/I2C0_IC_STATUS_MST_ACTIVITY.h"
#include "../enums/I2C0_IC_STATUS_RFF.h"
#include "../enums/I2C0_IC_STATUS_RFNE.h"
#include "../enums/I2C0_IC_STATUS_SLV_ACTIVITY.h"
#include "../enums/I2C0_IC_STATUS_TFE.h"
#include "../enums/I2C0_IC_STATUS_TFNF.h"
#include "../enums/I2C0_IC_TAR_GC_OR_START.h"
#include "../enums/I2C0_IC_TAR_SPECIAL.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ARB_LOST.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * DW_apb_i2c address block\n\n
 *         List of configuration constants for the Synopsys I2C hardware (you
 * may see references to these in I2C register header; these are *fixed*
 * values, set at hardware design time):\n\n IC_ULTRA_FAST_MODE
 * ................ 0x0\n IC_UFM_TBUF_CNT_DEFAULT ........... 0x8\n
 *         IC_UFM_SCL_LOW_COUNT .............. 0x0008\n
 *         IC_UFM_SCL_HIGH_COUNT ............. 0x0006\n
 *         IC_TX_TL .......................... 0x0\n
 *         IC_TX_CMD_BLOCK ................... 0x1\n
 *         IC_HAS_DMA ........................ 0x1\n
 *         IC_HAS_ASYNC_FIFO ................. 0x0\n
 *         IC_SMBUS_ARP ...................... 0x0\n
 *         IC_FIRST_DATA_BYTE_STATUS ......... 0x1\n
 *         IC_INTR_IO ........................ 0x1\n
 *         IC_MASTER_MODE .................... 0x1\n
 *         IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1\n
 *         IC_INTR_POL ....................... 0x1\n
 *         IC_OPTIONAL_SAR ................... 0x0\n
 *         IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055\n
 *         IC_DEFAULT_SLAVE_ADDR ............. 0x055\n
 *         IC_DEFAULT_HS_SPKLEN .............. 0x1\n
 *         IC_FS_SCL_HIGH_COUNT .............. 0x0006\n
 *         IC_HS_SCL_LOW_COUNT ............... 0x0008\n
 *         IC_DEVICE_ID_VALUE ................ 0x0\n
 *         IC_10BITADDR_MASTER ............... 0x0\n
 *         IC_CLK_FREQ_OPTIMIZATION .......... 0x0\n
 *         IC_DEFAULT_FS_SPKLEN .............. 0x7\n
 *         IC_ADD_ENCODED_PARAMS ............. 0x0\n
 *         IC_DEFAULT_SDA_HOLD ............... 0x000001\n
 *         IC_DEFAULT_SDA_SETUP .............. 0x64\n
 *         IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0\n
 *         IC_CLOCK_PERIOD ................... 100\n
 *         IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1\n
 *         IC_RESTART_EN ..................... 0x1\n
 *         IC_TX_CMD_BLOCK_DEFAULT ........... 0x0\n
 *         IC_BUS_CLEAR_FEATURE .............. 0x0\n
 *         IC_CAP_LOADING .................... 100\n
 *         IC_FS_SCL_LOW_COUNT ............... 0x000d\n
 *         APB_DATA_WIDTH .................... 32\n
 *         IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
 *         IC_SLV_DATA_NACK_ONLY ............. 0x1\n
 *         IC_10BITADDR_SLAVE ................ 0x0\n
 *         IC_CLK_TYPE ....................... 0x0\n
 *         IC_SMBUS_UDID_MSB ................. 0x0\n
 *         IC_SMBUS_SUSPEND_ALERT ............ 0x0\n
 *         IC_HS_SCL_HIGH_COUNT .............. 0x0006\n
 *         IC_SLV_RESTART_DET_EN ............. 0x1\n
 *         IC_SMBUS .......................... 0x0\n
 *         IC_OPTIONAL_SAR_DEFAULT ........... 0x0\n
 *         IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0\n
 *         IC_USE_COUNTS ..................... 0x0\n
 *         IC_RX_BUFFER_DEPTH ................ 16\n
 *         IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
 *         IC_RX_FULL_HLD_BUS_EN ............. 0x1\n
 *         IC_SLAVE_DISABLE .................. 0x1\n
 *         IC_RX_TL .......................... 0x0\n
 *         IC_DEVICE_ID ...................... 0x0\n
 *         IC_HC_COUNT_VALUES ................ 0x0\n
 *         I2C_DYNAMIC_TAR_UPDATE ............ 0\n
 *         IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff\n
 *         IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff\n
 *         IC_HS_MASTER_CODE ................. 0x1\n
 *         IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff\n
 *         IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff\n
 *         IC_SS_SCL_HIGH_COUNT .............. 0x0028\n
 *         IC_SS_SCL_LOW_COUNT ............... 0x002f\n
 *         IC_MAX_SPEED_MODE ................. 0x2\n
 *         IC_STAT_FOR_CLK_STRETCH ........... 0x0\n
 *         IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0\n
 *         IC_DEFAULT_UFM_SPKLEN ............. 0x1\n
 *         IC_TX_BUFFER_DEPTH ................ 16
 */
struct [[gnu::packed]] i2c0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 256; /*!< i2c0's size in bytes. */

    /* Fields. */
    uint32_t IC_CON; /*!< (read-write) I2C Control Register. This register can
be written only when the DW_apb_i2c is disabled, which corresponds to the
IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n
Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is
read only - bit 17 is read only - bits 18 and 19 are read only. */
    uint32_t IC_TAR; /*!< (read-write) I2C Target Address Register\n\n
This register is 12 bits wide, and bits 31:12 are reserved. This register can
be written to only when IC_ENABLE[0] is set to 0.\n\n Note: If the software or
application is aware that the DW_apb_i2c is not using the TAR address for the
pending commands in the Tx FIFO, then it is possible to update the TAR address
even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to
perform any write to this register if DW_apb_i2c is enabled as an I2C slave
only. */
    uint32_t IC_SAR; /*!< (read-write) I2C Slave Address Register */
    const uint32_t reserved_padding0 = {};
    uint32_t IC_DATA_CMD; /*!< (read-write) I2C Rx/Tx Data Buffer and Command
Register; this is the register the CPU writes to when filling the TX FIFO and
the CPU reads from when retrieving bytes from RX FIFO.\n\n The size of the
register changes as follows:\n\n Write: - 11 bits when
IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read:
- 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when
IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue
acknowledging reads, a read command should be written for every byte that is to
be received; otherwise the DW_apb_i2c will stop acknowledging. */
    uint32_t IC_SS_SCL_HCNT; /*!< (read-write) Standard Speed I2C Clock SCL
                                High Count Register */
    uint32_t IC_SS_SCL_LCNT; /*!< (read-write) Standard Speed I2C Clock SCL Low
                                Count Register */
    uint32_t IC_FS_SCL_HCNT; /*!< (read-write) Fast Mode or Fast Mode Plus I2C
                                Clock SCL High Count Register */
    uint32_t IC_FS_SCL_LCNT; /*!< (read-write) Fast Mode or Fast Mode Plus I2C
                                Clock SCL Low Count Register */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    const uint32_t IC_INTR_STAT = {}; /*!< (read-only) I2C Interrupt Status
Register\n\n Each bit in this register has a corresponding mask bit in the
IC_INTR_MASK register. These bits are cleared by reading the matching interrupt
clear register. The unmasked raw versions of these bits are available in the
IC_RAW_INTR_STAT register. */
    uint32_t IC_INTR_MASK; /*!< (read-write) I2C Interrupt Mask Register.\n\n
These bits mask their corresponding interrupt status bits. This register is
active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the
interrupt. */
    const uint32_t IC_RAW_INTR_STAT = {}; /*!< (read-only) I2C Raw Interrupt
Status Register\n\n Unlike the IC_INTR_STAT register, these bits are not masked
so they always show the true status of the DW_apb_i2c. */
    uint32_t IC_RX_TL; /*!< (read-write) I2C Receive FIFO Threshold Register */
    uint32_t
        IC_TX_TL; /*!< (read-write) I2C Transmit FIFO Threshold Register */
    const uint32_t IC_CLR_INTR = {}; /*!< (read-only) Clear Combined and
                                        Individual Interrupt Register */
    const uint32_t IC_CLR_RX_UNDER =
        {}; /*!< (read-only) Clear RX_UNDER Interrupt Register */
    const uint32_t IC_CLR_RX_OVER =
        {}; /*!< (read-only) Clear RX_OVER Interrupt Register */
    const uint32_t IC_CLR_TX_OVER =
        {}; /*!< (read-only) Clear TX_OVER Interrupt Register */
    const uint32_t IC_CLR_RD_REQ =
        {}; /*!< (read-only) Clear RD_REQ Interrupt Register */
    const uint32_t IC_CLR_TX_ABRT =
        {}; /*!< (read-only) Clear TX_ABRT Interrupt Register */
    const uint32_t IC_CLR_RX_DONE =
        {}; /*!< (read-only) Clear RX_DONE Interrupt Register */
    const uint32_t IC_CLR_ACTIVITY =
        {}; /*!< (read-only) Clear ACTIVITY Interrupt Register */
    const uint32_t IC_CLR_STOP_DET =
        {}; /*!< (read-only) Clear STOP_DET Interrupt Register */
    const uint32_t IC_CLR_START_DET =
        {}; /*!< (read-only) Clear START_DET Interrupt Register */
    const uint32_t IC_CLR_GEN_CALL =
        {};             /*!< (read-only) Clear GEN_CALL Interrupt Register */
    uint32_t IC_ENABLE; /*!< (read-write) I2C Enable Register */
    const uint32_t IC_STATUS = {}; /*!< (read-only) I2C Status Register\n\n
This is a read-only register used to indicate the current transfer status and
FIFO status. The status register may be read at any time. None of the bits in
this register request an interrupt.\n\n When the I2C is disabled by writing 0
in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10
are set to 0 When the master or slave state machines goes to idle and ic_en=0:
- Bits 5 and 6 are set to 0 */
    const uint32_t IC_TXFLR =
        {}; /*!< (read-only) I2C Transmit FIFO Level Register This register
               contains the number of valid data entries in the transmit FIFO
               buffer. It is cleared whenever: - The I2C is disabled - There is
               a transmit abort - that is, TX_ABRT bit is set in the
               IC_RAW_INTR_STAT register - The slave bulk transmit mode is
               aborted The register increments whenever data is placed into the
               transmit FIFO and decrements when data is taken from the
               transmit FIFO. */
    const uint32_t IC_RXFLR =
        {}; /*!< (read-only) I2C Receive FIFO Level Register This register
               contains the number of valid data entries in the receive FIFO
               buffer. It is cleared whenever: - The I2C is disabled - Whenever
               there is a transmit abort caused by any of the events tracked in
               IC_TX_ABRT_SOURCE The register increments whenever data is
               placed into the receive FIFO and decrements when data is taken
               from the receive FIFO. */
    uint32_t IC_SDA_HOLD; /*!< (read-write) I2C SDA Hold Time Length
Register\n\n The bits [15:0] of this register are used to control the hold time
of SDA during transmit in both slave and master mode (after SCL goes from HIGH
to LOW).\n\n The bits [23:16] of this register are used to extend the SDA
transition (if any) whenever SCL is HIGH in the receiver in either master or
slave mode.\n\n Writes to this register succeed only when IC_ENABLE[0]=0.\n\n
The values in this register are in units of ic_clk period. The value programmed
in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one
cycle in master mode, seven cycles in slave mode) for the value to be
implemented.\n\n The programmed SDA hold time during transmit (IC_SDA_TX_HOLD)
cannot exceed at any time the duration of the low part of scl. Therefore the
programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the
duration of the low part of the scl period measured in ic_clk cycles. */
    const uint32_t IC_TX_ABRT_SOURCE =
        {}; /*!< (read-only) I2C Transmit Abort Source Register\n\n
This register has 32 bits that indicate the source of the TX_ABRT bit. Except
for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the
IC_CLR_INTR register is read. To clear Bit 9, the source of the
ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1),
the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be
cleared (IC_TAR[10]).\n\n Once the source of the ABRT_SBYTE_NORSTRT is fixed,
then this bit can be cleared in the same manner as other bits in this register.
If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear
this bit, Bit 9 clears for one cycle and is then re-asserted. */
    uint32_t IC_SLV_DATA_NACK_ONLY; /*!< (read-write) Generate Slave Data NACK
Register\n\n The register is used to generate a NACK for the data part of a
transfer when DW_apb_i2c is acting as a slave-receiver. This register only
exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this
parameter disabled, this register does not exist and writing to the register's
address has no effect.\n\n A write can occur on this register if both of the
following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) -
Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register
read-back location for the internal slv_activity signal; the user should poll
this before writing the ic_slv_data_nack_only bit. */
    uint32_t IC_DMA_CR;             /*!< (read-write) DMA Control Register\n\n
The register is used to enable the DMA Controller interface operation. There is
            a separate bit for transmit and receive. This can be programmed regardless of
            the state of IC_ENABLE. */
    uint32_t IC_DMA_TDLR; /*!< (read-write) DMA Transmit Data Level Register */
    uint32_t IC_DMA_RDLR; /*!< (read-write) I2C Receive Data Level Register */
    uint32_t IC_SDA_SETUP;        /*!< (read-write) I2C SDA Setup Register\n\n
This register controls the amount of time delay (in terms of number of ic_clk
       clock periods) introduced in the rising edge of SCL - relative to SDA changing
       - when DW_apb_i2c services a read request in a slave-transmitter operation. The
       relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus
       Specification. This register must be programmed with a value equal to or
       greater than 2.\n\n        Writes to this register succeed only when
       IC_ENABLE[0] =        0.\n\n        Note: The length of setup time is
       calculated using
       [(IC_SDA_SETUP - 1) *        (ic_clk_period)], so if the user requires 10
       ic_clk        periods of setup time, they        should program a value of 11.
       The        IC_SDA_SETUP        register is only used by the        DW_apb_i2c
       when        operating as a        slave transmitter.
       */
    uint32_t IC_ACK_GENERAL_CALL; /*!< (read-write) I2C ACK General Call
Register\n\n The register controls whether DW_apb_i2c responds with a ACK or
NACK when it receives an I2C General Call address.\n\n This register is
applicable only when the DW_apb_i2c is in slave mode. */
    const uint32_t IC_ENABLE_STATUS = {}; /*!< (read-only) I2C Enable Status
Register\n\n The register is used to report the DW_apb_i2c hardware status when
the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is
disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and
bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been set to 0, bits 2:1 is only
be valid as soon as bit 0 is read as '0'.\n\n Note: When IC_ENABLE[0] has been
set to 0, a delay occurs for bit 0 to be read as 0 because disabling the
DW_apb_i2c depends on I2C bus activities. */
    uint32_t IC_FS_SPKLEN; /*!< (read-write) I2C SS, FS or FM+ spike
suppression limit\n\n This register is used to store the duration, measured in
ic_clk cycles, of the longest spike that is filtered out by the spike
suppression logic when the component is operating in SS, FS or FM+ modes. The
relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus
Specification. This register must be programmed with a minimum value of 1. */
    const uint32_t reserved_padding2 = {};
    const uint32_t IC_CLR_RESTART_DET =
        {}; /*!< (read-only) Clear RESTART_DET Interrupt Register */
    static constexpr std::size_t reserved_padding3_length = 18;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    const uint32_t IC_COMP_PARAM_1 = {}; /*!< (read-only) Component Parameter
Register 1\n\n Note This register is not implemented and therefore reads as 0.
If it was implemented it would be a constant read-only register that contains
encoded information about the component's parameter settings. Fields shown
below are the settings for those parameters */
    const uint32_t IC_COMP_VERSION =
        {}; /*!< (read-only) I2C Component Version Register */
    const uint32_t IC_COMP_TYPE =
        {}; /*!< (read-only) I2C Component Type Register */

    /* Methods. */

    /**
     * Get IC_CON's MASTER_MODE bit.
     */
    inline I2C0_IC_CON_MASTER_MODE get_IC_CON_MASTER_MODE() volatile
    {
        return I2C0_IC_CON_MASTER_MODE(IC_CON & (1u << 0u));
    }

    /**
     * Set IC_CON's MASTER_MODE bit.
     */
    inline void set_IC_CON_MASTER_MODE() volatile
    {
        IC_CON |= 1u << 0u;
    }

    /**
     * Clear IC_CON's MASTER_MODE bit.
     */
    inline void clear_IC_CON_MASTER_MODE() volatile
    {
        IC_CON &= ~(1u << 0u);
    }

    /**
     * Toggle IC_CON's MASTER_MODE bit.
     */
    inline void toggle_IC_CON_MASTER_MODE() volatile
    {
        IC_CON ^= 1u << 0u;
    }

    /**
     * Get IC_CON's SPEED field.
     */
    inline I2C0_IC_CON_SPEED get_IC_CON_SPEED() volatile
    {
        return I2C0_IC_CON_SPEED((IC_CON >> 1u) & 0b11u);
    }

    /**
     * Set IC_CON's SPEED field.
     */
    inline void set_IC_CON_SPEED(I2C0_IC_CON_SPEED value) volatile
    {
        uint32_t curr = IC_CON;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        IC_CON = curr;
    }

    /**
     * Get IC_CON's IC_10BITADDR_SLAVE bit.
     */
    inline I2C0_IC_CON_IC_10BITADDR_SLAVE
    get_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        return I2C0_IC_CON_IC_10BITADDR_SLAVE(IC_CON & (1u << 3u));
    }

    /**
     * Set IC_CON's IC_10BITADDR_SLAVE bit.
     */
    inline void set_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        IC_CON |= 1u << 3u;
    }

    /**
     * Clear IC_CON's IC_10BITADDR_SLAVE bit.
     */
    inline void clear_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        IC_CON &= ~(1u << 3u);
    }

    /**
     * Toggle IC_CON's IC_10BITADDR_SLAVE bit.
     */
    inline void toggle_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        IC_CON ^= 1u << 3u;
    }

    /**
     * Get IC_CON's IC_10BITADDR_MASTER bit.
     */
    inline I2C0_IC_CON_IC_10BITADDR_MASTER
    get_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        return I2C0_IC_CON_IC_10BITADDR_MASTER(IC_CON & (1u << 4u));
    }

    /**
     * Set IC_CON's IC_10BITADDR_MASTER bit.
     */
    inline void set_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        IC_CON |= 1u << 4u;
    }

    /**
     * Clear IC_CON's IC_10BITADDR_MASTER bit.
     */
    inline void clear_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        IC_CON &= ~(1u << 4u);
    }

    /**
     * Toggle IC_CON's IC_10BITADDR_MASTER bit.
     */
    inline void toggle_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        IC_CON ^= 1u << 4u;
    }

    /**
     * Get IC_CON's IC_RESTART_EN bit.
     */
    inline I2C0_IC_CON_IC_RESTART_EN get_IC_CON_IC_RESTART_EN() volatile
    {
        return I2C0_IC_CON_IC_RESTART_EN(IC_CON & (1u << 5u));
    }

    /**
     * Set IC_CON's IC_RESTART_EN bit.
     */
    inline void set_IC_CON_IC_RESTART_EN() volatile
    {
        IC_CON |= 1u << 5u;
    }

    /**
     * Clear IC_CON's IC_RESTART_EN bit.
     */
    inline void clear_IC_CON_IC_RESTART_EN() volatile
    {
        IC_CON &= ~(1u << 5u);
    }

    /**
     * Toggle IC_CON's IC_RESTART_EN bit.
     */
    inline void toggle_IC_CON_IC_RESTART_EN() volatile
    {
        IC_CON ^= 1u << 5u;
    }

    /**
     * Get IC_CON's IC_SLAVE_DISABLE bit.
     */
    inline I2C0_IC_CON_IC_SLAVE_DISABLE get_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        return I2C0_IC_CON_IC_SLAVE_DISABLE(IC_CON & (1u << 6u));
    }

    /**
     * Set IC_CON's IC_SLAVE_DISABLE bit.
     */
    inline void set_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        IC_CON |= 1u << 6u;
    }

    /**
     * Clear IC_CON's IC_SLAVE_DISABLE bit.
     */
    inline void clear_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        IC_CON &= ~(1u << 6u);
    }

    /**
     * Toggle IC_CON's IC_SLAVE_DISABLE bit.
     */
    inline void toggle_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        IC_CON ^= 1u << 6u;
    }

    /**
     * Get IC_CON's STOP_DET_IFADDRESSED bit.
     */
    inline I2C0_IC_CON_STOP_DET_IFADDRESSED
    get_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        return I2C0_IC_CON_STOP_DET_IFADDRESSED(IC_CON & (1u << 7u));
    }

    /**
     * Set IC_CON's STOP_DET_IFADDRESSED bit.
     */
    inline void set_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        IC_CON |= 1u << 7u;
    }

    /**
     * Clear IC_CON's STOP_DET_IFADDRESSED bit.
     */
    inline void clear_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        IC_CON &= ~(1u << 7u);
    }

    /**
     * Toggle IC_CON's STOP_DET_IFADDRESSED bit.
     */
    inline void toggle_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        IC_CON ^= 1u << 7u;
    }

    /**
     * Get IC_CON's TX_EMPTY_CTRL bit.
     */
    inline I2C0_IC_CON_TX_EMPTY_CTRL get_IC_CON_TX_EMPTY_CTRL() volatile
    {
        return I2C0_IC_CON_TX_EMPTY_CTRL(IC_CON & (1u << 8u));
    }

    /**
     * Set IC_CON's TX_EMPTY_CTRL bit.
     */
    inline void set_IC_CON_TX_EMPTY_CTRL() volatile
    {
        IC_CON |= 1u << 8u;
    }

    /**
     * Clear IC_CON's TX_EMPTY_CTRL bit.
     */
    inline void clear_IC_CON_TX_EMPTY_CTRL() volatile
    {
        IC_CON &= ~(1u << 8u);
    }

    /**
     * Toggle IC_CON's TX_EMPTY_CTRL bit.
     */
    inline void toggle_IC_CON_TX_EMPTY_CTRL() volatile
    {
        IC_CON ^= 1u << 8u;
    }

    /**
     * Get IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     */
    inline I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL
    get_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        return I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL(IC_CON & (1u << 9u));
    }

    /**
     * Set IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     */
    inline void set_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        IC_CON |= 1u << 9u;
    }

    /**
     * Clear IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     */
    inline void clear_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        IC_CON &= ~(1u << 9u);
    }

    /**
     * Toggle IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     */
    inline void toggle_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        IC_CON ^= 1u << 9u;
    }

    /**
     * Get IC_CON's STOP_DET_IF_MASTER_ACTIVE bit.
     */
    inline bool get_IC_CON_STOP_DET_IF_MASTER_ACTIVE() volatile
    {
        return IC_CON & (1u << 10u);
    }

    /**
     * Get all of IC_CON's bit fields.
     */
    inline void get_IC_CON(
        I2C0_IC_CON_MASTER_MODE &MASTER_MODE, I2C0_IC_CON_SPEED &SPEED,
        I2C0_IC_CON_IC_10BITADDR_SLAVE &IC_10BITADDR_SLAVE,
        I2C0_IC_CON_IC_10BITADDR_MASTER &IC_10BITADDR_MASTER,
        I2C0_IC_CON_IC_RESTART_EN &IC_RESTART_EN,
        I2C0_IC_CON_IC_SLAVE_DISABLE &IC_SLAVE_DISABLE,
        I2C0_IC_CON_STOP_DET_IFADDRESSED &STOP_DET_IFADDRESSED,
        I2C0_IC_CON_TX_EMPTY_CTRL &TX_EMPTY_CTRL,
        I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL &RX_FIFO_FULL_HLD_CTRL,
        bool &STOP_DET_IF_MASTER_ACTIVE) volatile
    {
        uint32_t curr = IC_CON;

        MASTER_MODE = I2C0_IC_CON_MASTER_MODE(curr & (1u << 0u));
        SPEED = I2C0_IC_CON_SPEED((curr >> 1u) & 0b11u);
        IC_10BITADDR_SLAVE = I2C0_IC_CON_IC_10BITADDR_SLAVE(curr & (1u << 3u));
        IC_10BITADDR_MASTER =
            I2C0_IC_CON_IC_10BITADDR_MASTER(curr & (1u << 4u));
        IC_RESTART_EN = I2C0_IC_CON_IC_RESTART_EN(curr & (1u << 5u));
        IC_SLAVE_DISABLE = I2C0_IC_CON_IC_SLAVE_DISABLE(curr & (1u << 6u));
        STOP_DET_IFADDRESSED =
            I2C0_IC_CON_STOP_DET_IFADDRESSED(curr & (1u << 7u));
        TX_EMPTY_CTRL = I2C0_IC_CON_TX_EMPTY_CTRL(curr & (1u << 8u));
        RX_FIFO_FULL_HLD_CTRL =
            I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL(curr & (1u << 9u));
        STOP_DET_IF_MASTER_ACTIVE = curr & (1u << 10u);
    }

    /**
     * Set all of IC_CON's bit fields.
     */
    inline void set_IC_CON(
        I2C0_IC_CON_MASTER_MODE MASTER_MODE, I2C0_IC_CON_SPEED SPEED,
        I2C0_IC_CON_IC_10BITADDR_SLAVE IC_10BITADDR_SLAVE,
        I2C0_IC_CON_IC_10BITADDR_MASTER IC_10BITADDR_MASTER,
        I2C0_IC_CON_IC_RESTART_EN IC_RESTART_EN,
        I2C0_IC_CON_IC_SLAVE_DISABLE IC_SLAVE_DISABLE,
        I2C0_IC_CON_STOP_DET_IFADDRESSED STOP_DET_IFADDRESSED,
        I2C0_IC_CON_TX_EMPTY_CTRL TX_EMPTY_CTRL,
        I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL RX_FIFO_FULL_HLD_CTRL) volatile
    {
        uint32_t curr = IC_CON;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(MASTER_MODE) & 0b1u) << 0u;
        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(SPEED) & 0b11u) << 1u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(IC_10BITADDR_SLAVE) & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(IC_10BITADDR_MASTER) & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(IC_RESTART_EN) & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(IC_SLAVE_DISABLE) & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (std::to_underlying(STOP_DET_IFADDRESSED) & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(TX_EMPTY_CTRL) & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(RX_FIFO_FULL_HLD_CTRL) & 0b1u) << 9u;

        IC_CON = curr;
    }

    /**
     * Get IC_TAR's IC_TAR field.
     */
    inline uint16_t get_IC_TAR_IC_TAR() volatile
    {
        return (IC_TAR >> 0u) & 0b1111111111u;
    }

    /**
     * Set IC_TAR's IC_TAR field.
     */
    inline void set_IC_TAR_IC_TAR(uint16_t value) volatile
    {
        uint32_t curr = IC_TAR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        IC_TAR = curr;
    }

    /**
     * Get IC_TAR's GC_OR_START bit.
     */
    inline I2C0_IC_TAR_GC_OR_START get_IC_TAR_GC_OR_START() volatile
    {
        return I2C0_IC_TAR_GC_OR_START(IC_TAR & (1u << 10u));
    }

    /**
     * Set IC_TAR's GC_OR_START bit.
     */
    inline void set_IC_TAR_GC_OR_START() volatile
    {
        IC_TAR |= 1u << 10u;
    }

    /**
     * Clear IC_TAR's GC_OR_START bit.
     */
    inline void clear_IC_TAR_GC_OR_START() volatile
    {
        IC_TAR &= ~(1u << 10u);
    }

    /**
     * Toggle IC_TAR's GC_OR_START bit.
     */
    inline void toggle_IC_TAR_GC_OR_START() volatile
    {
        IC_TAR ^= 1u << 10u;
    }

    /**
     * Get IC_TAR's SPECIAL bit.
     */
    inline I2C0_IC_TAR_SPECIAL get_IC_TAR_SPECIAL() volatile
    {
        return I2C0_IC_TAR_SPECIAL(IC_TAR & (1u << 11u));
    }

    /**
     * Set IC_TAR's SPECIAL bit.
     */
    inline void set_IC_TAR_SPECIAL() volatile
    {
        IC_TAR |= 1u << 11u;
    }

    /**
     * Clear IC_TAR's SPECIAL bit.
     */
    inline void clear_IC_TAR_SPECIAL() volatile
    {
        IC_TAR &= ~(1u << 11u);
    }

    /**
     * Toggle IC_TAR's SPECIAL bit.
     */
    inline void toggle_IC_TAR_SPECIAL() volatile
    {
        IC_TAR ^= 1u << 11u;
    }

    /**
     * Get all of IC_TAR's bit fields.
     */
    inline void get_IC_TAR(uint16_t &IC_TAR,
                           I2C0_IC_TAR_GC_OR_START &GC_OR_START,
                           I2C0_IC_TAR_SPECIAL &SPECIAL) volatile
    {
        uint32_t curr = IC_TAR;

        IC_TAR = (curr >> 0u) & 0b1111111111u;
        GC_OR_START = I2C0_IC_TAR_GC_OR_START(curr & (1u << 10u));
        SPECIAL = I2C0_IC_TAR_SPECIAL(curr & (1u << 11u));
    }

    /**
     * Set all of IC_TAR's bit fields.
     */
    inline void set_IC_TAR(uint16_t IC_TAR,
                           I2C0_IC_TAR_GC_OR_START GC_OR_START,
                           I2C0_IC_TAR_SPECIAL SPECIAL) volatile
    {
        uint32_t curr = IC_TAR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (IC_TAR & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(GC_OR_START) & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(SPECIAL) & 0b1u) << 11u;

        IC_TAR = curr;
    }

    /**
     * Get IC_SAR's IC_SAR field.
     */
    inline uint16_t get_IC_SAR_IC_SAR() volatile
    {
        return (IC_SAR >> 0u) & 0b1111111111u;
    }

    /**
     * Set IC_SAR's IC_SAR field.
     */
    inline void set_IC_SAR_IC_SAR(uint16_t value) volatile
    {
        uint32_t curr = IC_SAR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        IC_SAR = curr;
    }

    /**
     * Get IC_DATA_CMD's DAT field.
     */
    inline uint8_t get_IC_DATA_CMD_DAT() volatile
    {
        return (IC_DATA_CMD >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_DATA_CMD's DAT field.
     */
    inline void set_IC_DATA_CMD_DAT(uint8_t value) volatile
    {
        uint32_t curr = IC_DATA_CMD;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_DATA_CMD = curr;
    }

    /**
     * Get IC_DATA_CMD's CMD bit.
     */
    inline I2C0_IC_DATA_CMD_CMD get_IC_DATA_CMD_CMD() volatile
    {
        return I2C0_IC_DATA_CMD_CMD(IC_DATA_CMD & (1u << 8u));
    }

    /**
     * Set IC_DATA_CMD's CMD bit.
     */
    inline void set_IC_DATA_CMD_CMD() volatile
    {
        IC_DATA_CMD |= 1u << 8u;
    }

    /**
     * Clear IC_DATA_CMD's CMD bit.
     */
    inline void clear_IC_DATA_CMD_CMD() volatile
    {
        IC_DATA_CMD &= ~(1u << 8u);
    }

    /**
     * Toggle IC_DATA_CMD's CMD bit.
     */
    inline void toggle_IC_DATA_CMD_CMD() volatile
    {
        IC_DATA_CMD ^= 1u << 8u;
    }

    /**
     * Get IC_DATA_CMD's STOP bit.
     */
    inline I2C0_IC_DATA_CMD_STOP get_IC_DATA_CMD_STOP() volatile
    {
        return I2C0_IC_DATA_CMD_STOP(IC_DATA_CMD & (1u << 9u));
    }

    /**
     * Set IC_DATA_CMD's STOP bit.
     */
    inline void set_IC_DATA_CMD_STOP() volatile
    {
        IC_DATA_CMD |= 1u << 9u;
    }

    /**
     * Clear IC_DATA_CMD's STOP bit.
     */
    inline void clear_IC_DATA_CMD_STOP() volatile
    {
        IC_DATA_CMD &= ~(1u << 9u);
    }

    /**
     * Toggle IC_DATA_CMD's STOP bit.
     */
    inline void toggle_IC_DATA_CMD_STOP() volatile
    {
        IC_DATA_CMD ^= 1u << 9u;
    }

    /**
     * Get IC_DATA_CMD's RESTART bit.
     */
    inline I2C0_IC_DATA_CMD_RESTART get_IC_DATA_CMD_RESTART() volatile
    {
        return I2C0_IC_DATA_CMD_RESTART(IC_DATA_CMD & (1u << 10u));
    }

    /**
     * Set IC_DATA_CMD's RESTART bit.
     */
    inline void set_IC_DATA_CMD_RESTART() volatile
    {
        IC_DATA_CMD |= 1u << 10u;
    }

    /**
     * Clear IC_DATA_CMD's RESTART bit.
     */
    inline void clear_IC_DATA_CMD_RESTART() volatile
    {
        IC_DATA_CMD &= ~(1u << 10u);
    }

    /**
     * Toggle IC_DATA_CMD's RESTART bit.
     */
    inline void toggle_IC_DATA_CMD_RESTART() volatile
    {
        IC_DATA_CMD ^= 1u << 10u;
    }

    /**
     * Get IC_DATA_CMD's FIRST_DATA_BYTE bit.
     */
    inline I2C0_IC_DATA_CMD_FIRST_DATA_BYTE
    get_IC_DATA_CMD_FIRST_DATA_BYTE() volatile
    {
        return I2C0_IC_DATA_CMD_FIRST_DATA_BYTE(IC_DATA_CMD & (1u << 11u));
    }

    /**
     * Get all of IC_DATA_CMD's bit fields.
     */
    inline void get_IC_DATA_CMD(
        uint8_t &DAT, I2C0_IC_DATA_CMD_CMD &CMD, I2C0_IC_DATA_CMD_STOP &STOP,
        I2C0_IC_DATA_CMD_RESTART &RESTART,
        I2C0_IC_DATA_CMD_FIRST_DATA_BYTE &FIRST_DATA_BYTE) volatile
    {
        uint32_t curr = IC_DATA_CMD;

        DAT = (curr >> 0u) & 0b11111111u;
        CMD = I2C0_IC_DATA_CMD_CMD(curr & (1u << 8u));
        STOP = I2C0_IC_DATA_CMD_STOP(curr & (1u << 9u));
        RESTART = I2C0_IC_DATA_CMD_RESTART(curr & (1u << 10u));
        FIRST_DATA_BYTE = I2C0_IC_DATA_CMD_FIRST_DATA_BYTE(curr & (1u << 11u));
    }

    /**
     * Set all of IC_DATA_CMD's bit fields.
     */
    inline void set_IC_DATA_CMD(uint8_t DAT, I2C0_IC_DATA_CMD_CMD CMD,
                                I2C0_IC_DATA_CMD_STOP STOP,
                                I2C0_IC_DATA_CMD_RESTART RESTART) volatile
    {
        uint32_t curr = IC_DATA_CMD;

        curr &= ~(0b11111111u << 0u);
        curr |= (DAT & 0b11111111u) << 0u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(CMD) & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(STOP) & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(RESTART) & 0b1u) << 10u;

        IC_DATA_CMD = curr;
    }

    /**
     * Get IC_SS_SCL_HCNT's IC_SS_SCL_HCNT field.
     */
    inline uint16_t get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT() volatile
    {
        return (IC_SS_SCL_HCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_SS_SCL_HCNT's IC_SS_SCL_HCNT field.
     */
    inline void set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_SS_SCL_HCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_SS_SCL_HCNT = curr;
    }

    /**
     * Get IC_SS_SCL_LCNT's IC_SS_SCL_LCNT field.
     */
    inline uint16_t get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT() volatile
    {
        return (IC_SS_SCL_LCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_SS_SCL_LCNT's IC_SS_SCL_LCNT field.
     */
    inline void set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_SS_SCL_LCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_SS_SCL_LCNT = curr;
    }

    /**
     * Get IC_FS_SCL_HCNT's IC_FS_SCL_HCNT field.
     */
    inline uint16_t get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT() volatile
    {
        return (IC_FS_SCL_HCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_FS_SCL_HCNT's IC_FS_SCL_HCNT field.
     */
    inline void set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_FS_SCL_HCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_FS_SCL_HCNT = curr;
    }

    /**
     * Get IC_FS_SCL_LCNT's IC_FS_SCL_LCNT field.
     */
    inline uint16_t get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT() volatile
    {
        return (IC_FS_SCL_LCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_FS_SCL_LCNT's IC_FS_SCL_LCNT field.
     */
    inline void set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_FS_SCL_LCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_FS_SCL_LCNT = curr;
    }

    /**
     * Get IC_INTR_STAT's R_RX_UNDER bit.
     */
    inline I2C0_IC_INTR_STAT_R_RX_UNDER get_IC_INTR_STAT_R_RX_UNDER() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_UNDER(IC_INTR_STAT & (1u << 0u));
    }

    /**
     * Get IC_INTR_STAT's R_RX_OVER bit.
     */
    inline I2C0_IC_INTR_STAT_R_RX_OVER get_IC_INTR_STAT_R_RX_OVER() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_OVER(IC_INTR_STAT & (1u << 1u));
    }

    /**
     * Get IC_INTR_STAT's R_RX_FULL bit.
     */
    inline I2C0_IC_INTR_STAT_R_RX_FULL get_IC_INTR_STAT_R_RX_FULL() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_FULL(IC_INTR_STAT & (1u << 2u));
    }

    /**
     * Get IC_INTR_STAT's R_TX_OVER bit.
     */
    inline I2C0_IC_INTR_STAT_R_TX_OVER get_IC_INTR_STAT_R_TX_OVER() volatile
    {
        return I2C0_IC_INTR_STAT_R_TX_OVER(IC_INTR_STAT & (1u << 3u));
    }

    /**
     * Get IC_INTR_STAT's R_TX_EMPTY bit.
     */
    inline I2C0_IC_INTR_STAT_R_TX_EMPTY get_IC_INTR_STAT_R_TX_EMPTY() volatile
    {
        return I2C0_IC_INTR_STAT_R_TX_EMPTY(IC_INTR_STAT & (1u << 4u));
    }

    /**
     * Get IC_INTR_STAT's R_RD_REQ bit.
     */
    inline I2C0_IC_INTR_STAT_R_RD_REQ get_IC_INTR_STAT_R_RD_REQ() volatile
    {
        return I2C0_IC_INTR_STAT_R_RD_REQ(IC_INTR_STAT & (1u << 5u));
    }

    /**
     * Get IC_INTR_STAT's R_TX_ABRT bit.
     */
    inline I2C0_IC_INTR_STAT_R_TX_ABRT get_IC_INTR_STAT_R_TX_ABRT() volatile
    {
        return I2C0_IC_INTR_STAT_R_TX_ABRT(IC_INTR_STAT & (1u << 6u));
    }

    /**
     * Get IC_INTR_STAT's R_RX_DONE bit.
     */
    inline I2C0_IC_INTR_STAT_R_RX_DONE get_IC_INTR_STAT_R_RX_DONE() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_DONE(IC_INTR_STAT & (1u << 7u));
    }

    /**
     * Get IC_INTR_STAT's R_ACTIVITY bit.
     */
    inline I2C0_IC_INTR_STAT_R_ACTIVITY get_IC_INTR_STAT_R_ACTIVITY() volatile
    {
        return I2C0_IC_INTR_STAT_R_ACTIVITY(IC_INTR_STAT & (1u << 8u));
    }

    /**
     * Get IC_INTR_STAT's R_STOP_DET bit.
     */
    inline I2C0_IC_INTR_STAT_R_STOP_DET get_IC_INTR_STAT_R_STOP_DET() volatile
    {
        return I2C0_IC_INTR_STAT_R_STOP_DET(IC_INTR_STAT & (1u << 9u));
    }

    /**
     * Get IC_INTR_STAT's R_START_DET bit.
     */
    inline I2C0_IC_INTR_STAT_R_START_DET
    get_IC_INTR_STAT_R_START_DET() volatile
    {
        return I2C0_IC_INTR_STAT_R_START_DET(IC_INTR_STAT & (1u << 10u));
    }

    /**
     * Get IC_INTR_STAT's R_GEN_CALL bit.
     */
    inline I2C0_IC_INTR_STAT_R_GEN_CALL get_IC_INTR_STAT_R_GEN_CALL() volatile
    {
        return I2C0_IC_INTR_STAT_R_GEN_CALL(IC_INTR_STAT & (1u << 11u));
    }

    /**
     * Get IC_INTR_STAT's R_RESTART_DET bit.
     */
    inline I2C0_IC_INTR_STAT_R_RESTART_DET
    get_IC_INTR_STAT_R_RESTART_DET() volatile
    {
        return I2C0_IC_INTR_STAT_R_RESTART_DET(IC_INTR_STAT & (1u << 12u));
    }

    /**
     * Get all of IC_INTR_STAT's bit fields.
     */
    inline void get_IC_INTR_STAT(
        I2C0_IC_INTR_STAT_R_RX_UNDER &R_RX_UNDER,
        I2C0_IC_INTR_STAT_R_RX_OVER &R_RX_OVER,
        I2C0_IC_INTR_STAT_R_RX_FULL &R_RX_FULL,
        I2C0_IC_INTR_STAT_R_TX_OVER &R_TX_OVER,
        I2C0_IC_INTR_STAT_R_TX_EMPTY &R_TX_EMPTY,
        I2C0_IC_INTR_STAT_R_RD_REQ &R_RD_REQ,
        I2C0_IC_INTR_STAT_R_TX_ABRT &R_TX_ABRT,
        I2C0_IC_INTR_STAT_R_RX_DONE &R_RX_DONE,
        I2C0_IC_INTR_STAT_R_ACTIVITY &R_ACTIVITY,
        I2C0_IC_INTR_STAT_R_STOP_DET &R_STOP_DET,
        I2C0_IC_INTR_STAT_R_START_DET &R_START_DET,
        I2C0_IC_INTR_STAT_R_GEN_CALL &R_GEN_CALL,
        I2C0_IC_INTR_STAT_R_RESTART_DET &R_RESTART_DET) volatile
    {
        uint32_t curr = IC_INTR_STAT;

        R_RX_UNDER = I2C0_IC_INTR_STAT_R_RX_UNDER(curr & (1u << 0u));
        R_RX_OVER = I2C0_IC_INTR_STAT_R_RX_OVER(curr & (1u << 1u));
        R_RX_FULL = I2C0_IC_INTR_STAT_R_RX_FULL(curr & (1u << 2u));
        R_TX_OVER = I2C0_IC_INTR_STAT_R_TX_OVER(curr & (1u << 3u));
        R_TX_EMPTY = I2C0_IC_INTR_STAT_R_TX_EMPTY(curr & (1u << 4u));
        R_RD_REQ = I2C0_IC_INTR_STAT_R_RD_REQ(curr & (1u << 5u));
        R_TX_ABRT = I2C0_IC_INTR_STAT_R_TX_ABRT(curr & (1u << 6u));
        R_RX_DONE = I2C0_IC_INTR_STAT_R_RX_DONE(curr & (1u << 7u));
        R_ACTIVITY = I2C0_IC_INTR_STAT_R_ACTIVITY(curr & (1u << 8u));
        R_STOP_DET = I2C0_IC_INTR_STAT_R_STOP_DET(curr & (1u << 9u));
        R_START_DET = I2C0_IC_INTR_STAT_R_START_DET(curr & (1u << 10u));
        R_GEN_CALL = I2C0_IC_INTR_STAT_R_GEN_CALL(curr & (1u << 11u));
        R_RESTART_DET = I2C0_IC_INTR_STAT_R_RESTART_DET(curr & (1u << 12u));
    }

    /**
     * Get IC_INTR_MASK's M_RX_UNDER bit.
     */
    inline I2C0_IC_INTR_MASK_M_RX_UNDER get_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_UNDER(IC_INTR_MASK & (1u << 0u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_UNDER bit.
     */
    inline void set_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        IC_INTR_MASK |= 1u << 0u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_UNDER bit.
     */
    inline void clear_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        IC_INTR_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_UNDER bit.
     */
    inline void toggle_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        IC_INTR_MASK ^= 1u << 0u;
    }

    /**
     * Get IC_INTR_MASK's M_RX_OVER bit.
     */
    inline I2C0_IC_INTR_MASK_M_RX_OVER get_IC_INTR_MASK_M_RX_OVER() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_OVER(IC_INTR_MASK & (1u << 1u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_OVER bit.
     */
    inline void set_IC_INTR_MASK_M_RX_OVER() volatile
    {
        IC_INTR_MASK |= 1u << 1u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_OVER bit.
     */
    inline void clear_IC_INTR_MASK_M_RX_OVER() volatile
    {
        IC_INTR_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_OVER bit.
     */
    inline void toggle_IC_INTR_MASK_M_RX_OVER() volatile
    {
        IC_INTR_MASK ^= 1u << 1u;
    }

    /**
     * Get IC_INTR_MASK's M_RX_FULL bit.
     */
    inline I2C0_IC_INTR_MASK_M_RX_FULL get_IC_INTR_MASK_M_RX_FULL() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_FULL(IC_INTR_MASK & (1u << 2u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_FULL bit.
     */
    inline void set_IC_INTR_MASK_M_RX_FULL() volatile
    {
        IC_INTR_MASK |= 1u << 2u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_FULL bit.
     */
    inline void clear_IC_INTR_MASK_M_RX_FULL() volatile
    {
        IC_INTR_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_FULL bit.
     */
    inline void toggle_IC_INTR_MASK_M_RX_FULL() volatile
    {
        IC_INTR_MASK ^= 1u << 2u;
    }

    /**
     * Get IC_INTR_MASK's M_TX_OVER bit.
     */
    inline I2C0_IC_INTR_MASK_M_TX_OVER get_IC_INTR_MASK_M_TX_OVER() volatile
    {
        return I2C0_IC_INTR_MASK_M_TX_OVER(IC_INTR_MASK & (1u << 3u));
    }

    /**
     * Set IC_INTR_MASK's M_TX_OVER bit.
     */
    inline void set_IC_INTR_MASK_M_TX_OVER() volatile
    {
        IC_INTR_MASK |= 1u << 3u;
    }

    /**
     * Clear IC_INTR_MASK's M_TX_OVER bit.
     */
    inline void clear_IC_INTR_MASK_M_TX_OVER() volatile
    {
        IC_INTR_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle IC_INTR_MASK's M_TX_OVER bit.
     */
    inline void toggle_IC_INTR_MASK_M_TX_OVER() volatile
    {
        IC_INTR_MASK ^= 1u << 3u;
    }

    /**
     * Get IC_INTR_MASK's M_TX_EMPTY bit.
     */
    inline I2C0_IC_INTR_MASK_M_TX_EMPTY get_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        return I2C0_IC_INTR_MASK_M_TX_EMPTY(IC_INTR_MASK & (1u << 4u));
    }

    /**
     * Set IC_INTR_MASK's M_TX_EMPTY bit.
     */
    inline void set_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        IC_INTR_MASK |= 1u << 4u;
    }

    /**
     * Clear IC_INTR_MASK's M_TX_EMPTY bit.
     */
    inline void clear_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        IC_INTR_MASK &= ~(1u << 4u);
    }

    /**
     * Toggle IC_INTR_MASK's M_TX_EMPTY bit.
     */
    inline void toggle_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        IC_INTR_MASK ^= 1u << 4u;
    }

    /**
     * Get IC_INTR_MASK's M_RD_REQ bit.
     */
    inline I2C0_IC_INTR_MASK_M_RD_REQ get_IC_INTR_MASK_M_RD_REQ() volatile
    {
        return I2C0_IC_INTR_MASK_M_RD_REQ(IC_INTR_MASK & (1u << 5u));
    }

    /**
     * Set IC_INTR_MASK's M_RD_REQ bit.
     */
    inline void set_IC_INTR_MASK_M_RD_REQ() volatile
    {
        IC_INTR_MASK |= 1u << 5u;
    }

    /**
     * Clear IC_INTR_MASK's M_RD_REQ bit.
     */
    inline void clear_IC_INTR_MASK_M_RD_REQ() volatile
    {
        IC_INTR_MASK &= ~(1u << 5u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RD_REQ bit.
     */
    inline void toggle_IC_INTR_MASK_M_RD_REQ() volatile
    {
        IC_INTR_MASK ^= 1u << 5u;
    }

    /**
     * Get IC_INTR_MASK's M_TX_ABRT bit.
     */
    inline I2C0_IC_INTR_MASK_M_TX_ABRT get_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        return I2C0_IC_INTR_MASK_M_TX_ABRT(IC_INTR_MASK & (1u << 6u));
    }

    /**
     * Set IC_INTR_MASK's M_TX_ABRT bit.
     */
    inline void set_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        IC_INTR_MASK |= 1u << 6u;
    }

    /**
     * Clear IC_INTR_MASK's M_TX_ABRT bit.
     */
    inline void clear_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        IC_INTR_MASK &= ~(1u << 6u);
    }

    /**
     * Toggle IC_INTR_MASK's M_TX_ABRT bit.
     */
    inline void toggle_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        IC_INTR_MASK ^= 1u << 6u;
    }

    /**
     * Get IC_INTR_MASK's M_RX_DONE bit.
     */
    inline I2C0_IC_INTR_MASK_M_RX_DONE get_IC_INTR_MASK_M_RX_DONE() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_DONE(IC_INTR_MASK & (1u << 7u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_DONE bit.
     */
    inline void set_IC_INTR_MASK_M_RX_DONE() volatile
    {
        IC_INTR_MASK |= 1u << 7u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_DONE bit.
     */
    inline void clear_IC_INTR_MASK_M_RX_DONE() volatile
    {
        IC_INTR_MASK &= ~(1u << 7u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_DONE bit.
     */
    inline void toggle_IC_INTR_MASK_M_RX_DONE() volatile
    {
        IC_INTR_MASK ^= 1u << 7u;
    }

    /**
     * Get IC_INTR_MASK's M_ACTIVITY bit.
     */
    inline I2C0_IC_INTR_MASK_M_ACTIVITY get_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        return I2C0_IC_INTR_MASK_M_ACTIVITY(IC_INTR_MASK & (1u << 8u));
    }

    /**
     * Set IC_INTR_MASK's M_ACTIVITY bit.
     */
    inline void set_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        IC_INTR_MASK |= 1u << 8u;
    }

    /**
     * Clear IC_INTR_MASK's M_ACTIVITY bit.
     */
    inline void clear_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        IC_INTR_MASK &= ~(1u << 8u);
    }

    /**
     * Toggle IC_INTR_MASK's M_ACTIVITY bit.
     */
    inline void toggle_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        IC_INTR_MASK ^= 1u << 8u;
    }

    /**
     * Get IC_INTR_MASK's M_STOP_DET bit.
     */
    inline I2C0_IC_INTR_MASK_M_STOP_DET get_IC_INTR_MASK_M_STOP_DET() volatile
    {
        return I2C0_IC_INTR_MASK_M_STOP_DET(IC_INTR_MASK & (1u << 9u));
    }

    /**
     * Set IC_INTR_MASK's M_STOP_DET bit.
     */
    inline void set_IC_INTR_MASK_M_STOP_DET() volatile
    {
        IC_INTR_MASK |= 1u << 9u;
    }

    /**
     * Clear IC_INTR_MASK's M_STOP_DET bit.
     */
    inline void clear_IC_INTR_MASK_M_STOP_DET() volatile
    {
        IC_INTR_MASK &= ~(1u << 9u);
    }

    /**
     * Toggle IC_INTR_MASK's M_STOP_DET bit.
     */
    inline void toggle_IC_INTR_MASK_M_STOP_DET() volatile
    {
        IC_INTR_MASK ^= 1u << 9u;
    }

    /**
     * Get IC_INTR_MASK's M_START_DET bit.
     */
    inline I2C0_IC_INTR_MASK_M_START_DET
    get_IC_INTR_MASK_M_START_DET() volatile
    {
        return I2C0_IC_INTR_MASK_M_START_DET(IC_INTR_MASK & (1u << 10u));
    }

    /**
     * Set IC_INTR_MASK's M_START_DET bit.
     */
    inline void set_IC_INTR_MASK_M_START_DET() volatile
    {
        IC_INTR_MASK |= 1u << 10u;
    }

    /**
     * Clear IC_INTR_MASK's M_START_DET bit.
     */
    inline void clear_IC_INTR_MASK_M_START_DET() volatile
    {
        IC_INTR_MASK &= ~(1u << 10u);
    }

    /**
     * Toggle IC_INTR_MASK's M_START_DET bit.
     */
    inline void toggle_IC_INTR_MASK_M_START_DET() volatile
    {
        IC_INTR_MASK ^= 1u << 10u;
    }

    /**
     * Get IC_INTR_MASK's M_GEN_CALL bit.
     */
    inline I2C0_IC_INTR_MASK_M_GEN_CALL get_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        return I2C0_IC_INTR_MASK_M_GEN_CALL(IC_INTR_MASK & (1u << 11u));
    }

    /**
     * Set IC_INTR_MASK's M_GEN_CALL bit.
     */
    inline void set_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        IC_INTR_MASK |= 1u << 11u;
    }

    /**
     * Clear IC_INTR_MASK's M_GEN_CALL bit.
     */
    inline void clear_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        IC_INTR_MASK &= ~(1u << 11u);
    }

    /**
     * Toggle IC_INTR_MASK's M_GEN_CALL bit.
     */
    inline void toggle_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        IC_INTR_MASK ^= 1u << 11u;
    }

    /**
     * Get IC_INTR_MASK's M_RESTART_DET bit.
     */
    inline I2C0_IC_INTR_MASK_M_RESTART_DET
    get_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        return I2C0_IC_INTR_MASK_M_RESTART_DET(IC_INTR_MASK & (1u << 12u));
    }

    /**
     * Set IC_INTR_MASK's M_RESTART_DET bit.
     */
    inline void set_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        IC_INTR_MASK |= 1u << 12u;
    }

    /**
     * Clear IC_INTR_MASK's M_RESTART_DET bit.
     */
    inline void clear_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        IC_INTR_MASK &= ~(1u << 12u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RESTART_DET bit.
     */
    inline void toggle_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        IC_INTR_MASK ^= 1u << 12u;
    }

    /**
     * Get all of IC_INTR_MASK's bit fields.
     */
    inline void get_IC_INTR_MASK(
        I2C0_IC_INTR_MASK_M_RX_UNDER &M_RX_UNDER,
        I2C0_IC_INTR_MASK_M_RX_OVER &M_RX_OVER,
        I2C0_IC_INTR_MASK_M_RX_FULL &M_RX_FULL,
        I2C0_IC_INTR_MASK_M_TX_OVER &M_TX_OVER,
        I2C0_IC_INTR_MASK_M_TX_EMPTY &M_TX_EMPTY,
        I2C0_IC_INTR_MASK_M_RD_REQ &M_RD_REQ,
        I2C0_IC_INTR_MASK_M_TX_ABRT &M_TX_ABRT,
        I2C0_IC_INTR_MASK_M_RX_DONE &M_RX_DONE,
        I2C0_IC_INTR_MASK_M_ACTIVITY &M_ACTIVITY,
        I2C0_IC_INTR_MASK_M_STOP_DET &M_STOP_DET,
        I2C0_IC_INTR_MASK_M_START_DET &M_START_DET,
        I2C0_IC_INTR_MASK_M_GEN_CALL &M_GEN_CALL,
        I2C0_IC_INTR_MASK_M_RESTART_DET &M_RESTART_DET) volatile
    {
        uint32_t curr = IC_INTR_MASK;

        M_RX_UNDER = I2C0_IC_INTR_MASK_M_RX_UNDER(curr & (1u << 0u));
        M_RX_OVER = I2C0_IC_INTR_MASK_M_RX_OVER(curr & (1u << 1u));
        M_RX_FULL = I2C0_IC_INTR_MASK_M_RX_FULL(curr & (1u << 2u));
        M_TX_OVER = I2C0_IC_INTR_MASK_M_TX_OVER(curr & (1u << 3u));
        M_TX_EMPTY = I2C0_IC_INTR_MASK_M_TX_EMPTY(curr & (1u << 4u));
        M_RD_REQ = I2C0_IC_INTR_MASK_M_RD_REQ(curr & (1u << 5u));
        M_TX_ABRT = I2C0_IC_INTR_MASK_M_TX_ABRT(curr & (1u << 6u));
        M_RX_DONE = I2C0_IC_INTR_MASK_M_RX_DONE(curr & (1u << 7u));
        M_ACTIVITY = I2C0_IC_INTR_MASK_M_ACTIVITY(curr & (1u << 8u));
        M_STOP_DET = I2C0_IC_INTR_MASK_M_STOP_DET(curr & (1u << 9u));
        M_START_DET = I2C0_IC_INTR_MASK_M_START_DET(curr & (1u << 10u));
        M_GEN_CALL = I2C0_IC_INTR_MASK_M_GEN_CALL(curr & (1u << 11u));
        M_RESTART_DET = I2C0_IC_INTR_MASK_M_RESTART_DET(curr & (1u << 12u));
    }

    /**
     * Set all of IC_INTR_MASK's bit fields.
     */
    inline void set_IC_INTR_MASK(
        I2C0_IC_INTR_MASK_M_RX_UNDER M_RX_UNDER,
        I2C0_IC_INTR_MASK_M_RX_OVER M_RX_OVER,
        I2C0_IC_INTR_MASK_M_RX_FULL M_RX_FULL,
        I2C0_IC_INTR_MASK_M_TX_OVER M_TX_OVER,
        I2C0_IC_INTR_MASK_M_TX_EMPTY M_TX_EMPTY,
        I2C0_IC_INTR_MASK_M_RD_REQ M_RD_REQ,
        I2C0_IC_INTR_MASK_M_TX_ABRT M_TX_ABRT,
        I2C0_IC_INTR_MASK_M_RX_DONE M_RX_DONE,
        I2C0_IC_INTR_MASK_M_ACTIVITY M_ACTIVITY,
        I2C0_IC_INTR_MASK_M_STOP_DET M_STOP_DET,
        I2C0_IC_INTR_MASK_M_START_DET M_START_DET,
        I2C0_IC_INTR_MASK_M_GEN_CALL M_GEN_CALL,
        I2C0_IC_INTR_MASK_M_RESTART_DET M_RESTART_DET) volatile
    {
        uint32_t curr = IC_INTR_MASK;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(M_RX_UNDER) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(M_RX_OVER) & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(M_RX_FULL) & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(M_TX_OVER) & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(M_TX_EMPTY) & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(M_RD_REQ) & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(M_TX_ABRT) & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (std::to_underlying(M_RX_DONE) & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(M_ACTIVITY) & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(M_STOP_DET) & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(M_START_DET) & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(M_GEN_CALL) & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (std::to_underlying(M_RESTART_DET) & 0b1u) << 12u;

        IC_INTR_MASK = curr;
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_UNDER bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_UNDER
    get_IC_RAW_INTR_STAT_RX_UNDER() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_UNDER(IC_RAW_INTR_STAT & (1u << 0u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_OVER bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_OVER
    get_IC_RAW_INTR_STAT_RX_OVER() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_OVER(IC_RAW_INTR_STAT & (1u << 1u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_FULL bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_FULL
    get_IC_RAW_INTR_STAT_RX_FULL() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_FULL(IC_RAW_INTR_STAT & (1u << 2u));
    }

    /**
     * Get IC_RAW_INTR_STAT's TX_OVER bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_TX_OVER
    get_IC_RAW_INTR_STAT_TX_OVER() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_TX_OVER(IC_RAW_INTR_STAT & (1u << 3u));
    }

    /**
     * Get IC_RAW_INTR_STAT's TX_EMPTY bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_TX_EMPTY
    get_IC_RAW_INTR_STAT_TX_EMPTY() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_TX_EMPTY(IC_RAW_INTR_STAT & (1u << 4u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RD_REQ bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_RD_REQ get_IC_RAW_INTR_STAT_RD_REQ() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RD_REQ(IC_RAW_INTR_STAT & (1u << 5u));
    }

    /**
     * Get IC_RAW_INTR_STAT's TX_ABRT bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_TX_ABRT
    get_IC_RAW_INTR_STAT_TX_ABRT() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_TX_ABRT(IC_RAW_INTR_STAT & (1u << 6u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_DONE bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_DONE
    get_IC_RAW_INTR_STAT_RX_DONE() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_DONE(IC_RAW_INTR_STAT & (1u << 7u));
    }

    /**
     * Get IC_RAW_INTR_STAT's ACTIVITY bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_ACTIVITY
    get_IC_RAW_INTR_STAT_ACTIVITY() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_ACTIVITY(IC_RAW_INTR_STAT & (1u << 8u));
    }

    /**
     * Get IC_RAW_INTR_STAT's STOP_DET bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_STOP_DET
    get_IC_RAW_INTR_STAT_STOP_DET() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_STOP_DET(IC_RAW_INTR_STAT & (1u << 9u));
    }

    /**
     * Get IC_RAW_INTR_STAT's START_DET bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_START_DET
    get_IC_RAW_INTR_STAT_START_DET() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_START_DET(IC_RAW_INTR_STAT & (1u << 10u));
    }

    /**
     * Get IC_RAW_INTR_STAT's GEN_CALL bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_GEN_CALL
    get_IC_RAW_INTR_STAT_GEN_CALL() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_GEN_CALL(IC_RAW_INTR_STAT & (1u << 11u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RESTART_DET bit.
     */
    inline I2C0_IC_RAW_INTR_STAT_RESTART_DET
    get_IC_RAW_INTR_STAT_RESTART_DET() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RESTART_DET(IC_RAW_INTR_STAT &
                                                 (1u << 12u));
    }

    /**
     * Get all of IC_RAW_INTR_STAT's bit fields.
     */
    inline void get_IC_RAW_INTR_STAT(
        I2C0_IC_RAW_INTR_STAT_RX_UNDER &RX_UNDER,
        I2C0_IC_RAW_INTR_STAT_RX_OVER &RX_OVER,
        I2C0_IC_RAW_INTR_STAT_RX_FULL &RX_FULL,
        I2C0_IC_RAW_INTR_STAT_TX_OVER &TX_OVER,
        I2C0_IC_RAW_INTR_STAT_TX_EMPTY &TX_EMPTY,
        I2C0_IC_RAW_INTR_STAT_RD_REQ &RD_REQ,
        I2C0_IC_RAW_INTR_STAT_TX_ABRT &TX_ABRT,
        I2C0_IC_RAW_INTR_STAT_RX_DONE &RX_DONE,
        I2C0_IC_RAW_INTR_STAT_ACTIVITY &ACTIVITY,
        I2C0_IC_RAW_INTR_STAT_STOP_DET &STOP_DET,
        I2C0_IC_RAW_INTR_STAT_START_DET &START_DET,
        I2C0_IC_RAW_INTR_STAT_GEN_CALL &GEN_CALL,
        I2C0_IC_RAW_INTR_STAT_RESTART_DET &RESTART_DET) volatile
    {
        uint32_t curr = IC_RAW_INTR_STAT;

        RX_UNDER = I2C0_IC_RAW_INTR_STAT_RX_UNDER(curr & (1u << 0u));
        RX_OVER = I2C0_IC_RAW_INTR_STAT_RX_OVER(curr & (1u << 1u));
        RX_FULL = I2C0_IC_RAW_INTR_STAT_RX_FULL(curr & (1u << 2u));
        TX_OVER = I2C0_IC_RAW_INTR_STAT_TX_OVER(curr & (1u << 3u));
        TX_EMPTY = I2C0_IC_RAW_INTR_STAT_TX_EMPTY(curr & (1u << 4u));
        RD_REQ = I2C0_IC_RAW_INTR_STAT_RD_REQ(curr & (1u << 5u));
        TX_ABRT = I2C0_IC_RAW_INTR_STAT_TX_ABRT(curr & (1u << 6u));
        RX_DONE = I2C0_IC_RAW_INTR_STAT_RX_DONE(curr & (1u << 7u));
        ACTIVITY = I2C0_IC_RAW_INTR_STAT_ACTIVITY(curr & (1u << 8u));
        STOP_DET = I2C0_IC_RAW_INTR_STAT_STOP_DET(curr & (1u << 9u));
        START_DET = I2C0_IC_RAW_INTR_STAT_START_DET(curr & (1u << 10u));
        GEN_CALL = I2C0_IC_RAW_INTR_STAT_GEN_CALL(curr & (1u << 11u));
        RESTART_DET = I2C0_IC_RAW_INTR_STAT_RESTART_DET(curr & (1u << 12u));
    }

    /**
     * Get IC_RX_TL's RX_TL field.
     */
    inline uint8_t get_IC_RX_TL_RX_TL() volatile
    {
        return (IC_RX_TL >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_RX_TL's RX_TL field.
     */
    inline void set_IC_RX_TL_RX_TL(uint8_t value) volatile
    {
        uint32_t curr = IC_RX_TL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_RX_TL = curr;
    }

    /**
     * Get IC_TX_TL's TX_TL field.
     */
    inline uint8_t get_IC_TX_TL_TX_TL() volatile
    {
        return (IC_TX_TL >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_TX_TL's TX_TL field.
     */
    inline void set_IC_TX_TL_TX_TL(uint8_t value) volatile
    {
        uint32_t curr = IC_TX_TL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_TX_TL = curr;
    }

    /**
     * Get IC_CLR_INTR's CLR_INTR bit.
     */
    inline bool get_IC_CLR_INTR_CLR_INTR() volatile
    {
        return IC_CLR_INTR & (1u << 0u);
    }

    /**
     * Get IC_CLR_RX_UNDER's CLR_RX_UNDER bit.
     */
    inline bool get_IC_CLR_RX_UNDER_CLR_RX_UNDER() volatile
    {
        return IC_CLR_RX_UNDER & (1u << 0u);
    }

    /**
     * Get IC_CLR_RX_OVER's CLR_RX_OVER bit.
     */
    inline bool get_IC_CLR_RX_OVER_CLR_RX_OVER() volatile
    {
        return IC_CLR_RX_OVER & (1u << 0u);
    }

    /**
     * Get IC_CLR_TX_OVER's CLR_TX_OVER bit.
     */
    inline bool get_IC_CLR_TX_OVER_CLR_TX_OVER() volatile
    {
        return IC_CLR_TX_OVER & (1u << 0u);
    }

    /**
     * Get IC_CLR_RD_REQ's CLR_RD_REQ bit.
     */
    inline bool get_IC_CLR_RD_REQ_CLR_RD_REQ() volatile
    {
        return IC_CLR_RD_REQ & (1u << 0u);
    }

    /**
     * Get IC_CLR_TX_ABRT's CLR_TX_ABRT bit.
     */
    inline bool get_IC_CLR_TX_ABRT_CLR_TX_ABRT() volatile
    {
        return IC_CLR_TX_ABRT & (1u << 0u);
    }

    /**
     * Get IC_CLR_RX_DONE's CLR_RX_DONE bit.
     */
    inline bool get_IC_CLR_RX_DONE_CLR_RX_DONE() volatile
    {
        return IC_CLR_RX_DONE & (1u << 0u);
    }

    /**
     * Get IC_CLR_ACTIVITY's CLR_ACTIVITY bit.
     */
    inline bool get_IC_CLR_ACTIVITY_CLR_ACTIVITY() volatile
    {
        return IC_CLR_ACTIVITY & (1u << 0u);
    }

    /**
     * Get IC_CLR_STOP_DET's CLR_STOP_DET bit.
     */
    inline bool get_IC_CLR_STOP_DET_CLR_STOP_DET() volatile
    {
        return IC_CLR_STOP_DET & (1u << 0u);
    }

    /**
     * Get IC_CLR_START_DET's CLR_START_DET bit.
     */
    inline bool get_IC_CLR_START_DET_CLR_START_DET() volatile
    {
        return IC_CLR_START_DET & (1u << 0u);
    }

    /**
     * Get IC_CLR_GEN_CALL's CLR_GEN_CALL bit.
     */
    inline bool get_IC_CLR_GEN_CALL_CLR_GEN_CALL() volatile
    {
        return IC_CLR_GEN_CALL & (1u << 0u);
    }

    /**
     * Get IC_ENABLE's ENABLE bit.
     */
    inline I2C0_IC_ENABLE_ENABLE get_IC_ENABLE_ENABLE() volatile
    {
        return I2C0_IC_ENABLE_ENABLE(IC_ENABLE & (1u << 0u));
    }

    /**
     * Set IC_ENABLE's ENABLE bit.
     */
    inline void set_IC_ENABLE_ENABLE() volatile
    {
        IC_ENABLE |= 1u << 0u;
    }

    /**
     * Clear IC_ENABLE's ENABLE bit.
     */
    inline void clear_IC_ENABLE_ENABLE() volatile
    {
        IC_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle IC_ENABLE's ENABLE bit.
     */
    inline void toggle_IC_ENABLE_ENABLE() volatile
    {
        IC_ENABLE ^= 1u << 0u;
    }

    /**
     * Get IC_ENABLE's ABORT bit.
     */
    inline I2C0_IC_ENABLE_ABORT get_IC_ENABLE_ABORT() volatile
    {
        return I2C0_IC_ENABLE_ABORT(IC_ENABLE & (1u << 1u));
    }

    /**
     * Set IC_ENABLE's ABORT bit.
     */
    inline void set_IC_ENABLE_ABORT() volatile
    {
        IC_ENABLE |= 1u << 1u;
    }

    /**
     * Clear IC_ENABLE's ABORT bit.
     */
    inline void clear_IC_ENABLE_ABORT() volatile
    {
        IC_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle IC_ENABLE's ABORT bit.
     */
    inline void toggle_IC_ENABLE_ABORT() volatile
    {
        IC_ENABLE ^= 1u << 1u;
    }

    /**
     * Get IC_ENABLE's TX_CMD_BLOCK bit.
     */
    inline I2C0_IC_ENABLE_TX_CMD_BLOCK get_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        return I2C0_IC_ENABLE_TX_CMD_BLOCK(IC_ENABLE & (1u << 2u));
    }

    /**
     * Set IC_ENABLE's TX_CMD_BLOCK bit.
     */
    inline void set_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        IC_ENABLE |= 1u << 2u;
    }

    /**
     * Clear IC_ENABLE's TX_CMD_BLOCK bit.
     */
    inline void clear_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        IC_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle IC_ENABLE's TX_CMD_BLOCK bit.
     */
    inline void toggle_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        IC_ENABLE ^= 1u << 2u;
    }

    /**
     * Get all of IC_ENABLE's bit fields.
     */
    inline void get_IC_ENABLE(
        I2C0_IC_ENABLE_ENABLE &ENABLE, I2C0_IC_ENABLE_ABORT &ABORT,
        I2C0_IC_ENABLE_TX_CMD_BLOCK &TX_CMD_BLOCK) volatile
    {
        uint32_t curr = IC_ENABLE;

        ENABLE = I2C0_IC_ENABLE_ENABLE(curr & (1u << 0u));
        ABORT = I2C0_IC_ENABLE_ABORT(curr & (1u << 1u));
        TX_CMD_BLOCK = I2C0_IC_ENABLE_TX_CMD_BLOCK(curr & (1u << 2u));
    }

    /**
     * Set all of IC_ENABLE's bit fields.
     */
    inline void set_IC_ENABLE(
        I2C0_IC_ENABLE_ENABLE ENABLE, I2C0_IC_ENABLE_ABORT ABORT,
        I2C0_IC_ENABLE_TX_CMD_BLOCK TX_CMD_BLOCK) volatile
    {
        uint32_t curr = IC_ENABLE;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(ENABLE) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(ABORT) & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(TX_CMD_BLOCK) & 0b1u) << 2u;

        IC_ENABLE = curr;
    }

    /**
     * Get IC_STATUS's ACTIVITY bit.
     */
    inline I2C0_IC_STATUS_ACTIVITY get_IC_STATUS_ACTIVITY() volatile
    {
        return I2C0_IC_STATUS_ACTIVITY(IC_STATUS & (1u << 0u));
    }

    /**
     * Get IC_STATUS's TFNF bit.
     */
    inline I2C0_IC_STATUS_TFNF get_IC_STATUS_TFNF() volatile
    {
        return I2C0_IC_STATUS_TFNF(IC_STATUS & (1u << 1u));
    }

    /**
     * Get IC_STATUS's TFE bit.
     */
    inline I2C0_IC_STATUS_TFE get_IC_STATUS_TFE() volatile
    {
        return I2C0_IC_STATUS_TFE(IC_STATUS & (1u << 2u));
    }

    /**
     * Get IC_STATUS's RFNE bit.
     */
    inline I2C0_IC_STATUS_RFNE get_IC_STATUS_RFNE() volatile
    {
        return I2C0_IC_STATUS_RFNE(IC_STATUS & (1u << 3u));
    }

    /**
     * Get IC_STATUS's RFF bit.
     */
    inline I2C0_IC_STATUS_RFF get_IC_STATUS_RFF() volatile
    {
        return I2C0_IC_STATUS_RFF(IC_STATUS & (1u << 4u));
    }

    /**
     * Get IC_STATUS's MST_ACTIVITY bit.
     */
    inline I2C0_IC_STATUS_MST_ACTIVITY get_IC_STATUS_MST_ACTIVITY() volatile
    {
        return I2C0_IC_STATUS_MST_ACTIVITY(IC_STATUS & (1u << 5u));
    }

    /**
     * Get IC_STATUS's SLV_ACTIVITY bit.
     */
    inline I2C0_IC_STATUS_SLV_ACTIVITY get_IC_STATUS_SLV_ACTIVITY() volatile
    {
        return I2C0_IC_STATUS_SLV_ACTIVITY(IC_STATUS & (1u << 6u));
    }

    /**
     * Get all of IC_STATUS's bit fields.
     */
    inline void get_IC_STATUS(
        I2C0_IC_STATUS_ACTIVITY &ACTIVITY, I2C0_IC_STATUS_TFNF &TFNF,
        I2C0_IC_STATUS_TFE &TFE, I2C0_IC_STATUS_RFNE &RFNE,
        I2C0_IC_STATUS_RFF &RFF, I2C0_IC_STATUS_MST_ACTIVITY &MST_ACTIVITY,
        I2C0_IC_STATUS_SLV_ACTIVITY &SLV_ACTIVITY) volatile
    {
        uint32_t curr = IC_STATUS;

        ACTIVITY = I2C0_IC_STATUS_ACTIVITY(curr & (1u << 0u));
        TFNF = I2C0_IC_STATUS_TFNF(curr & (1u << 1u));
        TFE = I2C0_IC_STATUS_TFE(curr & (1u << 2u));
        RFNE = I2C0_IC_STATUS_RFNE(curr & (1u << 3u));
        RFF = I2C0_IC_STATUS_RFF(curr & (1u << 4u));
        MST_ACTIVITY = I2C0_IC_STATUS_MST_ACTIVITY(curr & (1u << 5u));
        SLV_ACTIVITY = I2C0_IC_STATUS_SLV_ACTIVITY(curr & (1u << 6u));
    }

    /**
     * Get IC_TXFLR's TXFLR field.
     */
    inline uint8_t get_IC_TXFLR_TXFLR() volatile
    {
        return (IC_TXFLR >> 0u) & 0b11111u;
    }

    /**
     * Get IC_RXFLR's RXFLR field.
     */
    inline uint8_t get_IC_RXFLR_RXFLR() volatile
    {
        return (IC_RXFLR >> 0u) & 0b11111u;
    }

    /**
     * Get IC_SDA_HOLD's IC_SDA_TX_HOLD field.
     */
    inline uint16_t get_IC_SDA_HOLD_IC_SDA_TX_HOLD() volatile
    {
        return (IC_SDA_HOLD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_SDA_HOLD's IC_SDA_TX_HOLD field.
     */
    inline void set_IC_SDA_HOLD_IC_SDA_TX_HOLD(uint16_t value) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_SDA_HOLD = curr;
    }

    /**
     * Get IC_SDA_HOLD's IC_SDA_RX_HOLD field.
     */
    inline uint8_t get_IC_SDA_HOLD_IC_SDA_RX_HOLD() volatile
    {
        return (IC_SDA_HOLD >> 16u) & 0b11111111u;
    }

    /**
     * Set IC_SDA_HOLD's IC_SDA_RX_HOLD field.
     */
    inline void set_IC_SDA_HOLD_IC_SDA_RX_HOLD(uint8_t value) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        IC_SDA_HOLD = curr;
    }

    /**
     * Get all of IC_SDA_HOLD's bit fields.
     */
    inline void get_IC_SDA_HOLD(uint16_t &IC_SDA_TX_HOLD,
                                uint8_t &IC_SDA_RX_HOLD) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        IC_SDA_TX_HOLD = (curr >> 0u) & 0b1111111111111111u;
        IC_SDA_RX_HOLD = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Set all of IC_SDA_HOLD's bit fields.
     */
    inline void set_IC_SDA_HOLD(uint16_t IC_SDA_TX_HOLD,
                                uint8_t IC_SDA_RX_HOLD) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (IC_SDA_TX_HOLD & 0b1111111111111111u) << 0u;
        curr &= ~(0b11111111u << 16u);
        curr |= (IC_SDA_RX_HOLD & 0b11111111u) << 16u;

        IC_SDA_HOLD = curr;
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_7B_ADDR_NOACK bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK(IC_TX_ABRT_SOURCE &
                                                         (1u << 0u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_10ADDR1_NOACK bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK(IC_TX_ABRT_SOURCE &
                                                         (1u << 1u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_10ADDR2_NOACK bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK(IC_TX_ABRT_SOURCE &
                                                         (1u << 2u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_TXDATA_NOACK bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK(IC_TX_ABRT_SOURCE &
                                                        (1u << 3u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_GCALL_NOACK bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK(IC_TX_ABRT_SOURCE &
                                                       (1u << 4u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_GCALL_READ bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ
    get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ(IC_TX_ABRT_SOURCE &
                                                      (1u << 5u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_HS_ACKDET bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET
    get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET(IC_TX_ABRT_SOURCE &
                                                     (1u << 6u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SBYTE_ACKDET bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET
    get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET(IC_TX_ABRT_SOURCE &
                                                        (1u << 7u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_HS_NORSTRT bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT
    get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT(IC_TX_ABRT_SOURCE &
                                                      (1u << 8u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SBYTE_NORSTRT bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT
    get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT(IC_TX_ABRT_SOURCE &
                                                         (1u << 9u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_10B_RD_NORSTRT bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT
    get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT(IC_TX_ABRT_SOURCE &
                                                          (1u << 10u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_MASTER_DIS bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS
    get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS(IC_TX_ABRT_SOURCE &
                                                      (1u << 11u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ARB_LOST bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ARB_LOST
    get_IC_TX_ABRT_SOURCE_ARB_LOST() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ARB_LOST(IC_TX_ABRT_SOURCE &
                                               (1u << 12u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SLVFLUSH_TXFIFO bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO
    get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO(IC_TX_ABRT_SOURCE &
                                                           (1u << 13u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SLV_ARBLOST bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST
    get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST(IC_TX_ABRT_SOURCE &
                                                       (1u << 14u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SLVRD_INTX bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX
    get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX(IC_TX_ABRT_SOURCE &
                                                      (1u << 15u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_USER_ABRT bit.
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT
    get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT(IC_TX_ABRT_SOURCE &
                                                     (1u << 16u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's TX_FLUSH_CNT field.
     */
    inline uint16_t get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT() volatile
    {
        return (IC_TX_ABRT_SOURCE >> 23u) & 0b111111111u;
    }

    /**
     * Get all of IC_TX_ABRT_SOURCE's bit fields.
     */
    inline void get_IC_TX_ABRT_SOURCE(
        I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK &ABRT_7B_ADDR_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK &ABRT_10ADDR1_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK &ABRT_10ADDR2_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK &ABRT_TXDATA_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK &ABRT_GCALL_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ &ABRT_GCALL_READ,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET &ABRT_HS_ACKDET,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET &ABRT_SBYTE_ACKDET,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT &ABRT_HS_NORSTRT,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT &ABRT_SBYTE_NORSTRT,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT &ABRT_10B_RD_NORSTRT,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS &ABRT_MASTER_DIS,
        I2C0_IC_TX_ABRT_SOURCE_ARB_LOST &ARB_LOST,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO &ABRT_SLVFLUSH_TXFIFO,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST &ABRT_SLV_ARBLOST,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX &ABRT_SLVRD_INTX,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT &ABRT_USER_ABRT,
        uint16_t &TX_FLUSH_CNT) volatile
    {
        uint32_t curr = IC_TX_ABRT_SOURCE;

        ABRT_7B_ADDR_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK(curr & (1u << 0u));
        ABRT_10ADDR1_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK(curr & (1u << 1u));
        ABRT_10ADDR2_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK(curr & (1u << 2u));
        ABRT_TXDATA_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK(curr & (1u << 3u));
        ABRT_GCALL_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK(curr & (1u << 4u));
        ABRT_GCALL_READ =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ(curr & (1u << 5u));
        ABRT_HS_ACKDET =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET(curr & (1u << 6u));
        ABRT_SBYTE_ACKDET =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET(curr & (1u << 7u));
        ABRT_HS_NORSTRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT(curr & (1u << 8u));
        ABRT_SBYTE_NORSTRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT(curr & (1u << 9u));
        ABRT_10B_RD_NORSTRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT(curr & (1u << 10u));
        ABRT_MASTER_DIS =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS(curr & (1u << 11u));
        ARB_LOST = I2C0_IC_TX_ABRT_SOURCE_ARB_LOST(curr & (1u << 12u));
        ABRT_SLVFLUSH_TXFIFO =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO(curr & (1u << 13u));
        ABRT_SLV_ARBLOST =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST(curr & (1u << 14u));
        ABRT_SLVRD_INTX =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX(curr & (1u << 15u));
        ABRT_USER_ABRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT(curr & (1u << 16u));
        TX_FLUSH_CNT = (curr >> 23u) & 0b111111111u;
    }

    /**
     * Get IC_SLV_DATA_NACK_ONLY's NACK bit.
     */
    inline I2C0_IC_SLV_DATA_NACK_ONLY_NACK
    get_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        return I2C0_IC_SLV_DATA_NACK_ONLY_NACK(IC_SLV_DATA_NACK_ONLY &
                                               (1u << 0u));
    }

    /**
     * Set IC_SLV_DATA_NACK_ONLY's NACK bit.
     */
    inline void set_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        IC_SLV_DATA_NACK_ONLY |= 1u << 0u;
    }

    /**
     * Clear IC_SLV_DATA_NACK_ONLY's NACK bit.
     */
    inline void clear_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        IC_SLV_DATA_NACK_ONLY &= ~(1u << 0u);
    }

    /**
     * Toggle IC_SLV_DATA_NACK_ONLY's NACK bit.
     */
    inline void toggle_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        IC_SLV_DATA_NACK_ONLY ^= 1u << 0u;
    }

    /**
     * Get IC_DMA_CR's RDMAE bit.
     */
    inline I2C0_IC_DMA_CR_RDMAE get_IC_DMA_CR_RDMAE() volatile
    {
        return I2C0_IC_DMA_CR_RDMAE(IC_DMA_CR & (1u << 0u));
    }

    /**
     * Set IC_DMA_CR's RDMAE bit.
     */
    inline void set_IC_DMA_CR_RDMAE() volatile
    {
        IC_DMA_CR |= 1u << 0u;
    }

    /**
     * Clear IC_DMA_CR's RDMAE bit.
     */
    inline void clear_IC_DMA_CR_RDMAE() volatile
    {
        IC_DMA_CR &= ~(1u << 0u);
    }

    /**
     * Toggle IC_DMA_CR's RDMAE bit.
     */
    inline void toggle_IC_DMA_CR_RDMAE() volatile
    {
        IC_DMA_CR ^= 1u << 0u;
    }

    /**
     * Get IC_DMA_CR's TDMAE bit.
     */
    inline I2C0_IC_DMA_CR_TDMAE get_IC_DMA_CR_TDMAE() volatile
    {
        return I2C0_IC_DMA_CR_TDMAE(IC_DMA_CR & (1u << 1u));
    }

    /**
     * Set IC_DMA_CR's TDMAE bit.
     */
    inline void set_IC_DMA_CR_TDMAE() volatile
    {
        IC_DMA_CR |= 1u << 1u;
    }

    /**
     * Clear IC_DMA_CR's TDMAE bit.
     */
    inline void clear_IC_DMA_CR_TDMAE() volatile
    {
        IC_DMA_CR &= ~(1u << 1u);
    }

    /**
     * Toggle IC_DMA_CR's TDMAE bit.
     */
    inline void toggle_IC_DMA_CR_TDMAE() volatile
    {
        IC_DMA_CR ^= 1u << 1u;
    }

    /**
     * Get all of IC_DMA_CR's bit fields.
     */
    inline void get_IC_DMA_CR(I2C0_IC_DMA_CR_RDMAE &RDMAE,
                              I2C0_IC_DMA_CR_TDMAE &TDMAE) volatile
    {
        uint32_t curr = IC_DMA_CR;

        RDMAE = I2C0_IC_DMA_CR_RDMAE(curr & (1u << 0u));
        TDMAE = I2C0_IC_DMA_CR_TDMAE(curr & (1u << 1u));
    }

    /**
     * Set all of IC_DMA_CR's bit fields.
     */
    inline void set_IC_DMA_CR(I2C0_IC_DMA_CR_RDMAE RDMAE,
                              I2C0_IC_DMA_CR_TDMAE TDMAE) volatile
    {
        uint32_t curr = IC_DMA_CR;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(RDMAE) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(TDMAE) & 0b1u) << 1u;

        IC_DMA_CR = curr;
    }

    /**
     * Get IC_DMA_TDLR's DMATDL field.
     */
    inline uint8_t get_IC_DMA_TDLR_DMATDL() volatile
    {
        return (IC_DMA_TDLR >> 0u) & 0b1111u;
    }

    /**
     * Set IC_DMA_TDLR's DMATDL field.
     */
    inline void set_IC_DMA_TDLR_DMATDL(uint8_t value) volatile
    {
        uint32_t curr = IC_DMA_TDLR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        IC_DMA_TDLR = curr;
    }

    /**
     * Get IC_DMA_RDLR's DMARDL field.
     */
    inline uint8_t get_IC_DMA_RDLR_DMARDL() volatile
    {
        return (IC_DMA_RDLR >> 0u) & 0b1111u;
    }

    /**
     * Set IC_DMA_RDLR's DMARDL field.
     */
    inline void set_IC_DMA_RDLR_DMARDL(uint8_t value) volatile
    {
        uint32_t curr = IC_DMA_RDLR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        IC_DMA_RDLR = curr;
    }

    /**
     * Get IC_SDA_SETUP's SDA_SETUP field.
     */
    inline uint8_t get_IC_SDA_SETUP_SDA_SETUP() volatile
    {
        return (IC_SDA_SETUP >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_SDA_SETUP's SDA_SETUP field.
     */
    inline void set_IC_SDA_SETUP_SDA_SETUP(uint8_t value) volatile
    {
        uint32_t curr = IC_SDA_SETUP;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_SDA_SETUP = curr;
    }

    /**
     * Get IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     */
    inline I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL
    get_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        return I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL(IC_ACK_GENERAL_CALL &
                                                     (1u << 0u));
    }

    /**
     * Set IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     */
    inline void set_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        IC_ACK_GENERAL_CALL |= 1u << 0u;
    }

    /**
     * Clear IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     */
    inline void clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        IC_ACK_GENERAL_CALL &= ~(1u << 0u);
    }

    /**
     * Toggle IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     */
    inline void toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        IC_ACK_GENERAL_CALL ^= 1u << 0u;
    }

    /**
     * Get IC_ENABLE_STATUS's IC_EN bit.
     */
    inline I2C0_IC_ENABLE_STATUS_IC_EN get_IC_ENABLE_STATUS_IC_EN() volatile
    {
        return I2C0_IC_ENABLE_STATUS_IC_EN(IC_ENABLE_STATUS & (1u << 0u));
    }

    /**
     * Get IC_ENABLE_STATUS's SLV_DISABLED_WHILE_BUSY bit.
     */
    inline I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY
    get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY() volatile
    {
        return I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY(IC_ENABLE_STATUS &
                                                             (1u << 1u));
    }

    /**
     * Get IC_ENABLE_STATUS's SLV_RX_DATA_LOST bit.
     */
    inline I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST
    get_IC_ENABLE_STATUS_SLV_RX_DATA_LOST() volatile
    {
        return I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST(IC_ENABLE_STATUS &
                                                      (1u << 2u));
    }

    /**
     * Get all of IC_ENABLE_STATUS's bit fields.
     */
    inline void get_IC_ENABLE_STATUS(
        I2C0_IC_ENABLE_STATUS_IC_EN &IC_EN,
        I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY &SLV_DISABLED_WHILE_BUSY,
        I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST &SLV_RX_DATA_LOST) volatile
    {
        uint32_t curr = IC_ENABLE_STATUS;

        IC_EN = I2C0_IC_ENABLE_STATUS_IC_EN(curr & (1u << 0u));
        SLV_DISABLED_WHILE_BUSY =
            I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY(curr & (1u << 1u));
        SLV_RX_DATA_LOST =
            I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST(curr & (1u << 2u));
    }

    /**
     * Get IC_FS_SPKLEN's IC_FS_SPKLEN field.
     */
    inline uint8_t get_IC_FS_SPKLEN_IC_FS_SPKLEN() volatile
    {
        return (IC_FS_SPKLEN >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_FS_SPKLEN's IC_FS_SPKLEN field.
     */
    inline void set_IC_FS_SPKLEN_IC_FS_SPKLEN(uint8_t value) volatile
    {
        uint32_t curr = IC_FS_SPKLEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_FS_SPKLEN = curr;
    }

    /**
     * Get IC_CLR_RESTART_DET's CLR_RESTART_DET bit.
     */
    inline bool get_IC_CLR_RESTART_DET_CLR_RESTART_DET() volatile
    {
        return IC_CLR_RESTART_DET & (1u << 0u);
    }

    /**
     * Get IC_COMP_PARAM_1's APB_DATA_WIDTH field.
     */
    inline uint8_t get_IC_COMP_PARAM_1_APB_DATA_WIDTH() volatile
    {
        return (IC_COMP_PARAM_1 >> 0u) & 0b11u;
    }

    /**
     * Get IC_COMP_PARAM_1's MAX_SPEED_MODE field.
     */
    inline uint8_t get_IC_COMP_PARAM_1_MAX_SPEED_MODE() volatile
    {
        return (IC_COMP_PARAM_1 >> 2u) & 0b11u;
    }

    /**
     * Get IC_COMP_PARAM_1's HC_COUNT_VALUES bit.
     */
    inline bool get_IC_COMP_PARAM_1_HC_COUNT_VALUES() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 4u);
    }

    /**
     * Get IC_COMP_PARAM_1's INTR_IO bit.
     */
    inline bool get_IC_COMP_PARAM_1_INTR_IO() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 5u);
    }

    /**
     * Get IC_COMP_PARAM_1's HAS_DMA bit.
     */
    inline bool get_IC_COMP_PARAM_1_HAS_DMA() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 6u);
    }

    /**
     * Get IC_COMP_PARAM_1's ADD_ENCODED_PARAMS bit.
     */
    inline bool get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 7u);
    }

    /**
     * Get IC_COMP_PARAM_1's RX_BUFFER_DEPTH field.
     */
    inline uint8_t get_IC_COMP_PARAM_1_RX_BUFFER_DEPTH() volatile
    {
        return (IC_COMP_PARAM_1 >> 8u) & 0b11111111u;
    }

    /**
     * Get IC_COMP_PARAM_1's TX_BUFFER_DEPTH field.
     */
    inline uint8_t get_IC_COMP_PARAM_1_TX_BUFFER_DEPTH() volatile
    {
        return (IC_COMP_PARAM_1 >> 16u) & 0b11111111u;
    }

    /**
     * Get all of IC_COMP_PARAM_1's bit fields.
     */
    inline void get_IC_COMP_PARAM_1(uint8_t &APB_DATA_WIDTH,
                                    uint8_t &MAX_SPEED_MODE,
                                    bool &HC_COUNT_VALUES, bool &INTR_IO,
                                    bool &HAS_DMA, bool &ADD_ENCODED_PARAMS,
                                    uint8_t &RX_BUFFER_DEPTH,
                                    uint8_t &TX_BUFFER_DEPTH) volatile
    {
        uint32_t curr = IC_COMP_PARAM_1;

        APB_DATA_WIDTH = (curr >> 0u) & 0b11u;
        MAX_SPEED_MODE = (curr >> 2u) & 0b11u;
        HC_COUNT_VALUES = curr & (1u << 4u);
        INTR_IO = curr & (1u << 5u);
        HAS_DMA = curr & (1u << 6u);
        ADD_ENCODED_PARAMS = curr & (1u << 7u);
        RX_BUFFER_DEPTH = (curr >> 8u) & 0b11111111u;
        TX_BUFFER_DEPTH = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Get IC_COMP_VERSION's IC_COMP_VERSION field.
     */
    inline uint32_t get_IC_COMP_VERSION_IC_COMP_VERSION() volatile
    {
        return (IC_COMP_VERSION >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get IC_COMP_TYPE's IC_COMP_TYPE field.
     */
    inline uint32_t get_IC_COMP_TYPE_IC_COMP_TYPE() volatile
    {
        return (IC_COMP_TYPE >> 0u) & 0b11111111111111111111111111111111u;
    }
};

static_assert(sizeof(i2c0) == i2c0::size);

static volatile i2c0 *const I2C0 = reinterpret_cast<i2c0 *>(0x40044000);

static volatile i2c0 *const I2C1 = reinterpret_cast<i2c0 *>(0x40048000);

}; // namespace RP2040
