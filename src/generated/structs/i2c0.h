/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../enums/I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL.h"
#include "../enums/I2C0_IC_CON_IC_10BITADDR_MASTER.h"
#include "../enums/I2C0_IC_CON_IC_10BITADDR_SLAVE.h"
#include "../enums/I2C0_IC_CON_IC_RESTART_EN.h"
#include "../enums/I2C0_IC_CON_IC_SLAVE_DISABLE.h"
#include "../enums/I2C0_IC_CON_MASTER_MODE.h"
#include "../enums/I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL.h"
#include "../enums/I2C0_IC_CON_SPEED.h"
#include "../enums/I2C0_IC_CON_STOP_DET_IFADDRESSED.h"
#include "../enums/I2C0_IC_CON_TX_EMPTY_CTRL.h"
#include "../enums/I2C0_IC_DATA_CMD_CMD.h"
#include "../enums/I2C0_IC_DATA_CMD_FIRST_DATA_BYTE.h"
#include "../enums/I2C0_IC_DATA_CMD_RESTART.h"
#include "../enums/I2C0_IC_DATA_CMD_STOP.h"
#include "../enums/I2C0_IC_DMA_CR_RDMAE.h"
#include "../enums/I2C0_IC_DMA_CR_TDMAE.h"
#include "../enums/I2C0_IC_ENABLE_ABORT.h"
#include "../enums/I2C0_IC_ENABLE_ENABLE.h"
#include "../enums/I2C0_IC_ENABLE_STATUS_IC_EN.h"
#include "../enums/I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY.h"
#include "../enums/I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST.h"
#include "../enums/I2C0_IC_ENABLE_TX_CMD_BLOCK.h"
#include "../enums/I2C0_IC_INTR_MASK_M_ACTIVITY.h"
#include "../enums/I2C0_IC_INTR_MASK_M_GEN_CALL.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RD_REQ.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RESTART_DET.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_DONE.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_FULL.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_OVER.h"
#include "../enums/I2C0_IC_INTR_MASK_M_RX_UNDER.h"
#include "../enums/I2C0_IC_INTR_MASK_M_START_DET.h"
#include "../enums/I2C0_IC_INTR_MASK_M_STOP_DET.h"
#include "../enums/I2C0_IC_INTR_MASK_M_TX_ABRT.h"
#include "../enums/I2C0_IC_INTR_MASK_M_TX_EMPTY.h"
#include "../enums/I2C0_IC_INTR_MASK_M_TX_OVER.h"
#include "../enums/I2C0_IC_INTR_STAT_R_ACTIVITY.h"
#include "../enums/I2C0_IC_INTR_STAT_R_GEN_CALL.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RD_REQ.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RESTART_DET.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_DONE.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_FULL.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_OVER.h"
#include "../enums/I2C0_IC_INTR_STAT_R_RX_UNDER.h"
#include "../enums/I2C0_IC_INTR_STAT_R_START_DET.h"
#include "../enums/I2C0_IC_INTR_STAT_R_STOP_DET.h"
#include "../enums/I2C0_IC_INTR_STAT_R_TX_ABRT.h"
#include "../enums/I2C0_IC_INTR_STAT_R_TX_EMPTY.h"
#include "../enums/I2C0_IC_INTR_STAT_R_TX_OVER.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_ACTIVITY.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_GEN_CALL.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RD_REQ.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RESTART_DET.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_DONE.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_FULL.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_OVER.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_RX_UNDER.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_START_DET.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_STOP_DET.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_TX_ABRT.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_TX_EMPTY.h"
#include "../enums/I2C0_IC_RAW_INTR_STAT_TX_OVER.h"
#include "../enums/I2C0_IC_SLV_DATA_NACK_ONLY_NACK.h"
#include "../enums/I2C0_IC_STATUS_ACTIVITY.h"
#include "../enums/I2C0_IC_STATUS_MST_ACTIVITY.h"
#include "../enums/I2C0_IC_STATUS_RFF.h"
#include "../enums/I2C0_IC_STATUS_RFNE.h"
#include "../enums/I2C0_IC_STATUS_SLV_ACTIVITY.h"
#include "../enums/I2C0_IC_STATUS_TFE.h"
#include "../enums/I2C0_IC_STATUS_TFNF.h"
#include "../enums/I2C0_IC_TAR_GC_OR_START.h"
#include "../enums/I2C0_IC_TAR_SPECIAL.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT.h"
#include "../enums/I2C0_IC_TX_ABRT_SOURCE_ARB_LOST.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * DW_apb_i2c address block\n\n
 *         List of configuration constants for the Synopsys I2C hardware (you
 * may see references to these in I2C register header; these are *fixed*
 * values, set at hardware design time):\n\n IC_ULTRA_FAST_MODE
 * ................ 0x0\n IC_UFM_TBUF_CNT_DEFAULT ........... 0x8\n
 *         IC_UFM_SCL_LOW_COUNT .............. 0x0008\n
 *         IC_UFM_SCL_HIGH_COUNT ............. 0x0006\n
 *         IC_TX_TL .......................... 0x0\n
 *         IC_TX_CMD_BLOCK ................... 0x1\n
 *         IC_HAS_DMA ........................ 0x1\n
 *         IC_HAS_ASYNC_FIFO ................. 0x0\n
 *         IC_SMBUS_ARP ...................... 0x0\n
 *         IC_FIRST_DATA_BYTE_STATUS ......... 0x1\n
 *         IC_INTR_IO ........................ 0x1\n
 *         IC_MASTER_MODE .................... 0x1\n
 *         IC_DEFAULT_ACK_GENERAL_CALL ....... 0x1\n
 *         IC_INTR_POL ....................... 0x1\n
 *         IC_OPTIONAL_SAR ................... 0x0\n
 *         IC_DEFAULT_TAR_SLAVE_ADDR ......... 0x055\n
 *         IC_DEFAULT_SLAVE_ADDR ............. 0x055\n
 *         IC_DEFAULT_HS_SPKLEN .............. 0x1\n
 *         IC_FS_SCL_HIGH_COUNT .............. 0x0006\n
 *         IC_HS_SCL_LOW_COUNT ............... 0x0008\n
 *         IC_DEVICE_ID_VALUE ................ 0x0\n
 *         IC_10BITADDR_MASTER ............... 0x0\n
 *         IC_CLK_FREQ_OPTIMIZATION .......... 0x0\n
 *         IC_DEFAULT_FS_SPKLEN .............. 0x7\n
 *         IC_ADD_ENCODED_PARAMS ............. 0x0\n
 *         IC_DEFAULT_SDA_HOLD ............... 0x000001\n
 *         IC_DEFAULT_SDA_SETUP .............. 0x64\n
 *         IC_AVOID_RX_FIFO_FLUSH_ON_TX_ABRT . 0x0\n
 *         IC_CLOCK_PERIOD ................... 100\n
 *         IC_EMPTYFIFO_HOLD_MASTER_EN ....... 1\n
 *         IC_RESTART_EN ..................... 0x1\n
 *         IC_TX_CMD_BLOCK_DEFAULT ........... 0x0\n
 *         IC_BUS_CLEAR_FEATURE .............. 0x0\n
 *         IC_CAP_LOADING .................... 100\n
 *         IC_FS_SCL_LOW_COUNT ............... 0x000d\n
 *         APB_DATA_WIDTH .................... 32\n
 *         IC_SDA_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
 *         IC_SLV_DATA_NACK_ONLY ............. 0x1\n
 *         IC_10BITADDR_SLAVE ................ 0x0\n
 *         IC_CLK_TYPE ....................... 0x0\n
 *         IC_SMBUS_UDID_MSB ................. 0x0\n
 *         IC_SMBUS_SUSPEND_ALERT ............ 0x0\n
 *         IC_HS_SCL_HIGH_COUNT .............. 0x0006\n
 *         IC_SLV_RESTART_DET_EN ............. 0x1\n
 *         IC_SMBUS .......................... 0x0\n
 *         IC_OPTIONAL_SAR_DEFAULT ........... 0x0\n
 *         IC_PERSISTANT_SLV_ADDR_DEFAULT .... 0x0\n
 *         IC_USE_COUNTS ..................... 0x0\n
 *         IC_RX_BUFFER_DEPTH ................ 16\n
 *         IC_SCL_STUCK_TIMEOUT_DEFAULT ...... 0xffffffff\n
 *         IC_RX_FULL_HLD_BUS_EN ............. 0x1\n
 *         IC_SLAVE_DISABLE .................. 0x1\n
 *         IC_RX_TL .......................... 0x0\n
 *         IC_DEVICE_ID ...................... 0x0\n
 *         IC_HC_COUNT_VALUES ................ 0x0\n
 *         I2C_DYNAMIC_TAR_UPDATE ............ 0\n
 *         IC_SMBUS_CLK_LOW_MEXT_DEFAULT ..... 0xffffffff\n
 *         IC_SMBUS_CLK_LOW_SEXT_DEFAULT ..... 0xffffffff\n
 *         IC_HS_MASTER_CODE ................. 0x1\n
 *         IC_SMBUS_RST_IDLE_CNT_DEFAULT ..... 0xffff\n
 *         IC_SMBUS_UDID_LSB_DEFAULT ......... 0xffffffff\n
 *         IC_SS_SCL_HIGH_COUNT .............. 0x0028\n
 *         IC_SS_SCL_LOW_COUNT ............... 0x002f\n
 *         IC_MAX_SPEED_MODE ................. 0x2\n
 *         IC_STAT_FOR_CLK_STRETCH ........... 0x0\n
 *         IC_STOP_DET_IF_MASTER_ACTIVE ...... 0x0\n
 *         IC_DEFAULT_UFM_SPKLEN ............. 0x1\n
 *         IC_TX_BUFFER_DEPTH ................ 16
 */
struct [[gnu::packed]] i2c0
{
    /* Constant attributes. */
    static constexpr std::size_t size = 256; /*!< i2c0's size in bytes. */

    /* Fields. */
    uint32_t IC_CON; /*!< (read-write) I2C Control Register. This register can
be written only when the DW_apb_i2c is disabled, which corresponds to the
IC_ENABLE[0] register being set to 0. Writes at other times have no effect.\n\n
Read/Write Access: - bit 10 is read only. - bit 11 is read only - bit 16 is
read only - bit 17 is read only - bits 18 and 19 are read only. */
    uint32_t IC_TAR; /*!< (read-write) I2C Target Address Register\n\n
This register is 12 bits wide, and bits 31:12 are reserved. This register can
be written to only when IC_ENABLE[0] is set to 0.\n\n Note: If the software or
application is aware that the DW_apb_i2c is not using the TAR address for the
pending commands in the Tx FIFO, then it is possible to update the TAR address
even while the Tx FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to
perform any write to this register if DW_apb_i2c is enabled as an I2C slave
only. */
    uint32_t IC_SAR; /*!< (read-write) I2C Slave Address Register */
    const uint32_t reserved_padding0 = {};
    uint32_t IC_DATA_CMD; /*!< (read-write) I2C Rx/Tx Data Buffer and Command
Register; this is the register the CPU writes to when filling the TX FIFO and
the CPU reads from when retrieving bytes from RX FIFO.\n\n The size of the
register changes as follows:\n\n Write: - 11 bits when
IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read:
- 12 bits when IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when
IC_FIRST_DATA_BYTE_STATUS = 0 Note: In order for the DW_apb_i2c to continue
acknowledging reads, a read command should be written for every byte that is to
be received; otherwise the DW_apb_i2c will stop acknowledging. */
    uint32_t IC_SS_SCL_HCNT; /*!< (read-write) Standard Speed I2C Clock SCL
                                High Count Register */
    uint32_t IC_SS_SCL_LCNT; /*!< (read-write) Standard Speed I2C Clock SCL Low
                                Count Register */
    uint32_t IC_FS_SCL_HCNT; /*!< (read-write) Fast Mode or Fast Mode Plus I2C
                                Clock SCL High Count Register */
    uint32_t IC_FS_SCL_LCNT; /*!< (read-write) Fast Mode or Fast Mode Plus I2C
                                Clock SCL Low Count Register */
    static constexpr std::size_t reserved_padding1_length = 2;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    const uint32_t IC_INTR_STAT = {}; /*!< (read-only) I2C Interrupt Status
Register\n\n Each bit in this register has a corresponding mask bit in the
IC_INTR_MASK register. These bits are cleared by reading the matching interrupt
clear register. The unmasked raw versions of these bits are available in the
IC_RAW_INTR_STAT register. */
    uint32_t IC_INTR_MASK; /*!< (read-write) I2C Interrupt Mask Register.\n\n
These bits mask their corresponding interrupt status bits. This register is
active low; a value of 0 masks the interrupt, whereas a value of 1 unmasks the
interrupt. */
    const uint32_t IC_RAW_INTR_STAT = {}; /*!< (read-only) I2C Raw Interrupt
Status Register\n\n Unlike the IC_INTR_STAT register, these bits are not masked
so they always show the true status of the DW_apb_i2c. */
    uint32_t IC_RX_TL; /*!< (read-write) I2C Receive FIFO Threshold Register */
    uint32_t
        IC_TX_TL; /*!< (read-write) I2C Transmit FIFO Threshold Register */
    const uint32_t IC_CLR_INTR = {}; /*!< (read-only) Clear Combined and
                                        Individual Interrupt Register */
    const uint32_t IC_CLR_RX_UNDER =
        {}; /*!< (read-only) Clear RX_UNDER Interrupt Register */
    const uint32_t IC_CLR_RX_OVER =
        {}; /*!< (read-only) Clear RX_OVER Interrupt Register */
    const uint32_t IC_CLR_TX_OVER =
        {}; /*!< (read-only) Clear TX_OVER Interrupt Register */
    const uint32_t IC_CLR_RD_REQ =
        {}; /*!< (read-only) Clear RD_REQ Interrupt Register */
    const uint32_t IC_CLR_TX_ABRT =
        {}; /*!< (read-only) Clear TX_ABRT Interrupt Register */
    const uint32_t IC_CLR_RX_DONE =
        {}; /*!< (read-only) Clear RX_DONE Interrupt Register */
    const uint32_t IC_CLR_ACTIVITY =
        {}; /*!< (read-only) Clear ACTIVITY Interrupt Register */
    const uint32_t IC_CLR_STOP_DET =
        {}; /*!< (read-only) Clear STOP_DET Interrupt Register */
    const uint32_t IC_CLR_START_DET =
        {}; /*!< (read-only) Clear START_DET Interrupt Register */
    const uint32_t IC_CLR_GEN_CALL =
        {};             /*!< (read-only) Clear GEN_CALL Interrupt Register */
    uint32_t IC_ENABLE; /*!< (read-write) I2C Enable Register */
    const uint32_t IC_STATUS = {}; /*!< (read-only) I2C Status Register\n\n
This is a read-only register used to indicate the current transfer status and
FIFO status. The status register may be read at any time. None of the bits in
this register request an interrupt.\n\n When the I2C is disabled by writing 0
in bit 0 of the IC_ENABLE register: - Bits 1 and 2 are set to 1 - Bits 3 and 10
are set to 0 When the master or slave state machines goes to idle and ic_en=0:
- Bits 5 and 6 are set to 0 */
    const uint32_t IC_TXFLR =
        {}; /*!< (read-only) I2C Transmit FIFO Level Register This register
               contains the number of valid data entries in the transmit FIFO
               buffer. It is cleared whenever: - The I2C is disabled - There is
               a transmit abort - that is, TX_ABRT bit is set in the
               IC_RAW_INTR_STAT register - The slave bulk transmit mode is
               aborted The register increments whenever data is placed into the
               transmit FIFO and decrements when data is taken from the
               transmit FIFO. */
    const uint32_t IC_RXFLR =
        {}; /*!< (read-only) I2C Receive FIFO Level Register This register
               contains the number of valid data entries in the receive FIFO
               buffer. It is cleared whenever: - The I2C is disabled - Whenever
               there is a transmit abort caused by any of the events tracked in
               IC_TX_ABRT_SOURCE The register increments whenever data is
               placed into the receive FIFO and decrements when data is taken
               from the receive FIFO. */
    uint32_t IC_SDA_HOLD; /*!< (read-write) I2C SDA Hold Time Length
Register\n\n The bits [15:0] of this register are used to control the hold time
of SDA during transmit in both slave and master mode (after SCL goes from HIGH
to LOW).\n\n The bits [23:16] of this register are used to extend the SDA
transition (if any) whenever SCL is HIGH in the receiver in either master or
slave mode.\n\n Writes to this register succeed only when IC_ENABLE[0]=0.\n\n
The values in this register are in units of ic_clk period. The value programmed
in IC_SDA_TX_HOLD must be greater than the minimum hold time in each mode (one
cycle in master mode, seven cycles in slave mode) for the value to be
implemented.\n\n The programmed SDA hold time during transmit (IC_SDA_TX_HOLD)
cannot exceed at any time the duration of the low part of scl. Therefore the
programmed value cannot be larger than N_SCL_LOW-2, where N_SCL_LOW is the
duration of the low part of the scl period measured in ic_clk cycles. */
    const uint32_t IC_TX_ABRT_SOURCE =
        {}; /*!< (read-only) I2C Transmit Abort Source Register\n\n
This register has 32 bits that indicate the source of the TX_ABRT bit. Except
for Bit 9, this register is cleared whenever the IC_CLR_TX_ABRT register or the
IC_CLR_INTR register is read. To clear Bit 9, the source of the
ABRT_SBYTE_NORSTRT must be fixed first; RESTART must be enabled (IC_CON[5]=1),
the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START bit must be
cleared (IC_TAR[10]).\n\n Once the source of the ABRT_SBYTE_NORSTRT is fixed,
then this bit can be cleared in the same manner as other bits in this register.
If the source of the ABRT_SBYTE_NORSTRT is not fixed before attempting to clear
this bit, Bit 9 clears for one cycle and is then re-asserted. */
    uint32_t IC_SLV_DATA_NACK_ONLY; /*!< (read-write) Generate Slave Data NACK
Register\n\n The register is used to generate a NACK for the data part of a
transfer when DW_apb_i2c is acting as a slave-receiver. This register only
exists when the IC_SLV_DATA_NACK_ONLY parameter is set to 1. When this
parameter disabled, this register does not exist and writing to the register's
address has no effect.\n\n A write can occur on this register if both of the
following conditions are met: - DW_apb_i2c is disabled (IC_ENABLE[0] = 0) -
Slave part is inactive (IC_STATUS[6] = 0) Note: The IC_STATUS[6] is a register
read-back location for the internal slv_activity signal; the user should poll
this before writing the ic_slv_data_nack_only bit. */
    uint32_t IC_DMA_CR;             /*!< (read-write) DMA Control Register\n\n
The register is used to enable the DMA Controller interface operation. There is
            a separate bit for transmit and receive. This can be programmed regardless of
            the state of IC_ENABLE. */
    uint32_t IC_DMA_TDLR; /*!< (read-write) DMA Transmit Data Level Register */
    uint32_t IC_DMA_RDLR; /*!< (read-write) I2C Receive Data Level Register */
    uint32_t IC_SDA_SETUP;        /*!< (read-write) I2C SDA Setup Register\n\n
This register controls the amount of time delay (in terms of number of ic_clk
       clock periods) introduced in the rising edge of SCL - relative to SDA changing
       - when DW_apb_i2c services a read request in a slave-transmitter operation. The
       relevant I2C requirement is tSU:DAT (note 4) as detailed in the I2C Bus
       Specification. This register must be programmed with a value equal to or
       greater than 2.\n\n        Writes to this register succeed only when
       IC_ENABLE[0] =        0.\n\n        Note: The length of setup time is
       calculated using
       [(IC_SDA_SETUP - 1) *        (ic_clk_period)], so if the user requires 10
       ic_clk        periods of setup time, they        should program a value of 11.
       The        IC_SDA_SETUP        register is only used by the        DW_apb_i2c
       when        operating as a        slave transmitter.
       */
    uint32_t IC_ACK_GENERAL_CALL; /*!< (read-write) I2C ACK General Call
Register\n\n The register controls whether DW_apb_i2c responds with a ACK or
NACK when it receives an I2C General Call address.\n\n This register is
applicable only when the DW_apb_i2c is in slave mode. */
    const uint32_t IC_ENABLE_STATUS = {}; /*!< (read-only) I2C Enable Status
Register\n\n The register is used to report the DW_apb_i2c hardware status when
the IC_ENABLE[0] register is set from 1 to 0; that is, when DW_apb_i2c is
disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1 are forced to 0, and
bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been set to 0, bits 2:1 is only
be valid as soon as bit 0 is read as '0'.\n\n Note: When IC_ENABLE[0] has been
set to 0, a delay occurs for bit 0 to be read as 0 because disabling the
DW_apb_i2c depends on I2C bus activities. */
    uint32_t IC_FS_SPKLEN; /*!< (read-write) I2C SS, FS or FM+ spike
suppression limit\n\n This register is used to store the duration, measured in
ic_clk cycles, of the longest spike that is filtered out by the spike
suppression logic when the component is operating in SS, FS or FM+ modes. The
relevant I2C requirement is tSP (table 4) as detailed in the I2C Bus
Specification. This register must be programmed with a minimum value of 1. */
    const uint32_t reserved_padding2 = {};
    const uint32_t IC_CLR_RESTART_DET =
        {}; /*!< (read-only) Clear RESTART_DET Interrupt Register */
    static constexpr std::size_t reserved_padding3_length = 18;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    const uint32_t IC_COMP_PARAM_1 = {}; /*!< (read-only) Component Parameter
Register 1\n\n Note This register is not implemented and therefore reads as 0.
If it was implemented it would be a constant read-only register that contains
encoded information about the component's parameter settings. Fields shown
below are the settings for those parameters */
    const uint32_t IC_COMP_VERSION =
        {}; /*!< (read-only) I2C Component Version Register */
    const uint32_t IC_COMP_TYPE =
        {}; /*!< (read-only) I2C Component Type Register */

    /* Methods. */

    /**
     * Get IC_CON's MASTER_MODE bit.
     *
     * This bit controls whether the DW_apb_i2c master is enabled.\n\n
     *                 NOTE: Software should ensure that if this bit is written
     * with '1' then bit 6 should also be written with a '1'.
     */
    inline I2C0_IC_CON_MASTER_MODE get_IC_CON_MASTER_MODE() volatile
    {
        return I2C0_IC_CON_MASTER_MODE(IC_CON & (1u << 0u));
    }

    /**
     * Set IC_CON's MASTER_MODE bit.
     *
     * This bit controls whether the DW_apb_i2c master is enabled.\n\n
     *                 NOTE: Software should ensure that if this bit is written
     * with '1' then bit 6 should also be written with a '1'.
     */
    inline void set_IC_CON_MASTER_MODE() volatile
    {
        IC_CON |= 1u << 0u;
    }

    /**
     * Clear IC_CON's MASTER_MODE bit.
     *
     * This bit controls whether the DW_apb_i2c master is enabled.\n\n
     *                 NOTE: Software should ensure that if this bit is written
     * with '1' then bit 6 should also be written with a '1'.
     */
    inline void clear_IC_CON_MASTER_MODE() volatile
    {
        IC_CON &= ~(1u << 0u);
    }

    /**
     * Toggle IC_CON's MASTER_MODE bit.
     *
     * This bit controls whether the DW_apb_i2c master is enabled.\n\n
     *                 NOTE: Software should ensure that if this bit is written
     * with '1' then bit 6 should also be written with a '1'.
     */
    inline void toggle_IC_CON_MASTER_MODE() volatile
    {
        IC_CON ^= 1u << 0u;
    }

    /**
     * Get IC_CON's SPEED field.
     *
     * These bits control at which speed the DW_apb_i2c operates; its setting
     * is relevant only if one is operating the DW_apb_i2c in master mode.
     * Hardware protects against illegal values being programmed by software.
     * These bits must be programmed appropriately for slave mode also, as it
     * is used to capture correct value of spike filter as per the speed
     * mode.\n\n This register should be programmed only with a value in the
     * range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this
     * register with the value of IC_MAX_SPEED_MODE.\n\n 1: standard mode (100
     * kbit/s)\n\n 2: fast mode (<=400 kbit/s) or fast mode plus
     * (<=1000Kbit/s)\n\n 3: high speed mode (3.4 Mbit/s)\n\n Note: This field
     * is not applicable when IC_ULTRA_FAST_MODE=1
     */
    inline I2C0_IC_CON_SPEED get_IC_CON_SPEED() volatile
    {
        return I2C0_IC_CON_SPEED((IC_CON >> 1u) & 0b11u);
    }

    /**
     * Set IC_CON's SPEED field.
     *
     * These bits control at which speed the DW_apb_i2c operates; its setting
     * is relevant only if one is operating the DW_apb_i2c in master mode.
     * Hardware protects against illegal values being programmed by software.
     * These bits must be programmed appropriately for slave mode also, as it
     * is used to capture correct value of spike filter as per the speed
     * mode.\n\n This register should be programmed only with a value in the
     * range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware updates this
     * register with the value of IC_MAX_SPEED_MODE.\n\n 1: standard mode (100
     * kbit/s)\n\n 2: fast mode (<=400 kbit/s) or fast mode plus
     * (<=1000Kbit/s)\n\n 3: high speed mode (3.4 Mbit/s)\n\n Note: This field
     * is not applicable when IC_ULTRA_FAST_MODE=1
     */
    inline void set_IC_CON_SPEED(I2C0_IC_CON_SPEED value) volatile
    {
        uint32_t curr = IC_CON;

        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(value) & 0b11u) << 1u;

        IC_CON = curr;
    }

    /**
     * Get IC_CON's IC_10BITADDR_SLAVE bit.
     *
     * When acting as a slave, this bit controls whether the DW_apb_i2c
     * responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The
     * DW_apb_i2c ignores transactions that involve 10-bit addressing; for
     * 7-bit addressing, only the lower 7 bits of the IC_SAR register are
     * compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit
     * addressing transfers that match the full 10 bits of the IC_SAR register.
     */
    inline I2C0_IC_CON_IC_10BITADDR_SLAVE
    get_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        return I2C0_IC_CON_IC_10BITADDR_SLAVE(IC_CON & (1u << 3u));
    }

    /**
     * Set IC_CON's IC_10BITADDR_SLAVE bit.
     *
     * When acting as a slave, this bit controls whether the DW_apb_i2c
     * responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The
     * DW_apb_i2c ignores transactions that involve 10-bit addressing; for
     * 7-bit addressing, only the lower 7 bits of the IC_SAR register are
     * compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit
     * addressing transfers that match the full 10 bits of the IC_SAR register.
     */
    inline void set_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        IC_CON |= 1u << 3u;
    }

    /**
     * Clear IC_CON's IC_10BITADDR_SLAVE bit.
     *
     * When acting as a slave, this bit controls whether the DW_apb_i2c
     * responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The
     * DW_apb_i2c ignores transactions that involve 10-bit addressing; for
     * 7-bit addressing, only the lower 7 bits of the IC_SAR register are
     * compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit
     * addressing transfers that match the full 10 bits of the IC_SAR register.
     */
    inline void clear_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        IC_CON &= ~(1u << 3u);
    }

    /**
     * Toggle IC_CON's IC_10BITADDR_SLAVE bit.
     *
     * When acting as a slave, this bit controls whether the DW_apb_i2c
     * responds to 7- or 10-bit addresses. - 0: 7-bit addressing. The
     * DW_apb_i2c ignores transactions that involve 10-bit addressing; for
     * 7-bit addressing, only the lower 7 bits of the IC_SAR register are
     * compared. - 1: 10-bit addressing. The DW_apb_i2c responds to only 10-bit
     * addressing transfers that match the full 10 bits of the IC_SAR register.
     */
    inline void toggle_IC_CON_IC_10BITADDR_SLAVE() volatile
    {
        IC_CON ^= 1u << 3u;
    }

    /**
     * Get IC_CON's IC_10BITADDR_MASTER bit.
     *
     * Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit
     * addressing mode when acting as a master. - 0: 7-bit addressing - 1:
     * 10-bit addressing
     */
    inline I2C0_IC_CON_IC_10BITADDR_MASTER
    get_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        return I2C0_IC_CON_IC_10BITADDR_MASTER(IC_CON & (1u << 4u));
    }

    /**
     * Set IC_CON's IC_10BITADDR_MASTER bit.
     *
     * Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit
     * addressing mode when acting as a master. - 0: 7-bit addressing - 1:
     * 10-bit addressing
     */
    inline void set_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        IC_CON |= 1u << 4u;
    }

    /**
     * Clear IC_CON's IC_10BITADDR_MASTER bit.
     *
     * Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit
     * addressing mode when acting as a master. - 0: 7-bit addressing - 1:
     * 10-bit addressing
     */
    inline void clear_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        IC_CON &= ~(1u << 4u);
    }

    /**
     * Toggle IC_CON's IC_10BITADDR_MASTER bit.
     *
     * Controls whether the DW_apb_i2c starts its transfers in 7- or 10-bit
     * addressing mode when acting as a master. - 0: 7-bit addressing - 1:
     * 10-bit addressing
     */
    inline void toggle_IC_CON_IC_10BITADDR_MASTER() volatile
    {
        IC_CON ^= 1u << 4u;
    }

    /**
     * Get IC_CON's IC_RESTART_EN bit.
     *
     * Determines whether RESTART conditions may be sent when acting as a
     * master. Some older slaves do not support handling RESTART conditions;
     * however, RESTART conditions are used in several DW_apb_i2c operations.
     * When RESTART is disabled, the master is prohibited from performing the
     * following functions: - Sending a START BYTE - Performing any high-speed
     * mode operation - High-speed mode operation - Performing direction
     * changes in combined format mode - Performing a read operation with a
     * 10-bit address By replacing RESTART condition followed by a STOP and a
     * subsequent START condition, split operations are broken down into
     * multiple DW_apb_i2c transfers. If the above operations are performed, it
     * will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register.\n\n Reset value: ENABLED
     */
    inline I2C0_IC_CON_IC_RESTART_EN get_IC_CON_IC_RESTART_EN() volatile
    {
        return I2C0_IC_CON_IC_RESTART_EN(IC_CON & (1u << 5u));
    }

    /**
     * Set IC_CON's IC_RESTART_EN bit.
     *
     * Determines whether RESTART conditions may be sent when acting as a
     * master. Some older slaves do not support handling RESTART conditions;
     * however, RESTART conditions are used in several DW_apb_i2c operations.
     * When RESTART is disabled, the master is prohibited from performing the
     * following functions: - Sending a START BYTE - Performing any high-speed
     * mode operation - High-speed mode operation - Performing direction
     * changes in combined format mode - Performing a read operation with a
     * 10-bit address By replacing RESTART condition followed by a STOP and a
     * subsequent START condition, split operations are broken down into
     * multiple DW_apb_i2c transfers. If the above operations are performed, it
     * will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register.\n\n Reset value: ENABLED
     */
    inline void set_IC_CON_IC_RESTART_EN() volatile
    {
        IC_CON |= 1u << 5u;
    }

    /**
     * Clear IC_CON's IC_RESTART_EN bit.
     *
     * Determines whether RESTART conditions may be sent when acting as a
     * master. Some older slaves do not support handling RESTART conditions;
     * however, RESTART conditions are used in several DW_apb_i2c operations.
     * When RESTART is disabled, the master is prohibited from performing the
     * following functions: - Sending a START BYTE - Performing any high-speed
     * mode operation - High-speed mode operation - Performing direction
     * changes in combined format mode - Performing a read operation with a
     * 10-bit address By replacing RESTART condition followed by a STOP and a
     * subsequent START condition, split operations are broken down into
     * multiple DW_apb_i2c transfers. If the above operations are performed, it
     * will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register.\n\n Reset value: ENABLED
     */
    inline void clear_IC_CON_IC_RESTART_EN() volatile
    {
        IC_CON &= ~(1u << 5u);
    }

    /**
     * Toggle IC_CON's IC_RESTART_EN bit.
     *
     * Determines whether RESTART conditions may be sent when acting as a
     * master. Some older slaves do not support handling RESTART conditions;
     * however, RESTART conditions are used in several DW_apb_i2c operations.
     * When RESTART is disabled, the master is prohibited from performing the
     * following functions: - Sending a START BYTE - Performing any high-speed
     * mode operation - High-speed mode operation - Performing direction
     * changes in combined format mode - Performing a read operation with a
     * 10-bit address By replacing RESTART condition followed by a STOP and a
     * subsequent START condition, split operations are broken down into
     * multiple DW_apb_i2c transfers. If the above operations are performed, it
     * will result in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register.\n\n Reset value: ENABLED
     */
    inline void toggle_IC_CON_IC_RESTART_EN() volatile
    {
        IC_CON ^= 1u << 5u;
    }

    /**
     * Get IC_CON's IC_SLAVE_DISABLE bit.
     *
     * This bit controls whether I2C has its slave disabled, which means once
     * the presetn signal is applied, then this bit is set and the slave is
     * disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c
     * functions only as a master and does not perform any action that requires
     * a slave.\n\n NOTE: Software should ensure that if this bit is written
     * with 0, then bit 0 should also be written with a 0.
     */
    inline I2C0_IC_CON_IC_SLAVE_DISABLE get_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        return I2C0_IC_CON_IC_SLAVE_DISABLE(IC_CON & (1u << 6u));
    }

    /**
     * Set IC_CON's IC_SLAVE_DISABLE bit.
     *
     * This bit controls whether I2C has its slave disabled, which means once
     * the presetn signal is applied, then this bit is set and the slave is
     * disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c
     * functions only as a master and does not perform any action that requires
     * a slave.\n\n NOTE: Software should ensure that if this bit is written
     * with 0, then bit 0 should also be written with a 0.
     */
    inline void set_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        IC_CON |= 1u << 6u;
    }

    /**
     * Clear IC_CON's IC_SLAVE_DISABLE bit.
     *
     * This bit controls whether I2C has its slave disabled, which means once
     * the presetn signal is applied, then this bit is set and the slave is
     * disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c
     * functions only as a master and does not perform any action that requires
     * a slave.\n\n NOTE: Software should ensure that if this bit is written
     * with 0, then bit 0 should also be written with a 0.
     */
    inline void clear_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        IC_CON &= ~(1u << 6u);
    }

    /**
     * Toggle IC_CON's IC_SLAVE_DISABLE bit.
     *
     * This bit controls whether I2C has its slave disabled, which means once
     * the presetn signal is applied, then this bit is set and the slave is
     * disabled.\n\n If this bit is set (slave is disabled), DW_apb_i2c
     * functions only as a master and does not perform any action that requires
     * a slave.\n\n NOTE: Software should ensure that if this bit is written
     * with 0, then bit 0 should also be written with a 0.
     */
    inline void toggle_IC_CON_IC_SLAVE_DISABLE() volatile
    {
        IC_CON ^= 1u << 6u;
    }

    /**
     * Get IC_CON's STOP_DET_IFADDRESSED bit.
     *
     * In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is
     * addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's
     * addressed or not. Reset value: 0x0\n\n NOTE: During a general call
     * address, this slave does not issue the STOP_DET interrupt if
     * STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general
     * call address by generating ACK. The STOP_DET interrupt is generated only
     * when the transmitted address matches the slave address (SAR).
     */
    inline I2C0_IC_CON_STOP_DET_IFADDRESSED
    get_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        return I2C0_IC_CON_STOP_DET_IFADDRESSED(IC_CON & (1u << 7u));
    }

    /**
     * Set IC_CON's STOP_DET_IFADDRESSED bit.
     *
     * In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is
     * addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's
     * addressed or not. Reset value: 0x0\n\n NOTE: During a general call
     * address, this slave does not issue the STOP_DET interrupt if
     * STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general
     * call address by generating ACK. The STOP_DET interrupt is generated only
     * when the transmitted address matches the slave address (SAR).
     */
    inline void set_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        IC_CON |= 1u << 7u;
    }

    /**
     * Clear IC_CON's STOP_DET_IFADDRESSED bit.
     *
     * In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is
     * addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's
     * addressed or not. Reset value: 0x0\n\n NOTE: During a general call
     * address, this slave does not issue the STOP_DET interrupt if
     * STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general
     * call address by generating ACK. The STOP_DET interrupt is generated only
     * when the transmitted address matches the slave address (SAR).
     */
    inline void clear_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        IC_CON &= ~(1u << 7u);
    }

    /**
     * Toggle IC_CON's STOP_DET_IFADDRESSED bit.
     *
     * In slave mode: - 1'b1:  issues the STOP_DET interrupt only when it is
     * addressed. - 1'b0:  issues the STOP_DET irrespective of whether it's
     * addressed or not. Reset value: 0x0\n\n NOTE: During a general call
     * address, this slave does not issue the STOP_DET interrupt if
     * STOP_DET_IF_ADDRESSED = 1'b1, even if the slave responds to the general
     * call address by generating ACK. The STOP_DET interrupt is generated only
     * when the transmitted address matches the slave address (SAR).
     */
    inline void toggle_IC_CON_STOP_DET_IFADDRESSED() volatile
    {
        IC_CON ^= 1u << 7u;
    }

    /**
     * Get IC_CON's TX_EMPTY_CTRL bit.
     *
     * This bit controls the generation of the TX_EMPTY interrupt, as described
     * in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
     */
    inline I2C0_IC_CON_TX_EMPTY_CTRL get_IC_CON_TX_EMPTY_CTRL() volatile
    {
        return I2C0_IC_CON_TX_EMPTY_CTRL(IC_CON & (1u << 8u));
    }

    /**
     * Set IC_CON's TX_EMPTY_CTRL bit.
     *
     * This bit controls the generation of the TX_EMPTY interrupt, as described
     * in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
     */
    inline void set_IC_CON_TX_EMPTY_CTRL() volatile
    {
        IC_CON |= 1u << 8u;
    }

    /**
     * Clear IC_CON's TX_EMPTY_CTRL bit.
     *
     * This bit controls the generation of the TX_EMPTY interrupt, as described
     * in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
     */
    inline void clear_IC_CON_TX_EMPTY_CTRL() volatile
    {
        IC_CON &= ~(1u << 8u);
    }

    /**
     * Toggle IC_CON's TX_EMPTY_CTRL bit.
     *
     * This bit controls the generation of the TX_EMPTY interrupt, as described
     * in the IC_RAW_INTR_STAT register.\n\n Reset value: 0x0.
     */
    inline void toggle_IC_CON_TX_EMPTY_CTRL() volatile
    {
        IC_CON ^= 1u << 8u;
    }

    /**
     * Get IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     *
     * This bit controls whether DW_apb_i2c should hold the bus when the Rx
     * FIFO is physically full to its RX_BUFFER_DEPTH, as described in the
     * IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
     */
    inline I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL
    get_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        return I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL(IC_CON & (1u << 9u));
    }

    /**
     * Set IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     *
     * This bit controls whether DW_apb_i2c should hold the bus when the Rx
     * FIFO is physically full to its RX_BUFFER_DEPTH, as described in the
     * IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
     */
    inline void set_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        IC_CON |= 1u << 9u;
    }

    /**
     * Clear IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     *
     * This bit controls whether DW_apb_i2c should hold the bus when the Rx
     * FIFO is physically full to its RX_BUFFER_DEPTH, as described in the
     * IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
     */
    inline void clear_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        IC_CON &= ~(1u << 9u);
    }

    /**
     * Toggle IC_CON's RX_FIFO_FULL_HLD_CTRL bit.
     *
     * This bit controls whether DW_apb_i2c should hold the bus when the Rx
     * FIFO is physically full to its RX_BUFFER_DEPTH, as described in the
     * IC_RX_FULL_HLD_BUS_EN parameter.\n\n Reset value: 0x0.
     */
    inline void toggle_IC_CON_RX_FIFO_FULL_HLD_CTRL() volatile
    {
        IC_CON ^= 1u << 9u;
    }

    /**
     * Get IC_CON's STOP_DET_IF_MASTER_ACTIVE bit.
     *
     * Master issues the STOP_DET interrupt irrespective of whether master is
     * active or not
     */
    inline bool get_IC_CON_STOP_DET_IF_MASTER_ACTIVE() volatile
    {
        return IC_CON & (1u << 10u);
    }

    /**
     * Get all of IC_CON's bit fields.
     *
     * (read-write) I2C Control Register. This register can be written only
     * when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0]
     * register being set to 0. Writes at other times have no effect.\n\n
     *             Read/Write Access: - bit 10 is read only. - bit 11 is read
     * only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are
     * read only.
     */
    inline void get_IC_CON(
        I2C0_IC_CON_MASTER_MODE &MASTER_MODE, I2C0_IC_CON_SPEED &SPEED,
        I2C0_IC_CON_IC_10BITADDR_SLAVE &IC_10BITADDR_SLAVE,
        I2C0_IC_CON_IC_10BITADDR_MASTER &IC_10BITADDR_MASTER,
        I2C0_IC_CON_IC_RESTART_EN &IC_RESTART_EN,
        I2C0_IC_CON_IC_SLAVE_DISABLE &IC_SLAVE_DISABLE,
        I2C0_IC_CON_STOP_DET_IFADDRESSED &STOP_DET_IFADDRESSED,
        I2C0_IC_CON_TX_EMPTY_CTRL &TX_EMPTY_CTRL,
        I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL &RX_FIFO_FULL_HLD_CTRL,
        bool &STOP_DET_IF_MASTER_ACTIVE) volatile
    {
        uint32_t curr = IC_CON;

        MASTER_MODE = I2C0_IC_CON_MASTER_MODE(curr & (1u << 0u));
        SPEED = I2C0_IC_CON_SPEED((curr >> 1u) & 0b11u);
        IC_10BITADDR_SLAVE = I2C0_IC_CON_IC_10BITADDR_SLAVE(curr & (1u << 3u));
        IC_10BITADDR_MASTER =
            I2C0_IC_CON_IC_10BITADDR_MASTER(curr & (1u << 4u));
        IC_RESTART_EN = I2C0_IC_CON_IC_RESTART_EN(curr & (1u << 5u));
        IC_SLAVE_DISABLE = I2C0_IC_CON_IC_SLAVE_DISABLE(curr & (1u << 6u));
        STOP_DET_IFADDRESSED =
            I2C0_IC_CON_STOP_DET_IFADDRESSED(curr & (1u << 7u));
        TX_EMPTY_CTRL = I2C0_IC_CON_TX_EMPTY_CTRL(curr & (1u << 8u));
        RX_FIFO_FULL_HLD_CTRL =
            I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL(curr & (1u << 9u));
        STOP_DET_IF_MASTER_ACTIVE = curr & (1u << 10u);
    }

    /**
     * Set all of IC_CON's bit fields.
     *
     * (read-write) I2C Control Register. This register can be written only
     * when the DW_apb_i2c is disabled, which corresponds to the IC_ENABLE[0]
     * register being set to 0. Writes at other times have no effect.\n\n
     *             Read/Write Access: - bit 10 is read only. - bit 11 is read
     * only - bit 16 is read only - bit 17 is read only - bits 18 and 19 are
     * read only.
     */
    inline void set_IC_CON(
        I2C0_IC_CON_MASTER_MODE MASTER_MODE, I2C0_IC_CON_SPEED SPEED,
        I2C0_IC_CON_IC_10BITADDR_SLAVE IC_10BITADDR_SLAVE,
        I2C0_IC_CON_IC_10BITADDR_MASTER IC_10BITADDR_MASTER,
        I2C0_IC_CON_IC_RESTART_EN IC_RESTART_EN,
        I2C0_IC_CON_IC_SLAVE_DISABLE IC_SLAVE_DISABLE,
        I2C0_IC_CON_STOP_DET_IFADDRESSED STOP_DET_IFADDRESSED,
        I2C0_IC_CON_TX_EMPTY_CTRL TX_EMPTY_CTRL,
        I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL RX_FIFO_FULL_HLD_CTRL) volatile
    {
        uint32_t curr = IC_CON;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(MASTER_MODE) & 0b1u) << 0u;
        curr &= ~(0b11u << 1u);
        curr |= (std::to_underlying(SPEED) & 0b11u) << 1u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(IC_10BITADDR_SLAVE) & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(IC_10BITADDR_MASTER) & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(IC_RESTART_EN) & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(IC_SLAVE_DISABLE) & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (std::to_underlying(STOP_DET_IFADDRESSED) & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(TX_EMPTY_CTRL) & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(RX_FIFO_FULL_HLD_CTRL) & 0b1u) << 9u;

        IC_CON = curr;
    }

    /**
     * Get IC_TAR's IC_TAR field.
     *
     * This is the target address for any master transaction. When transmitting
     * a General Call, these bits are ignored. To generate a START BYTE, the
     * CPU needs to write only once into these bits.\n\n If the IC_TAR and
     * IC_SAR are the same, loopback exists but the FIFOs are shared between
     * master and slave, so full loopback is not feasible. Only one direction
     * loopback mode is supported (simplex), not duplex. A master cannot
     * transmit to itself; it can transmit to only a slave.
     */
    inline uint16_t get_IC_TAR_IC_TAR() volatile
    {
        return (IC_TAR >> 0u) & 0b1111111111u;
    }

    /**
     * Set IC_TAR's IC_TAR field.
     *
     * This is the target address for any master transaction. When transmitting
     * a General Call, these bits are ignored. To generate a START BYTE, the
     * CPU needs to write only once into these bits.\n\n If the IC_TAR and
     * IC_SAR are the same, loopback exists but the FIFOs are shared between
     * master and slave, so full loopback is not feasible. Only one direction
     * loopback mode is supported (simplex), not duplex. A master cannot
     * transmit to itself; it can transmit to only a slave.
     */
    inline void set_IC_TAR_IC_TAR(uint16_t value) volatile
    {
        uint32_t curr = IC_TAR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        IC_TAR = curr;
    }

    /**
     * Get IC_TAR's GC_OR_START bit.
     *
     * If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then
     * this bit indicates whether a General Call or START byte command is to be
     * performed by the DW_apb_i2c. - 0: General Call Address - after issuing a
     * General Call, only writes may be performed. Attempting to issue a read
     * command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register. The DW_apb_i2c remains in General Call mode until the SPECIAL
     * bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
     */
    inline I2C0_IC_TAR_GC_OR_START get_IC_TAR_GC_OR_START() volatile
    {
        return I2C0_IC_TAR_GC_OR_START(IC_TAR & (1u << 10u));
    }

    /**
     * Set IC_TAR's GC_OR_START bit.
     *
     * If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then
     * this bit indicates whether a General Call or START byte command is to be
     * performed by the DW_apb_i2c. - 0: General Call Address - after issuing a
     * General Call, only writes may be performed. Attempting to issue a read
     * command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register. The DW_apb_i2c remains in General Call mode until the SPECIAL
     * bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
     */
    inline void set_IC_TAR_GC_OR_START() volatile
    {
        IC_TAR |= 1u << 10u;
    }

    /**
     * Clear IC_TAR's GC_OR_START bit.
     *
     * If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then
     * this bit indicates whether a General Call or START byte command is to be
     * performed by the DW_apb_i2c. - 0: General Call Address - after issuing a
     * General Call, only writes may be performed. Attempting to issue a read
     * command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register. The DW_apb_i2c remains in General Call mode until the SPECIAL
     * bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
     */
    inline void clear_IC_TAR_GC_OR_START() volatile
    {
        IC_TAR &= ~(1u << 10u);
    }

    /**
     * Toggle IC_TAR's GC_OR_START bit.
     *
     * If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID) is set to 0, then
     * this bit indicates whether a General Call or START byte command is to be
     * performed by the DW_apb_i2c. - 0: General Call Address - after issuing a
     * General Call, only writes may be performed. Attempting to issue a read
     * command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
     * register. The DW_apb_i2c remains in General Call mode until the SPECIAL
     * bit value (bit 11) is cleared. - 1: START BYTE Reset value: 0x0
     */
    inline void toggle_IC_TAR_GC_OR_START() volatile
    {
        IC_TAR ^= 1u << 10u;
    }

    /**
     * Get IC_TAR's SPECIAL bit.
     *
     * This bit indicates whether software performs a Device-ID or General Call
     * or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR
     * normally - 1: perform special I2C command as specified in Device_ID or
     * GC_OR_START bit Reset value: 0x0
     */
    inline I2C0_IC_TAR_SPECIAL get_IC_TAR_SPECIAL() volatile
    {
        return I2C0_IC_TAR_SPECIAL(IC_TAR & (1u << 11u));
    }

    /**
     * Set IC_TAR's SPECIAL bit.
     *
     * This bit indicates whether software performs a Device-ID or General Call
     * or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR
     * normally - 1: perform special I2C command as specified in Device_ID or
     * GC_OR_START bit Reset value: 0x0
     */
    inline void set_IC_TAR_SPECIAL() volatile
    {
        IC_TAR |= 1u << 11u;
    }

    /**
     * Clear IC_TAR's SPECIAL bit.
     *
     * This bit indicates whether software performs a Device-ID or General Call
     * or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR
     * normally - 1: perform special I2C command as specified in Device_ID or
     * GC_OR_START bit Reset value: 0x0
     */
    inline void clear_IC_TAR_SPECIAL() volatile
    {
        IC_TAR &= ~(1u << 11u);
    }

    /**
     * Toggle IC_TAR's SPECIAL bit.
     *
     * This bit indicates whether software performs a Device-ID or General Call
     * or START BYTE command. - 0: ignore bit 10 GC_OR_START and use IC_TAR
     * normally - 1: perform special I2C command as specified in Device_ID or
     * GC_OR_START bit Reset value: 0x0
     */
    inline void toggle_IC_TAR_SPECIAL() volatile
    {
        IC_TAR ^= 1u << 11u;
    }

    /**
     * Get all of IC_TAR's bit fields.
     *
     * (read-write) I2C Target Address Register\n\n
     *             This register is 12 bits wide, and bits 31:12 are reserved.
     * This register can be written to only when IC_ENABLE[0] is set to 0.\n\n
     *             Note: If the software or application is aware that the
     * DW_apb_i2c is not using the TAR address for the pending commands in the
     * Tx FIFO, then it is possible to update the TAR address even while the Tx
     * FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any
     * write to this register if DW_apb_i2c is enabled as an I2C slave only.
     */
    inline void get_IC_TAR(uint16_t &IC_TAR,
                           I2C0_IC_TAR_GC_OR_START &GC_OR_START,
                           I2C0_IC_TAR_SPECIAL &SPECIAL) volatile
    {
        uint32_t curr = IC_TAR;

        IC_TAR = (curr >> 0u) & 0b1111111111u;
        GC_OR_START = I2C0_IC_TAR_GC_OR_START(curr & (1u << 10u));
        SPECIAL = I2C0_IC_TAR_SPECIAL(curr & (1u << 11u));
    }

    /**
     * Set all of IC_TAR's bit fields.
     *
     * (read-write) I2C Target Address Register\n\n
     *             This register is 12 bits wide, and bits 31:12 are reserved.
     * This register can be written to only when IC_ENABLE[0] is set to 0.\n\n
     *             Note: If the software or application is aware that the
     * DW_apb_i2c is not using the TAR address for the pending commands in the
     * Tx FIFO, then it is possible to update the TAR address even while the Tx
     * FIFO has entries (IC_STATUS[2]= 0). - It is not necessary to perform any
     * write to this register if DW_apb_i2c is enabled as an I2C slave only.
     */
    inline void set_IC_TAR(uint16_t IC_TAR,
                           I2C0_IC_TAR_GC_OR_START GC_OR_START,
                           I2C0_IC_TAR_SPECIAL SPECIAL) volatile
    {
        uint32_t curr = IC_TAR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (IC_TAR & 0b1111111111u) << 0u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(GC_OR_START) & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(SPECIAL) & 0b1u) << 11u;

        IC_TAR = curr;
    }

    /**
     * Get IC_SAR's IC_SAR field.
     *
     * The IC_SAR holds the slave address when the I2C is operating as a slave.
     * For 7-bit addressing, only IC_SAR[6:0] is used.\n\n This register can be
     * written only when the I2C interface is disabled, which corresponds to
     * the IC_ENABLE[0] register being set to 0. Writes at other times have no
     * effect.\n\n Note: The default values cannot be any of the reserved
     * address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct
     * operation of the device is not guaranteed if you program the IC_SAR or
     * IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>>
     * for a complete list of these reserved values.
     */
    inline uint16_t get_IC_SAR_IC_SAR() volatile
    {
        return (IC_SAR >> 0u) & 0b1111111111u;
    }

    /**
     * Set IC_SAR's IC_SAR field.
     *
     * The IC_SAR holds the slave address when the I2C is operating as a slave.
     * For 7-bit addressing, only IC_SAR[6:0] is used.\n\n This register can be
     * written only when the I2C interface is disabled, which corresponds to
     * the IC_ENABLE[0] register being set to 0. Writes at other times have no
     * effect.\n\n Note: The default values cannot be any of the reserved
     * address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f. The correct
     * operation of the device is not guaranteed if you program the IC_SAR or
     * IC_TAR to a reserved value. Refer to <<table_I2C_firstbyte_bit_defs>>
     * for a complete list of these reserved values.
     */
    inline void set_IC_SAR_IC_SAR(uint16_t value) volatile
    {
        uint32_t curr = IC_SAR;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        IC_SAR = curr;
    }

    /**
     * Get IC_DATA_CMD's DAT field.
     *
     * This register contains the data to be transmitted or received on the I2C
     * bus. If you are writing to this register and want to perform a read,
     * bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read
     * this register, these bits return the value of data received on the
     * DW_apb_i2c interface.\n\n Reset value: 0x0
     */
    inline uint8_t get_IC_DATA_CMD_DAT() volatile
    {
        return (IC_DATA_CMD >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_DATA_CMD's DAT field.
     *
     * This register contains the data to be transmitted or received on the I2C
     * bus. If you are writing to this register and want to perform a read,
     * bits 7:0 (DAT) are ignored by the DW_apb_i2c. However, when you read
     * this register, these bits return the value of data received on the
     * DW_apb_i2c interface.\n\n Reset value: 0x0
     */
    inline void set_IC_DATA_CMD_DAT(uint8_t value) volatile
    {
        uint32_t curr = IC_DATA_CMD;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_DATA_CMD = curr;
    }

    /**
     * Get IC_DATA_CMD's CMD bit.
     *
     * This bit controls whether a read or a write is performed. This bit does
     * not control the direction when the DW_apb_i2con acts as a slave. It
     * controls only the direction when it acts as a master.\n\n When a command
     * is entered in the TX FIFO, this bit distinguishes the write and read
     * commands. In slave-receiver mode, this bit is a 'don't care' because
     * writes to this register are not required. In slave-transmitter mode, a
     * '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n
     *                 When programming this bit, you should remember the
     * following: attempting to perform a read operation after a General Call
     * command has been sent results in a TX_ABRT interrupt (bit 6 of the
     * IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR
     * register has been cleared. If a '1' is written to this bit after
     * receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset
     * value: 0x0
     */
    inline I2C0_IC_DATA_CMD_CMD get_IC_DATA_CMD_CMD() volatile
    {
        return I2C0_IC_DATA_CMD_CMD(IC_DATA_CMD & (1u << 8u));
    }

    /**
     * Set IC_DATA_CMD's CMD bit.
     *
     * This bit controls whether a read or a write is performed. This bit does
     * not control the direction when the DW_apb_i2con acts as a slave. It
     * controls only the direction when it acts as a master.\n\n When a command
     * is entered in the TX FIFO, this bit distinguishes the write and read
     * commands. In slave-receiver mode, this bit is a 'don't care' because
     * writes to this register are not required. In slave-transmitter mode, a
     * '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n
     *                 When programming this bit, you should remember the
     * following: attempting to perform a read operation after a General Call
     * command has been sent results in a TX_ABRT interrupt (bit 6 of the
     * IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR
     * register has been cleared. If a '1' is written to this bit after
     * receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset
     * value: 0x0
     */
    inline void set_IC_DATA_CMD_CMD() volatile
    {
        IC_DATA_CMD |= 1u << 8u;
    }

    /**
     * Clear IC_DATA_CMD's CMD bit.
     *
     * This bit controls whether a read or a write is performed. This bit does
     * not control the direction when the DW_apb_i2con acts as a slave. It
     * controls only the direction when it acts as a master.\n\n When a command
     * is entered in the TX FIFO, this bit distinguishes the write and read
     * commands. In slave-receiver mode, this bit is a 'don't care' because
     * writes to this register are not required. In slave-transmitter mode, a
     * '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n
     *                 When programming this bit, you should remember the
     * following: attempting to perform a read operation after a General Call
     * command has been sent results in a TX_ABRT interrupt (bit 6 of the
     * IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR
     * register has been cleared. If a '1' is written to this bit after
     * receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset
     * value: 0x0
     */
    inline void clear_IC_DATA_CMD_CMD() volatile
    {
        IC_DATA_CMD &= ~(1u << 8u);
    }

    /**
     * Toggle IC_DATA_CMD's CMD bit.
     *
     * This bit controls whether a read or a write is performed. This bit does
     * not control the direction when the DW_apb_i2con acts as a slave. It
     * controls only the direction when it acts as a master.\n\n When a command
     * is entered in the TX FIFO, this bit distinguishes the write and read
     * commands. In slave-receiver mode, this bit is a 'don't care' because
     * writes to this register are not required. In slave-transmitter mode, a
     * '0' indicates that the data in IC_DATA_CMD is to be transmitted.\n\n
     *                 When programming this bit, you should remember the
     * following: attempting to perform a read operation after a General Call
     * command has been sent results in a TX_ABRT interrupt (bit 6 of the
     * IC_RAW_INTR_STAT register), unless bit 11 (SPECIAL) in the IC_TAR
     * register has been cleared. If a '1' is written to this bit after
     * receiving a RD_REQ interrupt, then a TX_ABRT interrupt occurs.\n\n Reset
     * value: 0x0
     */
    inline void toggle_IC_DATA_CMD_CMD() volatile
    {
        IC_DATA_CMD ^= 1u << 8u;
    }

    /**
     * Get IC_DATA_CMD's STOP bit.
     *
     * This bit controls whether a STOP is issued after the byte is sent or
     * received.\n\n
     *                 - 1 - STOP is issued after this byte, regardless of
     * whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the
     * master immediately tries to start a new transfer by issuing a START and
     * arbitrating for the bus. - 0 - STOP is not issued after this byte,
     * regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not
     * empty, the master continues the current transfer by sending/receiving
     * data bytes according to the value of the CMD bit. If the Tx FIFO is
     * empty, the master holds the SCL line low and stalls the bus until a new
     * command is available in the Tx FIFO. Reset value: 0x0
     */
    inline I2C0_IC_DATA_CMD_STOP get_IC_DATA_CMD_STOP() volatile
    {
        return I2C0_IC_DATA_CMD_STOP(IC_DATA_CMD & (1u << 9u));
    }

    /**
     * Set IC_DATA_CMD's STOP bit.
     *
     * This bit controls whether a STOP is issued after the byte is sent or
     * received.\n\n
     *                 - 1 - STOP is issued after this byte, regardless of
     * whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the
     * master immediately tries to start a new transfer by issuing a START and
     * arbitrating for the bus. - 0 - STOP is not issued after this byte,
     * regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not
     * empty, the master continues the current transfer by sending/receiving
     * data bytes according to the value of the CMD bit. If the Tx FIFO is
     * empty, the master holds the SCL line low and stalls the bus until a new
     * command is available in the Tx FIFO. Reset value: 0x0
     */
    inline void set_IC_DATA_CMD_STOP() volatile
    {
        IC_DATA_CMD |= 1u << 9u;
    }

    /**
     * Clear IC_DATA_CMD's STOP bit.
     *
     * This bit controls whether a STOP is issued after the byte is sent or
     * received.\n\n
     *                 - 1 - STOP is issued after this byte, regardless of
     * whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the
     * master immediately tries to start a new transfer by issuing a START and
     * arbitrating for the bus. - 0 - STOP is not issued after this byte,
     * regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not
     * empty, the master continues the current transfer by sending/receiving
     * data bytes according to the value of the CMD bit. If the Tx FIFO is
     * empty, the master holds the SCL line low and stalls the bus until a new
     * command is available in the Tx FIFO. Reset value: 0x0
     */
    inline void clear_IC_DATA_CMD_STOP() volatile
    {
        IC_DATA_CMD &= ~(1u << 9u);
    }

    /**
     * Toggle IC_DATA_CMD's STOP bit.
     *
     * This bit controls whether a STOP is issued after the byte is sent or
     * received.\n\n
     *                 - 1 - STOP is issued after this byte, regardless of
     * whether or not the Tx FIFO is empty. If the Tx FIFO is not empty, the
     * master immediately tries to start a new transfer by issuing a START and
     * arbitrating for the bus. - 0 - STOP is not issued after this byte,
     * regardless of whether or not the Tx FIFO is empty. If the Tx FIFO is not
     * empty, the master continues the current transfer by sending/receiving
     * data bytes according to the value of the CMD bit. If the Tx FIFO is
     * empty, the master holds the SCL line low and stalls the bus until a new
     * command is available in the Tx FIFO. Reset value: 0x0
     */
    inline void toggle_IC_DATA_CMD_STOP() volatile
    {
        IC_DATA_CMD ^= 1u << 9u;
    }

    /**
     * Get IC_DATA_CMD's RESTART bit.
     *
     * This bit controls whether a RESTART is issued before the byte is sent or
     * received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the
     * data is sent/received (according to the value of CMD), regardless of
     * whether or not the transfer direction is changing from the previous
     * command; if IC_RESTART_EN is 0, a STOP followed by a START is issued
     * instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the
     * transfer direction is changing from the previous command; if
     * IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_DATA_CMD_RESTART get_IC_DATA_CMD_RESTART() volatile
    {
        return I2C0_IC_DATA_CMD_RESTART(IC_DATA_CMD & (1u << 10u));
    }

    /**
     * Set IC_DATA_CMD's RESTART bit.
     *
     * This bit controls whether a RESTART is issued before the byte is sent or
     * received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the
     * data is sent/received (according to the value of CMD), regardless of
     * whether or not the transfer direction is changing from the previous
     * command; if IC_RESTART_EN is 0, a STOP followed by a START is issued
     * instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the
     * transfer direction is changing from the previous command; if
     * IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n
     *                 Reset value: 0x0
     */
    inline void set_IC_DATA_CMD_RESTART() volatile
    {
        IC_DATA_CMD |= 1u << 10u;
    }

    /**
     * Clear IC_DATA_CMD's RESTART bit.
     *
     * This bit controls whether a RESTART is issued before the byte is sent or
     * received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the
     * data is sent/received (according to the value of CMD), regardless of
     * whether or not the transfer direction is changing from the previous
     * command; if IC_RESTART_EN is 0, a STOP followed by a START is issued
     * instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the
     * transfer direction is changing from the previous command; if
     * IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n
     *                 Reset value: 0x0
     */
    inline void clear_IC_DATA_CMD_RESTART() volatile
    {
        IC_DATA_CMD &= ~(1u << 10u);
    }

    /**
     * Toggle IC_DATA_CMD's RESTART bit.
     *
     * This bit controls whether a RESTART is issued before the byte is sent or
     * received.\n\n 1 - If IC_RESTART_EN is 1, a RESTART is issued before the
     * data is sent/received (according to the value of CMD), regardless of
     * whether or not the transfer direction is changing from the previous
     * command; if IC_RESTART_EN is 0, a STOP followed by a START is issued
     * instead.\n\n 0 - If IC_RESTART_EN is 1, a RESTART is issued only if the
     * transfer direction is changing from the previous command; if
     * IC_RESTART_EN is 0, a STOP followed by a START is issued instead.\n\n
     *                 Reset value: 0x0
     */
    inline void toggle_IC_DATA_CMD_RESTART() volatile
    {
        IC_DATA_CMD ^= 1u << 10u;
    }

    /**
     * Get IC_DATA_CMD's FIRST_DATA_BYTE bit.
     *
     * Indicates the first data byte received after the address phase for
     * receive transfer in Master receiver or Slave receiver mode.\n\n Reset
     * value : 0x0\n\n NOTE:  In case of APB_DATA_WIDTH=8,\n\n
     *                 1. The user has to perform two APB Reads to IC_DATA_CMD
     * in order to get status on 11 bit.\n\n
     *                 2. In order to read the 11 bit, the user has to perform
     * the first data byte read [7:0] (offset 0x10) and then perform the second
     * read [15:8] (offset 0x11) in order to know the status of 11 bit (whether
     * the data received in previous read is a first data byte or not).\n\n
     *                 3. The 11th bit is an optional read field, user can
     * ignore 2nd byte read [15:8] (offset 0x11) if not interested in
     * FIRST_DATA_BYTE status.
     */
    inline I2C0_IC_DATA_CMD_FIRST_DATA_BYTE
    get_IC_DATA_CMD_FIRST_DATA_BYTE() volatile
    {
        return I2C0_IC_DATA_CMD_FIRST_DATA_BYTE(IC_DATA_CMD & (1u << 11u));
    }

    /**
     * Get all of IC_DATA_CMD's bit fields.
     *
     * (read-write) I2C Rx/Tx Data Buffer and Command Register; this is the
     * register the CPU writes to when filling the TX FIFO and the CPU reads
     * from when retrieving bytes from RX FIFO.\n\n The size of the register
     * changes as follows:\n\n Write: - 11 bits when
     * IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when
     * IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when
     * IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS =
     * 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a
     * read command should be written for every byte that is to be received;
     * otherwise the DW_apb_i2c will stop acknowledging.
     */
    inline void get_IC_DATA_CMD(
        uint8_t &DAT, I2C0_IC_DATA_CMD_CMD &CMD, I2C0_IC_DATA_CMD_STOP &STOP,
        I2C0_IC_DATA_CMD_RESTART &RESTART,
        I2C0_IC_DATA_CMD_FIRST_DATA_BYTE &FIRST_DATA_BYTE) volatile
    {
        uint32_t curr = IC_DATA_CMD;

        DAT = (curr >> 0u) & 0b11111111u;
        CMD = I2C0_IC_DATA_CMD_CMD(curr & (1u << 8u));
        STOP = I2C0_IC_DATA_CMD_STOP(curr & (1u << 9u));
        RESTART = I2C0_IC_DATA_CMD_RESTART(curr & (1u << 10u));
        FIRST_DATA_BYTE = I2C0_IC_DATA_CMD_FIRST_DATA_BYTE(curr & (1u << 11u));
    }

    /**
     * Set all of IC_DATA_CMD's bit fields.
     *
     * (read-write) I2C Rx/Tx Data Buffer and Command Register; this is the
     * register the CPU writes to when filling the TX FIFO and the CPU reads
     * from when retrieving bytes from RX FIFO.\n\n The size of the register
     * changes as follows:\n\n Write: - 11 bits when
     * IC_EMPTYFIFO_HOLD_MASTER_EN=1 - 9 bits when
     * IC_EMPTYFIFO_HOLD_MASTER_EN=0 Read: - 12 bits when
     * IC_FIRST_DATA_BYTE_STATUS = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS =
     * 0 Note: In order for the DW_apb_i2c to continue acknowledging reads, a
     * read command should be written for every byte that is to be received;
     * otherwise the DW_apb_i2c will stop acknowledging.
     */
    inline void set_IC_DATA_CMD(uint8_t DAT, I2C0_IC_DATA_CMD_CMD CMD,
                                I2C0_IC_DATA_CMD_STOP STOP,
                                I2C0_IC_DATA_CMD_RESTART RESTART) volatile
    {
        uint32_t curr = IC_DATA_CMD;

        curr &= ~(0b11111111u << 0u);
        curr |= (DAT & 0b11111111u) << 0u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(CMD) & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(STOP) & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(RESTART) & 0b1u) << 10u;

        IC_DATA_CMD = curr;
    }

    /**
     * Get IC_SS_SCL_HCNT's IC_SS_SCL_HCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock
     * high-period count for standard speed. For more information, refer to
     * 'IC_CLK Frequency Configuration'.\n\n This register can be written only
     * when the I2C interface is disabled which corresponds to the IC_ENABLE[0]
     * register being set to 0. Writes at other times have no effect.\n\n The
     * minimum valid value is 6; hardware prevents values less than this being
     * written, and if attempted results in 6 being set. For designs with
     * APB_DATA_WIDTH = 8, the order of programming is important to ensure the
     * correct operation of the DW_apb_i2c. The lower byte must be programmed
     * first. Then the upper byte is programmed.\n\n NOTE: This register must
     * not be programmed to a value higher than 65525, because DW_apb_i2c uses
     * a 16-bit counter to flag an I2C bus idle condition when this counter
     * reaches a value of IC_SS_SCL_HCNT + 10.
     */
    inline uint16_t get_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT() volatile
    {
        return (IC_SS_SCL_HCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_SS_SCL_HCNT's IC_SS_SCL_HCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock
     * high-period count for standard speed. For more information, refer to
     * 'IC_CLK Frequency Configuration'.\n\n This register can be written only
     * when the I2C interface is disabled which corresponds to the IC_ENABLE[0]
     * register being set to 0. Writes at other times have no effect.\n\n The
     * minimum valid value is 6; hardware prevents values less than this being
     * written, and if attempted results in 6 being set. For designs with
     * APB_DATA_WIDTH = 8, the order of programming is important to ensure the
     * correct operation of the DW_apb_i2c. The lower byte must be programmed
     * first. Then the upper byte is programmed.\n\n NOTE: This register must
     * not be programmed to a value higher than 65525, because DW_apb_i2c uses
     * a 16-bit counter to flag an I2C bus idle condition when this counter
     * reaches a value of IC_SS_SCL_HCNT + 10.
     */
    inline void set_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_SS_SCL_HCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_SS_SCL_HCNT = curr;
    }

    /**
     * Get IC_SS_SCL_LCNT's IC_SS_SCL_LCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock low period
     * count for standard speed. For more information, refer to 'IC_CLK
     * Frequency Configuration'\n\n This register can be written only when the
     * I2C interface is disabled which corresponds to the IC_ENABLE[0] register
     * being set to 0. Writes at other times have no effect.\n\n The minimum
     * valid value is 8; hardware prevents values less than this being written,
     * and if attempted, results in 8 being set. For designs with
     * APB_DATA_WIDTH = 8, the order of programming is important to ensure the
     * correct operation of DW_apb_i2c. The lower byte must be programmed
     * first, and then the upper byte is programmed.
     */
    inline uint16_t get_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT() volatile
    {
        return (IC_SS_SCL_LCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_SS_SCL_LCNT's IC_SS_SCL_LCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock low period
     * count for standard speed. For more information, refer to 'IC_CLK
     * Frequency Configuration'\n\n This register can be written only when the
     * I2C interface is disabled which corresponds to the IC_ENABLE[0] register
     * being set to 0. Writes at other times have no effect.\n\n The minimum
     * valid value is 8; hardware prevents values less than this being written,
     * and if attempted, results in 8 being set. For designs with
     * APB_DATA_WIDTH = 8, the order of programming is important to ensure the
     * correct operation of DW_apb_i2c. The lower byte must be programmed
     * first, and then the upper byte is programmed.
     */
    inline void set_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_SS_SCL_LCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_SS_SCL_LCNT = curr;
    }

    /**
     * Get IC_FS_SCL_HCNT's IC_FS_SCL_HCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock
     * high-period count for fast mode or fast mode plus. It is used in
     * high-speed mode to send the Master Code and START BYTE or General CALL.
     * For more information, refer to 'IC_CLK Frequency Configuration'.\n\n
     *                 This register goes away and becomes read-only returning
     * 0s if IC_MAX_SPEED_MODE = standard. This register can be written only
     * when the I2C interface is disabled, which corresponds to the
     * IC_ENABLE[0] register being set to 0. Writes at other times have no
     * effect.\n\n The minimum valid value is 6; hardware prevents values less
     * than this being written, and if attempted results in 6 being set. For
     * designs with APB_DATA_WIDTH == 8 the order of programming is important
     * to ensure the correct operation of the DW_apb_i2c. The lower byte must
     * be programmed first. Then the upper byte is programmed.
     */
    inline uint16_t get_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT() volatile
    {
        return (IC_FS_SCL_HCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_FS_SCL_HCNT's IC_FS_SCL_HCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock
     * high-period count for fast mode or fast mode plus. It is used in
     * high-speed mode to send the Master Code and START BYTE or General CALL.
     * For more information, refer to 'IC_CLK Frequency Configuration'.\n\n
     *                 This register goes away and becomes read-only returning
     * 0s if IC_MAX_SPEED_MODE = standard. This register can be written only
     * when the I2C interface is disabled, which corresponds to the
     * IC_ENABLE[0] register being set to 0. Writes at other times have no
     * effect.\n\n The minimum valid value is 6; hardware prevents values less
     * than this being written, and if attempted results in 6 being set. For
     * designs with APB_DATA_WIDTH == 8 the order of programming is important
     * to ensure the correct operation of the DW_apb_i2c. The lower byte must
     * be programmed first. Then the upper byte is programmed.
     */
    inline void set_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_FS_SCL_HCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_FS_SCL_HCNT = curr;
    }

    /**
     * Get IC_FS_SCL_LCNT's IC_FS_SCL_LCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock low period
     * count for fast speed. It is used in high-speed mode to send the Master
     * Code and START BYTE or General CALL. For more information, refer to
     * 'IC_CLK Frequency Configuration'.\n\n This register goes away and
     * becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n This
     * register can be written only when the I2C interface is disabled, which
     * corresponds to the IC_ENABLE[0] register being set to 0. Writes at other
     * times have no effect.\n\n The minimum valid value is 8; hardware
     * prevents values less than this being written, and if attempted results
     * in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of
     * programming is important to ensure the correct operation of the
     * DW_apb_i2c. The lower byte must be programmed first. Then the upper byte
     * is programmed. If the value is less than 8 then the count value gets
     * changed to 8.
     */
    inline uint16_t get_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT() volatile
    {
        return (IC_FS_SCL_LCNT >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_FS_SCL_LCNT's IC_FS_SCL_LCNT field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure proper I/O timing. This register sets the SCL clock low period
     * count for fast speed. It is used in high-speed mode to send the Master
     * Code and START BYTE or General CALL. For more information, refer to
     * 'IC_CLK Frequency Configuration'.\n\n This register goes away and
     * becomes read-only returning 0s if IC_MAX_SPEED_MODE = standard.\n\n This
     * register can be written only when the I2C interface is disabled, which
     * corresponds to the IC_ENABLE[0] register being set to 0. Writes at other
     * times have no effect.\n\n The minimum valid value is 8; hardware
     * prevents values less than this being written, and if attempted results
     * in 8 being set. For designs with APB_DATA_WIDTH = 8 the order of
     * programming is important to ensure the correct operation of the
     * DW_apb_i2c. The lower byte must be programmed first. Then the upper byte
     * is programmed. If the value is less than 8 then the count value gets
     * changed to 8.
     */
    inline void set_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT(uint16_t value) volatile
    {
        uint32_t curr = IC_FS_SCL_LCNT;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_FS_SCL_LCNT = curr;
    }

    /**
     * Get IC_INTR_STAT's R_RX_UNDER bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_RX_UNDER get_IC_INTR_STAT_R_RX_UNDER() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_UNDER(IC_INTR_STAT & (1u << 0u));
    }

    /**
     * Get IC_INTR_STAT's R_RX_OVER bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_RX_OVER get_IC_INTR_STAT_R_RX_OVER() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_OVER(IC_INTR_STAT & (1u << 1u));
    }

    /**
     * Get IC_INTR_STAT's R_RX_FULL bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_RX_FULL get_IC_INTR_STAT_R_RX_FULL() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_FULL(IC_INTR_STAT & (1u << 2u));
    }

    /**
     * Get IC_INTR_STAT's R_TX_OVER bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_TX_OVER get_IC_INTR_STAT_R_TX_OVER() volatile
    {
        return I2C0_IC_INTR_STAT_R_TX_OVER(IC_INTR_STAT & (1u << 3u));
    }

    /**
     * Get IC_INTR_STAT's R_TX_EMPTY bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_TX_EMPTY get_IC_INTR_STAT_R_TX_EMPTY() volatile
    {
        return I2C0_IC_INTR_STAT_R_TX_EMPTY(IC_INTR_STAT & (1u << 4u));
    }

    /**
     * Get IC_INTR_STAT's R_RD_REQ bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_RD_REQ get_IC_INTR_STAT_R_RD_REQ() volatile
    {
        return I2C0_IC_INTR_STAT_R_RD_REQ(IC_INTR_STAT & (1u << 5u));
    }

    /**
     * Get IC_INTR_STAT's R_TX_ABRT bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_TX_ABRT get_IC_INTR_STAT_R_TX_ABRT() volatile
    {
        return I2C0_IC_INTR_STAT_R_TX_ABRT(IC_INTR_STAT & (1u << 6u));
    }

    /**
     * Get IC_INTR_STAT's R_RX_DONE bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_RX_DONE get_IC_INTR_STAT_R_RX_DONE() volatile
    {
        return I2C0_IC_INTR_STAT_R_RX_DONE(IC_INTR_STAT & (1u << 7u));
    }

    /**
     * Get IC_INTR_STAT's R_ACTIVITY bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_ACTIVITY get_IC_INTR_STAT_R_ACTIVITY() volatile
    {
        return I2C0_IC_INTR_STAT_R_ACTIVITY(IC_INTR_STAT & (1u << 8u));
    }

    /**
     * Get IC_INTR_STAT's R_STOP_DET bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_STOP_DET get_IC_INTR_STAT_R_STOP_DET() volatile
    {
        return I2C0_IC_INTR_STAT_R_STOP_DET(IC_INTR_STAT & (1u << 9u));
    }

    /**
     * Get IC_INTR_STAT's R_START_DET bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_START_DET bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_START_DET
    get_IC_INTR_STAT_R_START_DET() volatile
    {
        return I2C0_IC_INTR_STAT_R_START_DET(IC_INTR_STAT & (1u << 10u));
    }

    /**
     * Get IC_INTR_STAT's R_GEN_CALL bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_GEN_CALL bit.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_GEN_CALL get_IC_INTR_STAT_R_GEN_CALL() volatile
    {
        return I2C0_IC_INTR_STAT_R_GEN_CALL(IC_INTR_STAT & (1u << 11u));
    }

    /**
     * Get IC_INTR_STAT's R_RESTART_DET bit.
     *
     * See IC_RAW_INTR_STAT for a detailed description of R_RESTART_DET
     * bit.\n\n Reset value: 0x0
     */
    inline I2C0_IC_INTR_STAT_R_RESTART_DET
    get_IC_INTR_STAT_R_RESTART_DET() volatile
    {
        return I2C0_IC_INTR_STAT_R_RESTART_DET(IC_INTR_STAT & (1u << 12u));
    }

    /**
     * Get all of IC_INTR_STAT's bit fields.
     *
     * (read-only) I2C Interrupt Status Register\n\n
     *             Each bit in this register has a corresponding mask bit in
     * the IC_INTR_MASK register. These bits are cleared by reading the
     * matching interrupt clear register. The unmasked raw versions of these
     * bits are available in the IC_RAW_INTR_STAT register.
     */
    inline void get_IC_INTR_STAT(
        I2C0_IC_INTR_STAT_R_RX_UNDER &R_RX_UNDER,
        I2C0_IC_INTR_STAT_R_RX_OVER &R_RX_OVER,
        I2C0_IC_INTR_STAT_R_RX_FULL &R_RX_FULL,
        I2C0_IC_INTR_STAT_R_TX_OVER &R_TX_OVER,
        I2C0_IC_INTR_STAT_R_TX_EMPTY &R_TX_EMPTY,
        I2C0_IC_INTR_STAT_R_RD_REQ &R_RD_REQ,
        I2C0_IC_INTR_STAT_R_TX_ABRT &R_TX_ABRT,
        I2C0_IC_INTR_STAT_R_RX_DONE &R_RX_DONE,
        I2C0_IC_INTR_STAT_R_ACTIVITY &R_ACTIVITY,
        I2C0_IC_INTR_STAT_R_STOP_DET &R_STOP_DET,
        I2C0_IC_INTR_STAT_R_START_DET &R_START_DET,
        I2C0_IC_INTR_STAT_R_GEN_CALL &R_GEN_CALL,
        I2C0_IC_INTR_STAT_R_RESTART_DET &R_RESTART_DET) volatile
    {
        uint32_t curr = IC_INTR_STAT;

        R_RX_UNDER = I2C0_IC_INTR_STAT_R_RX_UNDER(curr & (1u << 0u));
        R_RX_OVER = I2C0_IC_INTR_STAT_R_RX_OVER(curr & (1u << 1u));
        R_RX_FULL = I2C0_IC_INTR_STAT_R_RX_FULL(curr & (1u << 2u));
        R_TX_OVER = I2C0_IC_INTR_STAT_R_TX_OVER(curr & (1u << 3u));
        R_TX_EMPTY = I2C0_IC_INTR_STAT_R_TX_EMPTY(curr & (1u << 4u));
        R_RD_REQ = I2C0_IC_INTR_STAT_R_RD_REQ(curr & (1u << 5u));
        R_TX_ABRT = I2C0_IC_INTR_STAT_R_TX_ABRT(curr & (1u << 6u));
        R_RX_DONE = I2C0_IC_INTR_STAT_R_RX_DONE(curr & (1u << 7u));
        R_ACTIVITY = I2C0_IC_INTR_STAT_R_ACTIVITY(curr & (1u << 8u));
        R_STOP_DET = I2C0_IC_INTR_STAT_R_STOP_DET(curr & (1u << 9u));
        R_START_DET = I2C0_IC_INTR_STAT_R_START_DET(curr & (1u << 10u));
        R_GEN_CALL = I2C0_IC_INTR_STAT_R_GEN_CALL(curr & (1u << 11u));
        R_RESTART_DET = I2C0_IC_INTR_STAT_R_RESTART_DET(curr & (1u << 12u));
    }

    /**
     * Get IC_INTR_MASK's M_RX_UNDER bit.
     *
     * This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_RX_UNDER get_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_UNDER(IC_INTR_MASK & (1u << 0u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_UNDER bit.
     *
     * This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        IC_INTR_MASK |= 1u << 0u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_UNDER bit.
     *
     * This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        IC_INTR_MASK &= ~(1u << 0u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_UNDER bit.
     *
     * This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_RX_UNDER() volatile
    {
        IC_INTR_MASK ^= 1u << 0u;
    }

    /**
     * Get IC_INTR_MASK's M_RX_OVER bit.
     *
     * This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_RX_OVER get_IC_INTR_MASK_M_RX_OVER() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_OVER(IC_INTR_MASK & (1u << 1u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_OVER bit.
     *
     * This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_RX_OVER() volatile
    {
        IC_INTR_MASK |= 1u << 1u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_OVER bit.
     *
     * This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_RX_OVER() volatile
    {
        IC_INTR_MASK &= ~(1u << 1u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_OVER bit.
     *
     * This bit masks the R_RX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_RX_OVER() volatile
    {
        IC_INTR_MASK ^= 1u << 1u;
    }

    /**
     * Get IC_INTR_MASK's M_RX_FULL bit.
     *
     * This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_RX_FULL get_IC_INTR_MASK_M_RX_FULL() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_FULL(IC_INTR_MASK & (1u << 2u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_FULL bit.
     *
     * This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_RX_FULL() volatile
    {
        IC_INTR_MASK |= 1u << 2u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_FULL bit.
     *
     * This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_RX_FULL() volatile
    {
        IC_INTR_MASK &= ~(1u << 2u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_FULL bit.
     *
     * This bit masks the R_RX_FULL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_RX_FULL() volatile
    {
        IC_INTR_MASK ^= 1u << 2u;
    }

    /**
     * Get IC_INTR_MASK's M_TX_OVER bit.
     *
     * This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_TX_OVER get_IC_INTR_MASK_M_TX_OVER() volatile
    {
        return I2C0_IC_INTR_MASK_M_TX_OVER(IC_INTR_MASK & (1u << 3u));
    }

    /**
     * Set IC_INTR_MASK's M_TX_OVER bit.
     *
     * This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_TX_OVER() volatile
    {
        IC_INTR_MASK |= 1u << 3u;
    }

    /**
     * Clear IC_INTR_MASK's M_TX_OVER bit.
     *
     * This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_TX_OVER() volatile
    {
        IC_INTR_MASK &= ~(1u << 3u);
    }

    /**
     * Toggle IC_INTR_MASK's M_TX_OVER bit.
     *
     * This bit masks the R_TX_OVER interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_TX_OVER() volatile
    {
        IC_INTR_MASK ^= 1u << 3u;
    }

    /**
     * Get IC_INTR_MASK's M_TX_EMPTY bit.
     *
     * This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_TX_EMPTY get_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        return I2C0_IC_INTR_MASK_M_TX_EMPTY(IC_INTR_MASK & (1u << 4u));
    }

    /**
     * Set IC_INTR_MASK's M_TX_EMPTY bit.
     *
     * This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        IC_INTR_MASK |= 1u << 4u;
    }

    /**
     * Clear IC_INTR_MASK's M_TX_EMPTY bit.
     *
     * This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        IC_INTR_MASK &= ~(1u << 4u);
    }

    /**
     * Toggle IC_INTR_MASK's M_TX_EMPTY bit.
     *
     * This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_TX_EMPTY() volatile
    {
        IC_INTR_MASK ^= 1u << 4u;
    }

    /**
     * Get IC_INTR_MASK's M_RD_REQ bit.
     *
     * This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_RD_REQ get_IC_INTR_MASK_M_RD_REQ() volatile
    {
        return I2C0_IC_INTR_MASK_M_RD_REQ(IC_INTR_MASK & (1u << 5u));
    }

    /**
     * Set IC_INTR_MASK's M_RD_REQ bit.
     *
     * This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_RD_REQ() volatile
    {
        IC_INTR_MASK |= 1u << 5u;
    }

    /**
     * Clear IC_INTR_MASK's M_RD_REQ bit.
     *
     * This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_RD_REQ() volatile
    {
        IC_INTR_MASK &= ~(1u << 5u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RD_REQ bit.
     *
     * This bit masks the R_RD_REQ interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_RD_REQ() volatile
    {
        IC_INTR_MASK ^= 1u << 5u;
    }

    /**
     * Get IC_INTR_MASK's M_TX_ABRT bit.
     *
     * This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_TX_ABRT get_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        return I2C0_IC_INTR_MASK_M_TX_ABRT(IC_INTR_MASK & (1u << 6u));
    }

    /**
     * Set IC_INTR_MASK's M_TX_ABRT bit.
     *
     * This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        IC_INTR_MASK |= 1u << 6u;
    }

    /**
     * Clear IC_INTR_MASK's M_TX_ABRT bit.
     *
     * This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        IC_INTR_MASK &= ~(1u << 6u);
    }

    /**
     * Toggle IC_INTR_MASK's M_TX_ABRT bit.
     *
     * This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_TX_ABRT() volatile
    {
        IC_INTR_MASK ^= 1u << 6u;
    }

    /**
     * Get IC_INTR_MASK's M_RX_DONE bit.
     *
     * This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_RX_DONE get_IC_INTR_MASK_M_RX_DONE() volatile
    {
        return I2C0_IC_INTR_MASK_M_RX_DONE(IC_INTR_MASK & (1u << 7u));
    }

    /**
     * Set IC_INTR_MASK's M_RX_DONE bit.
     *
     * This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_RX_DONE() volatile
    {
        IC_INTR_MASK |= 1u << 7u;
    }

    /**
     * Clear IC_INTR_MASK's M_RX_DONE bit.
     *
     * This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_RX_DONE() volatile
    {
        IC_INTR_MASK &= ~(1u << 7u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RX_DONE bit.
     *
     * This bit masks the R_RX_DONE interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_RX_DONE() volatile
    {
        IC_INTR_MASK ^= 1u << 7u;
    }

    /**
     * Get IC_INTR_MASK's M_ACTIVITY bit.
     *
     * This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_MASK_M_ACTIVITY get_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        return I2C0_IC_INTR_MASK_M_ACTIVITY(IC_INTR_MASK & (1u << 8u));
    }

    /**
     * Set IC_INTR_MASK's M_ACTIVITY bit.
     *
     * This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void set_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        IC_INTR_MASK |= 1u << 8u;
    }

    /**
     * Clear IC_INTR_MASK's M_ACTIVITY bit.
     *
     * This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void clear_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        IC_INTR_MASK &= ~(1u << 8u);
    }

    /**
     * Toggle IC_INTR_MASK's M_ACTIVITY bit.
     *
     * This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void toggle_IC_INTR_MASK_M_ACTIVITY() volatile
    {
        IC_INTR_MASK ^= 1u << 8u;
    }

    /**
     * Get IC_INTR_MASK's M_STOP_DET bit.
     *
     * This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_MASK_M_STOP_DET get_IC_INTR_MASK_M_STOP_DET() volatile
    {
        return I2C0_IC_INTR_MASK_M_STOP_DET(IC_INTR_MASK & (1u << 9u));
    }

    /**
     * Set IC_INTR_MASK's M_STOP_DET bit.
     *
     * This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void set_IC_INTR_MASK_M_STOP_DET() volatile
    {
        IC_INTR_MASK |= 1u << 9u;
    }

    /**
     * Clear IC_INTR_MASK's M_STOP_DET bit.
     *
     * This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void clear_IC_INTR_MASK_M_STOP_DET() volatile
    {
        IC_INTR_MASK &= ~(1u << 9u);
    }

    /**
     * Toggle IC_INTR_MASK's M_STOP_DET bit.
     *
     * This bit masks the R_STOP_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void toggle_IC_INTR_MASK_M_STOP_DET() volatile
    {
        IC_INTR_MASK ^= 1u << 9u;
    }

    /**
     * Get IC_INTR_MASK's M_START_DET bit.
     *
     * This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_MASK_M_START_DET
    get_IC_INTR_MASK_M_START_DET() volatile
    {
        return I2C0_IC_INTR_MASK_M_START_DET(IC_INTR_MASK & (1u << 10u));
    }

    /**
     * Set IC_INTR_MASK's M_START_DET bit.
     *
     * This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void set_IC_INTR_MASK_M_START_DET() volatile
    {
        IC_INTR_MASK |= 1u << 10u;
    }

    /**
     * Clear IC_INTR_MASK's M_START_DET bit.
     *
     * This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void clear_IC_INTR_MASK_M_START_DET() volatile
    {
        IC_INTR_MASK &= ~(1u << 10u);
    }

    /**
     * Toggle IC_INTR_MASK's M_START_DET bit.
     *
     * This bit masks the R_START_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void toggle_IC_INTR_MASK_M_START_DET() volatile
    {
        IC_INTR_MASK ^= 1u << 10u;
    }

    /**
     * Get IC_INTR_MASK's M_GEN_CALL bit.
     *
     * This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline I2C0_IC_INTR_MASK_M_GEN_CALL get_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        return I2C0_IC_INTR_MASK_M_GEN_CALL(IC_INTR_MASK & (1u << 11u));
    }

    /**
     * Set IC_INTR_MASK's M_GEN_CALL bit.
     *
     * This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void set_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        IC_INTR_MASK |= 1u << 11u;
    }

    /**
     * Clear IC_INTR_MASK's M_GEN_CALL bit.
     *
     * This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void clear_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        IC_INTR_MASK &= ~(1u << 11u);
    }

    /**
     * Toggle IC_INTR_MASK's M_GEN_CALL bit.
     *
     * This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x1
     */
    inline void toggle_IC_INTR_MASK_M_GEN_CALL() volatile
    {
        IC_INTR_MASK ^= 1u << 11u;
    }

    /**
     * Get IC_INTR_MASK's M_RESTART_DET bit.
     *
     * This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_INTR_MASK_M_RESTART_DET
    get_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        return I2C0_IC_INTR_MASK_M_RESTART_DET(IC_INTR_MASK & (1u << 12u));
    }

    /**
     * Set IC_INTR_MASK's M_RESTART_DET bit.
     *
     * This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void set_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        IC_INTR_MASK |= 1u << 12u;
    }

    /**
     * Clear IC_INTR_MASK's M_RESTART_DET bit.
     *
     * This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void clear_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        IC_INTR_MASK &= ~(1u << 12u);
    }

    /**
     * Toggle IC_INTR_MASK's M_RESTART_DET bit.
     *
     * This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline void toggle_IC_INTR_MASK_M_RESTART_DET() volatile
    {
        IC_INTR_MASK ^= 1u << 12u;
    }

    /**
     * Get all of IC_INTR_MASK's bit fields.
     *
     * (read-write) I2C Interrupt Mask Register.\n\n
     *             These bits mask their corresponding interrupt status bits.
     * This register is active low; a value of 0 masks the interrupt, whereas a
     * value of 1 unmasks the interrupt.
     */
    inline void get_IC_INTR_MASK(
        I2C0_IC_INTR_MASK_M_RX_UNDER &M_RX_UNDER,
        I2C0_IC_INTR_MASK_M_RX_OVER &M_RX_OVER,
        I2C0_IC_INTR_MASK_M_RX_FULL &M_RX_FULL,
        I2C0_IC_INTR_MASK_M_TX_OVER &M_TX_OVER,
        I2C0_IC_INTR_MASK_M_TX_EMPTY &M_TX_EMPTY,
        I2C0_IC_INTR_MASK_M_RD_REQ &M_RD_REQ,
        I2C0_IC_INTR_MASK_M_TX_ABRT &M_TX_ABRT,
        I2C0_IC_INTR_MASK_M_RX_DONE &M_RX_DONE,
        I2C0_IC_INTR_MASK_M_ACTIVITY &M_ACTIVITY,
        I2C0_IC_INTR_MASK_M_STOP_DET &M_STOP_DET,
        I2C0_IC_INTR_MASK_M_START_DET &M_START_DET,
        I2C0_IC_INTR_MASK_M_GEN_CALL &M_GEN_CALL,
        I2C0_IC_INTR_MASK_M_RESTART_DET &M_RESTART_DET) volatile
    {
        uint32_t curr = IC_INTR_MASK;

        M_RX_UNDER = I2C0_IC_INTR_MASK_M_RX_UNDER(curr & (1u << 0u));
        M_RX_OVER = I2C0_IC_INTR_MASK_M_RX_OVER(curr & (1u << 1u));
        M_RX_FULL = I2C0_IC_INTR_MASK_M_RX_FULL(curr & (1u << 2u));
        M_TX_OVER = I2C0_IC_INTR_MASK_M_TX_OVER(curr & (1u << 3u));
        M_TX_EMPTY = I2C0_IC_INTR_MASK_M_TX_EMPTY(curr & (1u << 4u));
        M_RD_REQ = I2C0_IC_INTR_MASK_M_RD_REQ(curr & (1u << 5u));
        M_TX_ABRT = I2C0_IC_INTR_MASK_M_TX_ABRT(curr & (1u << 6u));
        M_RX_DONE = I2C0_IC_INTR_MASK_M_RX_DONE(curr & (1u << 7u));
        M_ACTIVITY = I2C0_IC_INTR_MASK_M_ACTIVITY(curr & (1u << 8u));
        M_STOP_DET = I2C0_IC_INTR_MASK_M_STOP_DET(curr & (1u << 9u));
        M_START_DET = I2C0_IC_INTR_MASK_M_START_DET(curr & (1u << 10u));
        M_GEN_CALL = I2C0_IC_INTR_MASK_M_GEN_CALL(curr & (1u << 11u));
        M_RESTART_DET = I2C0_IC_INTR_MASK_M_RESTART_DET(curr & (1u << 12u));
    }

    /**
     * Set all of IC_INTR_MASK's bit fields.
     *
     * (read-write) I2C Interrupt Mask Register.\n\n
     *             These bits mask their corresponding interrupt status bits.
     * This register is active low; a value of 0 masks the interrupt, whereas a
     * value of 1 unmasks the interrupt.
     */
    inline void set_IC_INTR_MASK(
        I2C0_IC_INTR_MASK_M_RX_UNDER M_RX_UNDER,
        I2C0_IC_INTR_MASK_M_RX_OVER M_RX_OVER,
        I2C0_IC_INTR_MASK_M_RX_FULL M_RX_FULL,
        I2C0_IC_INTR_MASK_M_TX_OVER M_TX_OVER,
        I2C0_IC_INTR_MASK_M_TX_EMPTY M_TX_EMPTY,
        I2C0_IC_INTR_MASK_M_RD_REQ M_RD_REQ,
        I2C0_IC_INTR_MASK_M_TX_ABRT M_TX_ABRT,
        I2C0_IC_INTR_MASK_M_RX_DONE M_RX_DONE,
        I2C0_IC_INTR_MASK_M_ACTIVITY M_ACTIVITY,
        I2C0_IC_INTR_MASK_M_STOP_DET M_STOP_DET,
        I2C0_IC_INTR_MASK_M_START_DET M_START_DET,
        I2C0_IC_INTR_MASK_M_GEN_CALL M_GEN_CALL,
        I2C0_IC_INTR_MASK_M_RESTART_DET M_RESTART_DET) volatile
    {
        uint32_t curr = IC_INTR_MASK;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(M_RX_UNDER) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(M_RX_OVER) & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(M_RX_FULL) & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (std::to_underlying(M_TX_OVER) & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (std::to_underlying(M_TX_EMPTY) & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (std::to_underlying(M_RD_REQ) & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (std::to_underlying(M_TX_ABRT) & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (std::to_underlying(M_RX_DONE) & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (std::to_underlying(M_ACTIVITY) & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (std::to_underlying(M_STOP_DET) & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (std::to_underlying(M_START_DET) & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (std::to_underlying(M_GEN_CALL) & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (std::to_underlying(M_RESTART_DET) & 0b1u) << 12u;

        IC_INTR_MASK = curr;
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_UNDER bit.
     *
     * Set if the processor attempts to read the receive buffer when it is
     * empty by reading from the IC_DATA_CMD register. If the module is
     * disabled (IC_ENABLE[0]=0), this bit keeps its level until the master or
     * slave state machines go into idle, and when ic_en goes to 0, this
     * interrupt is cleared.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_UNDER
    get_IC_RAW_INTR_STAT_RX_UNDER() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_UNDER(IC_RAW_INTR_STAT & (1u << 0u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_OVER bit.
     *
     * Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH and
     * an additional byte is received from an external I2C device. The
     * DW_apb_i2c acknowledges this, but any data bytes received after the FIFO
     * is full are lost. If the module is disabled (IC_ENABLE[0]=0), this bit
     * keeps its level until the master or slave state machines go into idle,
     * and when ic_en goes to 0, this interrupt is cleared.\n\n Note:  If bit 9
     * of the IC_CON register (RX_FIFO_FULL_HLD_CTRL) is programmed to HIGH,
     * then the RX_OVER interrupt never occurs, because the Rx FIFO never
     * overflows.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_OVER
    get_IC_RAW_INTR_STAT_RX_OVER() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_OVER(IC_RAW_INTR_STAT & (1u << 1u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_FULL bit.
     *
     * Set when the receive buffer reaches or goes above the RX_TL threshold in
     * the IC_RX_TL register. It is automatically cleared by hardware when
     * buffer level goes below the threshold. If the module is disabled
     * (IC_ENABLE[0]=0), the RX FIFO is flushed and held in reset; therefore
     * the RX FIFO is not full. So this bit is cleared once the IC_ENABLE bit 0
     * is programmed with a 0, regardless of the activity that continues.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_FULL
    get_IC_RAW_INTR_STAT_RX_FULL() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_FULL(IC_RAW_INTR_STAT & (1u << 2u));
    }

    /**
     * Get IC_RAW_INTR_STAT's TX_OVER bit.
     *
     * Set during transmit if the transmit buffer is filled to
     * IC_TX_BUFFER_DEPTH and the processor attempts to issue another I2C
     * command by writing to the IC_DATA_CMD register. When the module is
     * disabled, this bit keeps its level until the master or slave state
     * machines go into idle, and when ic_en goes to 0, this interrupt is
     * cleared.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_TX_OVER
    get_IC_RAW_INTR_STAT_TX_OVER() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_TX_OVER(IC_RAW_INTR_STAT & (1u << 3u));
    }

    /**
     * Get IC_RAW_INTR_STAT's TX_EMPTY bit.
     *
     * The behavior of the TX_EMPTY interrupt status differs based on the
     * TX_EMPTY_CTRL selection in the IC_CON register. - When TX_EMPTY_CTRL =
     * 0: This bit is set to 1 when the transmit buffer is at or below the
     * threshold value set in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1:
     * This bit is set to 1 when the transmit buffer is at or below the
     * threshold value set in the IC_TX_TL register and the transmission of the
     * address/data from the internal shift register for the most recently
     * popped command is completed. It is automatically cleared by hardware
     * when the buffer level goes above the threshold. When IC_ENABLE[0] is set
     * to 0, the TX FIFO is flushed and held in reset. There the TX FIFO looks
     * like it has no data within it, so this bit is set to 1, provided there
     * is activity in the master or slave state machines. When there is no
     * longer any activity, then with ic_en=0, this bit is set to 0.\n\n Reset
     * value: 0x0.
     */
    inline I2C0_IC_RAW_INTR_STAT_TX_EMPTY
    get_IC_RAW_INTR_STAT_TX_EMPTY() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_TX_EMPTY(IC_RAW_INTR_STAT & (1u << 4u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RD_REQ bit.
     *
     * This bit is set to 1 when DW_apb_i2c is acting as a slave and another
     * I2C master is attempting to read data from DW_apb_i2c. The DW_apb_i2c
     * holds the I2C bus in a wait state (SCL=0) until this interrupt is
     * serviced, which means that the slave has been addressed by a remote
     * master that is asking for data to be transferred. The processor must
     * respond to this interrupt and then write the requested data to the
     * IC_DATA_CMD register. This bit is set to 0 just after the processor
     * reads the IC_CLR_RD_REQ register.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_RD_REQ get_IC_RAW_INTR_STAT_RD_REQ() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RD_REQ(IC_RAW_INTR_STAT & (1u << 5u));
    }

    /**
     * Get IC_RAW_INTR_STAT's TX_ABRT bit.
     *
     * This bit indicates if DW_apb_i2c, as an I2C transmitter, is unable to
     * complete the intended actions on the contents of the transmit FIFO. This
     * situation can occur both as an I2C master or an I2C slave, and is
     * referred to as a 'transmit abort'. When this bit is set to 1, the
     * IC_TX_ABRT_SOURCE register indicates the reason why the transmit abort
     * takes places.\n\n Note:  The DW_apb_i2c flushes/resets/empties the
     * TX_FIFO and RX_FIFO whenever there is a transmit abort caused by any of
     * the events tracked by the IC_TX_ABRT_SOURCE register. The FIFOs remains
     * in this flushed state until the register IC_CLR_TX_ABRT is read. Once
     * this read is performed, the Tx FIFO is then ready to accept more data
     * bytes from the APB interface.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_TX_ABRT
    get_IC_RAW_INTR_STAT_TX_ABRT() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_TX_ABRT(IC_RAW_INTR_STAT & (1u << 6u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RX_DONE bit.
     *
     * When the DW_apb_i2c is acting as a slave-transmitter, this bit is set to
     * 1 if the master does not acknowledge a transmitted byte. This occurs on
     * the last byte of the transmission, indicating that the transmission is
     * done.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_RX_DONE
    get_IC_RAW_INTR_STAT_RX_DONE() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RX_DONE(IC_RAW_INTR_STAT & (1u << 7u));
    }

    /**
     * Get IC_RAW_INTR_STAT's ACTIVITY bit.
     *
     * This bit captures DW_apb_i2c activity and stays set until it is cleared.
     * There are four ways to clear it: - Disabling the DW_apb_i2c - Reading
     * the IC_CLR_ACTIVITY register - Reading the IC_CLR_INTR register - System
     * reset Once this bit is set, it stays set unless one of the four methods
     * is used to clear it. Even if the DW_apb_i2c module is idle, this bit
     * remains set until cleared, indicating that there was activity on the
     * bus.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_ACTIVITY
    get_IC_RAW_INTR_STAT_ACTIVITY() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_ACTIVITY(IC_RAW_INTR_STAT & (1u << 8u));
    }

    /**
     * Get IC_RAW_INTR_STAT's STOP_DET bit.
     *
     * Indicates whether a STOP condition has occurred on the I2C interface
     * regardless of whether DW_apb_i2c is operating in slave or master
     * mode.\n\n In Slave Mode: - If IC_CON[7]=1'b1  (STOP_DET_IFADDRESSED),
     * the STOP_DET interrupt will be issued only if slave is addressed. Note:
     * During a general call address, this slave does not issue a STOP_DET
     * interrupt if STOP_DET_IF_ADDRESSED=1'b1, even if the slave responds to
     * the general call address by generating ACK. The STOP_DET interrupt is
     * generated only when the transmitted address matches the slave address
     * (SAR). - If IC_CON[7]=1'b0 (STOP_DET_IFADDRESSED), the STOP_DET
     * interrupt is issued irrespective of whether it is being addressed. In
     * Master Mode: - If IC_CON[10]=1'b1  (STOP_DET_IF_MASTER_ACTIVE),the
     * STOP_DET interrupt will be issued only if Master is active. - If
     * IC_CON[10]=1'b0  (STOP_DET_IFADDRESSED),the STOP_DET interrupt will be
     * issued irrespective of whether master is active or not. Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_STOP_DET
    get_IC_RAW_INTR_STAT_STOP_DET() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_STOP_DET(IC_RAW_INTR_STAT & (1u << 9u));
    }

    /**
     * Get IC_RAW_INTR_STAT's START_DET bit.
     *
     * Indicates whether a START or RESTART condition has occurred on the I2C
     * interface regardless of whether DW_apb_i2c is operating in slave or
     * master mode.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_START_DET
    get_IC_RAW_INTR_STAT_START_DET() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_START_DET(IC_RAW_INTR_STAT & (1u << 10u));
    }

    /**
     * Get IC_RAW_INTR_STAT's GEN_CALL bit.
     *
     * Set only when a General Call address is received and it is acknowledged.
     * It stays set until it is cleared either by disabling DW_apb_i2c or when
     * the CPU reads bit 0 of the IC_CLR_GEN_CALL register. DW_apb_i2c stores
     * the received data in the Rx buffer.\n\n Reset value: 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_GEN_CALL
    get_IC_RAW_INTR_STAT_GEN_CALL() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_GEN_CALL(IC_RAW_INTR_STAT & (1u << 11u));
    }

    /**
     * Get IC_RAW_INTR_STAT's RESTART_DET bit.
     *
     * Indicates whether a RESTART condition has occurred on the I2C interface
     * when DW_apb_i2c is operating in Slave mode and the slave is being
     * addressed. Enabled only when IC_SLV_RESTART_DET_EN=1.\n\n Note: However,
     * in high-speed mode or during a START BYTE transfer, the RESTART comes
     * before the address field as per the I2C protocol. In this case, the
     * slave is not the addressed slave when the RESTART is issued, therefore
     * DW_apb_i2c does not generate the RESTART_DET interrupt.\n\n Reset value:
     * 0x0
     */
    inline I2C0_IC_RAW_INTR_STAT_RESTART_DET
    get_IC_RAW_INTR_STAT_RESTART_DET() volatile
    {
        return I2C0_IC_RAW_INTR_STAT_RESTART_DET(IC_RAW_INTR_STAT &
                                                 (1u << 12u));
    }

    /**
     * Get all of IC_RAW_INTR_STAT's bit fields.
     *
     * (read-only) I2C Raw Interrupt Status Register\n\n
     *             Unlike the IC_INTR_STAT register, these bits are not masked
     * so they always show the true status of the DW_apb_i2c.
     */
    inline void get_IC_RAW_INTR_STAT(
        I2C0_IC_RAW_INTR_STAT_RX_UNDER &RX_UNDER,
        I2C0_IC_RAW_INTR_STAT_RX_OVER &RX_OVER,
        I2C0_IC_RAW_INTR_STAT_RX_FULL &RX_FULL,
        I2C0_IC_RAW_INTR_STAT_TX_OVER &TX_OVER,
        I2C0_IC_RAW_INTR_STAT_TX_EMPTY &TX_EMPTY,
        I2C0_IC_RAW_INTR_STAT_RD_REQ &RD_REQ,
        I2C0_IC_RAW_INTR_STAT_TX_ABRT &TX_ABRT,
        I2C0_IC_RAW_INTR_STAT_RX_DONE &RX_DONE,
        I2C0_IC_RAW_INTR_STAT_ACTIVITY &ACTIVITY,
        I2C0_IC_RAW_INTR_STAT_STOP_DET &STOP_DET,
        I2C0_IC_RAW_INTR_STAT_START_DET &START_DET,
        I2C0_IC_RAW_INTR_STAT_GEN_CALL &GEN_CALL,
        I2C0_IC_RAW_INTR_STAT_RESTART_DET &RESTART_DET) volatile
    {
        uint32_t curr = IC_RAW_INTR_STAT;

        RX_UNDER = I2C0_IC_RAW_INTR_STAT_RX_UNDER(curr & (1u << 0u));
        RX_OVER = I2C0_IC_RAW_INTR_STAT_RX_OVER(curr & (1u << 1u));
        RX_FULL = I2C0_IC_RAW_INTR_STAT_RX_FULL(curr & (1u << 2u));
        TX_OVER = I2C0_IC_RAW_INTR_STAT_TX_OVER(curr & (1u << 3u));
        TX_EMPTY = I2C0_IC_RAW_INTR_STAT_TX_EMPTY(curr & (1u << 4u));
        RD_REQ = I2C0_IC_RAW_INTR_STAT_RD_REQ(curr & (1u << 5u));
        TX_ABRT = I2C0_IC_RAW_INTR_STAT_TX_ABRT(curr & (1u << 6u));
        RX_DONE = I2C0_IC_RAW_INTR_STAT_RX_DONE(curr & (1u << 7u));
        ACTIVITY = I2C0_IC_RAW_INTR_STAT_ACTIVITY(curr & (1u << 8u));
        STOP_DET = I2C0_IC_RAW_INTR_STAT_STOP_DET(curr & (1u << 9u));
        START_DET = I2C0_IC_RAW_INTR_STAT_START_DET(curr & (1u << 10u));
        GEN_CALL = I2C0_IC_RAW_INTR_STAT_GEN_CALL(curr & (1u << 11u));
        RESTART_DET = I2C0_IC_RAW_INTR_STAT_RESTART_DET(curr & (1u << 12u));
    }

    /**
     * Get IC_RX_TL's RX_TL field.
     *
     * Receive FIFO Threshold Level.\n\n
     *                 Controls the level of entries (or above) that triggers
     * the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid
     * range is 0-255, with the additional restriction that hardware does not
     * allow this value to be set to a value larger than the depth of the
     * buffer. If an attempt is made to do that, the actual value set will be
     * the maximum depth of the buffer. A value of 0 sets the threshold for 1
     * entry, and a value of 255 sets the threshold for 256 entries.
     */
    inline uint8_t get_IC_RX_TL_RX_TL() volatile
    {
        return (IC_RX_TL >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_RX_TL's RX_TL field.
     *
     * Receive FIFO Threshold Level.\n\n
     *                 Controls the level of entries (or above) that triggers
     * the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register). The valid
     * range is 0-255, with the additional restriction that hardware does not
     * allow this value to be set to a value larger than the depth of the
     * buffer. If an attempt is made to do that, the actual value set will be
     * the maximum depth of the buffer. A value of 0 sets the threshold for 1
     * entry, and a value of 255 sets the threshold for 256 entries.
     */
    inline void set_IC_RX_TL_RX_TL(uint8_t value) volatile
    {
        uint32_t curr = IC_RX_TL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_RX_TL = curr;
    }

    /**
     * Get IC_TX_TL's TX_TL field.
     *
     * Transmit FIFO Threshold Level.\n\n
     *                 Controls the level of entries (or below) that trigger
     * the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid
     * range is 0-255, with the additional restriction that it may not be set
     * to value larger than the depth of the buffer. If an attempt is made to
     * do that, the actual value set will be the maximum depth of the buffer. A
     * value of 0 sets the threshold for 0 entries, and a value of 255 sets the
     * threshold for 255 entries.
     */
    inline uint8_t get_IC_TX_TL_TX_TL() volatile
    {
        return (IC_TX_TL >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_TX_TL's TX_TL field.
     *
     * Transmit FIFO Threshold Level.\n\n
     *                 Controls the level of entries (or below) that trigger
     * the TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register). The valid
     * range is 0-255, with the additional restriction that it may not be set
     * to value larger than the depth of the buffer. If an attempt is made to
     * do that, the actual value set will be the maximum depth of the buffer. A
     * value of 0 sets the threshold for 0 entries, and a value of 255 sets the
     * threshold for 255 entries.
     */
    inline void set_IC_TX_TL_TX_TL(uint8_t value) volatile
    {
        uint32_t curr = IC_TX_TL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_TX_TL = curr;
    }

    /**
     * Get IC_CLR_INTR's CLR_INTR bit.
     *
     * Read this register to clear the combined interrupt, all individual
     * interrupts, and the IC_TX_ABRT_SOURCE register. This bit does not clear
     * hardware clearable interrupts but software clearable interrupts. Refer
     * to Bit 9 of the IC_TX_ABRT_SOURCE register for an exception to clearing
     * IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_INTR_CLR_INTR() volatile
    {
        return IC_CLR_INTR & (1u << 0u);
    }

    /**
     * Get IC_CLR_RX_UNDER's CLR_RX_UNDER bit.
     *
     * Read this register to clear the RX_UNDER interrupt (bit 0) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_RX_UNDER_CLR_RX_UNDER() volatile
    {
        return IC_CLR_RX_UNDER & (1u << 0u);
    }

    /**
     * Get IC_CLR_RX_OVER's CLR_RX_OVER bit.
     *
     * Read this register to clear the RX_OVER interrupt (bit 1) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_RX_OVER_CLR_RX_OVER() volatile
    {
        return IC_CLR_RX_OVER & (1u << 0u);
    }

    /**
     * Get IC_CLR_TX_OVER's CLR_TX_OVER bit.
     *
     * Read this register to clear the TX_OVER interrupt (bit 3) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_TX_OVER_CLR_TX_OVER() volatile
    {
        return IC_CLR_TX_OVER & (1u << 0u);
    }

    /**
     * Get IC_CLR_RD_REQ's CLR_RD_REQ bit.
     *
     * Read this register to clear the RD_REQ interrupt (bit 5) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_RD_REQ_CLR_RD_REQ() volatile
    {
        return IC_CLR_RD_REQ & (1u << 0u);
    }

    /**
     * Get IC_CLR_TX_ABRT's CLR_TX_ABRT bit.
     *
     * Read this register to clear the TX_ABRT interrupt (bit 6) of the
     * IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE register. This also
     * releases the TX FIFO from the flushed/reset state, allowing more writes
     * to the TX FIFO. Refer to Bit 9 of the IC_TX_ABRT_SOURCE register for an
     * exception to clearing IC_TX_ABRT_SOURCE.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_TX_ABRT_CLR_TX_ABRT() volatile
    {
        return IC_CLR_TX_ABRT & (1u << 0u);
    }

    /**
     * Get IC_CLR_RX_DONE's CLR_RX_DONE bit.
     *
     * Read this register to clear the RX_DONE interrupt (bit 7) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_RX_DONE_CLR_RX_DONE() volatile
    {
        return IC_CLR_RX_DONE & (1u << 0u);
    }

    /**
     * Get IC_CLR_ACTIVITY's CLR_ACTIVITY bit.
     *
     * Reading this register clears the ACTIVITY interrupt if the I2C is not
     * active anymore. If the I2C module is still active on the bus, the
     * ACTIVITY interrupt bit continues to be set. It is automatically cleared
     * by hardware if the module is disabled and if there is no further
     * activity on the bus. The value read from this register to get status of
     * the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT register.\n\n
     *                 Reset value: 0x0
     */
    inline bool get_IC_CLR_ACTIVITY_CLR_ACTIVITY() volatile
    {
        return IC_CLR_ACTIVITY & (1u << 0u);
    }

    /**
     * Get IC_CLR_STOP_DET's CLR_STOP_DET bit.
     *
     * Read this register to clear the STOP_DET interrupt (bit 9) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_STOP_DET_CLR_STOP_DET() volatile
    {
        return IC_CLR_STOP_DET & (1u << 0u);
    }

    /**
     * Get IC_CLR_START_DET's CLR_START_DET bit.
     *
     * Read this register to clear the START_DET interrupt (bit 10) of the
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_START_DET_CLR_START_DET() volatile
    {
        return IC_CLR_START_DET & (1u << 0u);
    }

    /**
     * Get IC_CLR_GEN_CALL's CLR_GEN_CALL bit.
     *
     * Read this register to clear the GEN_CALL interrupt (bit 11) of
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_GEN_CALL_CLR_GEN_CALL() volatile
    {
        return IC_CLR_GEN_CALL & (1u << 0u);
    }

    /**
     * Get IC_ENABLE's ENABLE bit.
     *
     * Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX
     * and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c
     * Software can disable DW_apb_i2c while it is active. However, it is
     * important that care be taken to ensure that DW_apb_i2c is disabled
     * properly. A recommended procedure is described in 'Disabling
     * DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: -
     * The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT
     * register are still active until DW_apb_i2c goes into IDLE state. If the
     * module is transmitting, it stops as well as deletes the contents of the
     * transmit buffer after the current transfer is complete. If the module is
     * receiving, the DW_apb_i2c stops the current transfer at the end of the
     * current byte and does not acknowledge the transfer.\n\n In systems with
     * asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to
     * asynchronous (1), there is a two ic_clk delay when enabling or disabling
     * the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c,
     * refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
     */
    inline I2C0_IC_ENABLE_ENABLE get_IC_ENABLE_ENABLE() volatile
    {
        return I2C0_IC_ENABLE_ENABLE(IC_ENABLE & (1u << 0u));
    }

    /**
     * Set IC_ENABLE's ENABLE bit.
     *
     * Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX
     * and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c
     * Software can disable DW_apb_i2c while it is active. However, it is
     * important that care be taken to ensure that DW_apb_i2c is disabled
     * properly. A recommended procedure is described in 'Disabling
     * DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: -
     * The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT
     * register are still active until DW_apb_i2c goes into IDLE state. If the
     * module is transmitting, it stops as well as deletes the contents of the
     * transmit buffer after the current transfer is complete. If the module is
     * receiving, the DW_apb_i2c stops the current transfer at the end of the
     * current byte and does not acknowledge the transfer.\n\n In systems with
     * asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to
     * asynchronous (1), there is a two ic_clk delay when enabling or disabling
     * the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c,
     * refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
     */
    inline void set_IC_ENABLE_ENABLE() volatile
    {
        IC_ENABLE |= 1u << 0u;
    }

    /**
     * Clear IC_ENABLE's ENABLE bit.
     *
     * Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX
     * and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c
     * Software can disable DW_apb_i2c while it is active. However, it is
     * important that care be taken to ensure that DW_apb_i2c is disabled
     * properly. A recommended procedure is described in 'Disabling
     * DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: -
     * The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT
     * register are still active until DW_apb_i2c goes into IDLE state. If the
     * module is transmitting, it stops as well as deletes the contents of the
     * transmit buffer after the current transfer is complete. If the module is
     * receiving, the DW_apb_i2c stops the current transfer at the end of the
     * current byte and does not acknowledge the transfer.\n\n In systems with
     * asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to
     * asynchronous (1), there is a two ic_clk delay when enabling or disabling
     * the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c,
     * refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
     */
    inline void clear_IC_ENABLE_ENABLE() volatile
    {
        IC_ENABLE &= ~(1u << 0u);
    }

    /**
     * Toggle IC_ENABLE's ENABLE bit.
     *
     * Controls whether the DW_apb_i2c is enabled. - 0: Disables DW_apb_i2c (TX
     * and RX FIFOs are held in an erased state) - 1: Enables DW_apb_i2c
     * Software can disable DW_apb_i2c while it is active. However, it is
     * important that care be taken to ensure that DW_apb_i2c is disabled
     * properly. A recommended procedure is described in 'Disabling
     * DW_apb_i2c'.\n\n When DW_apb_i2c is disabled, the following occurs: -
     * The TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT
     * register are still active until DW_apb_i2c goes into IDLE state. If the
     * module is transmitting, it stops as well as deletes the contents of the
     * transmit buffer after the current transfer is complete. If the module is
     * receiving, the DW_apb_i2c stops the current transfer at the end of the
     * current byte and does not acknowledge the transfer.\n\n In systems with
     * asynchronous pclk and ic_clk when IC_CLK_TYPE parameter set to
     * asynchronous (1), there is a two ic_clk delay when enabling or disabling
     * the DW_apb_i2c. For a detailed description on how to disable DW_apb_i2c,
     * refer to 'Disabling DW_apb_i2c'\n\n Reset value: 0x0
     */
    inline void toggle_IC_ENABLE_ENABLE() volatile
    {
        IC_ENABLE ^= 1u << 0u;
    }

    /**
     * Get IC_ENABLE's ABORT bit.
     *
     * When set, the controller initiates the transfer abort. - 0: ABORT not
     * initiated or ABORT done - 1: ABORT operation in progress The software
     * can abort the I2C transfer in master mode by setting this bit. The
     * software can set this bit only when ENABLE is already set; otherwise,
     * the controller ignores any write to ABORT bit. The software cannot clear
     * the ABORT bit once set. In response to an ABORT, the controller issues a
     * STOP and flushes the Tx FIFO after completing the current transfer, then
     * sets the TX_ABORT interrupt after the abort operation. The ABORT bit is
     * cleared automatically after the abort operation.\n\n For a detailed
     * description on how to abort I2C transfers, refer to 'Aborting I2C
     * Transfers'.\n\n Reset value: 0x0
     */
    inline I2C0_IC_ENABLE_ABORT get_IC_ENABLE_ABORT() volatile
    {
        return I2C0_IC_ENABLE_ABORT(IC_ENABLE & (1u << 1u));
    }

    /**
     * Set IC_ENABLE's ABORT bit.
     *
     * When set, the controller initiates the transfer abort. - 0: ABORT not
     * initiated or ABORT done - 1: ABORT operation in progress The software
     * can abort the I2C transfer in master mode by setting this bit. The
     * software can set this bit only when ENABLE is already set; otherwise,
     * the controller ignores any write to ABORT bit. The software cannot clear
     * the ABORT bit once set. In response to an ABORT, the controller issues a
     * STOP and flushes the Tx FIFO after completing the current transfer, then
     * sets the TX_ABORT interrupt after the abort operation. The ABORT bit is
     * cleared automatically after the abort operation.\n\n For a detailed
     * description on how to abort I2C transfers, refer to 'Aborting I2C
     * Transfers'.\n\n Reset value: 0x0
     */
    inline void set_IC_ENABLE_ABORT() volatile
    {
        IC_ENABLE |= 1u << 1u;
    }

    /**
     * Clear IC_ENABLE's ABORT bit.
     *
     * When set, the controller initiates the transfer abort. - 0: ABORT not
     * initiated or ABORT done - 1: ABORT operation in progress The software
     * can abort the I2C transfer in master mode by setting this bit. The
     * software can set this bit only when ENABLE is already set; otherwise,
     * the controller ignores any write to ABORT bit. The software cannot clear
     * the ABORT bit once set. In response to an ABORT, the controller issues a
     * STOP and flushes the Tx FIFO after completing the current transfer, then
     * sets the TX_ABORT interrupt after the abort operation. The ABORT bit is
     * cleared automatically after the abort operation.\n\n For a detailed
     * description on how to abort I2C transfers, refer to 'Aborting I2C
     * Transfers'.\n\n Reset value: 0x0
     */
    inline void clear_IC_ENABLE_ABORT() volatile
    {
        IC_ENABLE &= ~(1u << 1u);
    }

    /**
     * Toggle IC_ENABLE's ABORT bit.
     *
     * When set, the controller initiates the transfer abort. - 0: ABORT not
     * initiated or ABORT done - 1: ABORT operation in progress The software
     * can abort the I2C transfer in master mode by setting this bit. The
     * software can set this bit only when ENABLE is already set; otherwise,
     * the controller ignores any write to ABORT bit. The software cannot clear
     * the ABORT bit once set. In response to an ABORT, the controller issues a
     * STOP and flushes the Tx FIFO after completing the current transfer, then
     * sets the TX_ABORT interrupt after the abort operation. The ABORT bit is
     * cleared automatically after the abort operation.\n\n For a detailed
     * description on how to abort I2C transfers, refer to 'Aborting I2C
     * Transfers'.\n\n Reset value: 0x0
     */
    inline void toggle_IC_ENABLE_ABORT() volatile
    {
        IC_ENABLE ^= 1u << 1u;
    }

    /**
     * Get IC_ENABLE's TX_CMD_BLOCK bit.
     *
     * In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even
     * if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts
     * on I2C bus automatically, as soon as the first data is available in the
     * Tx FIFO. Note: To block the execution of Master commands, set the
     * TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master
     * is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx
     * FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:
     * IC_TX_CMD_BLOCK_DEFAULT
     */
    inline I2C0_IC_ENABLE_TX_CMD_BLOCK get_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        return I2C0_IC_ENABLE_TX_CMD_BLOCK(IC_ENABLE & (1u << 2u));
    }

    /**
     * Set IC_ENABLE's TX_CMD_BLOCK bit.
     *
     * In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even
     * if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts
     * on I2C bus automatically, as soon as the first data is available in the
     * Tx FIFO. Note: To block the execution of Master commands, set the
     * TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master
     * is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx
     * FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:
     * IC_TX_CMD_BLOCK_DEFAULT
     */
    inline void set_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        IC_ENABLE |= 1u << 2u;
    }

    /**
     * Clear IC_ENABLE's TX_CMD_BLOCK bit.
     *
     * In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even
     * if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts
     * on I2C bus automatically, as soon as the first data is available in the
     * Tx FIFO. Note: To block the execution of Master commands, set the
     * TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master
     * is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx
     * FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:
     * IC_TX_CMD_BLOCK_DEFAULT
     */
    inline void clear_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        IC_ENABLE &= ~(1u << 2u);
    }

    /**
     * Toggle IC_ENABLE's TX_CMD_BLOCK bit.
     *
     * In Master mode: - 1'b1: Blocks the transmission of data on I2C bus even
     * if Tx FIFO has data to transmit. - 1'b0: The transmission of data starts
     * on I2C bus automatically, as soon as the first data is available in the
     * Tx FIFO. Note: To block the execution of Master commands, set the
     * TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1) and Master
     * is in Idle state (IC_STATUS[5] == 0). Any further commands put in the Tx
     * FIFO are not executed until TX_CMD_BLOCK bit is unset. Reset value:
     * IC_TX_CMD_BLOCK_DEFAULT
     */
    inline void toggle_IC_ENABLE_TX_CMD_BLOCK() volatile
    {
        IC_ENABLE ^= 1u << 2u;
    }

    /**
     * Get all of IC_ENABLE's bit fields.
     *
     * (read-write) I2C Enable Register
     */
    inline void get_IC_ENABLE(
        I2C0_IC_ENABLE_ENABLE &ENABLE, I2C0_IC_ENABLE_ABORT &ABORT,
        I2C0_IC_ENABLE_TX_CMD_BLOCK &TX_CMD_BLOCK) volatile
    {
        uint32_t curr = IC_ENABLE;

        ENABLE = I2C0_IC_ENABLE_ENABLE(curr & (1u << 0u));
        ABORT = I2C0_IC_ENABLE_ABORT(curr & (1u << 1u));
        TX_CMD_BLOCK = I2C0_IC_ENABLE_TX_CMD_BLOCK(curr & (1u << 2u));
    }

    /**
     * Set all of IC_ENABLE's bit fields.
     *
     * (read-write) I2C Enable Register
     */
    inline void set_IC_ENABLE(
        I2C0_IC_ENABLE_ENABLE ENABLE, I2C0_IC_ENABLE_ABORT ABORT,
        I2C0_IC_ENABLE_TX_CMD_BLOCK TX_CMD_BLOCK) volatile
    {
        uint32_t curr = IC_ENABLE;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(ENABLE) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(ABORT) & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (std::to_underlying(TX_CMD_BLOCK) & 0b1u) << 2u;

        IC_ENABLE = curr;
    }

    /**
     * Get IC_STATUS's ACTIVITY bit.
     *
     * I2C Activity Status. Reset value: 0x0
     */
    inline I2C0_IC_STATUS_ACTIVITY get_IC_STATUS_ACTIVITY() volatile
    {
        return I2C0_IC_STATUS_ACTIVITY(IC_STATUS & (1u << 0u));
    }

    /**
     * Get IC_STATUS's TFNF bit.
     *
     * Transmit FIFO Not Full. Set when the transmit FIFO contains one or more
     * empty locations, and is cleared when the FIFO is full. - 0: Transmit
     * FIFO is full - 1: Transmit FIFO is not full Reset value: 0x1
     */
    inline I2C0_IC_STATUS_TFNF get_IC_STATUS_TFNF() volatile
    {
        return I2C0_IC_STATUS_TFNF(IC_STATUS & (1u << 1u));
    }

    /**
     * Get IC_STATUS's TFE bit.
     *
     * Transmit FIFO Completely Empty. When the transmit FIFO is completely
     * empty, this bit is set. When it contains one or more valid entries, this
     * bit is cleared. This bit field does not request an interrupt. - 0:
     * Transmit FIFO is not empty - 1: Transmit FIFO is empty Reset value: 0x1
     */
    inline I2C0_IC_STATUS_TFE get_IC_STATUS_TFE() volatile
    {
        return I2C0_IC_STATUS_TFE(IC_STATUS & (1u << 2u));
    }

    /**
     * Get IC_STATUS's RFNE bit.
     *
     * Receive FIFO Not Empty. This bit is set when the receive FIFO contains
     * one or more entries; it is cleared when the receive FIFO is empty. - 0:
     * Receive FIFO is empty - 1: Receive FIFO is not empty Reset value: 0x0
     */
    inline I2C0_IC_STATUS_RFNE get_IC_STATUS_RFNE() volatile
    {
        return I2C0_IC_STATUS_RFNE(IC_STATUS & (1u << 3u));
    }

    /**
     * Get IC_STATUS's RFF bit.
     *
     * Receive FIFO Completely Full. When the receive FIFO is completely full,
     * this bit is set. When the receive FIFO contains one or more empty
     * location, this bit is cleared. - 0: Receive FIFO is not full - 1:
     * Receive FIFO is full Reset value: 0x0
     */
    inline I2C0_IC_STATUS_RFF get_IC_STATUS_RFF() volatile
    {
        return I2C0_IC_STATUS_RFF(IC_STATUS & (1u << 4u));
    }

    /**
     * Get IC_STATUS's MST_ACTIVITY bit.
     *
     * Master FSM Activity Status. When the Master Finite State Machine (FSM)
     * is not in the IDLE state, this bit is set. - 0: Master FSM is in IDLE
     * state so the Master part of DW_apb_i2c is not Active - 1: Master FSM is
     * not in IDLE state so the Master part of DW_apb_i2c is Active Note:
     * IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY and
     * MST_ACTIVITY bits.\n\n Reset value: 0x0
     */
    inline I2C0_IC_STATUS_MST_ACTIVITY get_IC_STATUS_MST_ACTIVITY() volatile
    {
        return I2C0_IC_STATUS_MST_ACTIVITY(IC_STATUS & (1u << 5u));
    }

    /**
     * Get IC_STATUS's SLV_ACTIVITY bit.
     *
     * Slave FSM Activity Status. When the Slave Finite State Machine (FSM) is
     * not in the IDLE state, this bit is set. - 0: Slave FSM is in IDLE state
     * so the Slave part of DW_apb_i2c is not Active - 1: Slave FSM is not in
     * IDLE state so the Slave part of DW_apb_i2c is Active Reset value: 0x0
     */
    inline I2C0_IC_STATUS_SLV_ACTIVITY get_IC_STATUS_SLV_ACTIVITY() volatile
    {
        return I2C0_IC_STATUS_SLV_ACTIVITY(IC_STATUS & (1u << 6u));
    }

    /**
     * Get all of IC_STATUS's bit fields.
     *
     * (read-only) I2C Status Register\n\n
     *             This is a read-only register used to indicate the current
     * transfer status and FIFO status. The status register may be read at any
     * time. None of the bits in this register request an interrupt.\n\n When
     * the I2C is disabled by writing 0 in bit 0 of the IC_ENABLE register: -
     * Bits 1 and 2 are set to 1 - Bits 3 and 10 are set to 0 When the master
     * or slave state machines goes to idle and ic_en=0: - Bits 5 and 6 are set
     * to 0
     */
    inline void get_IC_STATUS(
        I2C0_IC_STATUS_ACTIVITY &ACTIVITY, I2C0_IC_STATUS_TFNF &TFNF,
        I2C0_IC_STATUS_TFE &TFE, I2C0_IC_STATUS_RFNE &RFNE,
        I2C0_IC_STATUS_RFF &RFF, I2C0_IC_STATUS_MST_ACTIVITY &MST_ACTIVITY,
        I2C0_IC_STATUS_SLV_ACTIVITY &SLV_ACTIVITY) volatile
    {
        uint32_t curr = IC_STATUS;

        ACTIVITY = I2C0_IC_STATUS_ACTIVITY(curr & (1u << 0u));
        TFNF = I2C0_IC_STATUS_TFNF(curr & (1u << 1u));
        TFE = I2C0_IC_STATUS_TFE(curr & (1u << 2u));
        RFNE = I2C0_IC_STATUS_RFNE(curr & (1u << 3u));
        RFF = I2C0_IC_STATUS_RFF(curr & (1u << 4u));
        MST_ACTIVITY = I2C0_IC_STATUS_MST_ACTIVITY(curr & (1u << 5u));
        SLV_ACTIVITY = I2C0_IC_STATUS_SLV_ACTIVITY(curr & (1u << 6u));
    }

    /**
     * Get IC_TXFLR's TXFLR field.
     *
     * Transmit FIFO Level. Contains the number of valid data entries in the
     * transmit FIFO.\n\n Reset value: 0x0
     */
    inline uint8_t get_IC_TXFLR_TXFLR() volatile
    {
        return (IC_TXFLR >> 0u) & 0b11111u;
    }

    /**
     * Get IC_RXFLR's RXFLR field.
     *
     * Receive FIFO Level. Contains the number of valid data entries in the
     * receive FIFO.\n\n Reset value: 0x0
     */
    inline uint8_t get_IC_RXFLR_RXFLR() volatile
    {
        return (IC_RXFLR >> 0u) & 0b11111u;
    }

    /**
     * Get IC_SDA_HOLD's IC_SDA_TX_HOLD field.
     *
     * Sets the required SDA hold time in units of ic_clk period, when
     * DW_apb_i2c acts as a transmitter.\n\n Reset value:
     * IC_DEFAULT_SDA_HOLD[15:0].
     */
    inline uint16_t get_IC_SDA_HOLD_IC_SDA_TX_HOLD() volatile
    {
        return (IC_SDA_HOLD >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set IC_SDA_HOLD's IC_SDA_TX_HOLD field.
     *
     * Sets the required SDA hold time in units of ic_clk period, when
     * DW_apb_i2c acts as a transmitter.\n\n Reset value:
     * IC_DEFAULT_SDA_HOLD[15:0].
     */
    inline void set_IC_SDA_HOLD_IC_SDA_TX_HOLD(uint16_t value) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        IC_SDA_HOLD = curr;
    }

    /**
     * Get IC_SDA_HOLD's IC_SDA_RX_HOLD field.
     *
     * Sets the required SDA hold time in units of ic_clk period, when
     * DW_apb_i2c acts as a receiver.\n\n Reset value:
     * IC_DEFAULT_SDA_HOLD[23:16].
     */
    inline uint8_t get_IC_SDA_HOLD_IC_SDA_RX_HOLD() volatile
    {
        return (IC_SDA_HOLD >> 16u) & 0b11111111u;
    }

    /**
     * Set IC_SDA_HOLD's IC_SDA_RX_HOLD field.
     *
     * Sets the required SDA hold time in units of ic_clk period, when
     * DW_apb_i2c acts as a receiver.\n\n Reset value:
     * IC_DEFAULT_SDA_HOLD[23:16].
     */
    inline void set_IC_SDA_HOLD_IC_SDA_RX_HOLD(uint8_t value) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        curr &= ~(0b11111111u << 16u);
        curr |= (value & 0b11111111u) << 16u;

        IC_SDA_HOLD = curr;
    }

    /**
     * Get all of IC_SDA_HOLD's bit fields.
     *
     * (read-write) I2C SDA Hold Time Length Register\n\n
     *             The bits [15:0] of this register are used to control the
     * hold time of SDA during transmit in both slave and master mode (after
     * SCL goes from HIGH to LOW).\n\n The bits [23:16] of this register are
     * used to extend the SDA transition (if any) whenever SCL is HIGH in the
     * receiver in either master or slave mode.\n\n Writes to this register
     * succeed only when IC_ENABLE[0]=0.\n\n The values in this register are in
     * units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be
     * greater than the minimum hold time in each mode (one cycle in master
     * mode, seven cycles in slave mode) for the value to be implemented.\n\n
     *             The programmed SDA hold time during transmit
     * (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part
     * of scl. Therefore the programmed value cannot be larger than
     * N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl
     * period measured in ic_clk cycles.
     */
    inline void get_IC_SDA_HOLD(uint16_t &IC_SDA_TX_HOLD,
                                uint8_t &IC_SDA_RX_HOLD) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        IC_SDA_TX_HOLD = (curr >> 0u) & 0b1111111111111111u;
        IC_SDA_RX_HOLD = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Set all of IC_SDA_HOLD's bit fields.
     *
     * (read-write) I2C SDA Hold Time Length Register\n\n
     *             The bits [15:0] of this register are used to control the
     * hold time of SDA during transmit in both slave and master mode (after
     * SCL goes from HIGH to LOW).\n\n The bits [23:16] of this register are
     * used to extend the SDA transition (if any) whenever SCL is HIGH in the
     * receiver in either master or slave mode.\n\n Writes to this register
     * succeed only when IC_ENABLE[0]=0.\n\n The values in this register are in
     * units of ic_clk period. The value programmed in IC_SDA_TX_HOLD must be
     * greater than the minimum hold time in each mode (one cycle in master
     * mode, seven cycles in slave mode) for the value to be implemented.\n\n
     *             The programmed SDA hold time during transmit
     * (IC_SDA_TX_HOLD) cannot exceed at any time the duration of the low part
     * of scl. Therefore the programmed value cannot be larger than
     * N_SCL_LOW-2, where N_SCL_LOW is the duration of the low part of the scl
     * period measured in ic_clk cycles.
     */
    inline void set_IC_SDA_HOLD(uint16_t IC_SDA_TX_HOLD,
                                uint8_t IC_SDA_RX_HOLD) volatile
    {
        uint32_t curr = IC_SDA_HOLD;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (IC_SDA_TX_HOLD & 0b1111111111111111u) << 0u;
        curr &= ~(0b11111111u << 16u);
        curr |= (IC_SDA_RX_HOLD & 0b11111111u) << 16u;

        IC_SDA_HOLD = curr;
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_7B_ADDR_NOACK bit.
     *
     * This field indicates that the Master is in 7-bit addressing mode and the
     * address sent was not acknowledged by any slave.\n\n Reset value: 0x0\n\n
     *                 Role of DW_apb_i2c:  Master-Transmitter or
     * Master-Receiver
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK(IC_TX_ABRT_SOURCE &
                                                         (1u << 0u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_10ADDR1_NOACK bit.
     *
     * This field indicates that the Master is in 10-bit address mode and the
     * first 10-bit address byte was not acknowledged by any slave.\n\n Reset
     * value: 0x0\n\n Role of DW_apb_i2c:  Master-Transmitter or
     * Master-Receiver
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK(IC_TX_ABRT_SOURCE &
                                                         (1u << 1u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_10ADDR2_NOACK bit.
     *
     * This field indicates that the Master is in 10-bit address mode and that
     * the second address byte of the 10-bit address was not acknowledged by
     * any slave.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Master-Transmitter or Master-Receiver
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK(IC_TX_ABRT_SOURCE &
                                                         (1u << 2u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_TXDATA_NOACK bit.
     *
     * This field indicates the master-mode only bit. When the master receives
     * an acknowledgement for the address, but when it sends data byte(s)
     * following the address, it did not receive an acknowledge from the remote
     * slave(s).\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Master-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK(IC_TX_ABRT_SOURCE &
                                                        (1u << 3u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_GCALL_NOACK bit.
     *
     * This field indicates that DW_apb_i2c in master mode has sent a General
     * Call and no slave on the bus acknowledged the General Call.\n\n Reset
     * value: 0x0\n\n Role of DW_apb_i2c:  Master-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK
    get_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK(IC_TX_ABRT_SOURCE &
                                                       (1u << 4u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_GCALL_READ bit.
     *
     * This field indicates that DW_apb_i2c in the master mode has sent a
     * General Call but the user programmed the byte following the General Call
     * to be a read from the bus (IC_DATA_CMD[9] is set to 1).\n\n Reset value:
     * 0x0\n\n Role of DW_apb_i2c:  Master-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ
    get_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ(IC_TX_ABRT_SOURCE &
                                                      (1u << 5u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_HS_ACKDET bit.
     *
     * This field indicates that the Master is in High Speed mode and the High
     * Speed Master code was acknowledged (wrong behavior).\n\n Reset value:
     * 0x0\n\n Role of DW_apb_i2c:  Master
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET
    get_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET(IC_TX_ABRT_SOURCE &
                                                     (1u << 6u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SBYTE_ACKDET bit.
     *
     * This field indicates that the Master has sent a START Byte and the START
     * Byte was acknowledged (wrong behavior).\n\n Reset value: 0x0\n\n Role of
     * DW_apb_i2c:  Master
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET
    get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET(IC_TX_ABRT_SOURCE &
                                                        (1u << 7u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_HS_NORSTRT bit.
     *
     * This field indicates that the restart is disabled (IC_RESTART_EN bit
     * (IC_CON[5]) =0) and the user is trying to use the master to transfer
     * data in High Speed mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Master-Transmitter or Master-Receiver
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT
    get_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT(IC_TX_ABRT_SOURCE &
                                                      (1u << 8u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SBYTE_NORSTRT bit.
     *
     * To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed
     * first; restart must be enabled (IC_CON[5]=1), the SPECIAL bit must be
     * cleared (IC_TAR[11]), or the GC_OR_START bit must be cleared
     * (IC_TAR[10]). Once the source of the ABRT_SBYTE_NORSTRT is fixed, then
     * this bit can be cleared in the same manner as other bits in this
     * register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before
     * attempting to clear this bit, bit 9 clears for one cycle and then gets
     * reasserted. When this field is set to 1, the restart is disabled
     * (IC_RESTART_EN bit (IC_CON[5]) =0) and the user is trying to send a
     * START Byte.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:  Master
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT
    get_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT(IC_TX_ABRT_SOURCE &
                                                         (1u << 9u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_10B_RD_NORSTRT bit.
     *
     * This field indicates that the restart is disabled (IC_RESTART_EN bit
     * (IC_CON[5]) =0) and the master sends a read command in 10-bit addressing
     * mode.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:  Master-Receiver
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT
    get_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT(IC_TX_ABRT_SOURCE &
                                                          (1u << 10u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_MASTER_DIS bit.
     *
     * This field indicates that the User tries to initiate a Master operation
     * with the Master mode disabled.\n\n Reset value: 0x0\n\n Role of
     * DW_apb_i2c:  Master-Transmitter or Master-Receiver
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS
    get_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS(IC_TX_ABRT_SOURCE &
                                                      (1u << 11u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ARB_LOST bit.
     *
     * This field specifies that the Master has lost arbitration, or if
     * IC_TX_ABRT_SOURCE[14] is also set, then the slave transmitter has lost
     * arbitration.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Master-Transmitter or Slave-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ARB_LOST
    get_IC_TX_ABRT_SOURCE_ARB_LOST() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ARB_LOST(IC_TX_ABRT_SOURCE &
                                               (1u << 12u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SLVFLUSH_TXFIFO bit.
     *
     * This field specifies that the Slave has received a read command and some
     * data exists in the TX FIFO, so the slave issues a TX_ABRT interrupt to
     * flush old data in TX FIFO.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Slave-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO
    get_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO(IC_TX_ABRT_SOURCE &
                                                           (1u << 13u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SLV_ARBLOST bit.
     *
     * This field indicates that a Slave has lost the bus while transmitting
     * data to a remote master. IC_TX_ABRT_SOURCE[12] is set at the same time.
     * Note:  Even though the slave never 'owns' the bus, something could go
     * wrong on the bus. This is a fail safe check. For instance, during a data
     * transmission at the low-to-high transition of SCL, if what is on the
     * data bus is not what is supposed to be transmitted, then DW_apb_i2c no
     * longer own the bus.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Slave-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST
    get_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST(IC_TX_ABRT_SOURCE &
                                                       (1u << 14u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_SLVRD_INTX bit.
     *
     * 1: When the processor side responds to a slave mode request for data to
     * be transmitted to a remote master and user writes a 1 in CMD (bit 8) of
     * IC_DATA_CMD register.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Slave-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX
    get_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX(IC_TX_ABRT_SOURCE &
                                                      (1u << 15u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's ABRT_USER_ABRT bit.
     *
     * This is a master-mode-only bit. Master has detected the transfer abort
     * (IC_ENABLE[1])\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Master-Transmitter
     */
    inline I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT
    get_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT() volatile
    {
        return I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT(IC_TX_ABRT_SOURCE &
                                                     (1u << 16u));
    }

    /**
     * Get IC_TX_ABRT_SOURCE's TX_FLUSH_CNT field.
     *
     * This field indicates the number of Tx FIFO Data Commands which are
     * flushed due to TX_ABRT interrupt. It is cleared whenever I2C is
     * disabled.\n\n Reset value: 0x0\n\n Role of DW_apb_i2c:
     * Master-Transmitter or Slave-Transmitter
     */
    inline uint16_t get_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT() volatile
    {
        return (IC_TX_ABRT_SOURCE >> 23u) & 0b111111111u;
    }

    /**
     * Get all of IC_TX_ABRT_SOURCE's bit fields.
     *
     * (read-only) I2C Transmit Abort Source Register\n\n
     *             This register has 32 bits that indicate the source of the
     * TX_ABRT bit. Except for Bit 9, this register is cleared whenever the
     * IC_CLR_TX_ABRT register or the IC_CLR_INTR register is read. To clear
     * Bit 9, the source of the ABRT_SBYTE_NORSTRT must be fixed first; RESTART
     * must be enabled (IC_CON[5]=1), the SPECIAL bit must be cleared
     * (IC_TAR[11]), or the GC_OR_START bit must be cleared (IC_TAR[10]).\n\n
     *             Once the source of the ABRT_SBYTE_NORSTRT is fixed, then
     * this bit can be cleared in the same manner as other bits in this
     * register. If the source of the ABRT_SBYTE_NORSTRT is not fixed before
     * attempting to clear this bit, Bit 9 clears for one cycle and is then
     * re-asserted.
     */
    inline void get_IC_TX_ABRT_SOURCE(
        I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK &ABRT_7B_ADDR_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK &ABRT_10ADDR1_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK &ABRT_10ADDR2_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK &ABRT_TXDATA_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK &ABRT_GCALL_NOACK,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ &ABRT_GCALL_READ,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET &ABRT_HS_ACKDET,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET &ABRT_SBYTE_ACKDET,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT &ABRT_HS_NORSTRT,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT &ABRT_SBYTE_NORSTRT,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT &ABRT_10B_RD_NORSTRT,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS &ABRT_MASTER_DIS,
        I2C0_IC_TX_ABRT_SOURCE_ARB_LOST &ARB_LOST,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO &ABRT_SLVFLUSH_TXFIFO,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST &ABRT_SLV_ARBLOST,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX &ABRT_SLVRD_INTX,
        I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT &ABRT_USER_ABRT,
        uint16_t &TX_FLUSH_CNT) volatile
    {
        uint32_t curr = IC_TX_ABRT_SOURCE;

        ABRT_7B_ADDR_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK(curr & (1u << 0u));
        ABRT_10ADDR1_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK(curr & (1u << 1u));
        ABRT_10ADDR2_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK(curr & (1u << 2u));
        ABRT_TXDATA_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK(curr & (1u << 3u));
        ABRT_GCALL_NOACK =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK(curr & (1u << 4u));
        ABRT_GCALL_READ =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ(curr & (1u << 5u));
        ABRT_HS_ACKDET =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET(curr & (1u << 6u));
        ABRT_SBYTE_ACKDET =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET(curr & (1u << 7u));
        ABRT_HS_NORSTRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT(curr & (1u << 8u));
        ABRT_SBYTE_NORSTRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT(curr & (1u << 9u));
        ABRT_10B_RD_NORSTRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT(curr & (1u << 10u));
        ABRT_MASTER_DIS =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS(curr & (1u << 11u));
        ARB_LOST = I2C0_IC_TX_ABRT_SOURCE_ARB_LOST(curr & (1u << 12u));
        ABRT_SLVFLUSH_TXFIFO =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO(curr & (1u << 13u));
        ABRT_SLV_ARBLOST =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST(curr & (1u << 14u));
        ABRT_SLVRD_INTX =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX(curr & (1u << 15u));
        ABRT_USER_ABRT =
            I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT(curr & (1u << 16u));
        TX_FLUSH_CNT = (curr >> 23u) & 0b111111111u;
    }

    /**
     * Get IC_SLV_DATA_NACK_ONLY's NACK bit.
     *
     * Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
     * slave-receiver. If this register is set to a value of 1, it can only
     * generate a NACK after a data byte is received; hence, the data transfer
     * is aborted and the data received is not pushed to the receive
     * buffer.\n\n When the register is set to a value of 0, it generates
     * NACK/ACK, depending on normal criteria. - 1: generate NACK after data
     * byte received - 0: generate NACK/ACK normally Reset value: 0x0
     */
    inline I2C0_IC_SLV_DATA_NACK_ONLY_NACK
    get_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        return I2C0_IC_SLV_DATA_NACK_ONLY_NACK(IC_SLV_DATA_NACK_ONLY &
                                               (1u << 0u));
    }

    /**
     * Set IC_SLV_DATA_NACK_ONLY's NACK bit.
     *
     * Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
     * slave-receiver. If this register is set to a value of 1, it can only
     * generate a NACK after a data byte is received; hence, the data transfer
     * is aborted and the data received is not pushed to the receive
     * buffer.\n\n When the register is set to a value of 0, it generates
     * NACK/ACK, depending on normal criteria. - 1: generate NACK after data
     * byte received - 0: generate NACK/ACK normally Reset value: 0x0
     */
    inline void set_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        IC_SLV_DATA_NACK_ONLY |= 1u << 0u;
    }

    /**
     * Clear IC_SLV_DATA_NACK_ONLY's NACK bit.
     *
     * Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
     * slave-receiver. If this register is set to a value of 1, it can only
     * generate a NACK after a data byte is received; hence, the data transfer
     * is aborted and the data received is not pushed to the receive
     * buffer.\n\n When the register is set to a value of 0, it generates
     * NACK/ACK, depending on normal criteria. - 1: generate NACK after data
     * byte received - 0: generate NACK/ACK normally Reset value: 0x0
     */
    inline void clear_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        IC_SLV_DATA_NACK_ONLY &= ~(1u << 0u);
    }

    /**
     * Toggle IC_SLV_DATA_NACK_ONLY's NACK bit.
     *
     * Generate NACK. This NACK generation only occurs when DW_apb_i2c is a
     * slave-receiver. If this register is set to a value of 1, it can only
     * generate a NACK after a data byte is received; hence, the data transfer
     * is aborted and the data received is not pushed to the receive
     * buffer.\n\n When the register is set to a value of 0, it generates
     * NACK/ACK, depending on normal criteria. - 1: generate NACK after data
     * byte received - 0: generate NACK/ACK normally Reset value: 0x0
     */
    inline void toggle_IC_SLV_DATA_NACK_ONLY_NACK() volatile
    {
        IC_SLV_DATA_NACK_ONLY ^= 1u << 0u;
    }

    /**
     * Get IC_DMA_CR's RDMAE bit.
     *
     * Receive DMA Enable. This bit enables/disables the receive FIFO DMA
     * channel. Reset value: 0x0
     */
    inline I2C0_IC_DMA_CR_RDMAE get_IC_DMA_CR_RDMAE() volatile
    {
        return I2C0_IC_DMA_CR_RDMAE(IC_DMA_CR & (1u << 0u));
    }

    /**
     * Set IC_DMA_CR's RDMAE bit.
     *
     * Receive DMA Enable. This bit enables/disables the receive FIFO DMA
     * channel. Reset value: 0x0
     */
    inline void set_IC_DMA_CR_RDMAE() volatile
    {
        IC_DMA_CR |= 1u << 0u;
    }

    /**
     * Clear IC_DMA_CR's RDMAE bit.
     *
     * Receive DMA Enable. This bit enables/disables the receive FIFO DMA
     * channel. Reset value: 0x0
     */
    inline void clear_IC_DMA_CR_RDMAE() volatile
    {
        IC_DMA_CR &= ~(1u << 0u);
    }

    /**
     * Toggle IC_DMA_CR's RDMAE bit.
     *
     * Receive DMA Enable. This bit enables/disables the receive FIFO DMA
     * channel. Reset value: 0x0
     */
    inline void toggle_IC_DMA_CR_RDMAE() volatile
    {
        IC_DMA_CR ^= 1u << 0u;
    }

    /**
     * Get IC_DMA_CR's TDMAE bit.
     *
     * Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA
     * channel. Reset value: 0x0
     */
    inline I2C0_IC_DMA_CR_TDMAE get_IC_DMA_CR_TDMAE() volatile
    {
        return I2C0_IC_DMA_CR_TDMAE(IC_DMA_CR & (1u << 1u));
    }

    /**
     * Set IC_DMA_CR's TDMAE bit.
     *
     * Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA
     * channel. Reset value: 0x0
     */
    inline void set_IC_DMA_CR_TDMAE() volatile
    {
        IC_DMA_CR |= 1u << 1u;
    }

    /**
     * Clear IC_DMA_CR's TDMAE bit.
     *
     * Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA
     * channel. Reset value: 0x0
     */
    inline void clear_IC_DMA_CR_TDMAE() volatile
    {
        IC_DMA_CR &= ~(1u << 1u);
    }

    /**
     * Toggle IC_DMA_CR's TDMAE bit.
     *
     * Transmit DMA Enable. This bit enables/disables the transmit FIFO DMA
     * channel. Reset value: 0x0
     */
    inline void toggle_IC_DMA_CR_TDMAE() volatile
    {
        IC_DMA_CR ^= 1u << 1u;
    }

    /**
     * Get all of IC_DMA_CR's bit fields.
     *
     * (read-write) DMA Control Register\n\n
     *             The register is used to enable the DMA Controller interface
     * operation. There is a separate bit for transmit and receive. This can be
     * programmed regardless of the state of IC_ENABLE.
     */
    inline void get_IC_DMA_CR(I2C0_IC_DMA_CR_RDMAE &RDMAE,
                              I2C0_IC_DMA_CR_TDMAE &TDMAE) volatile
    {
        uint32_t curr = IC_DMA_CR;

        RDMAE = I2C0_IC_DMA_CR_RDMAE(curr & (1u << 0u));
        TDMAE = I2C0_IC_DMA_CR_TDMAE(curr & (1u << 1u));
    }

    /**
     * Set all of IC_DMA_CR's bit fields.
     *
     * (read-write) DMA Control Register\n\n
     *             The register is used to enable the DMA Controller interface
     * operation. There is a separate bit for transmit and receive. This can be
     * programmed regardless of the state of IC_ENABLE.
     */
    inline void set_IC_DMA_CR(I2C0_IC_DMA_CR_RDMAE RDMAE,
                              I2C0_IC_DMA_CR_TDMAE TDMAE) volatile
    {
        uint32_t curr = IC_DMA_CR;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(RDMAE) & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (std::to_underlying(TDMAE) & 0b1u) << 1u;

        IC_DMA_CR = curr;
    }

    /**
     * Get IC_DMA_TDLR's DMATDL field.
     *
     * Transmit Data Level. This bit field controls the level at which a DMA
     * request is made by the transmit logic. It is equal to the watermark
     * level; that is, the dma_tx_req signal is generated when the number of
     * valid data entries in the transmit FIFO is equal to or below this field
     * value, and TDMAE = 1.\n\n Reset value: 0x0
     */
    inline uint8_t get_IC_DMA_TDLR_DMATDL() volatile
    {
        return (IC_DMA_TDLR >> 0u) & 0b1111u;
    }

    /**
     * Set IC_DMA_TDLR's DMATDL field.
     *
     * Transmit Data Level. This bit field controls the level at which a DMA
     * request is made by the transmit logic. It is equal to the watermark
     * level; that is, the dma_tx_req signal is generated when the number of
     * valid data entries in the transmit FIFO is equal to or below this field
     * value, and TDMAE = 1.\n\n Reset value: 0x0
     */
    inline void set_IC_DMA_TDLR_DMATDL(uint8_t value) volatile
    {
        uint32_t curr = IC_DMA_TDLR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        IC_DMA_TDLR = curr;
    }

    /**
     * Get IC_DMA_RDLR's DMARDL field.
     *
     * Receive Data Level. This bit field controls the level at which a DMA
     * request is made by the receive logic. The watermark level = DMARDL+1;
     * that is, dma_rx_req is generated when the number of valid data entries
     * in the receive FIFO is equal to or more than this field value + 1, and
     * RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted
     * when 1 or more data entries are present in the receive FIFO.\n\n Reset
     * value: 0x0
     */
    inline uint8_t get_IC_DMA_RDLR_DMARDL() volatile
    {
        return (IC_DMA_RDLR >> 0u) & 0b1111u;
    }

    /**
     * Set IC_DMA_RDLR's DMARDL field.
     *
     * Receive Data Level. This bit field controls the level at which a DMA
     * request is made by the receive logic. The watermark level = DMARDL+1;
     * that is, dma_rx_req is generated when the number of valid data entries
     * in the receive FIFO is equal to or more than this field value + 1, and
     * RDMAE =1. For instance, when DMARDL is 0, then dma_rx_req is asserted
     * when 1 or more data entries are present in the receive FIFO.\n\n Reset
     * value: 0x0
     */
    inline void set_IC_DMA_RDLR_DMARDL(uint8_t value) volatile
    {
        uint32_t curr = IC_DMA_RDLR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        IC_DMA_RDLR = curr;
    }

    /**
     * Get IC_SDA_SETUP's SDA_SETUP field.
     *
     * SDA Setup. It is recommended that if the required delay is 1000ns, then
     * for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to
     * a value of 11. IC_SDA_SETUP must be programmed with a minimum value
     * of 2.
     */
    inline uint8_t get_IC_SDA_SETUP_SDA_SETUP() volatile
    {
        return (IC_SDA_SETUP >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_SDA_SETUP's SDA_SETUP field.
     *
     * SDA Setup. It is recommended that if the required delay is 1000ns, then
     * for an ic_clk frequency of 10 MHz, IC_SDA_SETUP should be programmed to
     * a value of 11. IC_SDA_SETUP must be programmed with a minimum value
     * of 2.
     */
    inline void set_IC_SDA_SETUP_SDA_SETUP(uint8_t value) volatile
    {
        uint32_t curr = IC_SDA_SETUP;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_SDA_SETUP = curr;
    }

    /**
     * Get IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     *
     * ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by
     * asserting ic_data_oe) when it receives a General Call. Otherwise,
     * DW_apb_i2c responds with a NACK (by negating ic_data_oe).
     */
    inline I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL
    get_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        return I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL(IC_ACK_GENERAL_CALL &
                                                     (1u << 0u));
    }

    /**
     * Set IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     *
     * ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by
     * asserting ic_data_oe) when it receives a General Call. Otherwise,
     * DW_apb_i2c responds with a NACK (by negating ic_data_oe).
     */
    inline void set_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        IC_ACK_GENERAL_CALL |= 1u << 0u;
    }

    /**
     * Clear IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     *
     * ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by
     * asserting ic_data_oe) when it receives a General Call. Otherwise,
     * DW_apb_i2c responds with a NACK (by negating ic_data_oe).
     */
    inline void clear_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        IC_ACK_GENERAL_CALL &= ~(1u << 0u);
    }

    /**
     * Toggle IC_ACK_GENERAL_CALL's ACK_GEN_CALL bit.
     *
     * ACK General Call. When set to 1, DW_apb_i2c responds with a ACK (by
     * asserting ic_data_oe) when it receives a General Call. Otherwise,
     * DW_apb_i2c responds with a NACK (by negating ic_data_oe).
     */
    inline void toggle_IC_ACK_GENERAL_CALL_ACK_GEN_CALL() volatile
    {
        IC_ACK_GENERAL_CALL ^= 1u << 0u;
    }

    /**
     * Get IC_ENABLE_STATUS's IC_EN bit.
     *
     * ic_en Status. This bit always reflects the value driven on the output
     * port ic_en. - When read as 1, DW_apb_i2c is deemed to be in an enabled
     * state. - When read as 0, DW_apb_i2c is deemed completely inactive. Note:
     * The CPU can safely read this bit anytime. When this bit is read as 0,
     * the CPU can safely read SLV_RX_DATA_LOST (bit 2) and
     * SLV_DISABLED_WHILE_BUSY (bit 1).\n\n Reset value: 0x0
     */
    inline I2C0_IC_ENABLE_STATUS_IC_EN get_IC_ENABLE_STATUS_IC_EN() volatile
    {
        return I2C0_IC_ENABLE_STATUS_IC_EN(IC_ENABLE_STATUS & (1u << 0u));
    }

    /**
     * Get IC_ENABLE_STATUS's SLV_DISABLED_WHILE_BUSY bit.
     *
     * Slave Disabled While Busy (Transmit, Receive). This bit indicates if a
     * potential or active Slave operation has been aborted due to the setting
     * bit 0 of the IC_ENABLE register from 1 to 0. This bit is set when the
     * CPU writes a 0 to the IC_ENABLE register while:\n\n (a) DW_apb_i2c is
     * receiving the address byte of the Slave-Transmitter operation from a
     * remote master;\n\n OR,\n\n (b) address and data bytes of the
     * Slave-Receiver operation from a remote master.\n\n When read as 1,
     * DW_apb_i2c is deemed to have forced a NACK during any part of an I2C
     * transfer, irrespective of whether the I2C address matches the slave
     * address set in DW_apb_i2c (IC_SAR register) OR if the transfer is
     * completed before IC_ENABLE is set to 0 but has not taken effect.\n\n
     *                 Note:  If the remote I2C master terminates the transfer
     * with a STOP condition before the DW_apb_i2c has a chance to NACK a
     * transfer, and IC_ENABLE[0] has been set to 0, then this bit will also be
     * set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been disabled
     * when there is master activity, or when the I2C bus is idle.\n\n Note:
     * The CPU can safely read this bit when IC_EN (bit 0) is read as 0.\n\n
     *                 Reset value: 0x0
     */
    inline I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY
    get_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY() volatile
    {
        return I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY(IC_ENABLE_STATUS &
                                                             (1u << 1u));
    }

    /**
     * Get IC_ENABLE_STATUS's SLV_RX_DATA_LOST bit.
     *
     * Slave Received Data Lost. This bit indicates if a Slave-Receiver
     * operation has been aborted with at least one data byte received from an
     * I2C transfer due to the setting bit 0 of IC_ENABLE from 1 to 0. When
     * read as 1, DW_apb_i2c is deemed to have been actively engaged in an
     * aborted I2C transfer (with matching address) and the data phase of the
     * I2C transfer has been entered, even though a data byte has been
     * responded with a NACK.\n\n Note:  If the remote I2C master terminates
     * the transfer with a STOP condition before the DW_apb_i2c has a chance to
     * NACK a transfer, and IC_ENABLE[0] has been set to 0, then this bit is
     * also set to 1.\n\n When read as 0, DW_apb_i2c is deemed to have been
     * disabled without being actively involved in the data phase of a
     * Slave-Receiver transfer.\n\n Note:  The CPU can safely read this bit
     * when IC_EN (bit 0) is read as 0.\n\n Reset value: 0x0
     */
    inline I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST
    get_IC_ENABLE_STATUS_SLV_RX_DATA_LOST() volatile
    {
        return I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST(IC_ENABLE_STATUS &
                                                      (1u << 2u));
    }

    /**
     * Get all of IC_ENABLE_STATUS's bit fields.
     *
     * (read-only) I2C Enable Status Register\n\n
     *             The register is used to report the DW_apb_i2c hardware
     * status when the IC_ENABLE[0] register is set from 1 to 0; that is, when
     * DW_apb_i2c is disabled.\n\n If IC_ENABLE[0] has been set to 1, bits 2:1
     * are forced to 0, and bit 0 is forced to 1.\n\n If IC_ENABLE[0] has been
     * set to 0, bits 2:1 is only be valid as soon as bit 0 is read as '0'.\n\n
     *             Note: When IC_ENABLE[0] has been set to 0, a delay occurs
     * for bit 0 to be read as 0 because disabling the DW_apb_i2c depends on
     * I2C bus activities.
     */
    inline void get_IC_ENABLE_STATUS(
        I2C0_IC_ENABLE_STATUS_IC_EN &IC_EN,
        I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY &SLV_DISABLED_WHILE_BUSY,
        I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST &SLV_RX_DATA_LOST) volatile
    {
        uint32_t curr = IC_ENABLE_STATUS;

        IC_EN = I2C0_IC_ENABLE_STATUS_IC_EN(curr & (1u << 0u));
        SLV_DISABLED_WHILE_BUSY =
            I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY(curr & (1u << 1u));
        SLV_RX_DATA_LOST =
            I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST(curr & (1u << 2u));
    }

    /**
     * Get IC_FS_SPKLEN's IC_FS_SPKLEN field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure stable operation. This register sets the duration, measured in
     * ic_clk cycles, of the longest spike in the SCL or SDA lines that will be
     * filtered out by the spike suppression logic. This register can be
     * written only when the I2C interface is disabled which corresponds to the
     * IC_ENABLE[0] register being set to 0. Writes at other times have no
     * effect. The minimum valid value is 1; hardware prevents values less than
     * this being written, and if attempted results in 1 being set. or more
     * information, refer to 'Spike Suppression'.
     */
    inline uint8_t get_IC_FS_SPKLEN_IC_FS_SPKLEN() volatile
    {
        return (IC_FS_SPKLEN >> 0u) & 0b11111111u;
    }

    /**
     * Set IC_FS_SPKLEN's IC_FS_SPKLEN field.
     *
     * This register must be set before any I2C bus transaction can take place
     * to ensure stable operation. This register sets the duration, measured in
     * ic_clk cycles, of the longest spike in the SCL or SDA lines that will be
     * filtered out by the spike suppression logic. This register can be
     * written only when the I2C interface is disabled which corresponds to the
     * IC_ENABLE[0] register being set to 0. Writes at other times have no
     * effect. The minimum valid value is 1; hardware prevents values less than
     * this being written, and if attempted results in 1 being set. or more
     * information, refer to 'Spike Suppression'.
     */
    inline void set_IC_FS_SPKLEN_IC_FS_SPKLEN(uint8_t value) volatile
    {
        uint32_t curr = IC_FS_SPKLEN;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        IC_FS_SPKLEN = curr;
    }

    /**
     * Get IC_CLR_RESTART_DET's CLR_RESTART_DET bit.
     *
     * Read this register to clear the RESTART_DET interrupt (bit 12) of
     * IC_RAW_INTR_STAT register.\n\n Reset value: 0x0
     */
    inline bool get_IC_CLR_RESTART_DET_CLR_RESTART_DET() volatile
    {
        return IC_CLR_RESTART_DET & (1u << 0u);
    }

    /**
     * Get IC_COMP_PARAM_1's APB_DATA_WIDTH field.
     *
     * APB data bus width is 32 bits
     */
    inline uint8_t get_IC_COMP_PARAM_1_APB_DATA_WIDTH() volatile
    {
        return (IC_COMP_PARAM_1 >> 0u) & 0b11u;
    }

    /**
     * Get IC_COMP_PARAM_1's MAX_SPEED_MODE field.
     *
     * MAX SPEED MODE = FAST MODE
     */
    inline uint8_t get_IC_COMP_PARAM_1_MAX_SPEED_MODE() volatile
    {
        return (IC_COMP_PARAM_1 >> 2u) & 0b11u;
    }

    /**
     * Get IC_COMP_PARAM_1's HC_COUNT_VALUES bit.
     *
     * Programmable count values for each mode.
     */
    inline bool get_IC_COMP_PARAM_1_HC_COUNT_VALUES() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 4u);
    }

    /**
     * Get IC_COMP_PARAM_1's INTR_IO bit.
     *
     * COMBINED Interrupt outputs
     */
    inline bool get_IC_COMP_PARAM_1_INTR_IO() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 5u);
    }

    /**
     * Get IC_COMP_PARAM_1's HAS_DMA bit.
     *
     * DMA handshaking signals are enabled
     */
    inline bool get_IC_COMP_PARAM_1_HAS_DMA() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 6u);
    }

    /**
     * Get IC_COMP_PARAM_1's ADD_ENCODED_PARAMS bit.
     *
     * Encoded parameters not visible
     */
    inline bool get_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS() volatile
    {
        return IC_COMP_PARAM_1 & (1u << 7u);
    }

    /**
     * Get IC_COMP_PARAM_1's RX_BUFFER_DEPTH field.
     *
     * RX Buffer Depth = 16
     */
    inline uint8_t get_IC_COMP_PARAM_1_RX_BUFFER_DEPTH() volatile
    {
        return (IC_COMP_PARAM_1 >> 8u) & 0b11111111u;
    }

    /**
     * Get IC_COMP_PARAM_1's TX_BUFFER_DEPTH field.
     *
     * TX Buffer Depth = 16
     */
    inline uint8_t get_IC_COMP_PARAM_1_TX_BUFFER_DEPTH() volatile
    {
        return (IC_COMP_PARAM_1 >> 16u) & 0b11111111u;
    }

    /**
     * Get all of IC_COMP_PARAM_1's bit fields.
     *
     * (read-only) Component Parameter Register 1\n\n
     *             Note This register is not implemented and therefore reads as
     * 0. If it was implemented it would be a constant read-only register that
     * contains encoded information about the component's parameter settings.
     * Fields shown below are the settings for those parameters
     */
    inline void get_IC_COMP_PARAM_1(uint8_t &APB_DATA_WIDTH,
                                    uint8_t &MAX_SPEED_MODE,
                                    bool &HC_COUNT_VALUES, bool &INTR_IO,
                                    bool &HAS_DMA, bool &ADD_ENCODED_PARAMS,
                                    uint8_t &RX_BUFFER_DEPTH,
                                    uint8_t &TX_BUFFER_DEPTH) volatile
    {
        uint32_t curr = IC_COMP_PARAM_1;

        APB_DATA_WIDTH = (curr >> 0u) & 0b11u;
        MAX_SPEED_MODE = (curr >> 2u) & 0b11u;
        HC_COUNT_VALUES = curr & (1u << 4u);
        INTR_IO = curr & (1u << 5u);
        HAS_DMA = curr & (1u << 6u);
        ADD_ENCODED_PARAMS = curr & (1u << 7u);
        RX_BUFFER_DEPTH = (curr >> 8u) & 0b11111111u;
        TX_BUFFER_DEPTH = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Get IC_COMP_VERSION's IC_COMP_VERSION field.
     */
    inline uint32_t get_IC_COMP_VERSION_IC_COMP_VERSION() volatile
    {
        return (IC_COMP_VERSION >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Get IC_COMP_TYPE's IC_COMP_TYPE field.
     *
     * Designware Component Type number = 0x44_57_01_40. This assigned unique
     * hex value is constant and is derived from the two ASCII letters 'DW'
     * followed by a 16-bit unsigned number.
     */
    inline uint32_t get_IC_COMP_TYPE_IC_COMP_TYPE() volatile
    {
        return (IC_COMP_TYPE >> 0u) & 0b11111111111111111111111111111111u;
    }
};

static_assert(sizeof(i2c0) == i2c0::size);

static volatile i2c0 *const I2C0 = reinterpret_cast<i2c0 *>(0x40044000);

static volatile i2c0 *const I2C1 = reinterpret_cast<i2c0 *>(0x40048000);

}; // namespace RP2040
