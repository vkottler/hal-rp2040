/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../enums/PWM_CH0_CSR_DIVMODE.h"
#include "../enums/PWM_CH1_CSR_DIVMODE.h"
#include "../enums/PWM_CH2_CSR_DIVMODE.h"
#include "../enums/PWM_CH3_CSR_DIVMODE.h"
#include "../enums/PWM_CH4_CSR_DIVMODE.h"
#include "../enums/PWM_CH5_CSR_DIVMODE.h"
#include "../enums/PWM_CH6_CSR_DIVMODE.h"
#include "../enums/PWM_CH7_CSR_DIVMODE.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * Simple PWM
 */
struct [[gnu::packed]] pwm
{
    /* Constant attributes. */
    static constexpr std::size_t size = 180; /*!< pwm's size in bytes. */

    /* Fields. */
    uint32_t CH0_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH0_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH0_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH0_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH0_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH1_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH1_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH1_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH1_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH1_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH2_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH2_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH2_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH2_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH2_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH3_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH3_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH3_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH3_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH3_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH4_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH4_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH4_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH4_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH4_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH5_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH5_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH5_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH5_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH5_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH6_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH6_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH6_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH6_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH6_TOP; /*!< (read-write) Counter wrap value */
    uint32_t CH7_CSR; /*!< (read-write) Control and status register */
    uint32_t
        CH7_DIV; /*!< (read-write) INT and FRAC form a fixed-point fractional
   number.\n Counting rate is system clock frequency divided by this number.\n
   Fractional division uses simple 1st-order sigma-delta. */
    uint32_t CH7_CTR; /*!< (read-write) Direct access to the PWM counter */
    uint32_t CH7_CC;  /*!< (read-write) Counter compare values */
    uint32_t CH7_TOP; /*!< (read-write) Counter wrap value */
    uint32_t EN;   /*!< (read-write) This register aliases the CSR_EN bits for
       all   channels.\n Writing to this register allows multiple channels to be
       enabled\n   or disabled simultaneously, so they can run in perfect sync.\n
       For each channel, there is only one physical EN register bit,\n
       which can be accessed through here or CHx_CSR. */
    uint32_t INTR; /*!< (read-write) Raw Interrupts */
    uint32_t INTE; /*!< (read-write) Interrupt Enable */
    uint32_t INTF; /*!< (read-write) Interrupt Force */
    const uint32_t INTS =
        {}; /*!< (read-only) Interrupt status after masking & forcing */

    /* Methods. */

    /**
     * Get CH0_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH0_CSR_EN() volatile
    {
        return CH0_CSR & (1u << 0u);
    }

    /**
     * Set CH0_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH0_CSR_EN() volatile
    {
        CH0_CSR |= 1u << 0u;
    }

    /**
     * Clear CH0_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH0_CSR_EN() volatile
    {
        CH0_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH0_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH0_CSR_EN() volatile
    {
        CH0_CSR ^= 1u << 0u;
    }

    /**
     * Get CH0_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH0_CSR_PH_CORRECT() volatile
    {
        return CH0_CSR & (1u << 1u);
    }

    /**
     * Set CH0_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH0_CSR_PH_CORRECT() volatile
    {
        CH0_CSR |= 1u << 1u;
    }

    /**
     * Clear CH0_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH0_CSR_PH_CORRECT() volatile
    {
        CH0_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH0_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH0_CSR_PH_CORRECT() volatile
    {
        CH0_CSR ^= 1u << 1u;
    }

    /**
     * Get CH0_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH0_CSR_A_INV() volatile
    {
        return CH0_CSR & (1u << 2u);
    }

    /**
     * Set CH0_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH0_CSR_A_INV() volatile
    {
        CH0_CSR |= 1u << 2u;
    }

    /**
     * Clear CH0_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH0_CSR_A_INV() volatile
    {
        CH0_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH0_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH0_CSR_A_INV() volatile
    {
        CH0_CSR ^= 1u << 2u;
    }

    /**
     * Get CH0_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH0_CSR_B_INV() volatile
    {
        return CH0_CSR & (1u << 3u);
    }

    /**
     * Set CH0_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH0_CSR_B_INV() volatile
    {
        CH0_CSR |= 1u << 3u;
    }

    /**
     * Clear CH0_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH0_CSR_B_INV() volatile
    {
        CH0_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH0_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH0_CSR_B_INV() volatile
    {
        CH0_CSR ^= 1u << 3u;
    }

    /**
     * Get CH0_CSR's DIVMODE field.
     */
    inline PWM_CH0_CSR_DIVMODE get_CH0_CSR_DIVMODE() volatile
    {
        return PWM_CH0_CSR_DIVMODE((CH0_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH0_CSR's DIVMODE field.
     */
    inline void set_CH0_CSR_DIVMODE(PWM_CH0_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH0_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH0_CSR = curr;
    }

    /**
     * Get CH0_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH0_CSR_PH_RET() volatile
    {
        return CH0_CSR & (1u << 6u);
    }

    /**
     * Set CH0_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH0_CSR_PH_RET() volatile
    {
        CH0_CSR |= 1u << 6u;
    }

    /**
     * Clear CH0_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH0_CSR_PH_RET() volatile
    {
        CH0_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH0_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH0_CSR_PH_RET() volatile
    {
        CH0_CSR ^= 1u << 6u;
    }

    /**
     * Get CH0_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH0_CSR_PH_ADV() volatile
    {
        return CH0_CSR & (1u << 7u);
    }

    /**
     * Set CH0_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH0_CSR_PH_ADV() volatile
    {
        CH0_CSR |= 1u << 7u;
    }

    /**
     * Clear CH0_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH0_CSR_PH_ADV() volatile
    {
        CH0_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH0_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH0_CSR_PH_ADV() volatile
    {
        CH0_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH0_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH0_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH0_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH0_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH0_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH0_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH0_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH0_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH0_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH0_CSR = curr;
    }

    /**
     * Get CH0_DIV's FRAC field.
     */
    inline uint8_t get_CH0_DIV_FRAC() volatile
    {
        return (CH0_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH0_DIV's FRAC field.
     */
    inline void set_CH0_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH0_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH0_DIV = curr;
    }

    /**
     * Get CH0_DIV's INT field.
     */
    inline uint8_t get_CH0_DIV_INT() volatile
    {
        return (CH0_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH0_DIV's INT field.
     */
    inline void set_CH0_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH0_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH0_DIV = curr;
    }

    /**
     * Get all of CH0_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH0_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH0_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH0_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH0_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH0_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH0_DIV = curr;
    }

    /**
     * Get CH0_CTR's CH0_CTR field.
     */
    inline uint16_t get_CH0_CTR_CH0_CTR() volatile
    {
        return (CH0_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH0_CTR's CH0_CTR field.
     */
    inline void set_CH0_CTR_CH0_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH0_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH0_CTR = curr;
    }

    /**
     * Get CH0_CC's A field.
     */
    inline uint16_t get_CH0_CC_A() volatile
    {
        return (CH0_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH0_CC's A field.
     */
    inline void set_CH0_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH0_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH0_CC = curr;
    }

    /**
     * Get CH0_CC's B field.
     */
    inline uint16_t get_CH0_CC_B() volatile
    {
        return (CH0_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH0_CC's B field.
     */
    inline void set_CH0_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH0_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH0_CC = curr;
    }

    /**
     * Get all of CH0_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH0_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH0_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH0_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH0_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH0_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH0_CC = curr;
    }

    /**
     * Get CH0_TOP's CH0_TOP field.
     */
    inline uint16_t get_CH0_TOP_CH0_TOP() volatile
    {
        return (CH0_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH0_TOP's CH0_TOP field.
     */
    inline void set_CH0_TOP_CH0_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH0_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH0_TOP = curr;
    }

    /**
     * Get CH1_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH1_CSR_EN() volatile
    {
        return CH1_CSR & (1u << 0u);
    }

    /**
     * Set CH1_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH1_CSR_EN() volatile
    {
        CH1_CSR |= 1u << 0u;
    }

    /**
     * Clear CH1_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH1_CSR_EN() volatile
    {
        CH1_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH1_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH1_CSR_EN() volatile
    {
        CH1_CSR ^= 1u << 0u;
    }

    /**
     * Get CH1_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH1_CSR_PH_CORRECT() volatile
    {
        return CH1_CSR & (1u << 1u);
    }

    /**
     * Set CH1_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH1_CSR_PH_CORRECT() volatile
    {
        CH1_CSR |= 1u << 1u;
    }

    /**
     * Clear CH1_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH1_CSR_PH_CORRECT() volatile
    {
        CH1_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH1_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH1_CSR_PH_CORRECT() volatile
    {
        CH1_CSR ^= 1u << 1u;
    }

    /**
     * Get CH1_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH1_CSR_A_INV() volatile
    {
        return CH1_CSR & (1u << 2u);
    }

    /**
     * Set CH1_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH1_CSR_A_INV() volatile
    {
        CH1_CSR |= 1u << 2u;
    }

    /**
     * Clear CH1_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH1_CSR_A_INV() volatile
    {
        CH1_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH1_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH1_CSR_A_INV() volatile
    {
        CH1_CSR ^= 1u << 2u;
    }

    /**
     * Get CH1_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH1_CSR_B_INV() volatile
    {
        return CH1_CSR & (1u << 3u);
    }

    /**
     * Set CH1_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH1_CSR_B_INV() volatile
    {
        CH1_CSR |= 1u << 3u;
    }

    /**
     * Clear CH1_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH1_CSR_B_INV() volatile
    {
        CH1_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH1_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH1_CSR_B_INV() volatile
    {
        CH1_CSR ^= 1u << 3u;
    }

    /**
     * Get CH1_CSR's DIVMODE field.
     */
    inline PWM_CH1_CSR_DIVMODE get_CH1_CSR_DIVMODE() volatile
    {
        return PWM_CH1_CSR_DIVMODE((CH1_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH1_CSR's DIVMODE field.
     */
    inline void set_CH1_CSR_DIVMODE(PWM_CH1_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH1_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH1_CSR = curr;
    }

    /**
     * Get CH1_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH1_CSR_PH_RET() volatile
    {
        return CH1_CSR & (1u << 6u);
    }

    /**
     * Set CH1_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH1_CSR_PH_RET() volatile
    {
        CH1_CSR |= 1u << 6u;
    }

    /**
     * Clear CH1_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH1_CSR_PH_RET() volatile
    {
        CH1_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH1_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH1_CSR_PH_RET() volatile
    {
        CH1_CSR ^= 1u << 6u;
    }

    /**
     * Get CH1_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH1_CSR_PH_ADV() volatile
    {
        return CH1_CSR & (1u << 7u);
    }

    /**
     * Set CH1_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH1_CSR_PH_ADV() volatile
    {
        CH1_CSR |= 1u << 7u;
    }

    /**
     * Clear CH1_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH1_CSR_PH_ADV() volatile
    {
        CH1_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH1_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH1_CSR_PH_ADV() volatile
    {
        CH1_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH1_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH1_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH1_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH1_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH1_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH1_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH1_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH1_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH1_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH1_CSR = curr;
    }

    /**
     * Get CH1_DIV's FRAC field.
     */
    inline uint8_t get_CH1_DIV_FRAC() volatile
    {
        return (CH1_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH1_DIV's FRAC field.
     */
    inline void set_CH1_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH1_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH1_DIV = curr;
    }

    /**
     * Get CH1_DIV's INT field.
     */
    inline uint8_t get_CH1_DIV_INT() volatile
    {
        return (CH1_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH1_DIV's INT field.
     */
    inline void set_CH1_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH1_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH1_DIV = curr;
    }

    /**
     * Get all of CH1_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH1_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH1_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH1_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH1_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH1_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH1_DIV = curr;
    }

    /**
     * Get CH1_CTR's CH1_CTR field.
     */
    inline uint16_t get_CH1_CTR_CH1_CTR() volatile
    {
        return (CH1_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH1_CTR's CH1_CTR field.
     */
    inline void set_CH1_CTR_CH1_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH1_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH1_CTR = curr;
    }

    /**
     * Get CH1_CC's A field.
     */
    inline uint16_t get_CH1_CC_A() volatile
    {
        return (CH1_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH1_CC's A field.
     */
    inline void set_CH1_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH1_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH1_CC = curr;
    }

    /**
     * Get CH1_CC's B field.
     */
    inline uint16_t get_CH1_CC_B() volatile
    {
        return (CH1_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH1_CC's B field.
     */
    inline void set_CH1_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH1_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH1_CC = curr;
    }

    /**
     * Get all of CH1_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH1_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH1_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH1_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH1_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH1_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH1_CC = curr;
    }

    /**
     * Get CH1_TOP's CH1_TOP field.
     */
    inline uint16_t get_CH1_TOP_CH1_TOP() volatile
    {
        return (CH1_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH1_TOP's CH1_TOP field.
     */
    inline void set_CH1_TOP_CH1_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH1_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH1_TOP = curr;
    }

    /**
     * Get CH2_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH2_CSR_EN() volatile
    {
        return CH2_CSR & (1u << 0u);
    }

    /**
     * Set CH2_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH2_CSR_EN() volatile
    {
        CH2_CSR |= 1u << 0u;
    }

    /**
     * Clear CH2_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH2_CSR_EN() volatile
    {
        CH2_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH2_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH2_CSR_EN() volatile
    {
        CH2_CSR ^= 1u << 0u;
    }

    /**
     * Get CH2_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH2_CSR_PH_CORRECT() volatile
    {
        return CH2_CSR & (1u << 1u);
    }

    /**
     * Set CH2_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH2_CSR_PH_CORRECT() volatile
    {
        CH2_CSR |= 1u << 1u;
    }

    /**
     * Clear CH2_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH2_CSR_PH_CORRECT() volatile
    {
        CH2_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH2_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH2_CSR_PH_CORRECT() volatile
    {
        CH2_CSR ^= 1u << 1u;
    }

    /**
     * Get CH2_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH2_CSR_A_INV() volatile
    {
        return CH2_CSR & (1u << 2u);
    }

    /**
     * Set CH2_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH2_CSR_A_INV() volatile
    {
        CH2_CSR |= 1u << 2u;
    }

    /**
     * Clear CH2_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH2_CSR_A_INV() volatile
    {
        CH2_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH2_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH2_CSR_A_INV() volatile
    {
        CH2_CSR ^= 1u << 2u;
    }

    /**
     * Get CH2_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH2_CSR_B_INV() volatile
    {
        return CH2_CSR & (1u << 3u);
    }

    /**
     * Set CH2_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH2_CSR_B_INV() volatile
    {
        CH2_CSR |= 1u << 3u;
    }

    /**
     * Clear CH2_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH2_CSR_B_INV() volatile
    {
        CH2_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH2_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH2_CSR_B_INV() volatile
    {
        CH2_CSR ^= 1u << 3u;
    }

    /**
     * Get CH2_CSR's DIVMODE field.
     */
    inline PWM_CH2_CSR_DIVMODE get_CH2_CSR_DIVMODE() volatile
    {
        return PWM_CH2_CSR_DIVMODE((CH2_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH2_CSR's DIVMODE field.
     */
    inline void set_CH2_CSR_DIVMODE(PWM_CH2_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH2_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH2_CSR = curr;
    }

    /**
     * Get CH2_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH2_CSR_PH_RET() volatile
    {
        return CH2_CSR & (1u << 6u);
    }

    /**
     * Set CH2_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH2_CSR_PH_RET() volatile
    {
        CH2_CSR |= 1u << 6u;
    }

    /**
     * Clear CH2_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH2_CSR_PH_RET() volatile
    {
        CH2_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH2_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH2_CSR_PH_RET() volatile
    {
        CH2_CSR ^= 1u << 6u;
    }

    /**
     * Get CH2_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH2_CSR_PH_ADV() volatile
    {
        return CH2_CSR & (1u << 7u);
    }

    /**
     * Set CH2_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH2_CSR_PH_ADV() volatile
    {
        CH2_CSR |= 1u << 7u;
    }

    /**
     * Clear CH2_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH2_CSR_PH_ADV() volatile
    {
        CH2_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH2_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH2_CSR_PH_ADV() volatile
    {
        CH2_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH2_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH2_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH2_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH2_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH2_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH2_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH2_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH2_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH2_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH2_CSR = curr;
    }

    /**
     * Get CH2_DIV's FRAC field.
     */
    inline uint8_t get_CH2_DIV_FRAC() volatile
    {
        return (CH2_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH2_DIV's FRAC field.
     */
    inline void set_CH2_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH2_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH2_DIV = curr;
    }

    /**
     * Get CH2_DIV's INT field.
     */
    inline uint8_t get_CH2_DIV_INT() volatile
    {
        return (CH2_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH2_DIV's INT field.
     */
    inline void set_CH2_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH2_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH2_DIV = curr;
    }

    /**
     * Get all of CH2_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH2_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH2_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH2_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH2_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH2_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH2_DIV = curr;
    }

    /**
     * Get CH2_CTR's CH2_CTR field.
     */
    inline uint16_t get_CH2_CTR_CH2_CTR() volatile
    {
        return (CH2_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH2_CTR's CH2_CTR field.
     */
    inline void set_CH2_CTR_CH2_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH2_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH2_CTR = curr;
    }

    /**
     * Get CH2_CC's A field.
     */
    inline uint16_t get_CH2_CC_A() volatile
    {
        return (CH2_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH2_CC's A field.
     */
    inline void set_CH2_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH2_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH2_CC = curr;
    }

    /**
     * Get CH2_CC's B field.
     */
    inline uint16_t get_CH2_CC_B() volatile
    {
        return (CH2_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH2_CC's B field.
     */
    inline void set_CH2_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH2_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH2_CC = curr;
    }

    /**
     * Get all of CH2_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH2_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH2_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH2_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH2_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH2_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH2_CC = curr;
    }

    /**
     * Get CH2_TOP's CH2_TOP field.
     */
    inline uint16_t get_CH2_TOP_CH2_TOP() volatile
    {
        return (CH2_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH2_TOP's CH2_TOP field.
     */
    inline void set_CH2_TOP_CH2_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH2_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH2_TOP = curr;
    }

    /**
     * Get CH3_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH3_CSR_EN() volatile
    {
        return CH3_CSR & (1u << 0u);
    }

    /**
     * Set CH3_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH3_CSR_EN() volatile
    {
        CH3_CSR |= 1u << 0u;
    }

    /**
     * Clear CH3_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH3_CSR_EN() volatile
    {
        CH3_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH3_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH3_CSR_EN() volatile
    {
        CH3_CSR ^= 1u << 0u;
    }

    /**
     * Get CH3_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH3_CSR_PH_CORRECT() volatile
    {
        return CH3_CSR & (1u << 1u);
    }

    /**
     * Set CH3_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH3_CSR_PH_CORRECT() volatile
    {
        CH3_CSR |= 1u << 1u;
    }

    /**
     * Clear CH3_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH3_CSR_PH_CORRECT() volatile
    {
        CH3_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH3_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH3_CSR_PH_CORRECT() volatile
    {
        CH3_CSR ^= 1u << 1u;
    }

    /**
     * Get CH3_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH3_CSR_A_INV() volatile
    {
        return CH3_CSR & (1u << 2u);
    }

    /**
     * Set CH3_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH3_CSR_A_INV() volatile
    {
        CH3_CSR |= 1u << 2u;
    }

    /**
     * Clear CH3_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH3_CSR_A_INV() volatile
    {
        CH3_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH3_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH3_CSR_A_INV() volatile
    {
        CH3_CSR ^= 1u << 2u;
    }

    /**
     * Get CH3_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH3_CSR_B_INV() volatile
    {
        return CH3_CSR & (1u << 3u);
    }

    /**
     * Set CH3_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH3_CSR_B_INV() volatile
    {
        CH3_CSR |= 1u << 3u;
    }

    /**
     * Clear CH3_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH3_CSR_B_INV() volatile
    {
        CH3_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH3_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH3_CSR_B_INV() volatile
    {
        CH3_CSR ^= 1u << 3u;
    }

    /**
     * Get CH3_CSR's DIVMODE field.
     */
    inline PWM_CH3_CSR_DIVMODE get_CH3_CSR_DIVMODE() volatile
    {
        return PWM_CH3_CSR_DIVMODE((CH3_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH3_CSR's DIVMODE field.
     */
    inline void set_CH3_CSR_DIVMODE(PWM_CH3_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH3_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH3_CSR = curr;
    }

    /**
     * Get CH3_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH3_CSR_PH_RET() volatile
    {
        return CH3_CSR & (1u << 6u);
    }

    /**
     * Set CH3_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH3_CSR_PH_RET() volatile
    {
        CH3_CSR |= 1u << 6u;
    }

    /**
     * Clear CH3_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH3_CSR_PH_RET() volatile
    {
        CH3_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH3_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH3_CSR_PH_RET() volatile
    {
        CH3_CSR ^= 1u << 6u;
    }

    /**
     * Get CH3_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH3_CSR_PH_ADV() volatile
    {
        return CH3_CSR & (1u << 7u);
    }

    /**
     * Set CH3_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH3_CSR_PH_ADV() volatile
    {
        CH3_CSR |= 1u << 7u;
    }

    /**
     * Clear CH3_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH3_CSR_PH_ADV() volatile
    {
        CH3_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH3_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH3_CSR_PH_ADV() volatile
    {
        CH3_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH3_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH3_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH3_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH3_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH3_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH3_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH3_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH3_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH3_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH3_CSR = curr;
    }

    /**
     * Get CH3_DIV's FRAC field.
     */
    inline uint8_t get_CH3_DIV_FRAC() volatile
    {
        return (CH3_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH3_DIV's FRAC field.
     */
    inline void set_CH3_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH3_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH3_DIV = curr;
    }

    /**
     * Get CH3_DIV's INT field.
     */
    inline uint8_t get_CH3_DIV_INT() volatile
    {
        return (CH3_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH3_DIV's INT field.
     */
    inline void set_CH3_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH3_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH3_DIV = curr;
    }

    /**
     * Get all of CH3_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH3_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH3_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH3_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH3_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH3_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH3_DIV = curr;
    }

    /**
     * Get CH3_CTR's CH3_CTR field.
     */
    inline uint16_t get_CH3_CTR_CH3_CTR() volatile
    {
        return (CH3_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH3_CTR's CH3_CTR field.
     */
    inline void set_CH3_CTR_CH3_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH3_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH3_CTR = curr;
    }

    /**
     * Get CH3_CC's A field.
     */
    inline uint16_t get_CH3_CC_A() volatile
    {
        return (CH3_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH3_CC's A field.
     */
    inline void set_CH3_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH3_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH3_CC = curr;
    }

    /**
     * Get CH3_CC's B field.
     */
    inline uint16_t get_CH3_CC_B() volatile
    {
        return (CH3_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH3_CC's B field.
     */
    inline void set_CH3_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH3_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH3_CC = curr;
    }

    /**
     * Get all of CH3_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH3_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH3_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH3_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH3_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH3_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH3_CC = curr;
    }

    /**
     * Get CH3_TOP's CH3_TOP field.
     */
    inline uint16_t get_CH3_TOP_CH3_TOP() volatile
    {
        return (CH3_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH3_TOP's CH3_TOP field.
     */
    inline void set_CH3_TOP_CH3_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH3_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH3_TOP = curr;
    }

    /**
     * Get CH4_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH4_CSR_EN() volatile
    {
        return CH4_CSR & (1u << 0u);
    }

    /**
     * Set CH4_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH4_CSR_EN() volatile
    {
        CH4_CSR |= 1u << 0u;
    }

    /**
     * Clear CH4_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH4_CSR_EN() volatile
    {
        CH4_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH4_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH4_CSR_EN() volatile
    {
        CH4_CSR ^= 1u << 0u;
    }

    /**
     * Get CH4_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH4_CSR_PH_CORRECT() volatile
    {
        return CH4_CSR & (1u << 1u);
    }

    /**
     * Set CH4_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH4_CSR_PH_CORRECT() volatile
    {
        CH4_CSR |= 1u << 1u;
    }

    /**
     * Clear CH4_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH4_CSR_PH_CORRECT() volatile
    {
        CH4_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH4_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH4_CSR_PH_CORRECT() volatile
    {
        CH4_CSR ^= 1u << 1u;
    }

    /**
     * Get CH4_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH4_CSR_A_INV() volatile
    {
        return CH4_CSR & (1u << 2u);
    }

    /**
     * Set CH4_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH4_CSR_A_INV() volatile
    {
        CH4_CSR |= 1u << 2u;
    }

    /**
     * Clear CH4_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH4_CSR_A_INV() volatile
    {
        CH4_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH4_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH4_CSR_A_INV() volatile
    {
        CH4_CSR ^= 1u << 2u;
    }

    /**
     * Get CH4_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH4_CSR_B_INV() volatile
    {
        return CH4_CSR & (1u << 3u);
    }

    /**
     * Set CH4_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH4_CSR_B_INV() volatile
    {
        CH4_CSR |= 1u << 3u;
    }

    /**
     * Clear CH4_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH4_CSR_B_INV() volatile
    {
        CH4_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH4_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH4_CSR_B_INV() volatile
    {
        CH4_CSR ^= 1u << 3u;
    }

    /**
     * Get CH4_CSR's DIVMODE field.
     */
    inline PWM_CH4_CSR_DIVMODE get_CH4_CSR_DIVMODE() volatile
    {
        return PWM_CH4_CSR_DIVMODE((CH4_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH4_CSR's DIVMODE field.
     */
    inline void set_CH4_CSR_DIVMODE(PWM_CH4_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH4_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH4_CSR = curr;
    }

    /**
     * Get CH4_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH4_CSR_PH_RET() volatile
    {
        return CH4_CSR & (1u << 6u);
    }

    /**
     * Set CH4_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH4_CSR_PH_RET() volatile
    {
        CH4_CSR |= 1u << 6u;
    }

    /**
     * Clear CH4_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH4_CSR_PH_RET() volatile
    {
        CH4_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH4_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH4_CSR_PH_RET() volatile
    {
        CH4_CSR ^= 1u << 6u;
    }

    /**
     * Get CH4_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH4_CSR_PH_ADV() volatile
    {
        return CH4_CSR & (1u << 7u);
    }

    /**
     * Set CH4_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH4_CSR_PH_ADV() volatile
    {
        CH4_CSR |= 1u << 7u;
    }

    /**
     * Clear CH4_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH4_CSR_PH_ADV() volatile
    {
        CH4_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH4_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH4_CSR_PH_ADV() volatile
    {
        CH4_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH4_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH4_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH4_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH4_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH4_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH4_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH4_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH4_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH4_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH4_CSR = curr;
    }

    /**
     * Get CH4_DIV's FRAC field.
     */
    inline uint8_t get_CH4_DIV_FRAC() volatile
    {
        return (CH4_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH4_DIV's FRAC field.
     */
    inline void set_CH4_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH4_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH4_DIV = curr;
    }

    /**
     * Get CH4_DIV's INT field.
     */
    inline uint8_t get_CH4_DIV_INT() volatile
    {
        return (CH4_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH4_DIV's INT field.
     */
    inline void set_CH4_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH4_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH4_DIV = curr;
    }

    /**
     * Get all of CH4_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH4_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH4_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH4_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH4_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH4_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH4_DIV = curr;
    }

    /**
     * Get CH4_CTR's CH4_CTR field.
     */
    inline uint16_t get_CH4_CTR_CH4_CTR() volatile
    {
        return (CH4_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH4_CTR's CH4_CTR field.
     */
    inline void set_CH4_CTR_CH4_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH4_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH4_CTR = curr;
    }

    /**
     * Get CH4_CC's A field.
     */
    inline uint16_t get_CH4_CC_A() volatile
    {
        return (CH4_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH4_CC's A field.
     */
    inline void set_CH4_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH4_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH4_CC = curr;
    }

    /**
     * Get CH4_CC's B field.
     */
    inline uint16_t get_CH4_CC_B() volatile
    {
        return (CH4_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH4_CC's B field.
     */
    inline void set_CH4_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH4_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH4_CC = curr;
    }

    /**
     * Get all of CH4_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH4_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH4_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH4_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH4_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH4_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH4_CC = curr;
    }

    /**
     * Get CH4_TOP's CH4_TOP field.
     */
    inline uint16_t get_CH4_TOP_CH4_TOP() volatile
    {
        return (CH4_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH4_TOP's CH4_TOP field.
     */
    inline void set_CH4_TOP_CH4_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH4_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH4_TOP = curr;
    }

    /**
     * Get CH5_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH5_CSR_EN() volatile
    {
        return CH5_CSR & (1u << 0u);
    }

    /**
     * Set CH5_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH5_CSR_EN() volatile
    {
        CH5_CSR |= 1u << 0u;
    }

    /**
     * Clear CH5_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH5_CSR_EN() volatile
    {
        CH5_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH5_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH5_CSR_EN() volatile
    {
        CH5_CSR ^= 1u << 0u;
    }

    /**
     * Get CH5_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH5_CSR_PH_CORRECT() volatile
    {
        return CH5_CSR & (1u << 1u);
    }

    /**
     * Set CH5_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH5_CSR_PH_CORRECT() volatile
    {
        CH5_CSR |= 1u << 1u;
    }

    /**
     * Clear CH5_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH5_CSR_PH_CORRECT() volatile
    {
        CH5_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH5_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH5_CSR_PH_CORRECT() volatile
    {
        CH5_CSR ^= 1u << 1u;
    }

    /**
     * Get CH5_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH5_CSR_A_INV() volatile
    {
        return CH5_CSR & (1u << 2u);
    }

    /**
     * Set CH5_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH5_CSR_A_INV() volatile
    {
        CH5_CSR |= 1u << 2u;
    }

    /**
     * Clear CH5_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH5_CSR_A_INV() volatile
    {
        CH5_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH5_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH5_CSR_A_INV() volatile
    {
        CH5_CSR ^= 1u << 2u;
    }

    /**
     * Get CH5_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH5_CSR_B_INV() volatile
    {
        return CH5_CSR & (1u << 3u);
    }

    /**
     * Set CH5_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH5_CSR_B_INV() volatile
    {
        CH5_CSR |= 1u << 3u;
    }

    /**
     * Clear CH5_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH5_CSR_B_INV() volatile
    {
        CH5_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH5_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH5_CSR_B_INV() volatile
    {
        CH5_CSR ^= 1u << 3u;
    }

    /**
     * Get CH5_CSR's DIVMODE field.
     */
    inline PWM_CH5_CSR_DIVMODE get_CH5_CSR_DIVMODE() volatile
    {
        return PWM_CH5_CSR_DIVMODE((CH5_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH5_CSR's DIVMODE field.
     */
    inline void set_CH5_CSR_DIVMODE(PWM_CH5_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH5_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH5_CSR = curr;
    }

    /**
     * Get CH5_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH5_CSR_PH_RET() volatile
    {
        return CH5_CSR & (1u << 6u);
    }

    /**
     * Set CH5_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH5_CSR_PH_RET() volatile
    {
        CH5_CSR |= 1u << 6u;
    }

    /**
     * Clear CH5_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH5_CSR_PH_RET() volatile
    {
        CH5_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH5_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH5_CSR_PH_RET() volatile
    {
        CH5_CSR ^= 1u << 6u;
    }

    /**
     * Get CH5_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH5_CSR_PH_ADV() volatile
    {
        return CH5_CSR & (1u << 7u);
    }

    /**
     * Set CH5_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH5_CSR_PH_ADV() volatile
    {
        CH5_CSR |= 1u << 7u;
    }

    /**
     * Clear CH5_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH5_CSR_PH_ADV() volatile
    {
        CH5_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH5_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH5_CSR_PH_ADV() volatile
    {
        CH5_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH5_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH5_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH5_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH5_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH5_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH5_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH5_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH5_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH5_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH5_CSR = curr;
    }

    /**
     * Get CH5_DIV's FRAC field.
     */
    inline uint8_t get_CH5_DIV_FRAC() volatile
    {
        return (CH5_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH5_DIV's FRAC field.
     */
    inline void set_CH5_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH5_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH5_DIV = curr;
    }

    /**
     * Get CH5_DIV's INT field.
     */
    inline uint8_t get_CH5_DIV_INT() volatile
    {
        return (CH5_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH5_DIV's INT field.
     */
    inline void set_CH5_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH5_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH5_DIV = curr;
    }

    /**
     * Get all of CH5_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH5_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH5_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH5_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH5_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH5_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH5_DIV = curr;
    }

    /**
     * Get CH5_CTR's CH5_CTR field.
     */
    inline uint16_t get_CH5_CTR_CH5_CTR() volatile
    {
        return (CH5_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH5_CTR's CH5_CTR field.
     */
    inline void set_CH5_CTR_CH5_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH5_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH5_CTR = curr;
    }

    /**
     * Get CH5_CC's A field.
     */
    inline uint16_t get_CH5_CC_A() volatile
    {
        return (CH5_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH5_CC's A field.
     */
    inline void set_CH5_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH5_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH5_CC = curr;
    }

    /**
     * Get CH5_CC's B field.
     */
    inline uint16_t get_CH5_CC_B() volatile
    {
        return (CH5_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH5_CC's B field.
     */
    inline void set_CH5_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH5_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH5_CC = curr;
    }

    /**
     * Get all of CH5_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH5_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH5_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH5_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH5_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH5_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH5_CC = curr;
    }

    /**
     * Get CH5_TOP's CH5_TOP field.
     */
    inline uint16_t get_CH5_TOP_CH5_TOP() volatile
    {
        return (CH5_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH5_TOP's CH5_TOP field.
     */
    inline void set_CH5_TOP_CH5_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH5_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH5_TOP = curr;
    }

    /**
     * Get CH6_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH6_CSR_EN() volatile
    {
        return CH6_CSR & (1u << 0u);
    }

    /**
     * Set CH6_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH6_CSR_EN() volatile
    {
        CH6_CSR |= 1u << 0u;
    }

    /**
     * Clear CH6_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH6_CSR_EN() volatile
    {
        CH6_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH6_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH6_CSR_EN() volatile
    {
        CH6_CSR ^= 1u << 0u;
    }

    /**
     * Get CH6_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH6_CSR_PH_CORRECT() volatile
    {
        return CH6_CSR & (1u << 1u);
    }

    /**
     * Set CH6_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH6_CSR_PH_CORRECT() volatile
    {
        CH6_CSR |= 1u << 1u;
    }

    /**
     * Clear CH6_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH6_CSR_PH_CORRECT() volatile
    {
        CH6_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH6_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH6_CSR_PH_CORRECT() volatile
    {
        CH6_CSR ^= 1u << 1u;
    }

    /**
     * Get CH6_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH6_CSR_A_INV() volatile
    {
        return CH6_CSR & (1u << 2u);
    }

    /**
     * Set CH6_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH6_CSR_A_INV() volatile
    {
        CH6_CSR |= 1u << 2u;
    }

    /**
     * Clear CH6_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH6_CSR_A_INV() volatile
    {
        CH6_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH6_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH6_CSR_A_INV() volatile
    {
        CH6_CSR ^= 1u << 2u;
    }

    /**
     * Get CH6_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH6_CSR_B_INV() volatile
    {
        return CH6_CSR & (1u << 3u);
    }

    /**
     * Set CH6_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH6_CSR_B_INV() volatile
    {
        CH6_CSR |= 1u << 3u;
    }

    /**
     * Clear CH6_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH6_CSR_B_INV() volatile
    {
        CH6_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH6_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH6_CSR_B_INV() volatile
    {
        CH6_CSR ^= 1u << 3u;
    }

    /**
     * Get CH6_CSR's DIVMODE field.
     */
    inline PWM_CH6_CSR_DIVMODE get_CH6_CSR_DIVMODE() volatile
    {
        return PWM_CH6_CSR_DIVMODE((CH6_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH6_CSR's DIVMODE field.
     */
    inline void set_CH6_CSR_DIVMODE(PWM_CH6_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH6_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH6_CSR = curr;
    }

    /**
     * Get CH6_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH6_CSR_PH_RET() volatile
    {
        return CH6_CSR & (1u << 6u);
    }

    /**
     * Set CH6_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH6_CSR_PH_RET() volatile
    {
        CH6_CSR |= 1u << 6u;
    }

    /**
     * Clear CH6_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH6_CSR_PH_RET() volatile
    {
        CH6_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH6_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH6_CSR_PH_RET() volatile
    {
        CH6_CSR ^= 1u << 6u;
    }

    /**
     * Get CH6_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH6_CSR_PH_ADV() volatile
    {
        return CH6_CSR & (1u << 7u);
    }

    /**
     * Set CH6_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH6_CSR_PH_ADV() volatile
    {
        CH6_CSR |= 1u << 7u;
    }

    /**
     * Clear CH6_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH6_CSR_PH_ADV() volatile
    {
        CH6_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH6_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH6_CSR_PH_ADV() volatile
    {
        CH6_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH6_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH6_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH6_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH6_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH6_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH6_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH6_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH6_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH6_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH6_CSR = curr;
    }

    /**
     * Get CH6_DIV's FRAC field.
     */
    inline uint8_t get_CH6_DIV_FRAC() volatile
    {
        return (CH6_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH6_DIV's FRAC field.
     */
    inline void set_CH6_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH6_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH6_DIV = curr;
    }

    /**
     * Get CH6_DIV's INT field.
     */
    inline uint8_t get_CH6_DIV_INT() volatile
    {
        return (CH6_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH6_DIV's INT field.
     */
    inline void set_CH6_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH6_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH6_DIV = curr;
    }

    /**
     * Get all of CH6_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH6_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH6_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH6_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH6_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH6_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH6_DIV = curr;
    }

    /**
     * Get CH6_CTR's CH6_CTR field.
     */
    inline uint16_t get_CH6_CTR_CH6_CTR() volatile
    {
        return (CH6_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH6_CTR's CH6_CTR field.
     */
    inline void set_CH6_CTR_CH6_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH6_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH6_CTR = curr;
    }

    /**
     * Get CH6_CC's A field.
     */
    inline uint16_t get_CH6_CC_A() volatile
    {
        return (CH6_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH6_CC's A field.
     */
    inline void set_CH6_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH6_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH6_CC = curr;
    }

    /**
     * Get CH6_CC's B field.
     */
    inline uint16_t get_CH6_CC_B() volatile
    {
        return (CH6_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH6_CC's B field.
     */
    inline void set_CH6_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH6_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH6_CC = curr;
    }

    /**
     * Get all of CH6_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH6_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH6_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH6_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH6_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH6_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH6_CC = curr;
    }

    /**
     * Get CH6_TOP's CH6_TOP field.
     */
    inline uint16_t get_CH6_TOP_CH6_TOP() volatile
    {
        return (CH6_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH6_TOP's CH6_TOP field.
     */
    inline void set_CH6_TOP_CH6_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH6_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH6_TOP = curr;
    }

    /**
     * Get CH7_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline bool get_CH7_CSR_EN() volatile
    {
        return CH7_CSR & (1u << 0u);
    }

    /**
     * Set CH7_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void set_CH7_CSR_EN() volatile
    {
        CH7_CSR |= 1u << 0u;
    }

    /**
     * Clear CH7_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void clear_CH7_CSR_EN() volatile
    {
        CH7_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle CH7_CSR's EN bit.
     *
     * Enable the PWM channel.
     */
    inline void toggle_CH7_CSR_EN() volatile
    {
        CH7_CSR ^= 1u << 0u;
    }

    /**
     * Get CH7_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline bool get_CH7_CSR_PH_CORRECT() volatile
    {
        return CH7_CSR & (1u << 1u);
    }

    /**
     * Set CH7_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void set_CH7_CSR_PH_CORRECT() volatile
    {
        CH7_CSR |= 1u << 1u;
    }

    /**
     * Clear CH7_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void clear_CH7_CSR_PH_CORRECT() volatile
    {
        CH7_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle CH7_CSR's PH_CORRECT bit.
     *
     * 1: Enable phase-correct modulation. 0: Trailing-edge
     */
    inline void toggle_CH7_CSR_PH_CORRECT() volatile
    {
        CH7_CSR ^= 1u << 1u;
    }

    /**
     * Get CH7_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline bool get_CH7_CSR_A_INV() volatile
    {
        return CH7_CSR & (1u << 2u);
    }

    /**
     * Set CH7_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void set_CH7_CSR_A_INV() volatile
    {
        CH7_CSR |= 1u << 2u;
    }

    /**
     * Clear CH7_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void clear_CH7_CSR_A_INV() volatile
    {
        CH7_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle CH7_CSR's A_INV bit.
     *
     * Invert output A
     */
    inline void toggle_CH7_CSR_A_INV() volatile
    {
        CH7_CSR ^= 1u << 2u;
    }

    /**
     * Get CH7_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline bool get_CH7_CSR_B_INV() volatile
    {
        return CH7_CSR & (1u << 3u);
    }

    /**
     * Set CH7_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void set_CH7_CSR_B_INV() volatile
    {
        CH7_CSR |= 1u << 3u;
    }

    /**
     * Clear CH7_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void clear_CH7_CSR_B_INV() volatile
    {
        CH7_CSR &= ~(1u << 3u);
    }

    /**
     * Toggle CH7_CSR's B_INV bit.
     *
     * Invert output B
     */
    inline void toggle_CH7_CSR_B_INV() volatile
    {
        CH7_CSR ^= 1u << 3u;
    }

    /**
     * Get CH7_CSR's DIVMODE field.
     */
    inline PWM_CH7_CSR_DIVMODE get_CH7_CSR_DIVMODE() volatile
    {
        return PWM_CH7_CSR_DIVMODE((CH7_CSR >> 4u) & 0b11u);
    }

    /**
     * Set CH7_CSR's DIVMODE field.
     */
    inline void set_CH7_CSR_DIVMODE(PWM_CH7_CSR_DIVMODE value) volatile
    {
        uint32_t curr = CH7_CSR;

        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(value) & 0b11u) << 4u;

        CH7_CSR = curr;
    }

    /**
     * Get CH7_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline bool get_CH7_CSR_PH_RET() volatile
    {
        return CH7_CSR & (1u << 6u);
    }

    /**
     * Set CH7_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void set_CH7_CSR_PH_RET() volatile
    {
        CH7_CSR |= 1u << 6u;
    }

    /**
     * Clear CH7_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void clear_CH7_CSR_PH_RET() volatile
    {
        CH7_CSR &= ~(1u << 6u);
    }

    /**
     * Toggle CH7_CSR's PH_RET bit.
     *
     * Retard the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running.
     */
    inline void toggle_CH7_CSR_PH_RET() volatile
    {
        CH7_CSR ^= 1u << 6u;
    }

    /**
     * Get CH7_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline bool get_CH7_CSR_PH_ADV() volatile
    {
        return CH7_CSR & (1u << 7u);
    }

    /**
     * Set CH7_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void set_CH7_CSR_PH_ADV() volatile
    {
        CH7_CSR |= 1u << 7u;
    }

    /**
     * Clear CH7_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void clear_CH7_CSR_PH_ADV() volatile
    {
        CH7_CSR &= ~(1u << 7u);
    }

    /**
     * Toggle CH7_CSR's PH_ADV bit.
     *
     * Advance the phase of the counter by 1 count, while it is running.\n
     *                 Self-clearing. Write a 1, and poll until low. Counter
     * must be running\n at less than full speed (div_int + div_frac / 16 > 1)
     */
    inline void toggle_CH7_CSR_PH_ADV() volatile
    {
        CH7_CSR ^= 1u << 7u;
    }

    /**
     * Get all of CH7_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void get_CH7_CSR(bool &EN, bool &PH_CORRECT, bool &A_INV,
                            bool &B_INV, PWM_CH7_CSR_DIVMODE &DIVMODE,
                            bool &PH_RET, bool &PH_ADV) volatile
    {
        uint32_t curr = CH7_CSR;

        EN = curr & (1u << 0u);
        PH_CORRECT = curr & (1u << 1u);
        A_INV = curr & (1u << 2u);
        B_INV = curr & (1u << 3u);
        DIVMODE = PWM_CH7_CSR_DIVMODE((curr >> 4u) & 0b11u);
        PH_RET = curr & (1u << 6u);
        PH_ADV = curr & (1u << 7u);
    }

    /**
     * Set all of CH7_CSR's bit fields.
     *
     * (read-write) Control and status register
     */
    inline void set_CH7_CSR(bool EN, bool PH_CORRECT, bool A_INV, bool B_INV,
                            PWM_CH7_CSR_DIVMODE DIVMODE, bool PH_RET,
                            bool PH_ADV) volatile
    {
        uint32_t curr = CH7_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (PH_CORRECT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (A_INV & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (B_INV & 0b1u) << 3u;
        curr &= ~(0b11u << 4u);
        curr |= (std::to_underlying(DIVMODE) & 0b11u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PH_RET & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (PH_ADV & 0b1u) << 7u;

        CH7_CSR = curr;
    }

    /**
     * Get CH7_DIV's FRAC field.
     */
    inline uint8_t get_CH7_DIV_FRAC() volatile
    {
        return (CH7_DIV >> 0u) & 0b1111u;
    }

    /**
     * Set CH7_DIV's FRAC field.
     */
    inline void set_CH7_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CH7_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        CH7_DIV = curr;
    }

    /**
     * Get CH7_DIV's INT field.
     */
    inline uint8_t get_CH7_DIV_INT() volatile
    {
        return (CH7_DIV >> 4u) & 0b11111111u;
    }

    /**
     * Set CH7_DIV's INT field.
     */
    inline void set_CH7_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CH7_DIV;

        curr &= ~(0b11111111u << 4u);
        curr |= (value & 0b11111111u) << 4u;

        CH7_DIV = curr;
    }

    /**
     * Get all of CH7_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void get_CH7_DIV(uint8_t &FRAC, uint8_t &INT) volatile
    {
        uint32_t curr = CH7_DIV;

        FRAC = (curr >> 0u) & 0b1111u;
        INT = (curr >> 4u) & 0b11111111u;
    }

    /**
     * Set all of CH7_DIV's bit fields.
     *
     * (read-write) INT and FRAC form a fixed-point fractional number.\n
     *             Counting rate is system clock frequency divided by this
     * number.\n Fractional division uses simple 1st-order sigma-delta.
     */
    inline void set_CH7_DIV(uint8_t FRAC, uint8_t INT) volatile
    {
        uint32_t curr = CH7_DIV;

        curr &= ~(0b1111u << 0u);
        curr |= (FRAC & 0b1111u) << 0u;
        curr &= ~(0b11111111u << 4u);
        curr |= (INT & 0b11111111u) << 4u;

        CH7_DIV = curr;
    }

    /**
     * Get CH7_CTR's CH7_CTR field.
     */
    inline uint16_t get_CH7_CTR_CH7_CTR() volatile
    {
        return (CH7_CTR >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH7_CTR's CH7_CTR field.
     */
    inline void set_CH7_CTR_CH7_CTR(uint16_t value) volatile
    {
        uint32_t curr = CH7_CTR;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH7_CTR = curr;
    }

    /**
     * Get CH7_CC's A field.
     */
    inline uint16_t get_CH7_CC_A() volatile
    {
        return (CH7_CC >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH7_CC's A field.
     */
    inline void set_CH7_CC_A(uint16_t value) volatile
    {
        uint32_t curr = CH7_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH7_CC = curr;
    }

    /**
     * Get CH7_CC's B field.
     */
    inline uint16_t get_CH7_CC_B() volatile
    {
        return (CH7_CC >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set CH7_CC's B field.
     */
    inline void set_CH7_CC_B(uint16_t value) volatile
    {
        uint32_t curr = CH7_CC;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        CH7_CC = curr;
    }

    /**
     * Get all of CH7_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void get_CH7_CC(uint16_t &A, uint16_t &B) volatile
    {
        uint32_t curr = CH7_CC;

        A = (curr >> 0u) & 0b1111111111111111u;
        B = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of CH7_CC's bit fields.
     *
     * (read-write) Counter compare values
     */
    inline void set_CH7_CC(uint16_t A, uint16_t B) volatile
    {
        uint32_t curr = CH7_CC;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (A & 0b1111111111111111u) << 0u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (B & 0b1111111111111111u) << 16u;

        CH7_CC = curr;
    }

    /**
     * Get CH7_TOP's CH7_TOP field.
     */
    inline uint16_t get_CH7_TOP_CH7_TOP() volatile
    {
        return (CH7_TOP >> 0u) & 0b1111111111111111u;
    }

    /**
     * Set CH7_TOP's CH7_TOP field.
     */
    inline void set_CH7_TOP_CH7_TOP(uint16_t value) volatile
    {
        uint32_t curr = CH7_TOP;

        curr &= ~(0b1111111111111111u << 0u);
        curr |= (value & 0b1111111111111111u) << 0u;

        CH7_TOP = curr;
    }

    /**
     * Get EN's CH0 bit.
     */
    inline bool get_EN_CH0() volatile
    {
        return EN & (1u << 0u);
    }

    /**
     * Set EN's CH0 bit.
     */
    inline void set_EN_CH0() volatile
    {
        EN |= 1u << 0u;
    }

    /**
     * Clear EN's CH0 bit.
     */
    inline void clear_EN_CH0() volatile
    {
        EN &= ~(1u << 0u);
    }

    /**
     * Toggle EN's CH0 bit.
     */
    inline void toggle_EN_CH0() volatile
    {
        EN ^= 1u << 0u;
    }

    /**
     * Get EN's CH1 bit.
     */
    inline bool get_EN_CH1() volatile
    {
        return EN & (1u << 1u);
    }

    /**
     * Set EN's CH1 bit.
     */
    inline void set_EN_CH1() volatile
    {
        EN |= 1u << 1u;
    }

    /**
     * Clear EN's CH1 bit.
     */
    inline void clear_EN_CH1() volatile
    {
        EN &= ~(1u << 1u);
    }

    /**
     * Toggle EN's CH1 bit.
     */
    inline void toggle_EN_CH1() volatile
    {
        EN ^= 1u << 1u;
    }

    /**
     * Get EN's CH2 bit.
     */
    inline bool get_EN_CH2() volatile
    {
        return EN & (1u << 2u);
    }

    /**
     * Set EN's CH2 bit.
     */
    inline void set_EN_CH2() volatile
    {
        EN |= 1u << 2u;
    }

    /**
     * Clear EN's CH2 bit.
     */
    inline void clear_EN_CH2() volatile
    {
        EN &= ~(1u << 2u);
    }

    /**
     * Toggle EN's CH2 bit.
     */
    inline void toggle_EN_CH2() volatile
    {
        EN ^= 1u << 2u;
    }

    /**
     * Get EN's CH3 bit.
     */
    inline bool get_EN_CH3() volatile
    {
        return EN & (1u << 3u);
    }

    /**
     * Set EN's CH3 bit.
     */
    inline void set_EN_CH3() volatile
    {
        EN |= 1u << 3u;
    }

    /**
     * Clear EN's CH3 bit.
     */
    inline void clear_EN_CH3() volatile
    {
        EN &= ~(1u << 3u);
    }

    /**
     * Toggle EN's CH3 bit.
     */
    inline void toggle_EN_CH3() volatile
    {
        EN ^= 1u << 3u;
    }

    /**
     * Get EN's CH4 bit.
     */
    inline bool get_EN_CH4() volatile
    {
        return EN & (1u << 4u);
    }

    /**
     * Set EN's CH4 bit.
     */
    inline void set_EN_CH4() volatile
    {
        EN |= 1u << 4u;
    }

    /**
     * Clear EN's CH4 bit.
     */
    inline void clear_EN_CH4() volatile
    {
        EN &= ~(1u << 4u);
    }

    /**
     * Toggle EN's CH4 bit.
     */
    inline void toggle_EN_CH4() volatile
    {
        EN ^= 1u << 4u;
    }

    /**
     * Get EN's CH5 bit.
     */
    inline bool get_EN_CH5() volatile
    {
        return EN & (1u << 5u);
    }

    /**
     * Set EN's CH5 bit.
     */
    inline void set_EN_CH5() volatile
    {
        EN |= 1u << 5u;
    }

    /**
     * Clear EN's CH5 bit.
     */
    inline void clear_EN_CH5() volatile
    {
        EN &= ~(1u << 5u);
    }

    /**
     * Toggle EN's CH5 bit.
     */
    inline void toggle_EN_CH5() volatile
    {
        EN ^= 1u << 5u;
    }

    /**
     * Get EN's CH6 bit.
     */
    inline bool get_EN_CH6() volatile
    {
        return EN & (1u << 6u);
    }

    /**
     * Set EN's CH6 bit.
     */
    inline void set_EN_CH6() volatile
    {
        EN |= 1u << 6u;
    }

    /**
     * Clear EN's CH6 bit.
     */
    inline void clear_EN_CH6() volatile
    {
        EN &= ~(1u << 6u);
    }

    /**
     * Toggle EN's CH6 bit.
     */
    inline void toggle_EN_CH6() volatile
    {
        EN ^= 1u << 6u;
    }

    /**
     * Get EN's CH7 bit.
     */
    inline bool get_EN_CH7() volatile
    {
        return EN & (1u << 7u);
    }

    /**
     * Set EN's CH7 bit.
     */
    inline void set_EN_CH7() volatile
    {
        EN |= 1u << 7u;
    }

    /**
     * Clear EN's CH7 bit.
     */
    inline void clear_EN_CH7() volatile
    {
        EN &= ~(1u << 7u);
    }

    /**
     * Toggle EN's CH7 bit.
     */
    inline void toggle_EN_CH7() volatile
    {
        EN ^= 1u << 7u;
    }

    /**
     * Get all of EN's bit fields.
     *
     * (read-write) This register aliases the CSR_EN bits for all channels.\n
     *             Writing to this register allows multiple channels to be
     * enabled\n or disabled simultaneously, so they can run in perfect sync.\n
     *             For each channel, there is only one physical EN register
     * bit,\n which can be accessed through here or CHx_CSR.
     */
    inline void get_EN(bool &CH0, bool &CH1, bool &CH2, bool &CH3, bool &CH4,
                       bool &CH5, bool &CH6, bool &CH7) volatile
    {
        uint32_t curr = EN;

        CH0 = curr & (1u << 0u);
        CH1 = curr & (1u << 1u);
        CH2 = curr & (1u << 2u);
        CH3 = curr & (1u << 3u);
        CH4 = curr & (1u << 4u);
        CH5 = curr & (1u << 5u);
        CH6 = curr & (1u << 6u);
        CH7 = curr & (1u << 7u);
    }

    /**
     * Set all of EN's bit fields.
     *
     * (read-write) This register aliases the CSR_EN bits for all channels.\n
     *             Writing to this register allows multiple channels to be
     * enabled\n or disabled simultaneously, so they can run in perfect sync.\n
     *             For each channel, there is only one physical EN register
     * bit,\n which can be accessed through here or CHx_CSR.
     */
    inline void set_EN(bool CH0, bool CH1, bool CH2, bool CH3, bool CH4,
                       bool CH5, bool CH6, bool CH7) volatile
    {
        uint32_t curr = EN;

        curr &= ~(0b1u << 0u);
        curr |= (CH0 & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CH1 & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CH2 & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CH3 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (CH4 & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (CH5 & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CH6 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CH7 & 0b1u) << 7u;

        EN = curr;
    }

    /**
     * Get INTR's CH0 bit.
     */
    inline bool get_INTR_CH0() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Set INTR's CH0 bit.
     */
    inline void set_INTR_CH0() volatile
    {
        INTR |= 1u << 0u;
    }

    /**
     * Clear INTR's CH0 bit.
     */
    inline void clear_INTR_CH0() volatile
    {
        INTR &= ~(1u << 0u);
    }

    /**
     * Toggle INTR's CH0 bit.
     */
    inline void toggle_INTR_CH0() volatile
    {
        INTR ^= 1u << 0u;
    }

    /**
     * Get INTR's CH1 bit.
     */
    inline bool get_INTR_CH1() volatile
    {
        return INTR & (1u << 1u);
    }

    /**
     * Set INTR's CH1 bit.
     */
    inline void set_INTR_CH1() volatile
    {
        INTR |= 1u << 1u;
    }

    /**
     * Clear INTR's CH1 bit.
     */
    inline void clear_INTR_CH1() volatile
    {
        INTR &= ~(1u << 1u);
    }

    /**
     * Toggle INTR's CH1 bit.
     */
    inline void toggle_INTR_CH1() volatile
    {
        INTR ^= 1u << 1u;
    }

    /**
     * Get INTR's CH2 bit.
     */
    inline bool get_INTR_CH2() volatile
    {
        return INTR & (1u << 2u);
    }

    /**
     * Set INTR's CH2 bit.
     */
    inline void set_INTR_CH2() volatile
    {
        INTR |= 1u << 2u;
    }

    /**
     * Clear INTR's CH2 bit.
     */
    inline void clear_INTR_CH2() volatile
    {
        INTR &= ~(1u << 2u);
    }

    /**
     * Toggle INTR's CH2 bit.
     */
    inline void toggle_INTR_CH2() volatile
    {
        INTR ^= 1u << 2u;
    }

    /**
     * Get INTR's CH3 bit.
     */
    inline bool get_INTR_CH3() volatile
    {
        return INTR & (1u << 3u);
    }

    /**
     * Set INTR's CH3 bit.
     */
    inline void set_INTR_CH3() volatile
    {
        INTR |= 1u << 3u;
    }

    /**
     * Clear INTR's CH3 bit.
     */
    inline void clear_INTR_CH3() volatile
    {
        INTR &= ~(1u << 3u);
    }

    /**
     * Toggle INTR's CH3 bit.
     */
    inline void toggle_INTR_CH3() volatile
    {
        INTR ^= 1u << 3u;
    }

    /**
     * Get INTR's CH4 bit.
     */
    inline bool get_INTR_CH4() volatile
    {
        return INTR & (1u << 4u);
    }

    /**
     * Set INTR's CH4 bit.
     */
    inline void set_INTR_CH4() volatile
    {
        INTR |= 1u << 4u;
    }

    /**
     * Clear INTR's CH4 bit.
     */
    inline void clear_INTR_CH4() volatile
    {
        INTR &= ~(1u << 4u);
    }

    /**
     * Toggle INTR's CH4 bit.
     */
    inline void toggle_INTR_CH4() volatile
    {
        INTR ^= 1u << 4u;
    }

    /**
     * Get INTR's CH5 bit.
     */
    inline bool get_INTR_CH5() volatile
    {
        return INTR & (1u << 5u);
    }

    /**
     * Set INTR's CH5 bit.
     */
    inline void set_INTR_CH5() volatile
    {
        INTR |= 1u << 5u;
    }

    /**
     * Clear INTR's CH5 bit.
     */
    inline void clear_INTR_CH5() volatile
    {
        INTR &= ~(1u << 5u);
    }

    /**
     * Toggle INTR's CH5 bit.
     */
    inline void toggle_INTR_CH5() volatile
    {
        INTR ^= 1u << 5u;
    }

    /**
     * Get INTR's CH6 bit.
     */
    inline bool get_INTR_CH6() volatile
    {
        return INTR & (1u << 6u);
    }

    /**
     * Set INTR's CH6 bit.
     */
    inline void set_INTR_CH6() volatile
    {
        INTR |= 1u << 6u;
    }

    /**
     * Clear INTR's CH6 bit.
     */
    inline void clear_INTR_CH6() volatile
    {
        INTR &= ~(1u << 6u);
    }

    /**
     * Toggle INTR's CH6 bit.
     */
    inline void toggle_INTR_CH6() volatile
    {
        INTR ^= 1u << 6u;
    }

    /**
     * Get INTR's CH7 bit.
     */
    inline bool get_INTR_CH7() volatile
    {
        return INTR & (1u << 7u);
    }

    /**
     * Set INTR's CH7 bit.
     */
    inline void set_INTR_CH7() volatile
    {
        INTR |= 1u << 7u;
    }

    /**
     * Clear INTR's CH7 bit.
     */
    inline void clear_INTR_CH7() volatile
    {
        INTR &= ~(1u << 7u);
    }

    /**
     * Toggle INTR's CH7 bit.
     */
    inline void toggle_INTR_CH7() volatile
    {
        INTR ^= 1u << 7u;
    }

    /**
     * Get all of INTR's bit fields.
     *
     * (read-write) Raw Interrupts
     */
    inline void get_INTR(bool &CH0, bool &CH1, bool &CH2, bool &CH3, bool &CH4,
                         bool &CH5, bool &CH6, bool &CH7) volatile
    {
        uint32_t curr = INTR;

        CH0 = curr & (1u << 0u);
        CH1 = curr & (1u << 1u);
        CH2 = curr & (1u << 2u);
        CH3 = curr & (1u << 3u);
        CH4 = curr & (1u << 4u);
        CH5 = curr & (1u << 5u);
        CH6 = curr & (1u << 6u);
        CH7 = curr & (1u << 7u);
    }

    /**
     * Set all of INTR's bit fields.
     *
     * (read-write) Raw Interrupts
     */
    inline void set_INTR(bool CH0, bool CH1, bool CH2, bool CH3, bool CH4,
                         bool CH5, bool CH6, bool CH7) volatile
    {
        uint32_t curr = INTR;

        curr &= ~(0b1u << 0u);
        curr |= (CH0 & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CH1 & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CH2 & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CH3 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (CH4 & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (CH5 & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CH6 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CH7 & 0b1u) << 7u;

        INTR = curr;
    }

    /**
     * Get INTE's CH0 bit.
     */
    inline bool get_INTE_CH0() volatile
    {
        return INTE & (1u << 0u);
    }

    /**
     * Set INTE's CH0 bit.
     */
    inline void set_INTE_CH0() volatile
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's CH0 bit.
     */
    inline void clear_INTE_CH0() volatile
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's CH0 bit.
     */
    inline void toggle_INTE_CH0() volatile
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get INTE's CH1 bit.
     */
    inline bool get_INTE_CH1() volatile
    {
        return INTE & (1u << 1u);
    }

    /**
     * Set INTE's CH1 bit.
     */
    inline void set_INTE_CH1() volatile
    {
        INTE |= 1u << 1u;
    }

    /**
     * Clear INTE's CH1 bit.
     */
    inline void clear_INTE_CH1() volatile
    {
        INTE &= ~(1u << 1u);
    }

    /**
     * Toggle INTE's CH1 bit.
     */
    inline void toggle_INTE_CH1() volatile
    {
        INTE ^= 1u << 1u;
    }

    /**
     * Get INTE's CH2 bit.
     */
    inline bool get_INTE_CH2() volatile
    {
        return INTE & (1u << 2u);
    }

    /**
     * Set INTE's CH2 bit.
     */
    inline void set_INTE_CH2() volatile
    {
        INTE |= 1u << 2u;
    }

    /**
     * Clear INTE's CH2 bit.
     */
    inline void clear_INTE_CH2() volatile
    {
        INTE &= ~(1u << 2u);
    }

    /**
     * Toggle INTE's CH2 bit.
     */
    inline void toggle_INTE_CH2() volatile
    {
        INTE ^= 1u << 2u;
    }

    /**
     * Get INTE's CH3 bit.
     */
    inline bool get_INTE_CH3() volatile
    {
        return INTE & (1u << 3u);
    }

    /**
     * Set INTE's CH3 bit.
     */
    inline void set_INTE_CH3() volatile
    {
        INTE |= 1u << 3u;
    }

    /**
     * Clear INTE's CH3 bit.
     */
    inline void clear_INTE_CH3() volatile
    {
        INTE &= ~(1u << 3u);
    }

    /**
     * Toggle INTE's CH3 bit.
     */
    inline void toggle_INTE_CH3() volatile
    {
        INTE ^= 1u << 3u;
    }

    /**
     * Get INTE's CH4 bit.
     */
    inline bool get_INTE_CH4() volatile
    {
        return INTE & (1u << 4u);
    }

    /**
     * Set INTE's CH4 bit.
     */
    inline void set_INTE_CH4() volatile
    {
        INTE |= 1u << 4u;
    }

    /**
     * Clear INTE's CH4 bit.
     */
    inline void clear_INTE_CH4() volatile
    {
        INTE &= ~(1u << 4u);
    }

    /**
     * Toggle INTE's CH4 bit.
     */
    inline void toggle_INTE_CH4() volatile
    {
        INTE ^= 1u << 4u;
    }

    /**
     * Get INTE's CH5 bit.
     */
    inline bool get_INTE_CH5() volatile
    {
        return INTE & (1u << 5u);
    }

    /**
     * Set INTE's CH5 bit.
     */
    inline void set_INTE_CH5() volatile
    {
        INTE |= 1u << 5u;
    }

    /**
     * Clear INTE's CH5 bit.
     */
    inline void clear_INTE_CH5() volatile
    {
        INTE &= ~(1u << 5u);
    }

    /**
     * Toggle INTE's CH5 bit.
     */
    inline void toggle_INTE_CH5() volatile
    {
        INTE ^= 1u << 5u;
    }

    /**
     * Get INTE's CH6 bit.
     */
    inline bool get_INTE_CH6() volatile
    {
        return INTE & (1u << 6u);
    }

    /**
     * Set INTE's CH6 bit.
     */
    inline void set_INTE_CH6() volatile
    {
        INTE |= 1u << 6u;
    }

    /**
     * Clear INTE's CH6 bit.
     */
    inline void clear_INTE_CH6() volatile
    {
        INTE &= ~(1u << 6u);
    }

    /**
     * Toggle INTE's CH6 bit.
     */
    inline void toggle_INTE_CH6() volatile
    {
        INTE ^= 1u << 6u;
    }

    /**
     * Get INTE's CH7 bit.
     */
    inline bool get_INTE_CH7() volatile
    {
        return INTE & (1u << 7u);
    }

    /**
     * Set INTE's CH7 bit.
     */
    inline void set_INTE_CH7() volatile
    {
        INTE |= 1u << 7u;
    }

    /**
     * Clear INTE's CH7 bit.
     */
    inline void clear_INTE_CH7() volatile
    {
        INTE &= ~(1u << 7u);
    }

    /**
     * Toggle INTE's CH7 bit.
     */
    inline void toggle_INTE_CH7() volatile
    {
        INTE ^= 1u << 7u;
    }

    /**
     * Get all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void get_INTE(bool &CH0, bool &CH1, bool &CH2, bool &CH3, bool &CH4,
                         bool &CH5, bool &CH6, bool &CH7) volatile
    {
        uint32_t curr = INTE;

        CH0 = curr & (1u << 0u);
        CH1 = curr & (1u << 1u);
        CH2 = curr & (1u << 2u);
        CH3 = curr & (1u << 3u);
        CH4 = curr & (1u << 4u);
        CH5 = curr & (1u << 5u);
        CH6 = curr & (1u << 6u);
        CH7 = curr & (1u << 7u);
    }

    /**
     * Set all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void set_INTE(bool CH0, bool CH1, bool CH2, bool CH3, bool CH4,
                         bool CH5, bool CH6, bool CH7) volatile
    {
        uint32_t curr = INTE;

        curr &= ~(0b1u << 0u);
        curr |= (CH0 & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CH1 & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CH2 & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CH3 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (CH4 & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (CH5 & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CH6 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CH7 & 0b1u) << 7u;

        INTE = curr;
    }

    /**
     * Get INTF's CH0 bit.
     */
    inline bool get_INTF_CH0() volatile
    {
        return INTF & (1u << 0u);
    }

    /**
     * Set INTF's CH0 bit.
     */
    inline void set_INTF_CH0() volatile
    {
        INTF |= 1u << 0u;
    }

    /**
     * Clear INTF's CH0 bit.
     */
    inline void clear_INTF_CH0() volatile
    {
        INTF &= ~(1u << 0u);
    }

    /**
     * Toggle INTF's CH0 bit.
     */
    inline void toggle_INTF_CH0() volatile
    {
        INTF ^= 1u << 0u;
    }

    /**
     * Get INTF's CH1 bit.
     */
    inline bool get_INTF_CH1() volatile
    {
        return INTF & (1u << 1u);
    }

    /**
     * Set INTF's CH1 bit.
     */
    inline void set_INTF_CH1() volatile
    {
        INTF |= 1u << 1u;
    }

    /**
     * Clear INTF's CH1 bit.
     */
    inline void clear_INTF_CH1() volatile
    {
        INTF &= ~(1u << 1u);
    }

    /**
     * Toggle INTF's CH1 bit.
     */
    inline void toggle_INTF_CH1() volatile
    {
        INTF ^= 1u << 1u;
    }

    /**
     * Get INTF's CH2 bit.
     */
    inline bool get_INTF_CH2() volatile
    {
        return INTF & (1u << 2u);
    }

    /**
     * Set INTF's CH2 bit.
     */
    inline void set_INTF_CH2() volatile
    {
        INTF |= 1u << 2u;
    }

    /**
     * Clear INTF's CH2 bit.
     */
    inline void clear_INTF_CH2() volatile
    {
        INTF &= ~(1u << 2u);
    }

    /**
     * Toggle INTF's CH2 bit.
     */
    inline void toggle_INTF_CH2() volatile
    {
        INTF ^= 1u << 2u;
    }

    /**
     * Get INTF's CH3 bit.
     */
    inline bool get_INTF_CH3() volatile
    {
        return INTF & (1u << 3u);
    }

    /**
     * Set INTF's CH3 bit.
     */
    inline void set_INTF_CH3() volatile
    {
        INTF |= 1u << 3u;
    }

    /**
     * Clear INTF's CH3 bit.
     */
    inline void clear_INTF_CH3() volatile
    {
        INTF &= ~(1u << 3u);
    }

    /**
     * Toggle INTF's CH3 bit.
     */
    inline void toggle_INTF_CH3() volatile
    {
        INTF ^= 1u << 3u;
    }

    /**
     * Get INTF's CH4 bit.
     */
    inline bool get_INTF_CH4() volatile
    {
        return INTF & (1u << 4u);
    }

    /**
     * Set INTF's CH4 bit.
     */
    inline void set_INTF_CH4() volatile
    {
        INTF |= 1u << 4u;
    }

    /**
     * Clear INTF's CH4 bit.
     */
    inline void clear_INTF_CH4() volatile
    {
        INTF &= ~(1u << 4u);
    }

    /**
     * Toggle INTF's CH4 bit.
     */
    inline void toggle_INTF_CH4() volatile
    {
        INTF ^= 1u << 4u;
    }

    /**
     * Get INTF's CH5 bit.
     */
    inline bool get_INTF_CH5() volatile
    {
        return INTF & (1u << 5u);
    }

    /**
     * Set INTF's CH5 bit.
     */
    inline void set_INTF_CH5() volatile
    {
        INTF |= 1u << 5u;
    }

    /**
     * Clear INTF's CH5 bit.
     */
    inline void clear_INTF_CH5() volatile
    {
        INTF &= ~(1u << 5u);
    }

    /**
     * Toggle INTF's CH5 bit.
     */
    inline void toggle_INTF_CH5() volatile
    {
        INTF ^= 1u << 5u;
    }

    /**
     * Get INTF's CH6 bit.
     */
    inline bool get_INTF_CH6() volatile
    {
        return INTF & (1u << 6u);
    }

    /**
     * Set INTF's CH6 bit.
     */
    inline void set_INTF_CH6() volatile
    {
        INTF |= 1u << 6u;
    }

    /**
     * Clear INTF's CH6 bit.
     */
    inline void clear_INTF_CH6() volatile
    {
        INTF &= ~(1u << 6u);
    }

    /**
     * Toggle INTF's CH6 bit.
     */
    inline void toggle_INTF_CH6() volatile
    {
        INTF ^= 1u << 6u;
    }

    /**
     * Get INTF's CH7 bit.
     */
    inline bool get_INTF_CH7() volatile
    {
        return INTF & (1u << 7u);
    }

    /**
     * Set INTF's CH7 bit.
     */
    inline void set_INTF_CH7() volatile
    {
        INTF |= 1u << 7u;
    }

    /**
     * Clear INTF's CH7 bit.
     */
    inline void clear_INTF_CH7() volatile
    {
        INTF &= ~(1u << 7u);
    }

    /**
     * Toggle INTF's CH7 bit.
     */
    inline void toggle_INTF_CH7() volatile
    {
        INTF ^= 1u << 7u;
    }

    /**
     * Get all of INTF's bit fields.
     *
     * (read-write) Interrupt Force
     */
    inline void get_INTF(bool &CH0, bool &CH1, bool &CH2, bool &CH3, bool &CH4,
                         bool &CH5, bool &CH6, bool &CH7) volatile
    {
        uint32_t curr = INTF;

        CH0 = curr & (1u << 0u);
        CH1 = curr & (1u << 1u);
        CH2 = curr & (1u << 2u);
        CH3 = curr & (1u << 3u);
        CH4 = curr & (1u << 4u);
        CH5 = curr & (1u << 5u);
        CH6 = curr & (1u << 6u);
        CH7 = curr & (1u << 7u);
    }

    /**
     * Set all of INTF's bit fields.
     *
     * (read-write) Interrupt Force
     */
    inline void set_INTF(bool CH0, bool CH1, bool CH2, bool CH3, bool CH4,
                         bool CH5, bool CH6, bool CH7) volatile
    {
        uint32_t curr = INTF;

        curr &= ~(0b1u << 0u);
        curr |= (CH0 & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (CH1 & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CH2 & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (CH3 & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (CH4 & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (CH5 & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (CH6 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (CH7 & 0b1u) << 7u;

        INTF = curr;
    }

    /**
     * Get INTS's CH0 bit.
     */
    inline bool get_INTS_CH0() volatile
    {
        return INTS & (1u << 0u);
    }

    /**
     * Get INTS's CH1 bit.
     */
    inline bool get_INTS_CH1() volatile
    {
        return INTS & (1u << 1u);
    }

    /**
     * Get INTS's CH2 bit.
     */
    inline bool get_INTS_CH2() volatile
    {
        return INTS & (1u << 2u);
    }

    /**
     * Get INTS's CH3 bit.
     */
    inline bool get_INTS_CH3() volatile
    {
        return INTS & (1u << 3u);
    }

    /**
     * Get INTS's CH4 bit.
     */
    inline bool get_INTS_CH4() volatile
    {
        return INTS & (1u << 4u);
    }

    /**
     * Get INTS's CH5 bit.
     */
    inline bool get_INTS_CH5() volatile
    {
        return INTS & (1u << 5u);
    }

    /**
     * Get INTS's CH6 bit.
     */
    inline bool get_INTS_CH6() volatile
    {
        return INTS & (1u << 6u);
    }

    /**
     * Get INTS's CH7 bit.
     */
    inline bool get_INTS_CH7() volatile
    {
        return INTS & (1u << 7u);
    }

    /**
     * Get all of INTS's bit fields.
     *
     * (read-only) Interrupt status after masking & forcing
     */
    inline void get_INTS(bool &CH0, bool &CH1, bool &CH2, bool &CH3, bool &CH4,
                         bool &CH5, bool &CH6, bool &CH7) volatile
    {
        uint32_t curr = INTS;

        CH0 = curr & (1u << 0u);
        CH1 = curr & (1u << 1u);
        CH2 = curr & (1u << 2u);
        CH3 = curr & (1u << 3u);
        CH4 = curr & (1u << 4u);
        CH5 = curr & (1u << 5u);
        CH6 = curr & (1u << 6u);
        CH7 = curr & (1u << 7u);
    }
};

static_assert(sizeof(pwm) == pwm::size);

static volatile pwm *const PWM = reinterpret_cast<pwm *>(0x40050000);

}; // namespace RP2040
