/**
 * \file
 * \brief Generated by ifgen (3.0.1).
 */
#pragma once

#include "../enums/CLOCKS_CLK_ADC_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT0_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT1_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT2_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT3_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_PERI_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_REF_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_REF_CTRL_SRC.h"
#include "../enums/CLOCKS_CLK_RTC_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_SYS_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_SYS_CTRL_SRC.h"
#include "../enums/CLOCKS_CLK_USB_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_FC0_SRC_FC0_SRC.h"
#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] clocks
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;        /*!< clocks's identifier. */
    static constexpr std::size_t size = 200; /*!< clocks's size in bytes. */

    /* Fields. */
    uint32_t CLK_GPOUT0_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT0_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT0_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_GPOUT1_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT1_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT1_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_GPOUT2_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT2_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT2_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_GPOUT3_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT3_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT3_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_REF_CTRL;     /*!< (read-write) Clock control, can be changed
                                  on-the-fly (except for auxsrc) */
    uint32_t CLK_REF_DIV;      /*!< (read-write) Clock divisor, can be changed
                                  on-the-fly */
    uint32_t CLK_REF_SELECTED; /*!< (read-write) Indicates which SRC is
 currently selected by the glitchless mux (one-hot).\n The glitchless
 multiplexer does not switch instantaneously (to avoid glitches), so software
 should poll this register to wait for the switch to complete. This register
 contains one decoded bit for each of the clock sources enumerated in the CTRL
 SRC field. At most one of these bits will be set at any time, indicating that
 clock is currently present at the output of the glitchless mux. Whilst
 switching is in progress, this register may briefly show all-0s. */
    uint32_t CLK_SYS_CTRL;     /*!< (read-write) Clock control, can be changed
                                  on-the-fly (except for auxsrc) */
    uint32_t CLK_SYS_DIV;      /*!< (read-write) Clock divisor, can be changed
                                  on-the-fly */
    uint32_t CLK_SYS_SELECTED; /*!< (read-write) Indicates which SRC is
 currently selected by the glitchless mux (one-hot).\n The glitchless
 multiplexer does not switch instantaneously (to avoid glitches), so software
 should poll this register to wait for the switch to complete. This register
 contains one decoded bit for each of the clock sources enumerated in the CTRL
 SRC field. At most one of these bits will be set at any time, indicating that
 clock is currently present at the output of the glitchless mux. Whilst
 switching is in progress, this register may briefly show all-0s. */
    uint32_t CLK_PERI_CTRL;    /*!< (read-write) Clock control, can be changed
                                  on-the-fly (except for auxsrc) */
    const uint32_t reserved_padding0 = {};
    uint32_t CLK_PERI_SELECTED; /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n This slice does not
  have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register is hardwired to 0x1. */
    uint32_t CLK_USB_CTRL;      /*!< (read-write) Clock control, can be changed
                                   on-the-fly (except for auxsrc) */
    uint32_t CLK_USB_DIV;       /*!< (read-write) Clock divisor, can be changed
                                   on-the-fly */
    uint32_t CLK_USB_SELECTED;  /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n  This slice does not
  have  a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register  is hardwired to 0x1. */
    uint32_t CLK_ADC_CTRL;      /*!< (read-write) Clock control, can be changed
                                   on-the-fly (except for auxsrc) */
    uint32_t CLK_ADC_DIV;       /*!< (read-write) Clock divisor, can be changed
                                   on-the-fly */
    uint32_t CLK_ADC_SELECTED;  /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n  This slice does not
  have  a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register  is hardwired to 0x1. */
    uint32_t CLK_RTC_CTRL;      /*!< (read-write) Clock control, can be changed
                                   on-the-fly (except for auxsrc) */
    uint32_t CLK_RTC_DIV;       /*!< (read-write) Clock divisor, can be changed
                                   on-the-fly */
    uint32_t CLK_RTC_SELECTED;  /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n  This slice does not
  have  a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register  is hardwired to 0x1. */
    uint32_t CLK_SYS_RESUS_CTRL;
    const uint32_t CLK_SYS_RESUS_STATUS = {};
    uint32_t FC0_REF_KHZ; /*!< (read-write) Reference clock frequency in kHz */
    uint32_t FC0_MIN_KHZ; /*!< (read-write) Minimum pass frequency in kHz. This
                             is optional. Set to 0 if you are not using the
                             pass/fail flags */
    uint32_t FC0_MAX_KHZ; /*!< (read-write) Maximum pass frequency in kHz. This
                             is optional. Set to 0x1ffffff if you are not using
                             the pass/fail flags */
    uint32_t FC0_DELAY;   /*!< (read-write) Delays the start of frequency
  counting to allow the mux to settle\n   Delay is measured in multiples of the
  reference clock period */
    uint32_t FC0_INTERVAL; /*!< (read-write) The test interval is 0.98us *
2**interval, but let's call it 1us * 2**interval\n The default gives a test
interval of 250us */
    uint32_t FC0_SRC; /*!< (read-write) Clock sent to frequency counter, set to
0 when not required\n Writing to this register initiates the frequency count */
    const uint32_t FC0_STATUS =
        {}; /*!< (read-only) Frequency counter status */
    const uint32_t FC0_RESULT =
        {}; /*!< (read-only) Result of frequency measurement, only valid when
               status_done=1 */
    uint32_t WAKE_EN0;  /*!< (read-write) enable clock in wake mode */
    uint32_t WAKE_EN1;  /*!< (read-write) enable clock in wake mode */
    uint32_t SLEEP_EN0; /*!< (read-write) enable clock in sleep mode */
    uint32_t SLEEP_EN1; /*!< (read-write) enable clock in sleep mode */
    const uint32_t ENABLED0 =
        {}; /*!< (read-only) indicates the state of the clock enable */
    const uint32_t ENABLED1 =
        {}; /*!< (read-only) indicates the state of the clock enable */
    const uint32_t INTR = {}; /*!< (read-only) Raw Interrupts */
    uint32_t INTE;            /*!< (read-write) Interrupt Enable */
    uint32_t INTF;            /*!< (read-write) Interrupt Force */
    const uint32_t INTS =
        {}; /*!< (read-only) Interrupt status after masking & forcing */

    /* Methods. */

    /**
     * Get CLK_GPOUT0_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_GPOUT0_CTRL_AUXSRC get_CLK_GPOUT0_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_GPOUT0_CTRL_AUXSRC((CLK_GPOUT0_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's AUXSRC field.
     */
    inline void set_CLK_GPOUT0_CTRL_AUXSRC(CLOCKS_CLK_GPOUT0_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_GPOUT0_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT0_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT0_CTRL's KILL bit.
     */
    bool get_CLK_GPOUT0_CTRL_KILL()
    {
        return CLK_GPOUT0_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's KILL bit.
     */
    inline void set_CLK_GPOUT0_CTRL_KILL()
    {
        CLK_GPOUT0_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's KILL bit.
     */
    inline void clear_CLK_GPOUT0_CTRL_KILL()
    {
        CLK_GPOUT0_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's KILL bit.
     */
    inline void toggle_CLK_GPOUT0_CTRL_KILL()
    {
        CLK_GPOUT0_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT0_CTRL's ENABLE bit.
     */
    bool get_CLK_GPOUT0_CTRL_ENABLE()
    {
        return CLK_GPOUT0_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's ENABLE bit.
     */
    inline void set_CLK_GPOUT0_CTRL_ENABLE()
    {
        CLK_GPOUT0_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's ENABLE bit.
     */
    inline void clear_CLK_GPOUT0_CTRL_ENABLE()
    {
        CLK_GPOUT0_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_GPOUT0_CTRL_ENABLE()
    {
        CLK_GPOUT0_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT0_CTRL's DC50 bit.
     */
    bool get_CLK_GPOUT0_CTRL_DC50()
    {
        return CLK_GPOUT0_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's DC50 bit.
     */
    inline void set_CLK_GPOUT0_CTRL_DC50()
    {
        CLK_GPOUT0_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's DC50 bit.
     */
    inline void clear_CLK_GPOUT0_CTRL_DC50()
    {
        CLK_GPOUT0_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's DC50 bit.
     */
    inline void toggle_CLK_GPOUT0_CTRL_DC50()
    {
        CLK_GPOUT0_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT0_CTRL's PHASE field.
     */
    uint8_t get_CLK_GPOUT0_CTRL_PHASE()
    {
        return (CLK_GPOUT0_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT0_CTRL's PHASE field.
     */
    inline void set_CLK_GPOUT0_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT0_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT0_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT0_CTRL's NUDGE bit.
     */
    bool get_CLK_GPOUT0_CTRL_NUDGE()
    {
        return CLK_GPOUT0_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's NUDGE bit.
     */
    inline void set_CLK_GPOUT0_CTRL_NUDGE()
    {
        CLK_GPOUT0_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's NUDGE bit.
     */
    inline void clear_CLK_GPOUT0_CTRL_NUDGE()
    {
        CLK_GPOUT0_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_GPOUT0_CTRL_NUDGE()
    {
        CLK_GPOUT0_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_GPOUT0_DIV's FRAC field.
     */
    uint8_t get_CLK_GPOUT0_DIV_FRAC()
    {
        return (CLK_GPOUT0_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT0_DIV's FRAC field.
     */
    inline void set_CLK_GPOUT0_DIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT0_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT0_DIV = curr;
    }

    /**
     * Get CLK_GPOUT0_DIV's INT field.
     */
    uint32_t get_CLK_GPOUT0_DIV_INT()
    {
        return (CLK_GPOUT0_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT0_DIV's INT field.
     */
    inline void set_CLK_GPOUT0_DIV_INT(uint32_t value)
    {
        uint32_t curr = CLK_GPOUT0_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT0_DIV = curr;
    }

    /**
     * Get CLK_GPOUT1_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_GPOUT1_CTRL_AUXSRC get_CLK_GPOUT1_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_GPOUT1_CTRL_AUXSRC((CLK_GPOUT1_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's AUXSRC field.
     */
    inline void set_CLK_GPOUT1_CTRL_AUXSRC(CLOCKS_CLK_GPOUT1_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_GPOUT1_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT1_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT1_CTRL's KILL bit.
     */
    bool get_CLK_GPOUT1_CTRL_KILL()
    {
        return CLK_GPOUT1_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's KILL bit.
     */
    inline void set_CLK_GPOUT1_CTRL_KILL()
    {
        CLK_GPOUT1_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's KILL bit.
     */
    inline void clear_CLK_GPOUT1_CTRL_KILL()
    {
        CLK_GPOUT1_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's KILL bit.
     */
    inline void toggle_CLK_GPOUT1_CTRL_KILL()
    {
        CLK_GPOUT1_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT1_CTRL's ENABLE bit.
     */
    bool get_CLK_GPOUT1_CTRL_ENABLE()
    {
        return CLK_GPOUT1_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's ENABLE bit.
     */
    inline void set_CLK_GPOUT1_CTRL_ENABLE()
    {
        CLK_GPOUT1_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's ENABLE bit.
     */
    inline void clear_CLK_GPOUT1_CTRL_ENABLE()
    {
        CLK_GPOUT1_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_GPOUT1_CTRL_ENABLE()
    {
        CLK_GPOUT1_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT1_CTRL's DC50 bit.
     */
    bool get_CLK_GPOUT1_CTRL_DC50()
    {
        return CLK_GPOUT1_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's DC50 bit.
     */
    inline void set_CLK_GPOUT1_CTRL_DC50()
    {
        CLK_GPOUT1_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's DC50 bit.
     */
    inline void clear_CLK_GPOUT1_CTRL_DC50()
    {
        CLK_GPOUT1_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's DC50 bit.
     */
    inline void toggle_CLK_GPOUT1_CTRL_DC50()
    {
        CLK_GPOUT1_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT1_CTRL's PHASE field.
     */
    uint8_t get_CLK_GPOUT1_CTRL_PHASE()
    {
        return (CLK_GPOUT1_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT1_CTRL's PHASE field.
     */
    inline void set_CLK_GPOUT1_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT1_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT1_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT1_CTRL's NUDGE bit.
     */
    bool get_CLK_GPOUT1_CTRL_NUDGE()
    {
        return CLK_GPOUT1_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's NUDGE bit.
     */
    inline void set_CLK_GPOUT1_CTRL_NUDGE()
    {
        CLK_GPOUT1_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's NUDGE bit.
     */
    inline void clear_CLK_GPOUT1_CTRL_NUDGE()
    {
        CLK_GPOUT1_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_GPOUT1_CTRL_NUDGE()
    {
        CLK_GPOUT1_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_GPOUT1_DIV's FRAC field.
     */
    uint8_t get_CLK_GPOUT1_DIV_FRAC()
    {
        return (CLK_GPOUT1_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT1_DIV's FRAC field.
     */
    inline void set_CLK_GPOUT1_DIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT1_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT1_DIV = curr;
    }

    /**
     * Get CLK_GPOUT1_DIV's INT field.
     */
    uint32_t get_CLK_GPOUT1_DIV_INT()
    {
        return (CLK_GPOUT1_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT1_DIV's INT field.
     */
    inline void set_CLK_GPOUT1_DIV_INT(uint32_t value)
    {
        uint32_t curr = CLK_GPOUT1_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT1_DIV = curr;
    }

    /**
     * Get CLK_GPOUT2_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_GPOUT2_CTRL_AUXSRC get_CLK_GPOUT2_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_GPOUT2_CTRL_AUXSRC((CLK_GPOUT2_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's AUXSRC field.
     */
    inline void set_CLK_GPOUT2_CTRL_AUXSRC(CLOCKS_CLK_GPOUT2_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_GPOUT2_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT2_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT2_CTRL's KILL bit.
     */
    bool get_CLK_GPOUT2_CTRL_KILL()
    {
        return CLK_GPOUT2_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's KILL bit.
     */
    inline void set_CLK_GPOUT2_CTRL_KILL()
    {
        CLK_GPOUT2_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's KILL bit.
     */
    inline void clear_CLK_GPOUT2_CTRL_KILL()
    {
        CLK_GPOUT2_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's KILL bit.
     */
    inline void toggle_CLK_GPOUT2_CTRL_KILL()
    {
        CLK_GPOUT2_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT2_CTRL's ENABLE bit.
     */
    bool get_CLK_GPOUT2_CTRL_ENABLE()
    {
        return CLK_GPOUT2_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's ENABLE bit.
     */
    inline void set_CLK_GPOUT2_CTRL_ENABLE()
    {
        CLK_GPOUT2_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's ENABLE bit.
     */
    inline void clear_CLK_GPOUT2_CTRL_ENABLE()
    {
        CLK_GPOUT2_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_GPOUT2_CTRL_ENABLE()
    {
        CLK_GPOUT2_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT2_CTRL's DC50 bit.
     */
    bool get_CLK_GPOUT2_CTRL_DC50()
    {
        return CLK_GPOUT2_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's DC50 bit.
     */
    inline void set_CLK_GPOUT2_CTRL_DC50()
    {
        CLK_GPOUT2_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's DC50 bit.
     */
    inline void clear_CLK_GPOUT2_CTRL_DC50()
    {
        CLK_GPOUT2_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's DC50 bit.
     */
    inline void toggle_CLK_GPOUT2_CTRL_DC50()
    {
        CLK_GPOUT2_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT2_CTRL's PHASE field.
     */
    uint8_t get_CLK_GPOUT2_CTRL_PHASE()
    {
        return (CLK_GPOUT2_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT2_CTRL's PHASE field.
     */
    inline void set_CLK_GPOUT2_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT2_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT2_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT2_CTRL's NUDGE bit.
     */
    bool get_CLK_GPOUT2_CTRL_NUDGE()
    {
        return CLK_GPOUT2_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's NUDGE bit.
     */
    inline void set_CLK_GPOUT2_CTRL_NUDGE()
    {
        CLK_GPOUT2_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's NUDGE bit.
     */
    inline void clear_CLK_GPOUT2_CTRL_NUDGE()
    {
        CLK_GPOUT2_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_GPOUT2_CTRL_NUDGE()
    {
        CLK_GPOUT2_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_GPOUT2_DIV's FRAC field.
     */
    uint8_t get_CLK_GPOUT2_DIV_FRAC()
    {
        return (CLK_GPOUT2_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT2_DIV's FRAC field.
     */
    inline void set_CLK_GPOUT2_DIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT2_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT2_DIV = curr;
    }

    /**
     * Get CLK_GPOUT2_DIV's INT field.
     */
    uint32_t get_CLK_GPOUT2_DIV_INT()
    {
        return (CLK_GPOUT2_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT2_DIV's INT field.
     */
    inline void set_CLK_GPOUT2_DIV_INT(uint32_t value)
    {
        uint32_t curr = CLK_GPOUT2_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT2_DIV = curr;
    }

    /**
     * Get CLK_GPOUT3_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_GPOUT3_CTRL_AUXSRC get_CLK_GPOUT3_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_GPOUT3_CTRL_AUXSRC((CLK_GPOUT3_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's AUXSRC field.
     */
    inline void set_CLK_GPOUT3_CTRL_AUXSRC(CLOCKS_CLK_GPOUT3_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_GPOUT3_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT3_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT3_CTRL's KILL bit.
     */
    bool get_CLK_GPOUT3_CTRL_KILL()
    {
        return CLK_GPOUT3_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's KILL bit.
     */
    inline void set_CLK_GPOUT3_CTRL_KILL()
    {
        CLK_GPOUT3_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's KILL bit.
     */
    inline void clear_CLK_GPOUT3_CTRL_KILL()
    {
        CLK_GPOUT3_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's KILL bit.
     */
    inline void toggle_CLK_GPOUT3_CTRL_KILL()
    {
        CLK_GPOUT3_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT3_CTRL's ENABLE bit.
     */
    bool get_CLK_GPOUT3_CTRL_ENABLE()
    {
        return CLK_GPOUT3_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's ENABLE bit.
     */
    inline void set_CLK_GPOUT3_CTRL_ENABLE()
    {
        CLK_GPOUT3_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's ENABLE bit.
     */
    inline void clear_CLK_GPOUT3_CTRL_ENABLE()
    {
        CLK_GPOUT3_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_GPOUT3_CTRL_ENABLE()
    {
        CLK_GPOUT3_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT3_CTRL's DC50 bit.
     */
    bool get_CLK_GPOUT3_CTRL_DC50()
    {
        return CLK_GPOUT3_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's DC50 bit.
     */
    inline void set_CLK_GPOUT3_CTRL_DC50()
    {
        CLK_GPOUT3_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's DC50 bit.
     */
    inline void clear_CLK_GPOUT3_CTRL_DC50()
    {
        CLK_GPOUT3_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's DC50 bit.
     */
    inline void toggle_CLK_GPOUT3_CTRL_DC50()
    {
        CLK_GPOUT3_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT3_CTRL's PHASE field.
     */
    uint8_t get_CLK_GPOUT3_CTRL_PHASE()
    {
        return (CLK_GPOUT3_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT3_CTRL's PHASE field.
     */
    inline void set_CLK_GPOUT3_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT3_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT3_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT3_CTRL's NUDGE bit.
     */
    bool get_CLK_GPOUT3_CTRL_NUDGE()
    {
        return CLK_GPOUT3_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's NUDGE bit.
     */
    inline void set_CLK_GPOUT3_CTRL_NUDGE()
    {
        CLK_GPOUT3_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's NUDGE bit.
     */
    inline void clear_CLK_GPOUT3_CTRL_NUDGE()
    {
        CLK_GPOUT3_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_GPOUT3_CTRL_NUDGE()
    {
        CLK_GPOUT3_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_GPOUT3_DIV's FRAC field.
     */
    uint8_t get_CLK_GPOUT3_DIV_FRAC()
    {
        return (CLK_GPOUT3_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT3_DIV's FRAC field.
     */
    inline void set_CLK_GPOUT3_DIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLK_GPOUT3_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT3_DIV = curr;
    }

    /**
     * Get CLK_GPOUT3_DIV's INT field.
     */
    uint32_t get_CLK_GPOUT3_DIV_INT()
    {
        return (CLK_GPOUT3_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT3_DIV's INT field.
     */
    inline void set_CLK_GPOUT3_DIV_INT(uint32_t value)
    {
        uint32_t curr = CLK_GPOUT3_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT3_DIV = curr;
    }

    /**
     * Get CLK_REF_CTRL's SRC field.
     */
    CLOCKS_CLK_REF_CTRL_SRC get_CLK_REF_CTRL_SRC()
    {
        return CLOCKS_CLK_REF_CTRL_SRC((CLK_REF_CTRL >> 0u) & 0b11u);
    }

    /**
     * Set CLK_REF_CTRL's SRC field.
     */
    inline void set_CLK_REF_CTRL_SRC(CLOCKS_CLK_REF_CTRL_SRC value)
    {
        uint32_t curr = CLK_REF_CTRL;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CLK_REF_CTRL = curr;
    }

    /**
     * Get CLK_REF_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_REF_CTRL_AUXSRC get_CLK_REF_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_REF_CTRL_AUXSRC((CLK_REF_CTRL >> 5u) & 0b11u);
    }

    /**
     * Set CLK_REF_CTRL's AUXSRC field.
     */
    inline void set_CLK_REF_CTRL_AUXSRC(CLOCKS_CLK_REF_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_REF_CTRL;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        CLK_REF_CTRL = curr;
    }

    /**
     * Get CLK_REF_DIV's INT field.
     */
    uint8_t get_CLK_REF_DIV_INT()
    {
        return (CLK_REF_DIV >> 8u) & 0b11u;
    }

    /**
     * Set CLK_REF_DIV's INT field.
     */
    inline void set_CLK_REF_DIV_INT(uint8_t value)
    {
        uint32_t curr = CLK_REF_DIV;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        CLK_REF_DIV = curr;
    }

    /**
     * Get CLK_SYS_CTRL's SRC bit.
     */
    CLOCKS_CLK_SYS_CTRL_SRC get_CLK_SYS_CTRL_SRC()
    {
        return CLOCKS_CLK_SYS_CTRL_SRC(CLK_SYS_CTRL & (1u << 0u));
    }

    /**
     * Set CLK_SYS_CTRL's SRC bit.
     */
    inline void set_CLK_SYS_CTRL_SRC()
    {
        CLK_SYS_CTRL |= 1u << 0u;
    }

    /**
     * Clear CLK_SYS_CTRL's SRC bit.
     */
    inline void clear_CLK_SYS_CTRL_SRC()
    {
        CLK_SYS_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CLK_SYS_CTRL's SRC bit.
     */
    inline void toggle_CLK_SYS_CTRL_SRC()
    {
        CLK_SYS_CTRL ^= 1u << 0u;
    }

    /**
     * Get CLK_SYS_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_SYS_CTRL_AUXSRC get_CLK_SYS_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_SYS_CTRL_AUXSRC((CLK_SYS_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_SYS_CTRL's AUXSRC field.
     */
    inline void set_CLK_SYS_CTRL_AUXSRC(CLOCKS_CLK_SYS_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_SYS_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_SYS_CTRL = curr;
    }

    /**
     * Get CLK_SYS_DIV's FRAC field.
     */
    uint8_t get_CLK_SYS_DIV_FRAC()
    {
        return (CLK_SYS_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_SYS_DIV's FRAC field.
     */
    inline void set_CLK_SYS_DIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLK_SYS_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_SYS_DIV = curr;
    }

    /**
     * Get CLK_SYS_DIV's INT field.
     */
    uint32_t get_CLK_SYS_DIV_INT()
    {
        return (CLK_SYS_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_SYS_DIV's INT field.
     */
    inline void set_CLK_SYS_DIV_INT(uint32_t value)
    {
        uint32_t curr = CLK_SYS_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_SYS_DIV = curr;
    }

    /**
     * Get CLK_PERI_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_PERI_CTRL_AUXSRC get_CLK_PERI_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_PERI_CTRL_AUXSRC((CLK_PERI_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_PERI_CTRL's AUXSRC field.
     */
    inline void set_CLK_PERI_CTRL_AUXSRC(CLOCKS_CLK_PERI_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_PERI_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_PERI_CTRL = curr;
    }

    /**
     * Get CLK_PERI_CTRL's KILL bit.
     */
    bool get_CLK_PERI_CTRL_KILL()
    {
        return CLK_PERI_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_PERI_CTRL's KILL bit.
     */
    inline void set_CLK_PERI_CTRL_KILL()
    {
        CLK_PERI_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_PERI_CTRL's KILL bit.
     */
    inline void clear_CLK_PERI_CTRL_KILL()
    {
        CLK_PERI_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_PERI_CTRL's KILL bit.
     */
    inline void toggle_CLK_PERI_CTRL_KILL()
    {
        CLK_PERI_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_PERI_CTRL's ENABLE bit.
     */
    bool get_CLK_PERI_CTRL_ENABLE()
    {
        return CLK_PERI_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_PERI_CTRL's ENABLE bit.
     */
    inline void set_CLK_PERI_CTRL_ENABLE()
    {
        CLK_PERI_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_PERI_CTRL's ENABLE bit.
     */
    inline void clear_CLK_PERI_CTRL_ENABLE()
    {
        CLK_PERI_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_PERI_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_PERI_CTRL_ENABLE()
    {
        CLK_PERI_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_USB_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_USB_CTRL_AUXSRC get_CLK_USB_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_USB_CTRL_AUXSRC((CLK_USB_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_USB_CTRL's AUXSRC field.
     */
    inline void set_CLK_USB_CTRL_AUXSRC(CLOCKS_CLK_USB_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_USB_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_USB_CTRL = curr;
    }

    /**
     * Get CLK_USB_CTRL's KILL bit.
     */
    bool get_CLK_USB_CTRL_KILL()
    {
        return CLK_USB_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_USB_CTRL's KILL bit.
     */
    inline void set_CLK_USB_CTRL_KILL()
    {
        CLK_USB_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_USB_CTRL's KILL bit.
     */
    inline void clear_CLK_USB_CTRL_KILL()
    {
        CLK_USB_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_USB_CTRL's KILL bit.
     */
    inline void toggle_CLK_USB_CTRL_KILL()
    {
        CLK_USB_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_USB_CTRL's ENABLE bit.
     */
    bool get_CLK_USB_CTRL_ENABLE()
    {
        return CLK_USB_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_USB_CTRL's ENABLE bit.
     */
    inline void set_CLK_USB_CTRL_ENABLE()
    {
        CLK_USB_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_USB_CTRL's ENABLE bit.
     */
    inline void clear_CLK_USB_CTRL_ENABLE()
    {
        CLK_USB_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_USB_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_USB_CTRL_ENABLE()
    {
        CLK_USB_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_USB_CTRL's PHASE field.
     */
    uint8_t get_CLK_USB_CTRL_PHASE()
    {
        return (CLK_USB_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_USB_CTRL's PHASE field.
     */
    inline void set_CLK_USB_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_USB_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_USB_CTRL = curr;
    }

    /**
     * Get CLK_USB_CTRL's NUDGE bit.
     */
    bool get_CLK_USB_CTRL_NUDGE()
    {
        return CLK_USB_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_USB_CTRL's NUDGE bit.
     */
    inline void set_CLK_USB_CTRL_NUDGE()
    {
        CLK_USB_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_USB_CTRL's NUDGE bit.
     */
    inline void clear_CLK_USB_CTRL_NUDGE()
    {
        CLK_USB_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_USB_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_USB_CTRL_NUDGE()
    {
        CLK_USB_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_USB_DIV's INT field.
     */
    uint8_t get_CLK_USB_DIV_INT()
    {
        return (CLK_USB_DIV >> 8u) & 0b11u;
    }

    /**
     * Set CLK_USB_DIV's INT field.
     */
    inline void set_CLK_USB_DIV_INT(uint8_t value)
    {
        uint32_t curr = CLK_USB_DIV;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        CLK_USB_DIV = curr;
    }

    /**
     * Get CLK_ADC_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_ADC_CTRL_AUXSRC get_CLK_ADC_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_ADC_CTRL_AUXSRC((CLK_ADC_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_ADC_CTRL's AUXSRC field.
     */
    inline void set_CLK_ADC_CTRL_AUXSRC(CLOCKS_CLK_ADC_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_ADC_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_ADC_CTRL = curr;
    }

    /**
     * Get CLK_ADC_CTRL's KILL bit.
     */
    bool get_CLK_ADC_CTRL_KILL()
    {
        return CLK_ADC_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_ADC_CTRL's KILL bit.
     */
    inline void set_CLK_ADC_CTRL_KILL()
    {
        CLK_ADC_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_ADC_CTRL's KILL bit.
     */
    inline void clear_CLK_ADC_CTRL_KILL()
    {
        CLK_ADC_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_ADC_CTRL's KILL bit.
     */
    inline void toggle_CLK_ADC_CTRL_KILL()
    {
        CLK_ADC_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_ADC_CTRL's ENABLE bit.
     */
    bool get_CLK_ADC_CTRL_ENABLE()
    {
        return CLK_ADC_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_ADC_CTRL's ENABLE bit.
     */
    inline void set_CLK_ADC_CTRL_ENABLE()
    {
        CLK_ADC_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_ADC_CTRL's ENABLE bit.
     */
    inline void clear_CLK_ADC_CTRL_ENABLE()
    {
        CLK_ADC_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_ADC_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_ADC_CTRL_ENABLE()
    {
        CLK_ADC_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_ADC_CTRL's PHASE field.
     */
    uint8_t get_CLK_ADC_CTRL_PHASE()
    {
        return (CLK_ADC_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_ADC_CTRL's PHASE field.
     */
    inline void set_CLK_ADC_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_ADC_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_ADC_CTRL = curr;
    }

    /**
     * Get CLK_ADC_CTRL's NUDGE bit.
     */
    bool get_CLK_ADC_CTRL_NUDGE()
    {
        return CLK_ADC_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_ADC_CTRL's NUDGE bit.
     */
    inline void set_CLK_ADC_CTRL_NUDGE()
    {
        CLK_ADC_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_ADC_CTRL's NUDGE bit.
     */
    inline void clear_CLK_ADC_CTRL_NUDGE()
    {
        CLK_ADC_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_ADC_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_ADC_CTRL_NUDGE()
    {
        CLK_ADC_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_ADC_DIV's INT field.
     */
    uint8_t get_CLK_ADC_DIV_INT()
    {
        return (CLK_ADC_DIV >> 8u) & 0b11u;
    }

    /**
     * Set CLK_ADC_DIV's INT field.
     */
    inline void set_CLK_ADC_DIV_INT(uint8_t value)
    {
        uint32_t curr = CLK_ADC_DIV;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        CLK_ADC_DIV = curr;
    }

    /**
     * Get CLK_RTC_CTRL's AUXSRC field.
     */
    CLOCKS_CLK_RTC_CTRL_AUXSRC get_CLK_RTC_CTRL_AUXSRC()
    {
        return CLOCKS_CLK_RTC_CTRL_AUXSRC((CLK_RTC_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_RTC_CTRL's AUXSRC field.
     */
    inline void set_CLK_RTC_CTRL_AUXSRC(CLOCKS_CLK_RTC_CTRL_AUXSRC value)
    {
        uint32_t curr = CLK_RTC_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_RTC_CTRL = curr;
    }

    /**
     * Get CLK_RTC_CTRL's KILL bit.
     */
    bool get_CLK_RTC_CTRL_KILL()
    {
        return CLK_RTC_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_RTC_CTRL's KILL bit.
     */
    inline void set_CLK_RTC_CTRL_KILL()
    {
        CLK_RTC_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_RTC_CTRL's KILL bit.
     */
    inline void clear_CLK_RTC_CTRL_KILL()
    {
        CLK_RTC_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_RTC_CTRL's KILL bit.
     */
    inline void toggle_CLK_RTC_CTRL_KILL()
    {
        CLK_RTC_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_RTC_CTRL's ENABLE bit.
     */
    bool get_CLK_RTC_CTRL_ENABLE()
    {
        return CLK_RTC_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_RTC_CTRL's ENABLE bit.
     */
    inline void set_CLK_RTC_CTRL_ENABLE()
    {
        CLK_RTC_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_RTC_CTRL's ENABLE bit.
     */
    inline void clear_CLK_RTC_CTRL_ENABLE()
    {
        CLK_RTC_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_RTC_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_RTC_CTRL_ENABLE()
    {
        CLK_RTC_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_RTC_CTRL's PHASE field.
     */
    uint8_t get_CLK_RTC_CTRL_PHASE()
    {
        return (CLK_RTC_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_RTC_CTRL's PHASE field.
     */
    inline void set_CLK_RTC_CTRL_PHASE(uint8_t value)
    {
        uint32_t curr = CLK_RTC_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_RTC_CTRL = curr;
    }

    /**
     * Get CLK_RTC_CTRL's NUDGE bit.
     */
    bool get_CLK_RTC_CTRL_NUDGE()
    {
        return CLK_RTC_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_RTC_CTRL's NUDGE bit.
     */
    inline void set_CLK_RTC_CTRL_NUDGE()
    {
        CLK_RTC_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_RTC_CTRL's NUDGE bit.
     */
    inline void clear_CLK_RTC_CTRL_NUDGE()
    {
        CLK_RTC_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_RTC_CTRL's NUDGE bit.
     */
    inline void toggle_CLK_RTC_CTRL_NUDGE()
    {
        CLK_RTC_CTRL ^= 1u << 20u;
    }

    /**
     * Get CLK_RTC_DIV's FRAC field.
     */
    uint8_t get_CLK_RTC_DIV_FRAC()
    {
        return (CLK_RTC_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_RTC_DIV's FRAC field.
     */
    inline void set_CLK_RTC_DIV_FRAC(uint8_t value)
    {
        uint32_t curr = CLK_RTC_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_RTC_DIV = curr;
    }

    /**
     * Get CLK_RTC_DIV's INT field.
     */
    uint32_t get_CLK_RTC_DIV_INT()
    {
        return (CLK_RTC_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_RTC_DIV's INT field.
     */
    inline void set_CLK_RTC_DIV_INT(uint32_t value)
    {
        uint32_t curr = CLK_RTC_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_RTC_DIV = curr;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's TIMEOUT field.
     */
    uint8_t get_CLK_SYS_RESUS_CTRL_TIMEOUT()
    {
        return (CLK_SYS_RESUS_CTRL >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's TIMEOUT field.
     */
    inline void set_CLK_SYS_RESUS_CTRL_TIMEOUT(uint8_t value)
    {
        uint32_t curr = CLK_SYS_RESUS_CTRL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_SYS_RESUS_CTRL = curr;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's ENABLE bit.
     */
    bool get_CLK_SYS_RESUS_CTRL_ENABLE()
    {
        return CLK_SYS_RESUS_CTRL & (1u << 8u);
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's ENABLE bit.
     */
    inline void set_CLK_SYS_RESUS_CTRL_ENABLE()
    {
        CLK_SYS_RESUS_CTRL |= 1u << 8u;
    }

    /**
     * Clear CLK_SYS_RESUS_CTRL's ENABLE bit.
     */
    inline void clear_CLK_SYS_RESUS_CTRL_ENABLE()
    {
        CLK_SYS_RESUS_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CLK_SYS_RESUS_CTRL's ENABLE bit.
     */
    inline void toggle_CLK_SYS_RESUS_CTRL_ENABLE()
    {
        CLK_SYS_RESUS_CTRL ^= 1u << 8u;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's FRCE bit.
     */
    bool get_CLK_SYS_RESUS_CTRL_FRCE()
    {
        return CLK_SYS_RESUS_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's FRCE bit.
     */
    inline void set_CLK_SYS_RESUS_CTRL_FRCE()
    {
        CLK_SYS_RESUS_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_SYS_RESUS_CTRL's FRCE bit.
     */
    inline void clear_CLK_SYS_RESUS_CTRL_FRCE()
    {
        CLK_SYS_RESUS_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_SYS_RESUS_CTRL's FRCE bit.
     */
    inline void toggle_CLK_SYS_RESUS_CTRL_FRCE()
    {
        CLK_SYS_RESUS_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's CLEAR bit.
     */
    bool get_CLK_SYS_RESUS_CTRL_CLEAR()
    {
        return CLK_SYS_RESUS_CTRL & (1u << 16u);
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's CLEAR bit.
     */
    inline void set_CLK_SYS_RESUS_CTRL_CLEAR()
    {
        CLK_SYS_RESUS_CTRL |= 1u << 16u;
    }

    /**
     * Clear CLK_SYS_RESUS_CTRL's CLEAR bit.
     */
    inline void clear_CLK_SYS_RESUS_CTRL_CLEAR()
    {
        CLK_SYS_RESUS_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CLK_SYS_RESUS_CTRL's CLEAR bit.
     */
    inline void toggle_CLK_SYS_RESUS_CTRL_CLEAR()
    {
        CLK_SYS_RESUS_CTRL ^= 1u << 16u;
    }

    /**
     * Get CLK_SYS_RESUS_STATUS's RESUSSED bit.
     */
    bool get_CLK_SYS_RESUS_STATUS_RESUSSED()
    {
        return CLK_SYS_RESUS_STATUS & (1u << 0u);
    }

    /**
     * Get FC0_REF_KHZ's FC0_REF_KHZ field.
     */
    uint32_t get_FC0_REF_KHZ_FC0_REF_KHZ()
    {
        return (FC0_REF_KHZ >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set FC0_REF_KHZ's FC0_REF_KHZ field.
     */
    inline void set_FC0_REF_KHZ_FC0_REF_KHZ(uint32_t value)
    {
        uint32_t curr = FC0_REF_KHZ;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111u) << 0u;

        FC0_REF_KHZ = curr;
    }

    /**
     * Get FC0_MIN_KHZ's FC0_MIN_KHZ field.
     */
    uint32_t get_FC0_MIN_KHZ_FC0_MIN_KHZ()
    {
        return (FC0_MIN_KHZ >> 0u) & 0b1111111111111111111111111u;
    }

    /**
     * Set FC0_MIN_KHZ's FC0_MIN_KHZ field.
     */
    inline void set_FC0_MIN_KHZ_FC0_MIN_KHZ(uint32_t value)
    {
        uint32_t curr = FC0_MIN_KHZ;

        curr &= ~(0b1111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111u) << 0u;

        FC0_MIN_KHZ = curr;
    }

    /**
     * Get FC0_MAX_KHZ's FC0_MAX_KHZ field.
     */
    uint32_t get_FC0_MAX_KHZ_FC0_MAX_KHZ()
    {
        return (FC0_MAX_KHZ >> 0u) & 0b1111111111111111111111111u;
    }

    /**
     * Set FC0_MAX_KHZ's FC0_MAX_KHZ field.
     */
    inline void set_FC0_MAX_KHZ_FC0_MAX_KHZ(uint32_t value)
    {
        uint32_t curr = FC0_MAX_KHZ;

        curr &= ~(0b1111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111u) << 0u;

        FC0_MAX_KHZ = curr;
    }

    /**
     * Get FC0_DELAY's FC0_DELAY field.
     */
    uint8_t get_FC0_DELAY_FC0_DELAY()
    {
        return (FC0_DELAY >> 0u) & 0b111u;
    }

    /**
     * Set FC0_DELAY's FC0_DELAY field.
     */
    inline void set_FC0_DELAY_FC0_DELAY(uint8_t value)
    {
        uint32_t curr = FC0_DELAY;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        FC0_DELAY = curr;
    }

    /**
     * Get FC0_INTERVAL's FC0_INTERVAL field.
     */
    uint8_t get_FC0_INTERVAL_FC0_INTERVAL()
    {
        return (FC0_INTERVAL >> 0u) & 0b1111u;
    }

    /**
     * Set FC0_INTERVAL's FC0_INTERVAL field.
     */
    inline void set_FC0_INTERVAL_FC0_INTERVAL(uint8_t value)
    {
        uint32_t curr = FC0_INTERVAL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FC0_INTERVAL = curr;
    }

    /**
     * Get FC0_SRC's FC0_SRC field.
     */
    CLOCKS_FC0_SRC_FC0_SRC get_FC0_SRC_FC0_SRC()
    {
        return CLOCKS_FC0_SRC_FC0_SRC((FC0_SRC >> 0u) & 0b11111111u);
    }

    /**
     * Set FC0_SRC's FC0_SRC field.
     */
    inline void set_FC0_SRC_FC0_SRC(CLOCKS_FC0_SRC_FC0_SRC value)
    {
        uint32_t curr = FC0_SRC;

        curr &= ~(0b11111111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 0u;

        FC0_SRC = curr;
    }

    /**
     * Get FC0_STATUS's PASS bit.
     */
    bool get_FC0_STATUS_PASS()
    {
        return FC0_STATUS & (1u << 0u);
    }

    /**
     * Get FC0_STATUS's DONE bit.
     */
    bool get_FC0_STATUS_DONE()
    {
        return FC0_STATUS & (1u << 4u);
    }

    /**
     * Get FC0_STATUS's RUNNING bit.
     */
    bool get_FC0_STATUS_RUNNING()
    {
        return FC0_STATUS & (1u << 8u);
    }

    /**
     * Get FC0_STATUS's WAITING bit.
     */
    bool get_FC0_STATUS_WAITING()
    {
        return FC0_STATUS & (1u << 12u);
    }

    /**
     * Get FC0_STATUS's FAIL bit.
     */
    bool get_FC0_STATUS_FAIL()
    {
        return FC0_STATUS & (1u << 16u);
    }

    /**
     * Get FC0_STATUS's SLOW bit.
     */
    bool get_FC0_STATUS_SLOW()
    {
        return FC0_STATUS & (1u << 20u);
    }

    /**
     * Get FC0_STATUS's FAST bit.
     */
    bool get_FC0_STATUS_FAST()
    {
        return FC0_STATUS & (1u << 24u);
    }

    /**
     * Get FC0_STATUS's DIED bit.
     */
    bool get_FC0_STATUS_DIED()
    {
        return FC0_STATUS & (1u << 28u);
    }

    /**
     * Get FC0_RESULT's FRAC field.
     */
    uint8_t get_FC0_RESULT_FRAC()
    {
        return (FC0_RESULT >> 0u) & 0b11111u;
    }

    /**
     * Get FC0_RESULT's KHZ field.
     */
    uint32_t get_FC0_RESULT_KHZ()
    {
        return (FC0_RESULT >> 5u) & 0b1111111111111111111111111u;
    }

    /**
     * Get WAKE_EN0's clk_sys_clocks bit.
     */
    bool get_WAKE_EN0_clk_sys_clocks()
    {
        return WAKE_EN0 & (1u << 0u);
    }

    /**
     * Set WAKE_EN0's clk_sys_clocks bit.
     */
    inline void set_WAKE_EN0_clk_sys_clocks()
    {
        WAKE_EN0 |= 1u << 0u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_clocks bit.
     */
    inline void clear_WAKE_EN0_clk_sys_clocks()
    {
        WAKE_EN0 &= ~(1u << 0u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_clocks bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_clocks()
    {
        WAKE_EN0 ^= 1u << 0u;
    }

    /**
     * Get WAKE_EN0's clk_adc_adc bit.
     */
    bool get_WAKE_EN0_clk_adc_adc()
    {
        return WAKE_EN0 & (1u << 1u);
    }

    /**
     * Set WAKE_EN0's clk_adc_adc bit.
     */
    inline void set_WAKE_EN0_clk_adc_adc()
    {
        WAKE_EN0 |= 1u << 1u;
    }

    /**
     * Clear WAKE_EN0's clk_adc_adc bit.
     */
    inline void clear_WAKE_EN0_clk_adc_adc()
    {
        WAKE_EN0 &= ~(1u << 1u);
    }

    /**
     * Toggle WAKE_EN0's clk_adc_adc bit.
     */
    inline void toggle_WAKE_EN0_clk_adc_adc()
    {
        WAKE_EN0 ^= 1u << 1u;
    }

    /**
     * Get WAKE_EN0's clk_sys_adc bit.
     */
    bool get_WAKE_EN0_clk_sys_adc()
    {
        return WAKE_EN0 & (1u << 2u);
    }

    /**
     * Set WAKE_EN0's clk_sys_adc bit.
     */
    inline void set_WAKE_EN0_clk_sys_adc()
    {
        WAKE_EN0 |= 1u << 2u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_adc bit.
     */
    inline void clear_WAKE_EN0_clk_sys_adc()
    {
        WAKE_EN0 &= ~(1u << 2u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_adc bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_adc()
    {
        WAKE_EN0 ^= 1u << 2u;
    }

    /**
     * Get WAKE_EN0's clk_sys_busctrl bit.
     */
    bool get_WAKE_EN0_clk_sys_busctrl()
    {
        return WAKE_EN0 & (1u << 3u);
    }

    /**
     * Set WAKE_EN0's clk_sys_busctrl bit.
     */
    inline void set_WAKE_EN0_clk_sys_busctrl()
    {
        WAKE_EN0 |= 1u << 3u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_busctrl bit.
     */
    inline void clear_WAKE_EN0_clk_sys_busctrl()
    {
        WAKE_EN0 &= ~(1u << 3u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_busctrl bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_busctrl()
    {
        WAKE_EN0 ^= 1u << 3u;
    }

    /**
     * Get WAKE_EN0's clk_sys_busfabric bit.
     */
    bool get_WAKE_EN0_clk_sys_busfabric()
    {
        return WAKE_EN0 & (1u << 4u);
    }

    /**
     * Set WAKE_EN0's clk_sys_busfabric bit.
     */
    inline void set_WAKE_EN0_clk_sys_busfabric()
    {
        WAKE_EN0 |= 1u << 4u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_busfabric bit.
     */
    inline void clear_WAKE_EN0_clk_sys_busfabric()
    {
        WAKE_EN0 &= ~(1u << 4u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_busfabric bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_busfabric()
    {
        WAKE_EN0 ^= 1u << 4u;
    }

    /**
     * Get WAKE_EN0's clk_sys_dma bit.
     */
    bool get_WAKE_EN0_clk_sys_dma()
    {
        return WAKE_EN0 & (1u << 5u);
    }

    /**
     * Set WAKE_EN0's clk_sys_dma bit.
     */
    inline void set_WAKE_EN0_clk_sys_dma()
    {
        WAKE_EN0 |= 1u << 5u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_dma bit.
     */
    inline void clear_WAKE_EN0_clk_sys_dma()
    {
        WAKE_EN0 &= ~(1u << 5u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_dma bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_dma()
    {
        WAKE_EN0 ^= 1u << 5u;
    }

    /**
     * Get WAKE_EN0's clk_sys_i2c0 bit.
     */
    bool get_WAKE_EN0_clk_sys_i2c0()
    {
        return WAKE_EN0 & (1u << 6u);
    }

    /**
     * Set WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_i2c0()
    {
        WAKE_EN0 |= 1u << 6u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_i2c0()
    {
        WAKE_EN0 &= ~(1u << 6u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_i2c0()
    {
        WAKE_EN0 ^= 1u << 6u;
    }

    /**
     * Get WAKE_EN0's clk_sys_i2c1 bit.
     */
    bool get_WAKE_EN0_clk_sys_i2c1()
    {
        return WAKE_EN0 & (1u << 7u);
    }

    /**
     * Set WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_i2c1()
    {
        WAKE_EN0 |= 1u << 7u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_i2c1()
    {
        WAKE_EN0 &= ~(1u << 7u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_i2c1()
    {
        WAKE_EN0 ^= 1u << 7u;
    }

    /**
     * Get WAKE_EN0's clk_sys_io bit.
     */
    bool get_WAKE_EN0_clk_sys_io()
    {
        return WAKE_EN0 & (1u << 8u);
    }

    /**
     * Set WAKE_EN0's clk_sys_io bit.
     */
    inline void set_WAKE_EN0_clk_sys_io()
    {
        WAKE_EN0 |= 1u << 8u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_io bit.
     */
    inline void clear_WAKE_EN0_clk_sys_io()
    {
        WAKE_EN0 &= ~(1u << 8u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_io bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_io()
    {
        WAKE_EN0 ^= 1u << 8u;
    }

    /**
     * Get WAKE_EN0's clk_sys_jtag bit.
     */
    bool get_WAKE_EN0_clk_sys_jtag()
    {
        return WAKE_EN0 & (1u << 9u);
    }

    /**
     * Set WAKE_EN0's clk_sys_jtag bit.
     */
    inline void set_WAKE_EN0_clk_sys_jtag()
    {
        WAKE_EN0 |= 1u << 9u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_jtag bit.
     */
    inline void clear_WAKE_EN0_clk_sys_jtag()
    {
        WAKE_EN0 &= ~(1u << 9u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_jtag bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_jtag()
    {
        WAKE_EN0 ^= 1u << 9u;
    }

    /**
     * Get WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    bool get_WAKE_EN0_clk_sys_vreg_and_chip_reset()
    {
        return WAKE_EN0 & (1u << 10u);
    }

    /**
     * Set WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void set_WAKE_EN0_clk_sys_vreg_and_chip_reset()
    {
        WAKE_EN0 |= 1u << 10u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void clear_WAKE_EN0_clk_sys_vreg_and_chip_reset()
    {
        WAKE_EN0 &= ~(1u << 10u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_vreg_and_chip_reset()
    {
        WAKE_EN0 ^= 1u << 10u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pads bit.
     */
    bool get_WAKE_EN0_clk_sys_pads()
    {
        return WAKE_EN0 & (1u << 11u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pads bit.
     */
    inline void set_WAKE_EN0_clk_sys_pads()
    {
        WAKE_EN0 |= 1u << 11u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pads bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pads()
    {
        WAKE_EN0 &= ~(1u << 11u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pads bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pads()
    {
        WAKE_EN0 ^= 1u << 11u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pio0 bit.
     */
    bool get_WAKE_EN0_clk_sys_pio0()
    {
        return WAKE_EN0 & (1u << 12u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pio0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_pio0()
    {
        WAKE_EN0 |= 1u << 12u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pio0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pio0()
    {
        WAKE_EN0 &= ~(1u << 12u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pio0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pio0()
    {
        WAKE_EN0 ^= 1u << 12u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pio1 bit.
     */
    bool get_WAKE_EN0_clk_sys_pio1()
    {
        return WAKE_EN0 & (1u << 13u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pio1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_pio1()
    {
        WAKE_EN0 |= 1u << 13u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pio1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pio1()
    {
        WAKE_EN0 &= ~(1u << 13u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pio1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pio1()
    {
        WAKE_EN0 ^= 1u << 13u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pll_sys bit.
     */
    bool get_WAKE_EN0_clk_sys_pll_sys()
    {
        return WAKE_EN0 & (1u << 14u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline void set_WAKE_EN0_clk_sys_pll_sys()
    {
        WAKE_EN0 |= 1u << 14u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pll_sys()
    {
        WAKE_EN0 &= ~(1u << 14u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pll_sys()
    {
        WAKE_EN0 ^= 1u << 14u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pll_usb bit.
     */
    bool get_WAKE_EN0_clk_sys_pll_usb()
    {
        return WAKE_EN0 & (1u << 15u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline void set_WAKE_EN0_clk_sys_pll_usb()
    {
        WAKE_EN0 |= 1u << 15u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pll_usb()
    {
        WAKE_EN0 &= ~(1u << 15u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pll_usb()
    {
        WAKE_EN0 ^= 1u << 15u;
    }

    /**
     * Get WAKE_EN0's clk_sys_psm bit.
     */
    bool get_WAKE_EN0_clk_sys_psm()
    {
        return WAKE_EN0 & (1u << 16u);
    }

    /**
     * Set WAKE_EN0's clk_sys_psm bit.
     */
    inline void set_WAKE_EN0_clk_sys_psm()
    {
        WAKE_EN0 |= 1u << 16u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_psm bit.
     */
    inline void clear_WAKE_EN0_clk_sys_psm()
    {
        WAKE_EN0 &= ~(1u << 16u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_psm bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_psm()
    {
        WAKE_EN0 ^= 1u << 16u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pwm bit.
     */
    bool get_WAKE_EN0_clk_sys_pwm()
    {
        return WAKE_EN0 & (1u << 17u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pwm bit.
     */
    inline void set_WAKE_EN0_clk_sys_pwm()
    {
        WAKE_EN0 |= 1u << 17u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pwm bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pwm()
    {
        WAKE_EN0 &= ~(1u << 17u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pwm bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pwm()
    {
        WAKE_EN0 ^= 1u << 17u;
    }

    /**
     * Get WAKE_EN0's clk_sys_resets bit.
     */
    bool get_WAKE_EN0_clk_sys_resets()
    {
        return WAKE_EN0 & (1u << 18u);
    }

    /**
     * Set WAKE_EN0's clk_sys_resets bit.
     */
    inline void set_WAKE_EN0_clk_sys_resets()
    {
        WAKE_EN0 |= 1u << 18u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_resets bit.
     */
    inline void clear_WAKE_EN0_clk_sys_resets()
    {
        WAKE_EN0 &= ~(1u << 18u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_resets bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_resets()
    {
        WAKE_EN0 ^= 1u << 18u;
    }

    /**
     * Get WAKE_EN0's clk_sys_rom bit.
     */
    bool get_WAKE_EN0_clk_sys_rom()
    {
        return WAKE_EN0 & (1u << 19u);
    }

    /**
     * Set WAKE_EN0's clk_sys_rom bit.
     */
    inline void set_WAKE_EN0_clk_sys_rom()
    {
        WAKE_EN0 |= 1u << 19u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_rom bit.
     */
    inline void clear_WAKE_EN0_clk_sys_rom()
    {
        WAKE_EN0 &= ~(1u << 19u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_rom bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_rom()
    {
        WAKE_EN0 ^= 1u << 19u;
    }

    /**
     * Get WAKE_EN0's clk_sys_rosc bit.
     */
    bool get_WAKE_EN0_clk_sys_rosc()
    {
        return WAKE_EN0 & (1u << 20u);
    }

    /**
     * Set WAKE_EN0's clk_sys_rosc bit.
     */
    inline void set_WAKE_EN0_clk_sys_rosc()
    {
        WAKE_EN0 |= 1u << 20u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_rosc bit.
     */
    inline void clear_WAKE_EN0_clk_sys_rosc()
    {
        WAKE_EN0 &= ~(1u << 20u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_rosc bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_rosc()
    {
        WAKE_EN0 ^= 1u << 20u;
    }

    /**
     * Get WAKE_EN0's clk_rtc_rtc bit.
     */
    bool get_WAKE_EN0_clk_rtc_rtc()
    {
        return WAKE_EN0 & (1u << 21u);
    }

    /**
     * Set WAKE_EN0's clk_rtc_rtc bit.
     */
    inline void set_WAKE_EN0_clk_rtc_rtc()
    {
        WAKE_EN0 |= 1u << 21u;
    }

    /**
     * Clear WAKE_EN0's clk_rtc_rtc bit.
     */
    inline void clear_WAKE_EN0_clk_rtc_rtc()
    {
        WAKE_EN0 &= ~(1u << 21u);
    }

    /**
     * Toggle WAKE_EN0's clk_rtc_rtc bit.
     */
    inline void toggle_WAKE_EN0_clk_rtc_rtc()
    {
        WAKE_EN0 ^= 1u << 21u;
    }

    /**
     * Get WAKE_EN0's clk_sys_rtc bit.
     */
    bool get_WAKE_EN0_clk_sys_rtc()
    {
        return WAKE_EN0 & (1u << 22u);
    }

    /**
     * Set WAKE_EN0's clk_sys_rtc bit.
     */
    inline void set_WAKE_EN0_clk_sys_rtc()
    {
        WAKE_EN0 |= 1u << 22u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_rtc bit.
     */
    inline void clear_WAKE_EN0_clk_sys_rtc()
    {
        WAKE_EN0 &= ~(1u << 22u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_rtc bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_rtc()
    {
        WAKE_EN0 ^= 1u << 22u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sio bit.
     */
    bool get_WAKE_EN0_clk_sys_sio()
    {
        return WAKE_EN0 & (1u << 23u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sio bit.
     */
    inline void set_WAKE_EN0_clk_sys_sio()
    {
        WAKE_EN0 |= 1u << 23u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sio bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sio()
    {
        WAKE_EN0 &= ~(1u << 23u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sio bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sio()
    {
        WAKE_EN0 ^= 1u << 23u;
    }

    /**
     * Get WAKE_EN0's clk_peri_spi0 bit.
     */
    bool get_WAKE_EN0_clk_peri_spi0()
    {
        return WAKE_EN0 & (1u << 24u);
    }

    /**
     * Set WAKE_EN0's clk_peri_spi0 bit.
     */
    inline void set_WAKE_EN0_clk_peri_spi0()
    {
        WAKE_EN0 |= 1u << 24u;
    }

    /**
     * Clear WAKE_EN0's clk_peri_spi0 bit.
     */
    inline void clear_WAKE_EN0_clk_peri_spi0()
    {
        WAKE_EN0 &= ~(1u << 24u);
    }

    /**
     * Toggle WAKE_EN0's clk_peri_spi0 bit.
     */
    inline void toggle_WAKE_EN0_clk_peri_spi0()
    {
        WAKE_EN0 ^= 1u << 24u;
    }

    /**
     * Get WAKE_EN0's clk_sys_spi0 bit.
     */
    bool get_WAKE_EN0_clk_sys_spi0()
    {
        return WAKE_EN0 & (1u << 25u);
    }

    /**
     * Set WAKE_EN0's clk_sys_spi0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_spi0()
    {
        WAKE_EN0 |= 1u << 25u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_spi0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_spi0()
    {
        WAKE_EN0 &= ~(1u << 25u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_spi0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_spi0()
    {
        WAKE_EN0 ^= 1u << 25u;
    }

    /**
     * Get WAKE_EN0's clk_peri_spi1 bit.
     */
    bool get_WAKE_EN0_clk_peri_spi1()
    {
        return WAKE_EN0 & (1u << 26u);
    }

    /**
     * Set WAKE_EN0's clk_peri_spi1 bit.
     */
    inline void set_WAKE_EN0_clk_peri_spi1()
    {
        WAKE_EN0 |= 1u << 26u;
    }

    /**
     * Clear WAKE_EN0's clk_peri_spi1 bit.
     */
    inline void clear_WAKE_EN0_clk_peri_spi1()
    {
        WAKE_EN0 &= ~(1u << 26u);
    }

    /**
     * Toggle WAKE_EN0's clk_peri_spi1 bit.
     */
    inline void toggle_WAKE_EN0_clk_peri_spi1()
    {
        WAKE_EN0 ^= 1u << 26u;
    }

    /**
     * Get WAKE_EN0's clk_sys_spi1 bit.
     */
    bool get_WAKE_EN0_clk_sys_spi1()
    {
        return WAKE_EN0 & (1u << 27u);
    }

    /**
     * Set WAKE_EN0's clk_sys_spi1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_spi1()
    {
        WAKE_EN0 |= 1u << 27u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_spi1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_spi1()
    {
        WAKE_EN0 &= ~(1u << 27u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_spi1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_spi1()
    {
        WAKE_EN0 ^= 1u << 27u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram0 bit.
     */
    bool get_WAKE_EN0_clk_sys_sram0()
    {
        return WAKE_EN0 & (1u << 28u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram0()
    {
        WAKE_EN0 |= 1u << 28u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram0()
    {
        WAKE_EN0 &= ~(1u << 28u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram0()
    {
        WAKE_EN0 ^= 1u << 28u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram1 bit.
     */
    bool get_WAKE_EN0_clk_sys_sram1()
    {
        return WAKE_EN0 & (1u << 29u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram1()
    {
        WAKE_EN0 |= 1u << 29u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram1()
    {
        WAKE_EN0 &= ~(1u << 29u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram1()
    {
        WAKE_EN0 ^= 1u << 29u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram2 bit.
     */
    bool get_WAKE_EN0_clk_sys_sram2()
    {
        return WAKE_EN0 & (1u << 30u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram2 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram2()
    {
        WAKE_EN0 |= 1u << 30u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram2 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram2()
    {
        WAKE_EN0 &= ~(1u << 30u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram2 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram2()
    {
        WAKE_EN0 ^= 1u << 30u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram3 bit.
     */
    bool get_WAKE_EN0_clk_sys_sram3()
    {
        return WAKE_EN0 & (1u << 31u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram3 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram3()
    {
        WAKE_EN0 |= 1u << 31u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram3 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram3()
    {
        WAKE_EN0 &= ~(1u << 31u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram3 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram3()
    {
        WAKE_EN0 ^= 1u << 31u;
    }

    /**
     * Get WAKE_EN1's clk_sys_sram4 bit.
     */
    bool get_WAKE_EN1_clk_sys_sram4()
    {
        return WAKE_EN1 & (1u << 0u);
    }

    /**
     * Set WAKE_EN1's clk_sys_sram4 bit.
     */
    inline void set_WAKE_EN1_clk_sys_sram4()
    {
        WAKE_EN1 |= 1u << 0u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_sram4 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_sram4()
    {
        WAKE_EN1 &= ~(1u << 0u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_sram4 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_sram4()
    {
        WAKE_EN1 ^= 1u << 0u;
    }

    /**
     * Get WAKE_EN1's clk_sys_sram5 bit.
     */
    bool get_WAKE_EN1_clk_sys_sram5()
    {
        return WAKE_EN1 & (1u << 1u);
    }

    /**
     * Set WAKE_EN1's clk_sys_sram5 bit.
     */
    inline void set_WAKE_EN1_clk_sys_sram5()
    {
        WAKE_EN1 |= 1u << 1u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_sram5 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_sram5()
    {
        WAKE_EN1 &= ~(1u << 1u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_sram5 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_sram5()
    {
        WAKE_EN1 ^= 1u << 1u;
    }

    /**
     * Get WAKE_EN1's clk_sys_syscfg bit.
     */
    bool get_WAKE_EN1_clk_sys_syscfg()
    {
        return WAKE_EN1 & (1u << 2u);
    }

    /**
     * Set WAKE_EN1's clk_sys_syscfg bit.
     */
    inline void set_WAKE_EN1_clk_sys_syscfg()
    {
        WAKE_EN1 |= 1u << 2u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_syscfg bit.
     */
    inline void clear_WAKE_EN1_clk_sys_syscfg()
    {
        WAKE_EN1 &= ~(1u << 2u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_syscfg bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_syscfg()
    {
        WAKE_EN1 ^= 1u << 2u;
    }

    /**
     * Get WAKE_EN1's clk_sys_sysinfo bit.
     */
    bool get_WAKE_EN1_clk_sys_sysinfo()
    {
        return WAKE_EN1 & (1u << 3u);
    }

    /**
     * Set WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline void set_WAKE_EN1_clk_sys_sysinfo()
    {
        WAKE_EN1 |= 1u << 3u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline void clear_WAKE_EN1_clk_sys_sysinfo()
    {
        WAKE_EN1 &= ~(1u << 3u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_sysinfo()
    {
        WAKE_EN1 ^= 1u << 3u;
    }

    /**
     * Get WAKE_EN1's clk_sys_tbman bit.
     */
    bool get_WAKE_EN1_clk_sys_tbman()
    {
        return WAKE_EN1 & (1u << 4u);
    }

    /**
     * Set WAKE_EN1's clk_sys_tbman bit.
     */
    inline void set_WAKE_EN1_clk_sys_tbman()
    {
        WAKE_EN1 |= 1u << 4u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_tbman bit.
     */
    inline void clear_WAKE_EN1_clk_sys_tbman()
    {
        WAKE_EN1 &= ~(1u << 4u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_tbman bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_tbman()
    {
        WAKE_EN1 ^= 1u << 4u;
    }

    /**
     * Get WAKE_EN1's clk_sys_timer bit.
     */
    bool get_WAKE_EN1_clk_sys_timer()
    {
        return WAKE_EN1 & (1u << 5u);
    }

    /**
     * Set WAKE_EN1's clk_sys_timer bit.
     */
    inline void set_WAKE_EN1_clk_sys_timer()
    {
        WAKE_EN1 |= 1u << 5u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_timer bit.
     */
    inline void clear_WAKE_EN1_clk_sys_timer()
    {
        WAKE_EN1 &= ~(1u << 5u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_timer bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_timer()
    {
        WAKE_EN1 ^= 1u << 5u;
    }

    /**
     * Get WAKE_EN1's clk_peri_uart0 bit.
     */
    bool get_WAKE_EN1_clk_peri_uart0()
    {
        return WAKE_EN1 & (1u << 6u);
    }

    /**
     * Set WAKE_EN1's clk_peri_uart0 bit.
     */
    inline void set_WAKE_EN1_clk_peri_uart0()
    {
        WAKE_EN1 |= 1u << 6u;
    }

    /**
     * Clear WAKE_EN1's clk_peri_uart0 bit.
     */
    inline void clear_WAKE_EN1_clk_peri_uart0()
    {
        WAKE_EN1 &= ~(1u << 6u);
    }

    /**
     * Toggle WAKE_EN1's clk_peri_uart0 bit.
     */
    inline void toggle_WAKE_EN1_clk_peri_uart0()
    {
        WAKE_EN1 ^= 1u << 6u;
    }

    /**
     * Get WAKE_EN1's clk_sys_uart0 bit.
     */
    bool get_WAKE_EN1_clk_sys_uart0()
    {
        return WAKE_EN1 & (1u << 7u);
    }

    /**
     * Set WAKE_EN1's clk_sys_uart0 bit.
     */
    inline void set_WAKE_EN1_clk_sys_uart0()
    {
        WAKE_EN1 |= 1u << 7u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_uart0 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_uart0()
    {
        WAKE_EN1 &= ~(1u << 7u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_uart0 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_uart0()
    {
        WAKE_EN1 ^= 1u << 7u;
    }

    /**
     * Get WAKE_EN1's clk_peri_uart1 bit.
     */
    bool get_WAKE_EN1_clk_peri_uart1()
    {
        return WAKE_EN1 & (1u << 8u);
    }

    /**
     * Set WAKE_EN1's clk_peri_uart1 bit.
     */
    inline void set_WAKE_EN1_clk_peri_uart1()
    {
        WAKE_EN1 |= 1u << 8u;
    }

    /**
     * Clear WAKE_EN1's clk_peri_uart1 bit.
     */
    inline void clear_WAKE_EN1_clk_peri_uart1()
    {
        WAKE_EN1 &= ~(1u << 8u);
    }

    /**
     * Toggle WAKE_EN1's clk_peri_uart1 bit.
     */
    inline void toggle_WAKE_EN1_clk_peri_uart1()
    {
        WAKE_EN1 ^= 1u << 8u;
    }

    /**
     * Get WAKE_EN1's clk_sys_uart1 bit.
     */
    bool get_WAKE_EN1_clk_sys_uart1()
    {
        return WAKE_EN1 & (1u << 9u);
    }

    /**
     * Set WAKE_EN1's clk_sys_uart1 bit.
     */
    inline void set_WAKE_EN1_clk_sys_uart1()
    {
        WAKE_EN1 |= 1u << 9u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_uart1 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_uart1()
    {
        WAKE_EN1 &= ~(1u << 9u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_uart1 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_uart1()
    {
        WAKE_EN1 ^= 1u << 9u;
    }

    /**
     * Get WAKE_EN1's clk_sys_usbctrl bit.
     */
    bool get_WAKE_EN1_clk_sys_usbctrl()
    {
        return WAKE_EN1 & (1u << 10u);
    }

    /**
     * Set WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline void set_WAKE_EN1_clk_sys_usbctrl()
    {
        WAKE_EN1 |= 1u << 10u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline void clear_WAKE_EN1_clk_sys_usbctrl()
    {
        WAKE_EN1 &= ~(1u << 10u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_usbctrl()
    {
        WAKE_EN1 ^= 1u << 10u;
    }

    /**
     * Get WAKE_EN1's clk_usb_usbctrl bit.
     */
    bool get_WAKE_EN1_clk_usb_usbctrl()
    {
        return WAKE_EN1 & (1u << 11u);
    }

    /**
     * Set WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline void set_WAKE_EN1_clk_usb_usbctrl()
    {
        WAKE_EN1 |= 1u << 11u;
    }

    /**
     * Clear WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline void clear_WAKE_EN1_clk_usb_usbctrl()
    {
        WAKE_EN1 &= ~(1u << 11u);
    }

    /**
     * Toggle WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline void toggle_WAKE_EN1_clk_usb_usbctrl()
    {
        WAKE_EN1 ^= 1u << 11u;
    }

    /**
     * Get WAKE_EN1's clk_sys_watchdog bit.
     */
    bool get_WAKE_EN1_clk_sys_watchdog()
    {
        return WAKE_EN1 & (1u << 12u);
    }

    /**
     * Set WAKE_EN1's clk_sys_watchdog bit.
     */
    inline void set_WAKE_EN1_clk_sys_watchdog()
    {
        WAKE_EN1 |= 1u << 12u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_watchdog bit.
     */
    inline void clear_WAKE_EN1_clk_sys_watchdog()
    {
        WAKE_EN1 &= ~(1u << 12u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_watchdog bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_watchdog()
    {
        WAKE_EN1 ^= 1u << 12u;
    }

    /**
     * Get WAKE_EN1's clk_sys_xip bit.
     */
    bool get_WAKE_EN1_clk_sys_xip()
    {
        return WAKE_EN1 & (1u << 13u);
    }

    /**
     * Set WAKE_EN1's clk_sys_xip bit.
     */
    inline void set_WAKE_EN1_clk_sys_xip()
    {
        WAKE_EN1 |= 1u << 13u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_xip bit.
     */
    inline void clear_WAKE_EN1_clk_sys_xip()
    {
        WAKE_EN1 &= ~(1u << 13u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_xip bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_xip()
    {
        WAKE_EN1 ^= 1u << 13u;
    }

    /**
     * Get WAKE_EN1's clk_sys_xosc bit.
     */
    bool get_WAKE_EN1_clk_sys_xosc()
    {
        return WAKE_EN1 & (1u << 14u);
    }

    /**
     * Set WAKE_EN1's clk_sys_xosc bit.
     */
    inline void set_WAKE_EN1_clk_sys_xosc()
    {
        WAKE_EN1 |= 1u << 14u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_xosc bit.
     */
    inline void clear_WAKE_EN1_clk_sys_xosc()
    {
        WAKE_EN1 &= ~(1u << 14u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_xosc bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_xosc()
    {
        WAKE_EN1 ^= 1u << 14u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_clocks bit.
     */
    bool get_SLEEP_EN0_clk_sys_clocks()
    {
        return SLEEP_EN0 & (1u << 0u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_clocks bit.
     */
    inline void set_SLEEP_EN0_clk_sys_clocks()
    {
        SLEEP_EN0 |= 1u << 0u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_clocks bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_clocks()
    {
        SLEEP_EN0 &= ~(1u << 0u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_clocks bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_clocks()
    {
        SLEEP_EN0 ^= 1u << 0u;
    }

    /**
     * Get SLEEP_EN0's clk_adc_adc bit.
     */
    bool get_SLEEP_EN0_clk_adc_adc()
    {
        return SLEEP_EN0 & (1u << 1u);
    }

    /**
     * Set SLEEP_EN0's clk_adc_adc bit.
     */
    inline void set_SLEEP_EN0_clk_adc_adc()
    {
        SLEEP_EN0 |= 1u << 1u;
    }

    /**
     * Clear SLEEP_EN0's clk_adc_adc bit.
     */
    inline void clear_SLEEP_EN0_clk_adc_adc()
    {
        SLEEP_EN0 &= ~(1u << 1u);
    }

    /**
     * Toggle SLEEP_EN0's clk_adc_adc bit.
     */
    inline void toggle_SLEEP_EN0_clk_adc_adc()
    {
        SLEEP_EN0 ^= 1u << 1u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_adc bit.
     */
    bool get_SLEEP_EN0_clk_sys_adc()
    {
        return SLEEP_EN0 & (1u << 2u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_adc bit.
     */
    inline void set_SLEEP_EN0_clk_sys_adc()
    {
        SLEEP_EN0 |= 1u << 2u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_adc bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_adc()
    {
        SLEEP_EN0 &= ~(1u << 2u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_adc bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_adc()
    {
        SLEEP_EN0 ^= 1u << 2u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_busctrl bit.
     */
    bool get_SLEEP_EN0_clk_sys_busctrl()
    {
        return SLEEP_EN0 & (1u << 3u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline void set_SLEEP_EN0_clk_sys_busctrl()
    {
        SLEEP_EN0 |= 1u << 3u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_busctrl()
    {
        SLEEP_EN0 &= ~(1u << 3u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_busctrl()
    {
        SLEEP_EN0 ^= 1u << 3u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_busfabric bit.
     */
    bool get_SLEEP_EN0_clk_sys_busfabric()
    {
        return SLEEP_EN0 & (1u << 4u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline void set_SLEEP_EN0_clk_sys_busfabric()
    {
        SLEEP_EN0 |= 1u << 4u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_busfabric()
    {
        SLEEP_EN0 &= ~(1u << 4u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_busfabric()
    {
        SLEEP_EN0 ^= 1u << 4u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_dma bit.
     */
    bool get_SLEEP_EN0_clk_sys_dma()
    {
        return SLEEP_EN0 & (1u << 5u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_dma bit.
     */
    inline void set_SLEEP_EN0_clk_sys_dma()
    {
        SLEEP_EN0 |= 1u << 5u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_dma bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_dma()
    {
        SLEEP_EN0 &= ~(1u << 5u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_dma bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_dma()
    {
        SLEEP_EN0 ^= 1u << 5u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_i2c0 bit.
     */
    bool get_SLEEP_EN0_clk_sys_i2c0()
    {
        return SLEEP_EN0 & (1u << 6u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_i2c0()
    {
        SLEEP_EN0 |= 1u << 6u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_i2c0()
    {
        SLEEP_EN0 &= ~(1u << 6u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_i2c0()
    {
        SLEEP_EN0 ^= 1u << 6u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_i2c1 bit.
     */
    bool get_SLEEP_EN0_clk_sys_i2c1()
    {
        return SLEEP_EN0 & (1u << 7u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_i2c1()
    {
        SLEEP_EN0 |= 1u << 7u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_i2c1()
    {
        SLEEP_EN0 &= ~(1u << 7u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_i2c1()
    {
        SLEEP_EN0 ^= 1u << 7u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_io bit.
     */
    bool get_SLEEP_EN0_clk_sys_io()
    {
        return SLEEP_EN0 & (1u << 8u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_io bit.
     */
    inline void set_SLEEP_EN0_clk_sys_io()
    {
        SLEEP_EN0 |= 1u << 8u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_io bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_io()
    {
        SLEEP_EN0 &= ~(1u << 8u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_io bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_io()
    {
        SLEEP_EN0 ^= 1u << 8u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_jtag bit.
     */
    bool get_SLEEP_EN0_clk_sys_jtag()
    {
        return SLEEP_EN0 & (1u << 9u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_jtag bit.
     */
    inline void set_SLEEP_EN0_clk_sys_jtag()
    {
        SLEEP_EN0 |= 1u << 9u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_jtag bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_jtag()
    {
        SLEEP_EN0 &= ~(1u << 9u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_jtag bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_jtag()
    {
        SLEEP_EN0 ^= 1u << 9u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    bool get_SLEEP_EN0_clk_sys_vreg_and_chip_reset()
    {
        return SLEEP_EN0 & (1u << 10u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void set_SLEEP_EN0_clk_sys_vreg_and_chip_reset()
    {
        SLEEP_EN0 |= 1u << 10u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_vreg_and_chip_reset()
    {
        SLEEP_EN0 &= ~(1u << 10u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_vreg_and_chip_reset()
    {
        SLEEP_EN0 ^= 1u << 10u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pads bit.
     */
    bool get_SLEEP_EN0_clk_sys_pads()
    {
        return SLEEP_EN0 & (1u << 11u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pads bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pads()
    {
        SLEEP_EN0 |= 1u << 11u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pads bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pads()
    {
        SLEEP_EN0 &= ~(1u << 11u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pads bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pads()
    {
        SLEEP_EN0 ^= 1u << 11u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pio0 bit.
     */
    bool get_SLEEP_EN0_clk_sys_pio0()
    {
        return SLEEP_EN0 & (1u << 12u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pio0()
    {
        SLEEP_EN0 |= 1u << 12u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pio0()
    {
        SLEEP_EN0 &= ~(1u << 12u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pio0()
    {
        SLEEP_EN0 ^= 1u << 12u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pio1 bit.
     */
    bool get_SLEEP_EN0_clk_sys_pio1()
    {
        return SLEEP_EN0 & (1u << 13u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pio1()
    {
        SLEEP_EN0 |= 1u << 13u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pio1()
    {
        SLEEP_EN0 &= ~(1u << 13u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pio1()
    {
        SLEEP_EN0 ^= 1u << 13u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pll_sys bit.
     */
    bool get_SLEEP_EN0_clk_sys_pll_sys()
    {
        return SLEEP_EN0 & (1u << 14u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pll_sys()
    {
        SLEEP_EN0 |= 1u << 14u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pll_sys()
    {
        SLEEP_EN0 &= ~(1u << 14u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pll_sys()
    {
        SLEEP_EN0 ^= 1u << 14u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pll_usb bit.
     */
    bool get_SLEEP_EN0_clk_sys_pll_usb()
    {
        return SLEEP_EN0 & (1u << 15u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pll_usb()
    {
        SLEEP_EN0 |= 1u << 15u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pll_usb()
    {
        SLEEP_EN0 &= ~(1u << 15u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pll_usb()
    {
        SLEEP_EN0 ^= 1u << 15u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_psm bit.
     */
    bool get_SLEEP_EN0_clk_sys_psm()
    {
        return SLEEP_EN0 & (1u << 16u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_psm bit.
     */
    inline void set_SLEEP_EN0_clk_sys_psm()
    {
        SLEEP_EN0 |= 1u << 16u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_psm bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_psm()
    {
        SLEEP_EN0 &= ~(1u << 16u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_psm bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_psm()
    {
        SLEEP_EN0 ^= 1u << 16u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pwm bit.
     */
    bool get_SLEEP_EN0_clk_sys_pwm()
    {
        return SLEEP_EN0 & (1u << 17u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pwm bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pwm()
    {
        SLEEP_EN0 |= 1u << 17u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pwm bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pwm()
    {
        SLEEP_EN0 &= ~(1u << 17u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pwm bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pwm()
    {
        SLEEP_EN0 ^= 1u << 17u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_resets bit.
     */
    bool get_SLEEP_EN0_clk_sys_resets()
    {
        return SLEEP_EN0 & (1u << 18u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_resets bit.
     */
    inline void set_SLEEP_EN0_clk_sys_resets()
    {
        SLEEP_EN0 |= 1u << 18u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_resets bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_resets()
    {
        SLEEP_EN0 &= ~(1u << 18u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_resets bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_resets()
    {
        SLEEP_EN0 ^= 1u << 18u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_rom bit.
     */
    bool get_SLEEP_EN0_clk_sys_rom()
    {
        return SLEEP_EN0 & (1u << 19u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_rom bit.
     */
    inline void set_SLEEP_EN0_clk_sys_rom()
    {
        SLEEP_EN0 |= 1u << 19u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_rom bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_rom()
    {
        SLEEP_EN0 &= ~(1u << 19u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_rom bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_rom()
    {
        SLEEP_EN0 ^= 1u << 19u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_rosc bit.
     */
    bool get_SLEEP_EN0_clk_sys_rosc()
    {
        return SLEEP_EN0 & (1u << 20u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_rosc bit.
     */
    inline void set_SLEEP_EN0_clk_sys_rosc()
    {
        SLEEP_EN0 |= 1u << 20u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_rosc bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_rosc()
    {
        SLEEP_EN0 &= ~(1u << 20u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_rosc bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_rosc()
    {
        SLEEP_EN0 ^= 1u << 20u;
    }

    /**
     * Get SLEEP_EN0's clk_rtc_rtc bit.
     */
    bool get_SLEEP_EN0_clk_rtc_rtc()
    {
        return SLEEP_EN0 & (1u << 21u);
    }

    /**
     * Set SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline void set_SLEEP_EN0_clk_rtc_rtc()
    {
        SLEEP_EN0 |= 1u << 21u;
    }

    /**
     * Clear SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline void clear_SLEEP_EN0_clk_rtc_rtc()
    {
        SLEEP_EN0 &= ~(1u << 21u);
    }

    /**
     * Toggle SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline void toggle_SLEEP_EN0_clk_rtc_rtc()
    {
        SLEEP_EN0 ^= 1u << 21u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_rtc bit.
     */
    bool get_SLEEP_EN0_clk_sys_rtc()
    {
        return SLEEP_EN0 & (1u << 22u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_rtc bit.
     */
    inline void set_SLEEP_EN0_clk_sys_rtc()
    {
        SLEEP_EN0 |= 1u << 22u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_rtc bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_rtc()
    {
        SLEEP_EN0 &= ~(1u << 22u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_rtc bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_rtc()
    {
        SLEEP_EN0 ^= 1u << 22u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sio bit.
     */
    bool get_SLEEP_EN0_clk_sys_sio()
    {
        return SLEEP_EN0 & (1u << 23u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sio bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sio()
    {
        SLEEP_EN0 |= 1u << 23u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sio bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sio()
    {
        SLEEP_EN0 &= ~(1u << 23u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sio bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sio()
    {
        SLEEP_EN0 ^= 1u << 23u;
    }

    /**
     * Get SLEEP_EN0's clk_peri_spi0 bit.
     */
    bool get_SLEEP_EN0_clk_peri_spi0()
    {
        return SLEEP_EN0 & (1u << 24u);
    }

    /**
     * Set SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline void set_SLEEP_EN0_clk_peri_spi0()
    {
        SLEEP_EN0 |= 1u << 24u;
    }

    /**
     * Clear SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline void clear_SLEEP_EN0_clk_peri_spi0()
    {
        SLEEP_EN0 &= ~(1u << 24u);
    }

    /**
     * Toggle SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_peri_spi0()
    {
        SLEEP_EN0 ^= 1u << 24u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_spi0 bit.
     */
    bool get_SLEEP_EN0_clk_sys_spi0()
    {
        return SLEEP_EN0 & (1u << 25u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_spi0()
    {
        SLEEP_EN0 |= 1u << 25u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_spi0()
    {
        SLEEP_EN0 &= ~(1u << 25u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_spi0()
    {
        SLEEP_EN0 ^= 1u << 25u;
    }

    /**
     * Get SLEEP_EN0's clk_peri_spi1 bit.
     */
    bool get_SLEEP_EN0_clk_peri_spi1()
    {
        return SLEEP_EN0 & (1u << 26u);
    }

    /**
     * Set SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline void set_SLEEP_EN0_clk_peri_spi1()
    {
        SLEEP_EN0 |= 1u << 26u;
    }

    /**
     * Clear SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline void clear_SLEEP_EN0_clk_peri_spi1()
    {
        SLEEP_EN0 &= ~(1u << 26u);
    }

    /**
     * Toggle SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_peri_spi1()
    {
        SLEEP_EN0 ^= 1u << 26u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_spi1 bit.
     */
    bool get_SLEEP_EN0_clk_sys_spi1()
    {
        return SLEEP_EN0 & (1u << 27u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_spi1()
    {
        SLEEP_EN0 |= 1u << 27u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_spi1()
    {
        SLEEP_EN0 &= ~(1u << 27u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_spi1()
    {
        SLEEP_EN0 ^= 1u << 27u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram0 bit.
     */
    bool get_SLEEP_EN0_clk_sys_sram0()
    {
        return SLEEP_EN0 & (1u << 28u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram0()
    {
        SLEEP_EN0 |= 1u << 28u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram0()
    {
        SLEEP_EN0 &= ~(1u << 28u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram0()
    {
        SLEEP_EN0 ^= 1u << 28u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram1 bit.
     */
    bool get_SLEEP_EN0_clk_sys_sram1()
    {
        return SLEEP_EN0 & (1u << 29u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram1()
    {
        SLEEP_EN0 |= 1u << 29u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram1()
    {
        SLEEP_EN0 &= ~(1u << 29u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram1()
    {
        SLEEP_EN0 ^= 1u << 29u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram2 bit.
     */
    bool get_SLEEP_EN0_clk_sys_sram2()
    {
        return SLEEP_EN0 & (1u << 30u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram2()
    {
        SLEEP_EN0 |= 1u << 30u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram2()
    {
        SLEEP_EN0 &= ~(1u << 30u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram2()
    {
        SLEEP_EN0 ^= 1u << 30u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram3 bit.
     */
    bool get_SLEEP_EN0_clk_sys_sram3()
    {
        return SLEEP_EN0 & (1u << 31u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram3()
    {
        SLEEP_EN0 |= 1u << 31u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram3()
    {
        SLEEP_EN0 &= ~(1u << 31u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram3()
    {
        SLEEP_EN0 ^= 1u << 31u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_sram4 bit.
     */
    bool get_SLEEP_EN1_clk_sys_sram4()
    {
        return SLEEP_EN1 & (1u << 0u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_sram4()
    {
        SLEEP_EN1 |= 1u << 0u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_sram4()
    {
        SLEEP_EN1 &= ~(1u << 0u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_sram4()
    {
        SLEEP_EN1 ^= 1u << 0u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_sram5 bit.
     */
    bool get_SLEEP_EN1_clk_sys_sram5()
    {
        return SLEEP_EN1 & (1u << 1u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_sram5()
    {
        SLEEP_EN1 |= 1u << 1u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_sram5()
    {
        SLEEP_EN1 &= ~(1u << 1u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_sram5()
    {
        SLEEP_EN1 ^= 1u << 1u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_syscfg bit.
     */
    bool get_SLEEP_EN1_clk_sys_syscfg()
    {
        return SLEEP_EN1 & (1u << 2u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline void set_SLEEP_EN1_clk_sys_syscfg()
    {
        SLEEP_EN1 |= 1u << 2u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_syscfg()
    {
        SLEEP_EN1 &= ~(1u << 2u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_syscfg()
    {
        SLEEP_EN1 ^= 1u << 2u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_sysinfo bit.
     */
    bool get_SLEEP_EN1_clk_sys_sysinfo()
    {
        return SLEEP_EN1 & (1u << 3u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline void set_SLEEP_EN1_clk_sys_sysinfo()
    {
        SLEEP_EN1 |= 1u << 3u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_sysinfo()
    {
        SLEEP_EN1 &= ~(1u << 3u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_sysinfo()
    {
        SLEEP_EN1 ^= 1u << 3u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_tbman bit.
     */
    bool get_SLEEP_EN1_clk_sys_tbman()
    {
        return SLEEP_EN1 & (1u << 4u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_tbman bit.
     */
    inline void set_SLEEP_EN1_clk_sys_tbman()
    {
        SLEEP_EN1 |= 1u << 4u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_tbman bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_tbman()
    {
        SLEEP_EN1 &= ~(1u << 4u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_tbman bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_tbman()
    {
        SLEEP_EN1 ^= 1u << 4u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_timer bit.
     */
    bool get_SLEEP_EN1_clk_sys_timer()
    {
        return SLEEP_EN1 & (1u << 5u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_timer bit.
     */
    inline void set_SLEEP_EN1_clk_sys_timer()
    {
        SLEEP_EN1 |= 1u << 5u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_timer bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_timer()
    {
        SLEEP_EN1 &= ~(1u << 5u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_timer bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_timer()
    {
        SLEEP_EN1 ^= 1u << 5u;
    }

    /**
     * Get SLEEP_EN1's clk_peri_uart0 bit.
     */
    bool get_SLEEP_EN1_clk_peri_uart0()
    {
        return SLEEP_EN1 & (1u << 6u);
    }

    /**
     * Set SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline void set_SLEEP_EN1_clk_peri_uart0()
    {
        SLEEP_EN1 |= 1u << 6u;
    }

    /**
     * Clear SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline void clear_SLEEP_EN1_clk_peri_uart0()
    {
        SLEEP_EN1 &= ~(1u << 6u);
    }

    /**
     * Toggle SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline void toggle_SLEEP_EN1_clk_peri_uart0()
    {
        SLEEP_EN1 ^= 1u << 6u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_uart0 bit.
     */
    bool get_SLEEP_EN1_clk_sys_uart0()
    {
        return SLEEP_EN1 & (1u << 7u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_uart0()
    {
        SLEEP_EN1 |= 1u << 7u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_uart0()
    {
        SLEEP_EN1 &= ~(1u << 7u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_uart0()
    {
        SLEEP_EN1 ^= 1u << 7u;
    }

    /**
     * Get SLEEP_EN1's clk_peri_uart1 bit.
     */
    bool get_SLEEP_EN1_clk_peri_uart1()
    {
        return SLEEP_EN1 & (1u << 8u);
    }

    /**
     * Set SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline void set_SLEEP_EN1_clk_peri_uart1()
    {
        SLEEP_EN1 |= 1u << 8u;
    }

    /**
     * Clear SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline void clear_SLEEP_EN1_clk_peri_uart1()
    {
        SLEEP_EN1 &= ~(1u << 8u);
    }

    /**
     * Toggle SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline void toggle_SLEEP_EN1_clk_peri_uart1()
    {
        SLEEP_EN1 ^= 1u << 8u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_uart1 bit.
     */
    bool get_SLEEP_EN1_clk_sys_uart1()
    {
        return SLEEP_EN1 & (1u << 9u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_uart1()
    {
        SLEEP_EN1 |= 1u << 9u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_uart1()
    {
        SLEEP_EN1 &= ~(1u << 9u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_uart1()
    {
        SLEEP_EN1 ^= 1u << 9u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_usbctrl bit.
     */
    bool get_SLEEP_EN1_clk_sys_usbctrl()
    {
        return SLEEP_EN1 & (1u << 10u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline void set_SLEEP_EN1_clk_sys_usbctrl()
    {
        SLEEP_EN1 |= 1u << 10u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_usbctrl()
    {
        SLEEP_EN1 &= ~(1u << 10u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_usbctrl()
    {
        SLEEP_EN1 ^= 1u << 10u;
    }

    /**
     * Get SLEEP_EN1's clk_usb_usbctrl bit.
     */
    bool get_SLEEP_EN1_clk_usb_usbctrl()
    {
        return SLEEP_EN1 & (1u << 11u);
    }

    /**
     * Set SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline void set_SLEEP_EN1_clk_usb_usbctrl()
    {
        SLEEP_EN1 |= 1u << 11u;
    }

    /**
     * Clear SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline void clear_SLEEP_EN1_clk_usb_usbctrl()
    {
        SLEEP_EN1 &= ~(1u << 11u);
    }

    /**
     * Toggle SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline void toggle_SLEEP_EN1_clk_usb_usbctrl()
    {
        SLEEP_EN1 ^= 1u << 11u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_watchdog bit.
     */
    bool get_SLEEP_EN1_clk_sys_watchdog()
    {
        return SLEEP_EN1 & (1u << 12u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline void set_SLEEP_EN1_clk_sys_watchdog()
    {
        SLEEP_EN1 |= 1u << 12u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_watchdog()
    {
        SLEEP_EN1 &= ~(1u << 12u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_watchdog()
    {
        SLEEP_EN1 ^= 1u << 12u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_xip bit.
     */
    bool get_SLEEP_EN1_clk_sys_xip()
    {
        return SLEEP_EN1 & (1u << 13u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_xip bit.
     */
    inline void set_SLEEP_EN1_clk_sys_xip()
    {
        SLEEP_EN1 |= 1u << 13u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_xip bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_xip()
    {
        SLEEP_EN1 &= ~(1u << 13u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_xip bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_xip()
    {
        SLEEP_EN1 ^= 1u << 13u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_xosc bit.
     */
    bool get_SLEEP_EN1_clk_sys_xosc()
    {
        return SLEEP_EN1 & (1u << 14u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_xosc bit.
     */
    inline void set_SLEEP_EN1_clk_sys_xosc()
    {
        SLEEP_EN1 |= 1u << 14u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_xosc bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_xosc()
    {
        SLEEP_EN1 &= ~(1u << 14u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_xosc bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_xosc()
    {
        SLEEP_EN1 ^= 1u << 14u;
    }

    /**
     * Get ENABLED0's clk_sys_clocks bit.
     */
    bool get_ENABLED0_clk_sys_clocks()
    {
        return ENABLED0 & (1u << 0u);
    }

    /**
     * Get ENABLED0's clk_adc_adc bit.
     */
    bool get_ENABLED0_clk_adc_adc()
    {
        return ENABLED0 & (1u << 1u);
    }

    /**
     * Get ENABLED0's clk_sys_adc bit.
     */
    bool get_ENABLED0_clk_sys_adc()
    {
        return ENABLED0 & (1u << 2u);
    }

    /**
     * Get ENABLED0's clk_sys_busctrl bit.
     */
    bool get_ENABLED0_clk_sys_busctrl()
    {
        return ENABLED0 & (1u << 3u);
    }

    /**
     * Get ENABLED0's clk_sys_busfabric bit.
     */
    bool get_ENABLED0_clk_sys_busfabric()
    {
        return ENABLED0 & (1u << 4u);
    }

    /**
     * Get ENABLED0's clk_sys_dma bit.
     */
    bool get_ENABLED0_clk_sys_dma()
    {
        return ENABLED0 & (1u << 5u);
    }

    /**
     * Get ENABLED0's clk_sys_i2c0 bit.
     */
    bool get_ENABLED0_clk_sys_i2c0()
    {
        return ENABLED0 & (1u << 6u);
    }

    /**
     * Get ENABLED0's clk_sys_i2c1 bit.
     */
    bool get_ENABLED0_clk_sys_i2c1()
    {
        return ENABLED0 & (1u << 7u);
    }

    /**
     * Get ENABLED0's clk_sys_io bit.
     */
    bool get_ENABLED0_clk_sys_io()
    {
        return ENABLED0 & (1u << 8u);
    }

    /**
     * Get ENABLED0's clk_sys_jtag bit.
     */
    bool get_ENABLED0_clk_sys_jtag()
    {
        return ENABLED0 & (1u << 9u);
    }

    /**
     * Get ENABLED0's clk_sys_vreg_and_chip_reset bit.
     */
    bool get_ENABLED0_clk_sys_vreg_and_chip_reset()
    {
        return ENABLED0 & (1u << 10u);
    }

    /**
     * Get ENABLED0's clk_sys_pads bit.
     */
    bool get_ENABLED0_clk_sys_pads()
    {
        return ENABLED0 & (1u << 11u);
    }

    /**
     * Get ENABLED0's clk_sys_pio0 bit.
     */
    bool get_ENABLED0_clk_sys_pio0()
    {
        return ENABLED0 & (1u << 12u);
    }

    /**
     * Get ENABLED0's clk_sys_pio1 bit.
     */
    bool get_ENABLED0_clk_sys_pio1()
    {
        return ENABLED0 & (1u << 13u);
    }

    /**
     * Get ENABLED0's clk_sys_pll_sys bit.
     */
    bool get_ENABLED0_clk_sys_pll_sys()
    {
        return ENABLED0 & (1u << 14u);
    }

    /**
     * Get ENABLED0's clk_sys_pll_usb bit.
     */
    bool get_ENABLED0_clk_sys_pll_usb()
    {
        return ENABLED0 & (1u << 15u);
    }

    /**
     * Get ENABLED0's clk_sys_psm bit.
     */
    bool get_ENABLED0_clk_sys_psm()
    {
        return ENABLED0 & (1u << 16u);
    }

    /**
     * Get ENABLED0's clk_sys_pwm bit.
     */
    bool get_ENABLED0_clk_sys_pwm()
    {
        return ENABLED0 & (1u << 17u);
    }

    /**
     * Get ENABLED0's clk_sys_resets bit.
     */
    bool get_ENABLED0_clk_sys_resets()
    {
        return ENABLED0 & (1u << 18u);
    }

    /**
     * Get ENABLED0's clk_sys_rom bit.
     */
    bool get_ENABLED0_clk_sys_rom()
    {
        return ENABLED0 & (1u << 19u);
    }

    /**
     * Get ENABLED0's clk_sys_rosc bit.
     */
    bool get_ENABLED0_clk_sys_rosc()
    {
        return ENABLED0 & (1u << 20u);
    }

    /**
     * Get ENABLED0's clk_rtc_rtc bit.
     */
    bool get_ENABLED0_clk_rtc_rtc()
    {
        return ENABLED0 & (1u << 21u);
    }

    /**
     * Get ENABLED0's clk_sys_rtc bit.
     */
    bool get_ENABLED0_clk_sys_rtc()
    {
        return ENABLED0 & (1u << 22u);
    }

    /**
     * Get ENABLED0's clk_sys_sio bit.
     */
    bool get_ENABLED0_clk_sys_sio()
    {
        return ENABLED0 & (1u << 23u);
    }

    /**
     * Get ENABLED0's clk_peri_spi0 bit.
     */
    bool get_ENABLED0_clk_peri_spi0()
    {
        return ENABLED0 & (1u << 24u);
    }

    /**
     * Get ENABLED0's clk_sys_spi0 bit.
     */
    bool get_ENABLED0_clk_sys_spi0()
    {
        return ENABLED0 & (1u << 25u);
    }

    /**
     * Get ENABLED0's clk_peri_spi1 bit.
     */
    bool get_ENABLED0_clk_peri_spi1()
    {
        return ENABLED0 & (1u << 26u);
    }

    /**
     * Get ENABLED0's clk_sys_spi1 bit.
     */
    bool get_ENABLED0_clk_sys_spi1()
    {
        return ENABLED0 & (1u << 27u);
    }

    /**
     * Get ENABLED0's clk_sys_sram0 bit.
     */
    bool get_ENABLED0_clk_sys_sram0()
    {
        return ENABLED0 & (1u << 28u);
    }

    /**
     * Get ENABLED0's clk_sys_sram1 bit.
     */
    bool get_ENABLED0_clk_sys_sram1()
    {
        return ENABLED0 & (1u << 29u);
    }

    /**
     * Get ENABLED0's clk_sys_sram2 bit.
     */
    bool get_ENABLED0_clk_sys_sram2()
    {
        return ENABLED0 & (1u << 30u);
    }

    /**
     * Get ENABLED0's clk_sys_sram3 bit.
     */
    bool get_ENABLED0_clk_sys_sram3()
    {
        return ENABLED0 & (1u << 31u);
    }

    /**
     * Get ENABLED1's clk_sys_sram4 bit.
     */
    bool get_ENABLED1_clk_sys_sram4()
    {
        return ENABLED1 & (1u << 0u);
    }

    /**
     * Get ENABLED1's clk_sys_sram5 bit.
     */
    bool get_ENABLED1_clk_sys_sram5()
    {
        return ENABLED1 & (1u << 1u);
    }

    /**
     * Get ENABLED1's clk_sys_syscfg bit.
     */
    bool get_ENABLED1_clk_sys_syscfg()
    {
        return ENABLED1 & (1u << 2u);
    }

    /**
     * Get ENABLED1's clk_sys_sysinfo bit.
     */
    bool get_ENABLED1_clk_sys_sysinfo()
    {
        return ENABLED1 & (1u << 3u);
    }

    /**
     * Get ENABLED1's clk_sys_tbman bit.
     */
    bool get_ENABLED1_clk_sys_tbman()
    {
        return ENABLED1 & (1u << 4u);
    }

    /**
     * Get ENABLED1's clk_sys_timer bit.
     */
    bool get_ENABLED1_clk_sys_timer()
    {
        return ENABLED1 & (1u << 5u);
    }

    /**
     * Get ENABLED1's clk_peri_uart0 bit.
     */
    bool get_ENABLED1_clk_peri_uart0()
    {
        return ENABLED1 & (1u << 6u);
    }

    /**
     * Get ENABLED1's clk_sys_uart0 bit.
     */
    bool get_ENABLED1_clk_sys_uart0()
    {
        return ENABLED1 & (1u << 7u);
    }

    /**
     * Get ENABLED1's clk_peri_uart1 bit.
     */
    bool get_ENABLED1_clk_peri_uart1()
    {
        return ENABLED1 & (1u << 8u);
    }

    /**
     * Get ENABLED1's clk_sys_uart1 bit.
     */
    bool get_ENABLED1_clk_sys_uart1()
    {
        return ENABLED1 & (1u << 9u);
    }

    /**
     * Get ENABLED1's clk_sys_usbctrl bit.
     */
    bool get_ENABLED1_clk_sys_usbctrl()
    {
        return ENABLED1 & (1u << 10u);
    }

    /**
     * Get ENABLED1's clk_usb_usbctrl bit.
     */
    bool get_ENABLED1_clk_usb_usbctrl()
    {
        return ENABLED1 & (1u << 11u);
    }

    /**
     * Get ENABLED1's clk_sys_watchdog bit.
     */
    bool get_ENABLED1_clk_sys_watchdog()
    {
        return ENABLED1 & (1u << 12u);
    }

    /**
     * Get ENABLED1's clk_sys_xip bit.
     */
    bool get_ENABLED1_clk_sys_xip()
    {
        return ENABLED1 & (1u << 13u);
    }

    /**
     * Get ENABLED1's clk_sys_xosc bit.
     */
    bool get_ENABLED1_clk_sys_xosc()
    {
        return ENABLED1 & (1u << 14u);
    }

    /**
     * Get INTR's CLK_SYS_RESUS bit.
     */
    bool get_INTR_CLK_SYS_RESUS()
    {
        return INTR & (1u << 0u);
    }

    /**
     * Get INTE's CLK_SYS_RESUS bit.
     */
    bool get_INTE_CLK_SYS_RESUS()
    {
        return INTE & (1u << 0u);
    }

    /**
     * Set INTE's CLK_SYS_RESUS bit.
     */
    inline void set_INTE_CLK_SYS_RESUS()
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's CLK_SYS_RESUS bit.
     */
    inline void clear_INTE_CLK_SYS_RESUS()
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's CLK_SYS_RESUS bit.
     */
    inline void toggle_INTE_CLK_SYS_RESUS()
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get INTF's CLK_SYS_RESUS bit.
     */
    bool get_INTF_CLK_SYS_RESUS()
    {
        return INTF & (1u << 0u);
    }

    /**
     * Set INTF's CLK_SYS_RESUS bit.
     */
    inline void set_INTF_CLK_SYS_RESUS()
    {
        INTF |= 1u << 0u;
    }

    /**
     * Clear INTF's CLK_SYS_RESUS bit.
     */
    inline void clear_INTF_CLK_SYS_RESUS()
    {
        INTF &= ~(1u << 0u);
    }

    /**
     * Toggle INTF's CLK_SYS_RESUS bit.
     */
    inline void toggle_INTF_CLK_SYS_RESUS()
    {
        INTF ^= 1u << 0u;
    }

    /**
     * Get INTS's CLK_SYS_RESUS bit.
     */
    bool get_INTS_CLK_SYS_RESUS()
    {
        return INTS & (1u << 0u);
    }
};

static_assert(sizeof(clocks) == clocks::size);

static volatile clocks *const CLOCKS = reinterpret_cast<clocks *>(0x40008000);

}; // namespace RP2040
