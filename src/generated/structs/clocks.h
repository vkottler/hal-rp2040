/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../enums/CLOCKS_CLK_ADC_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT0_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT1_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT2_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_GPOUT3_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_PERI_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_REF_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_REF_CTRL_SRC.h"
#include "../enums/CLOCKS_CLK_RTC_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_SYS_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_CLK_SYS_CTRL_SRC.h"
#include "../enums/CLOCKS_CLK_USB_CTRL_AUXSRC.h"
#include "../enums/CLOCKS_FC0_SRC_FC0_SRC.h"
#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] clocks
{
    /* Constant attributes. */
    static constexpr std::size_t size = 200; /*!< clocks's size in bytes. */

    /* Fields. */
    uint32_t CLK_GPOUT0_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT0_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT0_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_GPOUT1_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT1_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT1_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_GPOUT2_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT2_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT2_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_GPOUT3_CTRL; /*!< (read-write) Clock control, can be changed
                                 on-the-fly (except for auxsrc) */
    uint32_t CLK_GPOUT3_DIV;  /*!< (read-write) Clock divisor, can be changed
                                 on-the-fly */
    uint32_t CLK_GPOUT3_SELECTED; /*!< (read-write) Indicates which SRC is
    currently selected by the glitchless mux (one-hot).\n This slice does not
    have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
    register is hardwired to 0x1. */
    uint32_t CLK_REF_CTRL;     /*!< (read-write) Clock control, can be changed
                                  on-the-fly (except for auxsrc) */
    uint32_t CLK_REF_DIV;      /*!< (read-write) Clock divisor, can be changed
                                  on-the-fly */
    uint32_t CLK_REF_SELECTED; /*!< (read-write) Indicates which SRC is
 currently selected by the glitchless mux (one-hot).\n The glitchless
 multiplexer does not switch instantaneously (to avoid glitches), so software
 should poll this register to wait for the switch to complete. This register
 contains one decoded bit for each of the clock sources enumerated in the CTRL
 SRC field. At most one of these bits will be set at any time, indicating that
 clock is currently present at the output of the glitchless mux. Whilst
 switching is in progress, this register may briefly show all-0s. */
    uint32_t CLK_SYS_CTRL;     /*!< (read-write) Clock control, can be changed
                                  on-the-fly (except for auxsrc) */
    uint32_t CLK_SYS_DIV;      /*!< (read-write) Clock divisor, can be changed
                                  on-the-fly */
    uint32_t CLK_SYS_SELECTED; /*!< (read-write) Indicates which SRC is
 currently selected by the glitchless mux (one-hot).\n The glitchless
 multiplexer does not switch instantaneously (to avoid glitches), so software
 should poll this register to wait for the switch to complete. This register
 contains one decoded bit for each of the clock sources enumerated in the CTRL
 SRC field. At most one of these bits will be set at any time, indicating that
 clock is currently present at the output of the glitchless mux. Whilst
 switching is in progress, this register may briefly show all-0s. */
    uint32_t CLK_PERI_CTRL;    /*!< (read-write) Clock control, can be changed
                                  on-the-fly (except for auxsrc) */
    const uint32_t reserved_padding0 = {};
    uint32_t CLK_PERI_SELECTED; /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n This slice does not
  have a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register is hardwired to 0x1. */
    uint32_t CLK_USB_CTRL;      /*!< (read-write) Clock control, can be changed
                                   on-the-fly (except for auxsrc) */
    uint32_t CLK_USB_DIV;       /*!< (read-write) Clock divisor, can be changed
                                   on-the-fly */
    uint32_t CLK_USB_SELECTED;  /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n  This slice does not
  have  a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register  is hardwired to 0x1. */
    uint32_t CLK_ADC_CTRL;      /*!< (read-write) Clock control, can be changed
                                   on-the-fly (except for auxsrc) */
    uint32_t CLK_ADC_DIV;       /*!< (read-write) Clock divisor, can be changed
                                   on-the-fly */
    uint32_t CLK_ADC_SELECTED;  /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n  This slice does not
  have  a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register  is hardwired to 0x1. */
    uint32_t CLK_RTC_CTRL;      /*!< (read-write) Clock control, can be changed
                                   on-the-fly (except for auxsrc) */
    uint32_t CLK_RTC_DIV;       /*!< (read-write) Clock divisor, can be changed
                                   on-the-fly */
    uint32_t CLK_RTC_SELECTED;  /*!< (read-write) Indicates which SRC is
  currently selected by the glitchless mux (one-hot).\n  This slice does not
  have  a glitchless mux (only the AUX_SRC field is present, not SRC) so this
  register  is hardwired to 0x1. */
    uint32_t CLK_SYS_RESUS_CTRL;
    const uint32_t CLK_SYS_RESUS_STATUS = {};
    uint32_t FC0_REF_KHZ; /*!< (read-write) Reference clock frequency in kHz */
    uint32_t FC0_MIN_KHZ; /*!< (read-write) Minimum pass frequency in kHz. This
                             is optional. Set to 0 if you are not using the
                             pass/fail flags */
    uint32_t FC0_MAX_KHZ; /*!< (read-write) Maximum pass frequency in kHz. This
                             is optional. Set to 0x1ffffff if you are not using
                             the pass/fail flags */
    uint32_t FC0_DELAY;   /*!< (read-write) Delays the start of frequency
  counting to allow the mux to settle\n   Delay is measured in multiples of the
  reference clock period */
    uint32_t FC0_INTERVAL; /*!< (read-write) The test interval is 0.98us *
2**interval, but let's call it 1us * 2**interval\n The default gives a test
interval of 250us */
    uint32_t FC0_SRC; /*!< (read-write) Clock sent to frequency counter, set to
0 when not required\n Writing to this register initiates the frequency count */
    const uint32_t FC0_STATUS =
        {}; /*!< (read-only) Frequency counter status */
    const uint32_t FC0_RESULT =
        {}; /*!< (read-only) Result of frequency measurement, only valid when
               status_done=1 */
    uint32_t WAKE_EN0;  /*!< (read-write) enable clock in wake mode */
    uint32_t WAKE_EN1;  /*!< (read-write) enable clock in wake mode */
    uint32_t SLEEP_EN0; /*!< (read-write) enable clock in sleep mode */
    uint32_t SLEEP_EN1; /*!< (read-write) enable clock in sleep mode */
    const uint32_t ENABLED0 =
        {}; /*!< (read-only) indicates the state of the clock enable */
    const uint32_t ENABLED1 =
        {}; /*!< (read-only) indicates the state of the clock enable */
    const uint32_t INTR = {}; /*!< (read-only) Raw Interrupts */
    uint32_t INTE;            /*!< (read-write) Interrupt Enable */
    uint32_t INTF;            /*!< (read-write) Interrupt Force */
    const uint32_t INTS =
        {}; /*!< (read-only) Interrupt status after masking & forcing */

    /* Methods. */

    /**
     * Get CLK_GPOUT0_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_GPOUT0_CTRL_AUXSRC get_CLK_GPOUT0_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_GPOUT0_CTRL_AUXSRC((CLK_GPOUT0_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_GPOUT0_CTRL_AUXSRC(
        CLOCKS_CLK_GPOUT0_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_GPOUT0_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT0_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT0_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_GPOUT0_CTRL_KILL() volatile
    {
        return CLK_GPOUT0_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_GPOUT0_CTRL_KILL() volatile
    {
        CLK_GPOUT0_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_GPOUT0_CTRL_KILL() volatile
    {
        CLK_GPOUT0_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_GPOUT0_CTRL_KILL() volatile
    {
        CLK_GPOUT0_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT0_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_GPOUT0_CTRL_ENABLE() volatile
    {
        return CLK_GPOUT0_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_GPOUT0_CTRL_ENABLE() volatile
    {
        CLK_GPOUT0_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_GPOUT0_CTRL_ENABLE() volatile
    {
        CLK_GPOUT0_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_GPOUT0_CTRL_ENABLE() volatile
    {
        CLK_GPOUT0_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT0_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline bool get_CLK_GPOUT0_CTRL_DC50() volatile
    {
        return CLK_GPOUT0_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void set_CLK_GPOUT0_CTRL_DC50() volatile
    {
        CLK_GPOUT0_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void clear_CLK_GPOUT0_CTRL_DC50() volatile
    {
        CLK_GPOUT0_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void toggle_CLK_GPOUT0_CTRL_DC50() volatile
    {
        CLK_GPOUT0_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT0_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_GPOUT0_CTRL_PHASE() volatile
    {
        return (CLK_GPOUT0_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT0_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_GPOUT0_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT0_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT0_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT0_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_GPOUT0_CTRL_NUDGE() volatile
    {
        return CLK_GPOUT0_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT0_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_GPOUT0_CTRL_NUDGE() volatile
    {
        CLK_GPOUT0_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT0_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_GPOUT0_CTRL_NUDGE() volatile
    {
        CLK_GPOUT0_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT0_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_GPOUT0_CTRL_NUDGE() volatile
    {
        CLK_GPOUT0_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_GPOUT0_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_GPOUT0_CTRL(CLOCKS_CLK_GPOUT0_CTRL_AUXSRC &AUXSRC,
                                    bool &KILL, bool &ENABLE, bool &DC50,
                                    uint8_t &PHASE, bool &NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT0_CTRL;

        AUXSRC = CLOCKS_CLK_GPOUT0_CTRL_AUXSRC((curr >> 5u) & 0b1111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        DC50 = curr & (1u << 12u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_GPOUT0_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_GPOUT0_CTRL(CLOCKS_CLK_GPOUT0_CTRL_AUXSRC AUXSRC,
                                    bool KILL, bool ENABLE, bool DC50,
                                    uint8_t PHASE, bool NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT0_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b1111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (DC50 & 0b1u) << 12u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_GPOUT0_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT0_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline uint8_t get_CLK_GPOUT0_DIV_FRAC() volatile
    {
        return (CLK_GPOUT0_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT0_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline void set_CLK_GPOUT0_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT0_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT0_DIV = curr;
    }

    /**
     * Get CLK_GPOUT0_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint32_t get_CLK_GPOUT0_DIV_INT() volatile
    {
        return (CLK_GPOUT0_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT0_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_GPOUT0_DIV_INT(uint32_t value) volatile
    {
        uint32_t curr = CLK_GPOUT0_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT0_DIV = curr;
    }

    /**
     * Get all of CLK_GPOUT0_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void get_CLK_GPOUT0_DIV(uint8_t &FRAC, uint32_t &INT) volatile
    {
        uint32_t curr = CLK_GPOUT0_DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of CLK_GPOUT0_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void set_CLK_GPOUT0_DIV(uint8_t FRAC, uint32_t INT) volatile
    {
        uint32_t curr = CLK_GPOUT0_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (INT & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT0_DIV = curr;
    }

    /**
     * Get CLK_GPOUT1_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_GPOUT1_CTRL_AUXSRC get_CLK_GPOUT1_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_GPOUT1_CTRL_AUXSRC((CLK_GPOUT1_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_GPOUT1_CTRL_AUXSRC(
        CLOCKS_CLK_GPOUT1_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_GPOUT1_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT1_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT1_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_GPOUT1_CTRL_KILL() volatile
    {
        return CLK_GPOUT1_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_GPOUT1_CTRL_KILL() volatile
    {
        CLK_GPOUT1_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_GPOUT1_CTRL_KILL() volatile
    {
        CLK_GPOUT1_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_GPOUT1_CTRL_KILL() volatile
    {
        CLK_GPOUT1_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT1_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_GPOUT1_CTRL_ENABLE() volatile
    {
        return CLK_GPOUT1_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_GPOUT1_CTRL_ENABLE() volatile
    {
        CLK_GPOUT1_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_GPOUT1_CTRL_ENABLE() volatile
    {
        CLK_GPOUT1_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_GPOUT1_CTRL_ENABLE() volatile
    {
        CLK_GPOUT1_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT1_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline bool get_CLK_GPOUT1_CTRL_DC50() volatile
    {
        return CLK_GPOUT1_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void set_CLK_GPOUT1_CTRL_DC50() volatile
    {
        CLK_GPOUT1_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void clear_CLK_GPOUT1_CTRL_DC50() volatile
    {
        CLK_GPOUT1_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void toggle_CLK_GPOUT1_CTRL_DC50() volatile
    {
        CLK_GPOUT1_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT1_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_GPOUT1_CTRL_PHASE() volatile
    {
        return (CLK_GPOUT1_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT1_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_GPOUT1_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT1_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT1_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT1_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_GPOUT1_CTRL_NUDGE() volatile
    {
        return CLK_GPOUT1_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT1_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_GPOUT1_CTRL_NUDGE() volatile
    {
        CLK_GPOUT1_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT1_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_GPOUT1_CTRL_NUDGE() volatile
    {
        CLK_GPOUT1_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT1_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_GPOUT1_CTRL_NUDGE() volatile
    {
        CLK_GPOUT1_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_GPOUT1_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_GPOUT1_CTRL(CLOCKS_CLK_GPOUT1_CTRL_AUXSRC &AUXSRC,
                                    bool &KILL, bool &ENABLE, bool &DC50,
                                    uint8_t &PHASE, bool &NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT1_CTRL;

        AUXSRC = CLOCKS_CLK_GPOUT1_CTRL_AUXSRC((curr >> 5u) & 0b1111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        DC50 = curr & (1u << 12u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_GPOUT1_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_GPOUT1_CTRL(CLOCKS_CLK_GPOUT1_CTRL_AUXSRC AUXSRC,
                                    bool KILL, bool ENABLE, bool DC50,
                                    uint8_t PHASE, bool NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT1_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b1111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (DC50 & 0b1u) << 12u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_GPOUT1_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT1_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline uint8_t get_CLK_GPOUT1_DIV_FRAC() volatile
    {
        return (CLK_GPOUT1_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT1_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline void set_CLK_GPOUT1_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT1_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT1_DIV = curr;
    }

    /**
     * Get CLK_GPOUT1_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint32_t get_CLK_GPOUT1_DIV_INT() volatile
    {
        return (CLK_GPOUT1_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT1_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_GPOUT1_DIV_INT(uint32_t value) volatile
    {
        uint32_t curr = CLK_GPOUT1_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT1_DIV = curr;
    }

    /**
     * Get all of CLK_GPOUT1_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void get_CLK_GPOUT1_DIV(uint8_t &FRAC, uint32_t &INT) volatile
    {
        uint32_t curr = CLK_GPOUT1_DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of CLK_GPOUT1_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void set_CLK_GPOUT1_DIV(uint8_t FRAC, uint32_t INT) volatile
    {
        uint32_t curr = CLK_GPOUT1_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (INT & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT1_DIV = curr;
    }

    /**
     * Get CLK_GPOUT2_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_GPOUT2_CTRL_AUXSRC get_CLK_GPOUT2_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_GPOUT2_CTRL_AUXSRC((CLK_GPOUT2_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_GPOUT2_CTRL_AUXSRC(
        CLOCKS_CLK_GPOUT2_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_GPOUT2_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT2_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT2_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_GPOUT2_CTRL_KILL() volatile
    {
        return CLK_GPOUT2_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_GPOUT2_CTRL_KILL() volatile
    {
        CLK_GPOUT2_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_GPOUT2_CTRL_KILL() volatile
    {
        CLK_GPOUT2_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_GPOUT2_CTRL_KILL() volatile
    {
        CLK_GPOUT2_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT2_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_GPOUT2_CTRL_ENABLE() volatile
    {
        return CLK_GPOUT2_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_GPOUT2_CTRL_ENABLE() volatile
    {
        CLK_GPOUT2_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_GPOUT2_CTRL_ENABLE() volatile
    {
        CLK_GPOUT2_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_GPOUT2_CTRL_ENABLE() volatile
    {
        CLK_GPOUT2_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT2_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline bool get_CLK_GPOUT2_CTRL_DC50() volatile
    {
        return CLK_GPOUT2_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void set_CLK_GPOUT2_CTRL_DC50() volatile
    {
        CLK_GPOUT2_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void clear_CLK_GPOUT2_CTRL_DC50() volatile
    {
        CLK_GPOUT2_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void toggle_CLK_GPOUT2_CTRL_DC50() volatile
    {
        CLK_GPOUT2_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT2_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_GPOUT2_CTRL_PHASE() volatile
    {
        return (CLK_GPOUT2_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT2_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_GPOUT2_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT2_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT2_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT2_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_GPOUT2_CTRL_NUDGE() volatile
    {
        return CLK_GPOUT2_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT2_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_GPOUT2_CTRL_NUDGE() volatile
    {
        CLK_GPOUT2_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT2_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_GPOUT2_CTRL_NUDGE() volatile
    {
        CLK_GPOUT2_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT2_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_GPOUT2_CTRL_NUDGE() volatile
    {
        CLK_GPOUT2_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_GPOUT2_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_GPOUT2_CTRL(CLOCKS_CLK_GPOUT2_CTRL_AUXSRC &AUXSRC,
                                    bool &KILL, bool &ENABLE, bool &DC50,
                                    uint8_t &PHASE, bool &NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT2_CTRL;

        AUXSRC = CLOCKS_CLK_GPOUT2_CTRL_AUXSRC((curr >> 5u) & 0b1111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        DC50 = curr & (1u << 12u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_GPOUT2_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_GPOUT2_CTRL(CLOCKS_CLK_GPOUT2_CTRL_AUXSRC AUXSRC,
                                    bool KILL, bool ENABLE, bool DC50,
                                    uint8_t PHASE, bool NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT2_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b1111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (DC50 & 0b1u) << 12u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_GPOUT2_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT2_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline uint8_t get_CLK_GPOUT2_DIV_FRAC() volatile
    {
        return (CLK_GPOUT2_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT2_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline void set_CLK_GPOUT2_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT2_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT2_DIV = curr;
    }

    /**
     * Get CLK_GPOUT2_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint32_t get_CLK_GPOUT2_DIV_INT() volatile
    {
        return (CLK_GPOUT2_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT2_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_GPOUT2_DIV_INT(uint32_t value) volatile
    {
        uint32_t curr = CLK_GPOUT2_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT2_DIV = curr;
    }

    /**
     * Get all of CLK_GPOUT2_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void get_CLK_GPOUT2_DIV(uint8_t &FRAC, uint32_t &INT) volatile
    {
        uint32_t curr = CLK_GPOUT2_DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of CLK_GPOUT2_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void set_CLK_GPOUT2_DIV(uint8_t FRAC, uint32_t INT) volatile
    {
        uint32_t curr = CLK_GPOUT2_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (INT & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT2_DIV = curr;
    }

    /**
     * Get CLK_GPOUT3_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_GPOUT3_CTRL_AUXSRC get_CLK_GPOUT3_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_GPOUT3_CTRL_AUXSRC((CLK_GPOUT3_CTRL >> 5u) &
                                             0b1111u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_GPOUT3_CTRL_AUXSRC(
        CLOCKS_CLK_GPOUT3_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_GPOUT3_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(value) & 0b1111u) << 5u;

        CLK_GPOUT3_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT3_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_GPOUT3_CTRL_KILL() volatile
    {
        return CLK_GPOUT3_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_GPOUT3_CTRL_KILL() volatile
    {
        CLK_GPOUT3_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_GPOUT3_CTRL_KILL() volatile
    {
        CLK_GPOUT3_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_GPOUT3_CTRL_KILL() volatile
    {
        CLK_GPOUT3_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_GPOUT3_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_GPOUT3_CTRL_ENABLE() volatile
    {
        return CLK_GPOUT3_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_GPOUT3_CTRL_ENABLE() volatile
    {
        CLK_GPOUT3_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_GPOUT3_CTRL_ENABLE() volatile
    {
        CLK_GPOUT3_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_GPOUT3_CTRL_ENABLE() volatile
    {
        CLK_GPOUT3_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_GPOUT3_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline bool get_CLK_GPOUT3_CTRL_DC50() volatile
    {
        return CLK_GPOUT3_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void set_CLK_GPOUT3_CTRL_DC50() volatile
    {
        CLK_GPOUT3_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void clear_CLK_GPOUT3_CTRL_DC50() volatile
    {
        CLK_GPOUT3_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's DC50 bit.
     *
     * Enables duty cycle correction for odd divisors
     */
    inline void toggle_CLK_GPOUT3_CTRL_DC50() volatile
    {
        CLK_GPOUT3_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_GPOUT3_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_GPOUT3_CTRL_PHASE() volatile
    {
        return (CLK_GPOUT3_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_GPOUT3_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_GPOUT3_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT3_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_GPOUT3_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT3_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_GPOUT3_CTRL_NUDGE() volatile
    {
        return CLK_GPOUT3_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_GPOUT3_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_GPOUT3_CTRL_NUDGE() volatile
    {
        CLK_GPOUT3_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_GPOUT3_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_GPOUT3_CTRL_NUDGE() volatile
    {
        CLK_GPOUT3_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_GPOUT3_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_GPOUT3_CTRL_NUDGE() volatile
    {
        CLK_GPOUT3_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_GPOUT3_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_GPOUT3_CTRL(CLOCKS_CLK_GPOUT3_CTRL_AUXSRC &AUXSRC,
                                    bool &KILL, bool &ENABLE, bool &DC50,
                                    uint8_t &PHASE, bool &NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT3_CTRL;

        AUXSRC = CLOCKS_CLK_GPOUT3_CTRL_AUXSRC((curr >> 5u) & 0b1111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        DC50 = curr & (1u << 12u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_GPOUT3_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_GPOUT3_CTRL(CLOCKS_CLK_GPOUT3_CTRL_AUXSRC AUXSRC,
                                    bool KILL, bool ENABLE, bool DC50,
                                    uint8_t PHASE, bool NUDGE) volatile
    {
        uint32_t curr = CLK_GPOUT3_CTRL;

        curr &= ~(0b1111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b1111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (DC50 & 0b1u) << 12u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_GPOUT3_CTRL = curr;
    }

    /**
     * Get CLK_GPOUT3_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline uint8_t get_CLK_GPOUT3_DIV_FRAC() volatile
    {
        return (CLK_GPOUT3_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_GPOUT3_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline void set_CLK_GPOUT3_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CLK_GPOUT3_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_GPOUT3_DIV = curr;
    }

    /**
     * Get CLK_GPOUT3_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint32_t get_CLK_GPOUT3_DIV_INT() volatile
    {
        return (CLK_GPOUT3_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_GPOUT3_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_GPOUT3_DIV_INT(uint32_t value) volatile
    {
        uint32_t curr = CLK_GPOUT3_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT3_DIV = curr;
    }

    /**
     * Get all of CLK_GPOUT3_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void get_CLK_GPOUT3_DIV(uint8_t &FRAC, uint32_t &INT) volatile
    {
        uint32_t curr = CLK_GPOUT3_DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of CLK_GPOUT3_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void set_CLK_GPOUT3_DIV(uint8_t FRAC, uint32_t INT) volatile
    {
        uint32_t curr = CLK_GPOUT3_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (INT & 0b111111111111111111111111u) << 8u;

        CLK_GPOUT3_DIV = curr;
    }

    /**
     * Get CLK_REF_CTRL's SRC field.
     *
     * Selects the clock source glitchlessly, can be changed on-the-fly
     */
    inline CLOCKS_CLK_REF_CTRL_SRC get_CLK_REF_CTRL_SRC() volatile
    {
        return CLOCKS_CLK_REF_CTRL_SRC((CLK_REF_CTRL >> 0u) & 0b11u);
    }

    /**
     * Set CLK_REF_CTRL's SRC field.
     *
     * Selects the clock source glitchlessly, can be changed on-the-fly
     */
    inline void set_CLK_REF_CTRL_SRC(CLOCKS_CLK_REF_CTRL_SRC value) volatile
    {
        uint32_t curr = CLK_REF_CTRL;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(value) & 0b11u) << 0u;

        CLK_REF_CTRL = curr;
    }

    /**
     * Get CLK_REF_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_REF_CTRL_AUXSRC get_CLK_REF_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_REF_CTRL_AUXSRC((CLK_REF_CTRL >> 5u) & 0b11u);
    }

    /**
     * Set CLK_REF_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_REF_CTRL_AUXSRC(
        CLOCKS_CLK_REF_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_REF_CTRL;

        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(value) & 0b11u) << 5u;

        CLK_REF_CTRL = curr;
    }

    /**
     * Get all of CLK_REF_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_REF_CTRL(CLOCKS_CLK_REF_CTRL_SRC &SRC,
                                 CLOCKS_CLK_REF_CTRL_AUXSRC &AUXSRC) volatile
    {
        uint32_t curr = CLK_REF_CTRL;

        SRC = CLOCKS_CLK_REF_CTRL_SRC((curr >> 0u) & 0b11u);
        AUXSRC = CLOCKS_CLK_REF_CTRL_AUXSRC((curr >> 5u) & 0b11u);
    }

    /**
     * Set all of CLK_REF_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_REF_CTRL(CLOCKS_CLK_REF_CTRL_SRC SRC,
                                 CLOCKS_CLK_REF_CTRL_AUXSRC AUXSRC) volatile
    {
        uint32_t curr = CLK_REF_CTRL;

        curr &= ~(0b11u << 0u);
        curr |= (std::to_underlying(SRC) & 0b11u) << 0u;
        curr &= ~(0b11u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b11u) << 5u;

        CLK_REF_CTRL = curr;
    }

    /**
     * Get CLK_REF_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint8_t get_CLK_REF_DIV_INT() volatile
    {
        return (CLK_REF_DIV >> 8u) & 0b11u;
    }

    /**
     * Set CLK_REF_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_REF_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CLK_REF_DIV;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        CLK_REF_DIV = curr;
    }

    /**
     * Get CLK_SYS_CTRL's SRC bit.
     *
     * Selects the clock source glitchlessly, can be changed on-the-fly
     */
    inline CLOCKS_CLK_SYS_CTRL_SRC get_CLK_SYS_CTRL_SRC() volatile
    {
        return CLOCKS_CLK_SYS_CTRL_SRC(CLK_SYS_CTRL & (1u << 0u));
    }

    /**
     * Set CLK_SYS_CTRL's SRC bit.
     *
     * Selects the clock source glitchlessly, can be changed on-the-fly
     */
    inline void set_CLK_SYS_CTRL_SRC() volatile
    {
        CLK_SYS_CTRL |= 1u << 0u;
    }

    /**
     * Clear CLK_SYS_CTRL's SRC bit.
     *
     * Selects the clock source glitchlessly, can be changed on-the-fly
     */
    inline void clear_CLK_SYS_CTRL_SRC() volatile
    {
        CLK_SYS_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle CLK_SYS_CTRL's SRC bit.
     *
     * Selects the clock source glitchlessly, can be changed on-the-fly
     */
    inline void toggle_CLK_SYS_CTRL_SRC() volatile
    {
        CLK_SYS_CTRL ^= 1u << 0u;
    }

    /**
     * Get CLK_SYS_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_SYS_CTRL_AUXSRC get_CLK_SYS_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_SYS_CTRL_AUXSRC((CLK_SYS_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_SYS_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_SYS_CTRL_AUXSRC(
        CLOCKS_CLK_SYS_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_SYS_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_SYS_CTRL = curr;
    }

    /**
     * Get all of CLK_SYS_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_SYS_CTRL(CLOCKS_CLK_SYS_CTRL_SRC &SRC,
                                 CLOCKS_CLK_SYS_CTRL_AUXSRC &AUXSRC) volatile
    {
        uint32_t curr = CLK_SYS_CTRL;

        SRC = CLOCKS_CLK_SYS_CTRL_SRC(curr & (1u << 0u));
        AUXSRC = CLOCKS_CLK_SYS_CTRL_AUXSRC((curr >> 5u) & 0b111u);
    }

    /**
     * Set all of CLK_SYS_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_SYS_CTRL(CLOCKS_CLK_SYS_CTRL_SRC SRC,
                                 CLOCKS_CLK_SYS_CTRL_AUXSRC AUXSRC) volatile
    {
        uint32_t curr = CLK_SYS_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (std::to_underlying(SRC) & 0b1u) << 0u;
        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b111u) << 5u;

        CLK_SYS_CTRL = curr;
    }

    /**
     * Get CLK_SYS_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline uint8_t get_CLK_SYS_DIV_FRAC() volatile
    {
        return (CLK_SYS_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_SYS_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline void set_CLK_SYS_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CLK_SYS_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_SYS_DIV = curr;
    }

    /**
     * Get CLK_SYS_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint32_t get_CLK_SYS_DIV_INT() volatile
    {
        return (CLK_SYS_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_SYS_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_SYS_DIV_INT(uint32_t value) volatile
    {
        uint32_t curr = CLK_SYS_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_SYS_DIV = curr;
    }

    /**
     * Get all of CLK_SYS_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void get_CLK_SYS_DIV(uint8_t &FRAC, uint32_t &INT) volatile
    {
        uint32_t curr = CLK_SYS_DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of CLK_SYS_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void set_CLK_SYS_DIV(uint8_t FRAC, uint32_t INT) volatile
    {
        uint32_t curr = CLK_SYS_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (INT & 0b111111111111111111111111u) << 8u;

        CLK_SYS_DIV = curr;
    }

    /**
     * Get CLK_PERI_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_PERI_CTRL_AUXSRC get_CLK_PERI_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_PERI_CTRL_AUXSRC((CLK_PERI_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_PERI_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_PERI_CTRL_AUXSRC(
        CLOCKS_CLK_PERI_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_PERI_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_PERI_CTRL = curr;
    }

    /**
     * Get CLK_PERI_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_PERI_CTRL_KILL() volatile
    {
        return CLK_PERI_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_PERI_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_PERI_CTRL_KILL() volatile
    {
        CLK_PERI_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_PERI_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_PERI_CTRL_KILL() volatile
    {
        CLK_PERI_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_PERI_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_PERI_CTRL_KILL() volatile
    {
        CLK_PERI_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_PERI_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_PERI_CTRL_ENABLE() volatile
    {
        return CLK_PERI_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_PERI_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_PERI_CTRL_ENABLE() volatile
    {
        CLK_PERI_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_PERI_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_PERI_CTRL_ENABLE() volatile
    {
        CLK_PERI_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_PERI_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_PERI_CTRL_ENABLE() volatile
    {
        CLK_PERI_CTRL ^= 1u << 11u;
    }

    /**
     * Get all of CLK_PERI_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_PERI_CTRL(CLOCKS_CLK_PERI_CTRL_AUXSRC &AUXSRC,
                                  bool &KILL, bool &ENABLE) volatile
    {
        uint32_t curr = CLK_PERI_CTRL;

        AUXSRC = CLOCKS_CLK_PERI_CTRL_AUXSRC((curr >> 5u) & 0b111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
    }

    /**
     * Set all of CLK_PERI_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_PERI_CTRL(CLOCKS_CLK_PERI_CTRL_AUXSRC AUXSRC,
                                  bool KILL, bool ENABLE) volatile
    {
        uint32_t curr = CLK_PERI_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;

        CLK_PERI_CTRL = curr;
    }

    /**
     * Get CLK_USB_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_USB_CTRL_AUXSRC get_CLK_USB_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_USB_CTRL_AUXSRC((CLK_USB_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_USB_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_USB_CTRL_AUXSRC(
        CLOCKS_CLK_USB_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_USB_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_USB_CTRL = curr;
    }

    /**
     * Get CLK_USB_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_USB_CTRL_KILL() volatile
    {
        return CLK_USB_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_USB_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_USB_CTRL_KILL() volatile
    {
        CLK_USB_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_USB_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_USB_CTRL_KILL() volatile
    {
        CLK_USB_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_USB_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_USB_CTRL_KILL() volatile
    {
        CLK_USB_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_USB_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_USB_CTRL_ENABLE() volatile
    {
        return CLK_USB_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_USB_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_USB_CTRL_ENABLE() volatile
    {
        CLK_USB_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_USB_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_USB_CTRL_ENABLE() volatile
    {
        CLK_USB_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_USB_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_USB_CTRL_ENABLE() volatile
    {
        CLK_USB_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_USB_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_USB_CTRL_PHASE() volatile
    {
        return (CLK_USB_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_USB_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_USB_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_USB_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_USB_CTRL = curr;
    }

    /**
     * Get CLK_USB_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_USB_CTRL_NUDGE() volatile
    {
        return CLK_USB_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_USB_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_USB_CTRL_NUDGE() volatile
    {
        CLK_USB_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_USB_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_USB_CTRL_NUDGE() volatile
    {
        CLK_USB_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_USB_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_USB_CTRL_NUDGE() volatile
    {
        CLK_USB_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_USB_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_USB_CTRL(CLOCKS_CLK_USB_CTRL_AUXSRC &AUXSRC,
                                 bool &KILL, bool &ENABLE, uint8_t &PHASE,
                                 bool &NUDGE) volatile
    {
        uint32_t curr = CLK_USB_CTRL;

        AUXSRC = CLOCKS_CLK_USB_CTRL_AUXSRC((curr >> 5u) & 0b111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_USB_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_USB_CTRL(CLOCKS_CLK_USB_CTRL_AUXSRC AUXSRC, bool KILL,
                                 bool ENABLE, uint8_t PHASE,
                                 bool NUDGE) volatile
    {
        uint32_t curr = CLK_USB_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_USB_CTRL = curr;
    }

    /**
     * Get CLK_USB_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint8_t get_CLK_USB_DIV_INT() volatile
    {
        return (CLK_USB_DIV >> 8u) & 0b11u;
    }

    /**
     * Set CLK_USB_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_USB_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CLK_USB_DIV;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        CLK_USB_DIV = curr;
    }

    /**
     * Get CLK_ADC_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_ADC_CTRL_AUXSRC get_CLK_ADC_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_ADC_CTRL_AUXSRC((CLK_ADC_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_ADC_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_ADC_CTRL_AUXSRC(
        CLOCKS_CLK_ADC_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_ADC_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_ADC_CTRL = curr;
    }

    /**
     * Get CLK_ADC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_ADC_CTRL_KILL() volatile
    {
        return CLK_ADC_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_ADC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_ADC_CTRL_KILL() volatile
    {
        CLK_ADC_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_ADC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_ADC_CTRL_KILL() volatile
    {
        CLK_ADC_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_ADC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_ADC_CTRL_KILL() volatile
    {
        CLK_ADC_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_ADC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_ADC_CTRL_ENABLE() volatile
    {
        return CLK_ADC_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_ADC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_ADC_CTRL_ENABLE() volatile
    {
        CLK_ADC_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_ADC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_ADC_CTRL_ENABLE() volatile
    {
        CLK_ADC_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_ADC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_ADC_CTRL_ENABLE() volatile
    {
        CLK_ADC_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_ADC_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_ADC_CTRL_PHASE() volatile
    {
        return (CLK_ADC_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_ADC_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_ADC_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_ADC_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_ADC_CTRL = curr;
    }

    /**
     * Get CLK_ADC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_ADC_CTRL_NUDGE() volatile
    {
        return CLK_ADC_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_ADC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_ADC_CTRL_NUDGE() volatile
    {
        CLK_ADC_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_ADC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_ADC_CTRL_NUDGE() volatile
    {
        CLK_ADC_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_ADC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_ADC_CTRL_NUDGE() volatile
    {
        CLK_ADC_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_ADC_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_ADC_CTRL(CLOCKS_CLK_ADC_CTRL_AUXSRC &AUXSRC,
                                 bool &KILL, bool &ENABLE, uint8_t &PHASE,
                                 bool &NUDGE) volatile
    {
        uint32_t curr = CLK_ADC_CTRL;

        AUXSRC = CLOCKS_CLK_ADC_CTRL_AUXSRC((curr >> 5u) & 0b111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_ADC_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_ADC_CTRL(CLOCKS_CLK_ADC_CTRL_AUXSRC AUXSRC, bool KILL,
                                 bool ENABLE, uint8_t PHASE,
                                 bool NUDGE) volatile
    {
        uint32_t curr = CLK_ADC_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_ADC_CTRL = curr;
    }

    /**
     * Get CLK_ADC_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint8_t get_CLK_ADC_DIV_INT() volatile
    {
        return (CLK_ADC_DIV >> 8u) & 0b11u;
    }

    /**
     * Set CLK_ADC_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_ADC_DIV_INT(uint8_t value) volatile
    {
        uint32_t curr = CLK_ADC_DIV;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        CLK_ADC_DIV = curr;
    }

    /**
     * Get CLK_RTC_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline CLOCKS_CLK_RTC_CTRL_AUXSRC get_CLK_RTC_CTRL_AUXSRC() volatile
    {
        return CLOCKS_CLK_RTC_CTRL_AUXSRC((CLK_RTC_CTRL >> 5u) & 0b111u);
    }

    /**
     * Set CLK_RTC_CTRL's AUXSRC field.
     *
     * Selects the auxiliary clock source, will glitch when switching
     */
    inline void set_CLK_RTC_CTRL_AUXSRC(
        CLOCKS_CLK_RTC_CTRL_AUXSRC value) volatile
    {
        uint32_t curr = CLK_RTC_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(value) & 0b111u) << 5u;

        CLK_RTC_CTRL = curr;
    }

    /**
     * Get CLK_RTC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline bool get_CLK_RTC_CTRL_KILL() volatile
    {
        return CLK_RTC_CTRL & (1u << 10u);
    }

    /**
     * Set CLK_RTC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void set_CLK_RTC_CTRL_KILL() volatile
    {
        CLK_RTC_CTRL |= 1u << 10u;
    }

    /**
     * Clear CLK_RTC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void clear_CLK_RTC_CTRL_KILL() volatile
    {
        CLK_RTC_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle CLK_RTC_CTRL's KILL bit.
     *
     * Asynchronously kills the clock generator
     */
    inline void toggle_CLK_RTC_CTRL_KILL() volatile
    {
        CLK_RTC_CTRL ^= 1u << 10u;
    }

    /**
     * Get CLK_RTC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline bool get_CLK_RTC_CTRL_ENABLE() volatile
    {
        return CLK_RTC_CTRL & (1u << 11u);
    }

    /**
     * Set CLK_RTC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void set_CLK_RTC_CTRL_ENABLE() volatile
    {
        CLK_RTC_CTRL |= 1u << 11u;
    }

    /**
     * Clear CLK_RTC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void clear_CLK_RTC_CTRL_ENABLE() volatile
    {
        CLK_RTC_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle CLK_RTC_CTRL's ENABLE bit.
     *
     * Starts and stops the clock generator cleanly
     */
    inline void toggle_CLK_RTC_CTRL_ENABLE() volatile
    {
        CLK_RTC_CTRL ^= 1u << 11u;
    }

    /**
     * Get CLK_RTC_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline uint8_t get_CLK_RTC_CTRL_PHASE() volatile
    {
        return (CLK_RTC_CTRL >> 16u) & 0b11u;
    }

    /**
     * Set CLK_RTC_CTRL's PHASE field.
     *
     * This delays the enable signal by up to 3 cycles of the input clock\n
     *                 This must be set before the clock is enabled to have any
     * effect
     */
    inline void set_CLK_RTC_CTRL_PHASE(uint8_t value) volatile
    {
        uint32_t curr = CLK_RTC_CTRL;

        curr &= ~(0b11u << 16u);
        curr |= (value & 0b11u) << 16u;

        CLK_RTC_CTRL = curr;
    }

    /**
     * Get CLK_RTC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline bool get_CLK_RTC_CTRL_NUDGE() volatile
    {
        return CLK_RTC_CTRL & (1u << 20u);
    }

    /**
     * Set CLK_RTC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void set_CLK_RTC_CTRL_NUDGE() volatile
    {
        CLK_RTC_CTRL |= 1u << 20u;
    }

    /**
     * Clear CLK_RTC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void clear_CLK_RTC_CTRL_NUDGE() volatile
    {
        CLK_RTC_CTRL &= ~(1u << 20u);
    }

    /**
     * Toggle CLK_RTC_CTRL's NUDGE bit.
     *
     * An edge on this signal shifts the phase of the output by 1 cycle of the
     * input clock\n This can be done at any time
     */
    inline void toggle_CLK_RTC_CTRL_NUDGE() volatile
    {
        CLK_RTC_CTRL ^= 1u << 20u;
    }

    /**
     * Get all of CLK_RTC_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void get_CLK_RTC_CTRL(CLOCKS_CLK_RTC_CTRL_AUXSRC &AUXSRC,
                                 bool &KILL, bool &ENABLE, uint8_t &PHASE,
                                 bool &NUDGE) volatile
    {
        uint32_t curr = CLK_RTC_CTRL;

        AUXSRC = CLOCKS_CLK_RTC_CTRL_AUXSRC((curr >> 5u) & 0b111u);
        KILL = curr & (1u << 10u);
        ENABLE = curr & (1u << 11u);
        PHASE = (curr >> 16u) & 0b11u;
        NUDGE = curr & (1u << 20u);
    }

    /**
     * Set all of CLK_RTC_CTRL's bit fields.
     *
     * (read-write) Clock control, can be changed on-the-fly (except for
     * auxsrc)
     */
    inline void set_CLK_RTC_CTRL(CLOCKS_CLK_RTC_CTRL_AUXSRC AUXSRC, bool KILL,
                                 bool ENABLE, uint8_t PHASE,
                                 bool NUDGE) volatile
    {
        uint32_t curr = CLK_RTC_CTRL;

        curr &= ~(0b111u << 5u);
        curr |= (std::to_underlying(AUXSRC) & 0b111u) << 5u;
        curr &= ~(0b1u << 10u);
        curr |= (KILL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (ENABLE & 0b1u) << 11u;
        curr &= ~(0b11u << 16u);
        curr |= (PHASE & 0b11u) << 16u;
        curr &= ~(0b1u << 20u);
        curr |= (NUDGE & 0b1u) << 20u;

        CLK_RTC_CTRL = curr;
    }

    /**
     * Get CLK_RTC_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline uint8_t get_CLK_RTC_DIV_FRAC() volatile
    {
        return (CLK_RTC_DIV >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_RTC_DIV's FRAC field.
     *
     * Fractional component of the divisor
     */
    inline void set_CLK_RTC_DIV_FRAC(uint8_t value) volatile
    {
        uint32_t curr = CLK_RTC_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_RTC_DIV = curr;
    }

    /**
     * Get CLK_RTC_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline uint32_t get_CLK_RTC_DIV_INT() volatile
    {
        return (CLK_RTC_DIV >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set CLK_RTC_DIV's INT field.
     *
     * Integer component of the divisor, 0 -> divide by 2^16
     */
    inline void set_CLK_RTC_DIV_INT(uint32_t value) volatile
    {
        uint32_t curr = CLK_RTC_DIV;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        CLK_RTC_DIV = curr;
    }

    /**
     * Get all of CLK_RTC_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void get_CLK_RTC_DIV(uint8_t &FRAC, uint32_t &INT) volatile
    {
        uint32_t curr = CLK_RTC_DIV;

        FRAC = (curr >> 0u) & 0b11111111u;
        INT = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of CLK_RTC_DIV's bit fields.
     *
     * (read-write) Clock divisor, can be changed on-the-fly
     */
    inline void set_CLK_RTC_DIV(uint8_t FRAC, uint32_t INT) volatile
    {
        uint32_t curr = CLK_RTC_DIV;

        curr &= ~(0b11111111u << 0u);
        curr |= (FRAC & 0b11111111u) << 0u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (INT & 0b111111111111111111111111u) << 8u;

        CLK_RTC_DIV = curr;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's TIMEOUT field.
     *
     * This is expressed as a number of clk_ref cycles\n
     *                 and must be >= 2x clk_ref_freq/min_clk_tst_freq
     */
    inline uint8_t get_CLK_SYS_RESUS_CTRL_TIMEOUT() volatile
    {
        return (CLK_SYS_RESUS_CTRL >> 0u) & 0b11111111u;
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's TIMEOUT field.
     *
     * This is expressed as a number of clk_ref cycles\n
     *                 and must be >= 2x clk_ref_freq/min_clk_tst_freq
     */
    inline void set_CLK_SYS_RESUS_CTRL_TIMEOUT(uint8_t value) volatile
    {
        uint32_t curr = CLK_SYS_RESUS_CTRL;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        CLK_SYS_RESUS_CTRL = curr;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's ENABLE bit.
     *
     * Enable resus
     */
    inline bool get_CLK_SYS_RESUS_CTRL_ENABLE() volatile
    {
        return CLK_SYS_RESUS_CTRL & (1u << 8u);
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's ENABLE bit.
     *
     * Enable resus
     */
    inline void set_CLK_SYS_RESUS_CTRL_ENABLE() volatile
    {
        CLK_SYS_RESUS_CTRL |= 1u << 8u;
    }

    /**
     * Clear CLK_SYS_RESUS_CTRL's ENABLE bit.
     *
     * Enable resus
     */
    inline void clear_CLK_SYS_RESUS_CTRL_ENABLE() volatile
    {
        CLK_SYS_RESUS_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle CLK_SYS_RESUS_CTRL's ENABLE bit.
     *
     * Enable resus
     */
    inline void toggle_CLK_SYS_RESUS_CTRL_ENABLE() volatile
    {
        CLK_SYS_RESUS_CTRL ^= 1u << 8u;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's FRCE bit.
     *
     * Force a resus, for test purposes only
     */
    inline bool get_CLK_SYS_RESUS_CTRL_FRCE() volatile
    {
        return CLK_SYS_RESUS_CTRL & (1u << 12u);
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's FRCE bit.
     *
     * Force a resus, for test purposes only
     */
    inline void set_CLK_SYS_RESUS_CTRL_FRCE() volatile
    {
        CLK_SYS_RESUS_CTRL |= 1u << 12u;
    }

    /**
     * Clear CLK_SYS_RESUS_CTRL's FRCE bit.
     *
     * Force a resus, for test purposes only
     */
    inline void clear_CLK_SYS_RESUS_CTRL_FRCE() volatile
    {
        CLK_SYS_RESUS_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle CLK_SYS_RESUS_CTRL's FRCE bit.
     *
     * Force a resus, for test purposes only
     */
    inline void toggle_CLK_SYS_RESUS_CTRL_FRCE() volatile
    {
        CLK_SYS_RESUS_CTRL ^= 1u << 12u;
    }

    /**
     * Get CLK_SYS_RESUS_CTRL's CLEAR bit.
     *
     * For clearing the resus after the fault that triggered it has been
     * corrected
     */
    inline bool get_CLK_SYS_RESUS_CTRL_CLEAR() volatile
    {
        return CLK_SYS_RESUS_CTRL & (1u << 16u);
    }

    /**
     * Set CLK_SYS_RESUS_CTRL's CLEAR bit.
     *
     * For clearing the resus after the fault that triggered it has been
     * corrected
     */
    inline void set_CLK_SYS_RESUS_CTRL_CLEAR() volatile
    {
        CLK_SYS_RESUS_CTRL |= 1u << 16u;
    }

    /**
     * Clear CLK_SYS_RESUS_CTRL's CLEAR bit.
     *
     * For clearing the resus after the fault that triggered it has been
     * corrected
     */
    inline void clear_CLK_SYS_RESUS_CTRL_CLEAR() volatile
    {
        CLK_SYS_RESUS_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle CLK_SYS_RESUS_CTRL's CLEAR bit.
     *
     * For clearing the resus after the fault that triggered it has been
     * corrected
     */
    inline void toggle_CLK_SYS_RESUS_CTRL_CLEAR() volatile
    {
        CLK_SYS_RESUS_CTRL ^= 1u << 16u;
    }

    /**
     * Get all of CLK_SYS_RESUS_CTRL's bit fields.
     */
    inline void get_CLK_SYS_RESUS_CTRL(uint8_t &TIMEOUT, bool &ENABLE,
                                       bool &FRCE, bool &CLEAR) volatile
    {
        uint32_t curr = CLK_SYS_RESUS_CTRL;

        TIMEOUT = (curr >> 0u) & 0b11111111u;
        ENABLE = curr & (1u << 8u);
        FRCE = curr & (1u << 12u);
        CLEAR = curr & (1u << 16u);
    }

    /**
     * Set all of CLK_SYS_RESUS_CTRL's bit fields.
     */
    inline void set_CLK_SYS_RESUS_CTRL(uint8_t TIMEOUT, bool ENABLE, bool FRCE,
                                       bool CLEAR) volatile
    {
        uint32_t curr = CLK_SYS_RESUS_CTRL;

        curr &= ~(0b11111111u << 0u);
        curr |= (TIMEOUT & 0b11111111u) << 0u;
        curr &= ~(0b1u << 8u);
        curr |= (ENABLE & 0b1u) << 8u;
        curr &= ~(0b1u << 12u);
        curr |= (FRCE & 0b1u) << 12u;
        curr &= ~(0b1u << 16u);
        curr |= (CLEAR & 0b1u) << 16u;

        CLK_SYS_RESUS_CTRL = curr;
    }

    /**
     * Get CLK_SYS_RESUS_STATUS's RESUSSED bit.
     *
     * Clock has been resuscitated, correct the error then send ctrl_clear=1
     */
    inline bool get_CLK_SYS_RESUS_STATUS_RESUSSED() volatile
    {
        return CLK_SYS_RESUS_STATUS & (1u << 0u);
    }

    /**
     * Get FC0_REF_KHZ's FC0_REF_KHZ field.
     */
    inline uint32_t get_FC0_REF_KHZ_FC0_REF_KHZ() volatile
    {
        return (FC0_REF_KHZ >> 0u) & 0b11111111111111111111u;
    }

    /**
     * Set FC0_REF_KHZ's FC0_REF_KHZ field.
     */
    inline void set_FC0_REF_KHZ_FC0_REF_KHZ(uint32_t value) volatile
    {
        uint32_t curr = FC0_REF_KHZ;

        curr &= ~(0b11111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111u) << 0u;

        FC0_REF_KHZ = curr;
    }

    /**
     * Get FC0_MIN_KHZ's FC0_MIN_KHZ field.
     */
    inline uint32_t get_FC0_MIN_KHZ_FC0_MIN_KHZ() volatile
    {
        return (FC0_MIN_KHZ >> 0u) & 0b1111111111111111111111111u;
    }

    /**
     * Set FC0_MIN_KHZ's FC0_MIN_KHZ field.
     */
    inline void set_FC0_MIN_KHZ_FC0_MIN_KHZ(uint32_t value) volatile
    {
        uint32_t curr = FC0_MIN_KHZ;

        curr &= ~(0b1111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111u) << 0u;

        FC0_MIN_KHZ = curr;
    }

    /**
     * Get FC0_MAX_KHZ's FC0_MAX_KHZ field.
     */
    inline uint32_t get_FC0_MAX_KHZ_FC0_MAX_KHZ() volatile
    {
        return (FC0_MAX_KHZ >> 0u) & 0b1111111111111111111111111u;
    }

    /**
     * Set FC0_MAX_KHZ's FC0_MAX_KHZ field.
     */
    inline void set_FC0_MAX_KHZ_FC0_MAX_KHZ(uint32_t value) volatile
    {
        uint32_t curr = FC0_MAX_KHZ;

        curr &= ~(0b1111111111111111111111111u << 0u);
        curr |= (value & 0b1111111111111111111111111u) << 0u;

        FC0_MAX_KHZ = curr;
    }

    /**
     * Get FC0_DELAY's FC0_DELAY field.
     */
    inline uint8_t get_FC0_DELAY_FC0_DELAY() volatile
    {
        return (FC0_DELAY >> 0u) & 0b111u;
    }

    /**
     * Set FC0_DELAY's FC0_DELAY field.
     */
    inline void set_FC0_DELAY_FC0_DELAY(uint8_t value) volatile
    {
        uint32_t curr = FC0_DELAY;

        curr &= ~(0b111u << 0u);
        curr |= (value & 0b111u) << 0u;

        FC0_DELAY = curr;
    }

    /**
     * Get FC0_INTERVAL's FC0_INTERVAL field.
     */
    inline uint8_t get_FC0_INTERVAL_FC0_INTERVAL() volatile
    {
        return (FC0_INTERVAL >> 0u) & 0b1111u;
    }

    /**
     * Set FC0_INTERVAL's FC0_INTERVAL field.
     */
    inline void set_FC0_INTERVAL_FC0_INTERVAL(uint8_t value) volatile
    {
        uint32_t curr = FC0_INTERVAL;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        FC0_INTERVAL = curr;
    }

    /**
     * Get FC0_SRC's FC0_SRC field.
     */
    inline CLOCKS_FC0_SRC_FC0_SRC get_FC0_SRC_FC0_SRC() volatile
    {
        return CLOCKS_FC0_SRC_FC0_SRC((FC0_SRC >> 0u) & 0b11111111u);
    }

    /**
     * Set FC0_SRC's FC0_SRC field.
     */
    inline void set_FC0_SRC_FC0_SRC(CLOCKS_FC0_SRC_FC0_SRC value) volatile
    {
        uint32_t curr = FC0_SRC;

        curr &= ~(0b11111111u << 0u);
        curr |= (std::to_underlying(value) & 0b11111111u) << 0u;

        FC0_SRC = curr;
    }

    /**
     * Get FC0_STATUS's PASS bit.
     *
     * Test passed
     */
    inline bool get_FC0_STATUS_PASS() volatile
    {
        return FC0_STATUS & (1u << 0u);
    }

    /**
     * Get FC0_STATUS's DONE bit.
     *
     * Test complete
     */
    inline bool get_FC0_STATUS_DONE() volatile
    {
        return FC0_STATUS & (1u << 4u);
    }

    /**
     * Get FC0_STATUS's RUNNING bit.
     *
     * Test running
     */
    inline bool get_FC0_STATUS_RUNNING() volatile
    {
        return FC0_STATUS & (1u << 8u);
    }

    /**
     * Get FC0_STATUS's WAITING bit.
     *
     * Waiting for test clock to start
     */
    inline bool get_FC0_STATUS_WAITING() volatile
    {
        return FC0_STATUS & (1u << 12u);
    }

    /**
     * Get FC0_STATUS's FAIL bit.
     *
     * Test failed
     */
    inline bool get_FC0_STATUS_FAIL() volatile
    {
        return FC0_STATUS & (1u << 16u);
    }

    /**
     * Get FC0_STATUS's SLOW bit.
     *
     * Test clock slower than expected, only valid when status_done=1
     */
    inline bool get_FC0_STATUS_SLOW() volatile
    {
        return FC0_STATUS & (1u << 20u);
    }

    /**
     * Get FC0_STATUS's FAST bit.
     *
     * Test clock faster than expected, only valid when status_done=1
     */
    inline bool get_FC0_STATUS_FAST() volatile
    {
        return FC0_STATUS & (1u << 24u);
    }

    /**
     * Get FC0_STATUS's DIED bit.
     *
     * Test clock stopped during test
     */
    inline bool get_FC0_STATUS_DIED() volatile
    {
        return FC0_STATUS & (1u << 28u);
    }

    /**
     * Get all of FC0_STATUS's bit fields.
     *
     * (read-only) Frequency counter status
     */
    inline void get_FC0_STATUS(bool &PASS, bool &DONE, bool &RUNNING,
                               bool &WAITING, bool &FAIL, bool &SLOW,
                               bool &FAST, bool &DIED) volatile
    {
        uint32_t curr = FC0_STATUS;

        PASS = curr & (1u << 0u);
        DONE = curr & (1u << 4u);
        RUNNING = curr & (1u << 8u);
        WAITING = curr & (1u << 12u);
        FAIL = curr & (1u << 16u);
        SLOW = curr & (1u << 20u);
        FAST = curr & (1u << 24u);
        DIED = curr & (1u << 28u);
    }

    /**
     * Get FC0_RESULT's FRAC field.
     */
    inline uint8_t get_FC0_RESULT_FRAC() volatile
    {
        return (FC0_RESULT >> 0u) & 0b11111u;
    }

    /**
     * Get FC0_RESULT's KHZ field.
     */
    inline uint32_t get_FC0_RESULT_KHZ() volatile
    {
        return (FC0_RESULT >> 5u) & 0b1111111111111111111111111u;
    }

    /**
     * Get all of FC0_RESULT's bit fields.
     *
     * (read-only) Result of frequency measurement, only valid when
     * status_done=1
     */
    inline void get_FC0_RESULT(uint8_t &FRAC, uint32_t &KHZ) volatile
    {
        uint32_t curr = FC0_RESULT;

        FRAC = (curr >> 0u) & 0b11111u;
        KHZ = (curr >> 5u) & 0b1111111111111111111111111u;
    }

    /**
     * Get WAKE_EN0's clk_sys_clocks bit.
     */
    inline bool get_WAKE_EN0_clk_sys_clocks() volatile
    {
        return WAKE_EN0 & (1u << 0u);
    }

    /**
     * Set WAKE_EN0's clk_sys_clocks bit.
     */
    inline void set_WAKE_EN0_clk_sys_clocks() volatile
    {
        WAKE_EN0 |= 1u << 0u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_clocks bit.
     */
    inline void clear_WAKE_EN0_clk_sys_clocks() volatile
    {
        WAKE_EN0 &= ~(1u << 0u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_clocks bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_clocks() volatile
    {
        WAKE_EN0 ^= 1u << 0u;
    }

    /**
     * Get WAKE_EN0's clk_adc_adc bit.
     */
    inline bool get_WAKE_EN0_clk_adc_adc() volatile
    {
        return WAKE_EN0 & (1u << 1u);
    }

    /**
     * Set WAKE_EN0's clk_adc_adc bit.
     */
    inline void set_WAKE_EN0_clk_adc_adc() volatile
    {
        WAKE_EN0 |= 1u << 1u;
    }

    /**
     * Clear WAKE_EN0's clk_adc_adc bit.
     */
    inline void clear_WAKE_EN0_clk_adc_adc() volatile
    {
        WAKE_EN0 &= ~(1u << 1u);
    }

    /**
     * Toggle WAKE_EN0's clk_adc_adc bit.
     */
    inline void toggle_WAKE_EN0_clk_adc_adc() volatile
    {
        WAKE_EN0 ^= 1u << 1u;
    }

    /**
     * Get WAKE_EN0's clk_sys_adc bit.
     */
    inline bool get_WAKE_EN0_clk_sys_adc() volatile
    {
        return WAKE_EN0 & (1u << 2u);
    }

    /**
     * Set WAKE_EN0's clk_sys_adc bit.
     */
    inline void set_WAKE_EN0_clk_sys_adc() volatile
    {
        WAKE_EN0 |= 1u << 2u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_adc bit.
     */
    inline void clear_WAKE_EN0_clk_sys_adc() volatile
    {
        WAKE_EN0 &= ~(1u << 2u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_adc bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_adc() volatile
    {
        WAKE_EN0 ^= 1u << 2u;
    }

    /**
     * Get WAKE_EN0's clk_sys_busctrl bit.
     */
    inline bool get_WAKE_EN0_clk_sys_busctrl() volatile
    {
        return WAKE_EN0 & (1u << 3u);
    }

    /**
     * Set WAKE_EN0's clk_sys_busctrl bit.
     */
    inline void set_WAKE_EN0_clk_sys_busctrl() volatile
    {
        WAKE_EN0 |= 1u << 3u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_busctrl bit.
     */
    inline void clear_WAKE_EN0_clk_sys_busctrl() volatile
    {
        WAKE_EN0 &= ~(1u << 3u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_busctrl bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_busctrl() volatile
    {
        WAKE_EN0 ^= 1u << 3u;
    }

    /**
     * Get WAKE_EN0's clk_sys_busfabric bit.
     */
    inline bool get_WAKE_EN0_clk_sys_busfabric() volatile
    {
        return WAKE_EN0 & (1u << 4u);
    }

    /**
     * Set WAKE_EN0's clk_sys_busfabric bit.
     */
    inline void set_WAKE_EN0_clk_sys_busfabric() volatile
    {
        WAKE_EN0 |= 1u << 4u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_busfabric bit.
     */
    inline void clear_WAKE_EN0_clk_sys_busfabric() volatile
    {
        WAKE_EN0 &= ~(1u << 4u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_busfabric bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_busfabric() volatile
    {
        WAKE_EN0 ^= 1u << 4u;
    }

    /**
     * Get WAKE_EN0's clk_sys_dma bit.
     */
    inline bool get_WAKE_EN0_clk_sys_dma() volatile
    {
        return WAKE_EN0 & (1u << 5u);
    }

    /**
     * Set WAKE_EN0's clk_sys_dma bit.
     */
    inline void set_WAKE_EN0_clk_sys_dma() volatile
    {
        WAKE_EN0 |= 1u << 5u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_dma bit.
     */
    inline void clear_WAKE_EN0_clk_sys_dma() volatile
    {
        WAKE_EN0 &= ~(1u << 5u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_dma bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_dma() volatile
    {
        WAKE_EN0 ^= 1u << 5u;
    }

    /**
     * Get WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_i2c0() volatile
    {
        return WAKE_EN0 & (1u << 6u);
    }

    /**
     * Set WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_i2c0() volatile
    {
        WAKE_EN0 |= 1u << 6u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_i2c0() volatile
    {
        WAKE_EN0 &= ~(1u << 6u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_i2c0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_i2c0() volatile
    {
        WAKE_EN0 ^= 1u << 6u;
    }

    /**
     * Get WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_i2c1() volatile
    {
        return WAKE_EN0 & (1u << 7u);
    }

    /**
     * Set WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_i2c1() volatile
    {
        WAKE_EN0 |= 1u << 7u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_i2c1() volatile
    {
        WAKE_EN0 &= ~(1u << 7u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_i2c1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_i2c1() volatile
    {
        WAKE_EN0 ^= 1u << 7u;
    }

    /**
     * Get WAKE_EN0's clk_sys_io bit.
     */
    inline bool get_WAKE_EN0_clk_sys_io() volatile
    {
        return WAKE_EN0 & (1u << 8u);
    }

    /**
     * Set WAKE_EN0's clk_sys_io bit.
     */
    inline void set_WAKE_EN0_clk_sys_io() volatile
    {
        WAKE_EN0 |= 1u << 8u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_io bit.
     */
    inline void clear_WAKE_EN0_clk_sys_io() volatile
    {
        WAKE_EN0 &= ~(1u << 8u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_io bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_io() volatile
    {
        WAKE_EN0 ^= 1u << 8u;
    }

    /**
     * Get WAKE_EN0's clk_sys_jtag bit.
     */
    inline bool get_WAKE_EN0_clk_sys_jtag() volatile
    {
        return WAKE_EN0 & (1u << 9u);
    }

    /**
     * Set WAKE_EN0's clk_sys_jtag bit.
     */
    inline void set_WAKE_EN0_clk_sys_jtag() volatile
    {
        WAKE_EN0 |= 1u << 9u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_jtag bit.
     */
    inline void clear_WAKE_EN0_clk_sys_jtag() volatile
    {
        WAKE_EN0 &= ~(1u << 9u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_jtag bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_jtag() volatile
    {
        WAKE_EN0 ^= 1u << 9u;
    }

    /**
     * Get WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline bool get_WAKE_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        return WAKE_EN0 & (1u << 10u);
    }

    /**
     * Set WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void set_WAKE_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        WAKE_EN0 |= 1u << 10u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void clear_WAKE_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        WAKE_EN0 &= ~(1u << 10u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        WAKE_EN0 ^= 1u << 10u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pads bit.
     */
    inline bool get_WAKE_EN0_clk_sys_pads() volatile
    {
        return WAKE_EN0 & (1u << 11u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pads bit.
     */
    inline void set_WAKE_EN0_clk_sys_pads() volatile
    {
        WAKE_EN0 |= 1u << 11u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pads bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pads() volatile
    {
        WAKE_EN0 &= ~(1u << 11u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pads bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pads() volatile
    {
        WAKE_EN0 ^= 1u << 11u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pio0 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_pio0() volatile
    {
        return WAKE_EN0 & (1u << 12u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pio0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_pio0() volatile
    {
        WAKE_EN0 |= 1u << 12u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pio0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pio0() volatile
    {
        WAKE_EN0 &= ~(1u << 12u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pio0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pio0() volatile
    {
        WAKE_EN0 ^= 1u << 12u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pio1 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_pio1() volatile
    {
        return WAKE_EN0 & (1u << 13u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pio1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_pio1() volatile
    {
        WAKE_EN0 |= 1u << 13u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pio1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pio1() volatile
    {
        WAKE_EN0 &= ~(1u << 13u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pio1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pio1() volatile
    {
        WAKE_EN0 ^= 1u << 13u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline bool get_WAKE_EN0_clk_sys_pll_sys() volatile
    {
        return WAKE_EN0 & (1u << 14u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline void set_WAKE_EN0_clk_sys_pll_sys() volatile
    {
        WAKE_EN0 |= 1u << 14u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pll_sys() volatile
    {
        WAKE_EN0 &= ~(1u << 14u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pll_sys bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pll_sys() volatile
    {
        WAKE_EN0 ^= 1u << 14u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline bool get_WAKE_EN0_clk_sys_pll_usb() volatile
    {
        return WAKE_EN0 & (1u << 15u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline void set_WAKE_EN0_clk_sys_pll_usb() volatile
    {
        WAKE_EN0 |= 1u << 15u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pll_usb() volatile
    {
        WAKE_EN0 &= ~(1u << 15u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pll_usb bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pll_usb() volatile
    {
        WAKE_EN0 ^= 1u << 15u;
    }

    /**
     * Get WAKE_EN0's clk_sys_psm bit.
     */
    inline bool get_WAKE_EN0_clk_sys_psm() volatile
    {
        return WAKE_EN0 & (1u << 16u);
    }

    /**
     * Set WAKE_EN0's clk_sys_psm bit.
     */
    inline void set_WAKE_EN0_clk_sys_psm() volatile
    {
        WAKE_EN0 |= 1u << 16u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_psm bit.
     */
    inline void clear_WAKE_EN0_clk_sys_psm() volatile
    {
        WAKE_EN0 &= ~(1u << 16u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_psm bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_psm() volatile
    {
        WAKE_EN0 ^= 1u << 16u;
    }

    /**
     * Get WAKE_EN0's clk_sys_pwm bit.
     */
    inline bool get_WAKE_EN0_clk_sys_pwm() volatile
    {
        return WAKE_EN0 & (1u << 17u);
    }

    /**
     * Set WAKE_EN0's clk_sys_pwm bit.
     */
    inline void set_WAKE_EN0_clk_sys_pwm() volatile
    {
        WAKE_EN0 |= 1u << 17u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_pwm bit.
     */
    inline void clear_WAKE_EN0_clk_sys_pwm() volatile
    {
        WAKE_EN0 &= ~(1u << 17u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_pwm bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_pwm() volatile
    {
        WAKE_EN0 ^= 1u << 17u;
    }

    /**
     * Get WAKE_EN0's clk_sys_resets bit.
     */
    inline bool get_WAKE_EN0_clk_sys_resets() volatile
    {
        return WAKE_EN0 & (1u << 18u);
    }

    /**
     * Set WAKE_EN0's clk_sys_resets bit.
     */
    inline void set_WAKE_EN0_clk_sys_resets() volatile
    {
        WAKE_EN0 |= 1u << 18u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_resets bit.
     */
    inline void clear_WAKE_EN0_clk_sys_resets() volatile
    {
        WAKE_EN0 &= ~(1u << 18u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_resets bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_resets() volatile
    {
        WAKE_EN0 ^= 1u << 18u;
    }

    /**
     * Get WAKE_EN0's clk_sys_rom bit.
     */
    inline bool get_WAKE_EN0_clk_sys_rom() volatile
    {
        return WAKE_EN0 & (1u << 19u);
    }

    /**
     * Set WAKE_EN0's clk_sys_rom bit.
     */
    inline void set_WAKE_EN0_clk_sys_rom() volatile
    {
        WAKE_EN0 |= 1u << 19u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_rom bit.
     */
    inline void clear_WAKE_EN0_clk_sys_rom() volatile
    {
        WAKE_EN0 &= ~(1u << 19u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_rom bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_rom() volatile
    {
        WAKE_EN0 ^= 1u << 19u;
    }

    /**
     * Get WAKE_EN0's clk_sys_rosc bit.
     */
    inline bool get_WAKE_EN0_clk_sys_rosc() volatile
    {
        return WAKE_EN0 & (1u << 20u);
    }

    /**
     * Set WAKE_EN0's clk_sys_rosc bit.
     */
    inline void set_WAKE_EN0_clk_sys_rosc() volatile
    {
        WAKE_EN0 |= 1u << 20u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_rosc bit.
     */
    inline void clear_WAKE_EN0_clk_sys_rosc() volatile
    {
        WAKE_EN0 &= ~(1u << 20u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_rosc bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_rosc() volatile
    {
        WAKE_EN0 ^= 1u << 20u;
    }

    /**
     * Get WAKE_EN0's clk_rtc_rtc bit.
     */
    inline bool get_WAKE_EN0_clk_rtc_rtc() volatile
    {
        return WAKE_EN0 & (1u << 21u);
    }

    /**
     * Set WAKE_EN0's clk_rtc_rtc bit.
     */
    inline void set_WAKE_EN0_clk_rtc_rtc() volatile
    {
        WAKE_EN0 |= 1u << 21u;
    }

    /**
     * Clear WAKE_EN0's clk_rtc_rtc bit.
     */
    inline void clear_WAKE_EN0_clk_rtc_rtc() volatile
    {
        WAKE_EN0 &= ~(1u << 21u);
    }

    /**
     * Toggle WAKE_EN0's clk_rtc_rtc bit.
     */
    inline void toggle_WAKE_EN0_clk_rtc_rtc() volatile
    {
        WAKE_EN0 ^= 1u << 21u;
    }

    /**
     * Get WAKE_EN0's clk_sys_rtc bit.
     */
    inline bool get_WAKE_EN0_clk_sys_rtc() volatile
    {
        return WAKE_EN0 & (1u << 22u);
    }

    /**
     * Set WAKE_EN0's clk_sys_rtc bit.
     */
    inline void set_WAKE_EN0_clk_sys_rtc() volatile
    {
        WAKE_EN0 |= 1u << 22u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_rtc bit.
     */
    inline void clear_WAKE_EN0_clk_sys_rtc() volatile
    {
        WAKE_EN0 &= ~(1u << 22u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_rtc bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_rtc() volatile
    {
        WAKE_EN0 ^= 1u << 22u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sio bit.
     */
    inline bool get_WAKE_EN0_clk_sys_sio() volatile
    {
        return WAKE_EN0 & (1u << 23u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sio bit.
     */
    inline void set_WAKE_EN0_clk_sys_sio() volatile
    {
        WAKE_EN0 |= 1u << 23u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sio bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sio() volatile
    {
        WAKE_EN0 &= ~(1u << 23u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sio bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sio() volatile
    {
        WAKE_EN0 ^= 1u << 23u;
    }

    /**
     * Get WAKE_EN0's clk_peri_spi0 bit.
     */
    inline bool get_WAKE_EN0_clk_peri_spi0() volatile
    {
        return WAKE_EN0 & (1u << 24u);
    }

    /**
     * Set WAKE_EN0's clk_peri_spi0 bit.
     */
    inline void set_WAKE_EN0_clk_peri_spi0() volatile
    {
        WAKE_EN0 |= 1u << 24u;
    }

    /**
     * Clear WAKE_EN0's clk_peri_spi0 bit.
     */
    inline void clear_WAKE_EN0_clk_peri_spi0() volatile
    {
        WAKE_EN0 &= ~(1u << 24u);
    }

    /**
     * Toggle WAKE_EN0's clk_peri_spi0 bit.
     */
    inline void toggle_WAKE_EN0_clk_peri_spi0() volatile
    {
        WAKE_EN0 ^= 1u << 24u;
    }

    /**
     * Get WAKE_EN0's clk_sys_spi0 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_spi0() volatile
    {
        return WAKE_EN0 & (1u << 25u);
    }

    /**
     * Set WAKE_EN0's clk_sys_spi0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_spi0() volatile
    {
        WAKE_EN0 |= 1u << 25u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_spi0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_spi0() volatile
    {
        WAKE_EN0 &= ~(1u << 25u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_spi0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_spi0() volatile
    {
        WAKE_EN0 ^= 1u << 25u;
    }

    /**
     * Get WAKE_EN0's clk_peri_spi1 bit.
     */
    inline bool get_WAKE_EN0_clk_peri_spi1() volatile
    {
        return WAKE_EN0 & (1u << 26u);
    }

    /**
     * Set WAKE_EN0's clk_peri_spi1 bit.
     */
    inline void set_WAKE_EN0_clk_peri_spi1() volatile
    {
        WAKE_EN0 |= 1u << 26u;
    }

    /**
     * Clear WAKE_EN0's clk_peri_spi1 bit.
     */
    inline void clear_WAKE_EN0_clk_peri_spi1() volatile
    {
        WAKE_EN0 &= ~(1u << 26u);
    }

    /**
     * Toggle WAKE_EN0's clk_peri_spi1 bit.
     */
    inline void toggle_WAKE_EN0_clk_peri_spi1() volatile
    {
        WAKE_EN0 ^= 1u << 26u;
    }

    /**
     * Get WAKE_EN0's clk_sys_spi1 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_spi1() volatile
    {
        return WAKE_EN0 & (1u << 27u);
    }

    /**
     * Set WAKE_EN0's clk_sys_spi1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_spi1() volatile
    {
        WAKE_EN0 |= 1u << 27u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_spi1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_spi1() volatile
    {
        WAKE_EN0 &= ~(1u << 27u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_spi1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_spi1() volatile
    {
        WAKE_EN0 ^= 1u << 27u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram0 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_sram0() volatile
    {
        return WAKE_EN0 & (1u << 28u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram0 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram0() volatile
    {
        WAKE_EN0 |= 1u << 28u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram0 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram0() volatile
    {
        WAKE_EN0 &= ~(1u << 28u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram0 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram0() volatile
    {
        WAKE_EN0 ^= 1u << 28u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram1 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_sram1() volatile
    {
        return WAKE_EN0 & (1u << 29u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram1 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram1() volatile
    {
        WAKE_EN0 |= 1u << 29u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram1 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram1() volatile
    {
        WAKE_EN0 &= ~(1u << 29u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram1 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram1() volatile
    {
        WAKE_EN0 ^= 1u << 29u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram2 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_sram2() volatile
    {
        return WAKE_EN0 & (1u << 30u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram2 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram2() volatile
    {
        WAKE_EN0 |= 1u << 30u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram2 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram2() volatile
    {
        WAKE_EN0 &= ~(1u << 30u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram2 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram2() volatile
    {
        WAKE_EN0 ^= 1u << 30u;
    }

    /**
     * Get WAKE_EN0's clk_sys_sram3 bit.
     */
    inline bool get_WAKE_EN0_clk_sys_sram3() volatile
    {
        return WAKE_EN0 & (1u << 31u);
    }

    /**
     * Set WAKE_EN0's clk_sys_sram3 bit.
     */
    inline void set_WAKE_EN0_clk_sys_sram3() volatile
    {
        WAKE_EN0 |= 1u << 31u;
    }

    /**
     * Clear WAKE_EN0's clk_sys_sram3 bit.
     */
    inline void clear_WAKE_EN0_clk_sys_sram3() volatile
    {
        WAKE_EN0 &= ~(1u << 31u);
    }

    /**
     * Toggle WAKE_EN0's clk_sys_sram3 bit.
     */
    inline void toggle_WAKE_EN0_clk_sys_sram3() volatile
    {
        WAKE_EN0 ^= 1u << 31u;
    }

    /**
     * Get all of WAKE_EN0's bit fields.
     *
     * (read-write) enable clock in wake mode
     */
    inline void get_WAKE_EN0(
        bool &clk_sys_clocks, bool &clk_adc_adc, bool &clk_sys_adc,
        bool &clk_sys_busctrl, bool &clk_sys_busfabric, bool &clk_sys_dma,
        bool &clk_sys_i2c0, bool &clk_sys_i2c1, bool &clk_sys_io,
        bool &clk_sys_jtag, bool &clk_sys_vreg_and_chip_reset,
        bool &clk_sys_pads, bool &clk_sys_pio0, bool &clk_sys_pio1,
        bool &clk_sys_pll_sys, bool &clk_sys_pll_usb, bool &clk_sys_psm,
        bool &clk_sys_pwm, bool &clk_sys_resets, bool &clk_sys_rom,
        bool &clk_sys_rosc, bool &clk_rtc_rtc, bool &clk_sys_rtc,
        bool &clk_sys_sio, bool &clk_peri_spi0, bool &clk_sys_spi0,
        bool &clk_peri_spi1, bool &clk_sys_spi1, bool &clk_sys_sram0,
        bool &clk_sys_sram1, bool &clk_sys_sram2, bool &clk_sys_sram3) volatile
    {
        uint32_t curr = WAKE_EN0;

        clk_sys_clocks = curr & (1u << 0u);
        clk_adc_adc = curr & (1u << 1u);
        clk_sys_adc = curr & (1u << 2u);
        clk_sys_busctrl = curr & (1u << 3u);
        clk_sys_busfabric = curr & (1u << 4u);
        clk_sys_dma = curr & (1u << 5u);
        clk_sys_i2c0 = curr & (1u << 6u);
        clk_sys_i2c1 = curr & (1u << 7u);
        clk_sys_io = curr & (1u << 8u);
        clk_sys_jtag = curr & (1u << 9u);
        clk_sys_vreg_and_chip_reset = curr & (1u << 10u);
        clk_sys_pads = curr & (1u << 11u);
        clk_sys_pio0 = curr & (1u << 12u);
        clk_sys_pio1 = curr & (1u << 13u);
        clk_sys_pll_sys = curr & (1u << 14u);
        clk_sys_pll_usb = curr & (1u << 15u);
        clk_sys_psm = curr & (1u << 16u);
        clk_sys_pwm = curr & (1u << 17u);
        clk_sys_resets = curr & (1u << 18u);
        clk_sys_rom = curr & (1u << 19u);
        clk_sys_rosc = curr & (1u << 20u);
        clk_rtc_rtc = curr & (1u << 21u);
        clk_sys_rtc = curr & (1u << 22u);
        clk_sys_sio = curr & (1u << 23u);
        clk_peri_spi0 = curr & (1u << 24u);
        clk_sys_spi0 = curr & (1u << 25u);
        clk_peri_spi1 = curr & (1u << 26u);
        clk_sys_spi1 = curr & (1u << 27u);
        clk_sys_sram0 = curr & (1u << 28u);
        clk_sys_sram1 = curr & (1u << 29u);
        clk_sys_sram2 = curr & (1u << 30u);
        clk_sys_sram3 = curr & (1u << 31u);
    }

    /**
     * Set all of WAKE_EN0's bit fields.
     *
     * (read-write) enable clock in wake mode
     */
    inline void set_WAKE_EN0(
        bool clk_sys_clocks, bool clk_adc_adc, bool clk_sys_adc,
        bool clk_sys_busctrl, bool clk_sys_busfabric, bool clk_sys_dma,
        bool clk_sys_i2c0, bool clk_sys_i2c1, bool clk_sys_io,
        bool clk_sys_jtag, bool clk_sys_vreg_and_chip_reset, bool clk_sys_pads,
        bool clk_sys_pio0, bool clk_sys_pio1, bool clk_sys_pll_sys,
        bool clk_sys_pll_usb, bool clk_sys_psm, bool clk_sys_pwm,
        bool clk_sys_resets, bool clk_sys_rom, bool clk_sys_rosc,
        bool clk_rtc_rtc, bool clk_sys_rtc, bool clk_sys_sio,
        bool clk_peri_spi0, bool clk_sys_spi0, bool clk_peri_spi1,
        bool clk_sys_spi1, bool clk_sys_sram0, bool clk_sys_sram1,
        bool clk_sys_sram2, bool clk_sys_sram3) volatile
    {
        uint32_t curr = WAKE_EN0;

        curr &= ~(0b1u << 0u);
        curr |= (clk_sys_clocks & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (clk_adc_adc & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clk_sys_adc & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (clk_sys_busctrl & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (clk_sys_busfabric & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (clk_sys_dma & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (clk_sys_i2c0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (clk_sys_i2c1 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (clk_sys_io & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (clk_sys_jtag & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (clk_sys_vreg_and_chip_reset & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (clk_sys_pads & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (clk_sys_pio0 & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (clk_sys_pio1 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (clk_sys_pll_sys & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (clk_sys_pll_usb & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (clk_sys_psm & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (clk_sys_pwm & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (clk_sys_resets & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (clk_sys_rom & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (clk_sys_rosc & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (clk_rtc_rtc & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (clk_sys_rtc & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (clk_sys_sio & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (clk_peri_spi0 & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (clk_sys_spi0 & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (clk_peri_spi1 & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (clk_sys_spi1 & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (clk_sys_sram0 & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (clk_sys_sram1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (clk_sys_sram2 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (clk_sys_sram3 & 0b1u) << 31u;

        WAKE_EN0 = curr;
    }

    /**
     * Get WAKE_EN1's clk_sys_sram4 bit.
     */
    inline bool get_WAKE_EN1_clk_sys_sram4() volatile
    {
        return WAKE_EN1 & (1u << 0u);
    }

    /**
     * Set WAKE_EN1's clk_sys_sram4 bit.
     */
    inline void set_WAKE_EN1_clk_sys_sram4() volatile
    {
        WAKE_EN1 |= 1u << 0u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_sram4 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_sram4() volatile
    {
        WAKE_EN1 &= ~(1u << 0u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_sram4 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_sram4() volatile
    {
        WAKE_EN1 ^= 1u << 0u;
    }

    /**
     * Get WAKE_EN1's clk_sys_sram5 bit.
     */
    inline bool get_WAKE_EN1_clk_sys_sram5() volatile
    {
        return WAKE_EN1 & (1u << 1u);
    }

    /**
     * Set WAKE_EN1's clk_sys_sram5 bit.
     */
    inline void set_WAKE_EN1_clk_sys_sram5() volatile
    {
        WAKE_EN1 |= 1u << 1u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_sram5 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_sram5() volatile
    {
        WAKE_EN1 &= ~(1u << 1u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_sram5 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_sram5() volatile
    {
        WAKE_EN1 ^= 1u << 1u;
    }

    /**
     * Get WAKE_EN1's clk_sys_syscfg bit.
     */
    inline bool get_WAKE_EN1_clk_sys_syscfg() volatile
    {
        return WAKE_EN1 & (1u << 2u);
    }

    /**
     * Set WAKE_EN1's clk_sys_syscfg bit.
     */
    inline void set_WAKE_EN1_clk_sys_syscfg() volatile
    {
        WAKE_EN1 |= 1u << 2u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_syscfg bit.
     */
    inline void clear_WAKE_EN1_clk_sys_syscfg() volatile
    {
        WAKE_EN1 &= ~(1u << 2u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_syscfg bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_syscfg() volatile
    {
        WAKE_EN1 ^= 1u << 2u;
    }

    /**
     * Get WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline bool get_WAKE_EN1_clk_sys_sysinfo() volatile
    {
        return WAKE_EN1 & (1u << 3u);
    }

    /**
     * Set WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline void set_WAKE_EN1_clk_sys_sysinfo() volatile
    {
        WAKE_EN1 |= 1u << 3u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline void clear_WAKE_EN1_clk_sys_sysinfo() volatile
    {
        WAKE_EN1 &= ~(1u << 3u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_sysinfo bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_sysinfo() volatile
    {
        WAKE_EN1 ^= 1u << 3u;
    }

    /**
     * Get WAKE_EN1's clk_sys_tbman bit.
     */
    inline bool get_WAKE_EN1_clk_sys_tbman() volatile
    {
        return WAKE_EN1 & (1u << 4u);
    }

    /**
     * Set WAKE_EN1's clk_sys_tbman bit.
     */
    inline void set_WAKE_EN1_clk_sys_tbman() volatile
    {
        WAKE_EN1 |= 1u << 4u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_tbman bit.
     */
    inline void clear_WAKE_EN1_clk_sys_tbman() volatile
    {
        WAKE_EN1 &= ~(1u << 4u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_tbman bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_tbman() volatile
    {
        WAKE_EN1 ^= 1u << 4u;
    }

    /**
     * Get WAKE_EN1's clk_sys_timer bit.
     */
    inline bool get_WAKE_EN1_clk_sys_timer() volatile
    {
        return WAKE_EN1 & (1u << 5u);
    }

    /**
     * Set WAKE_EN1's clk_sys_timer bit.
     */
    inline void set_WAKE_EN1_clk_sys_timer() volatile
    {
        WAKE_EN1 |= 1u << 5u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_timer bit.
     */
    inline void clear_WAKE_EN1_clk_sys_timer() volatile
    {
        WAKE_EN1 &= ~(1u << 5u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_timer bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_timer() volatile
    {
        WAKE_EN1 ^= 1u << 5u;
    }

    /**
     * Get WAKE_EN1's clk_peri_uart0 bit.
     */
    inline bool get_WAKE_EN1_clk_peri_uart0() volatile
    {
        return WAKE_EN1 & (1u << 6u);
    }

    /**
     * Set WAKE_EN1's clk_peri_uart0 bit.
     */
    inline void set_WAKE_EN1_clk_peri_uart0() volatile
    {
        WAKE_EN1 |= 1u << 6u;
    }

    /**
     * Clear WAKE_EN1's clk_peri_uart0 bit.
     */
    inline void clear_WAKE_EN1_clk_peri_uart0() volatile
    {
        WAKE_EN1 &= ~(1u << 6u);
    }

    /**
     * Toggle WAKE_EN1's clk_peri_uart0 bit.
     */
    inline void toggle_WAKE_EN1_clk_peri_uart0() volatile
    {
        WAKE_EN1 ^= 1u << 6u;
    }

    /**
     * Get WAKE_EN1's clk_sys_uart0 bit.
     */
    inline bool get_WAKE_EN1_clk_sys_uart0() volatile
    {
        return WAKE_EN1 & (1u << 7u);
    }

    /**
     * Set WAKE_EN1's clk_sys_uart0 bit.
     */
    inline void set_WAKE_EN1_clk_sys_uart0() volatile
    {
        WAKE_EN1 |= 1u << 7u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_uart0 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_uart0() volatile
    {
        WAKE_EN1 &= ~(1u << 7u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_uart0 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_uart0() volatile
    {
        WAKE_EN1 ^= 1u << 7u;
    }

    /**
     * Get WAKE_EN1's clk_peri_uart1 bit.
     */
    inline bool get_WAKE_EN1_clk_peri_uart1() volatile
    {
        return WAKE_EN1 & (1u << 8u);
    }

    /**
     * Set WAKE_EN1's clk_peri_uart1 bit.
     */
    inline void set_WAKE_EN1_clk_peri_uart1() volatile
    {
        WAKE_EN1 |= 1u << 8u;
    }

    /**
     * Clear WAKE_EN1's clk_peri_uart1 bit.
     */
    inline void clear_WAKE_EN1_clk_peri_uart1() volatile
    {
        WAKE_EN1 &= ~(1u << 8u);
    }

    /**
     * Toggle WAKE_EN1's clk_peri_uart1 bit.
     */
    inline void toggle_WAKE_EN1_clk_peri_uart1() volatile
    {
        WAKE_EN1 ^= 1u << 8u;
    }

    /**
     * Get WAKE_EN1's clk_sys_uart1 bit.
     */
    inline bool get_WAKE_EN1_clk_sys_uart1() volatile
    {
        return WAKE_EN1 & (1u << 9u);
    }

    /**
     * Set WAKE_EN1's clk_sys_uart1 bit.
     */
    inline void set_WAKE_EN1_clk_sys_uart1() volatile
    {
        WAKE_EN1 |= 1u << 9u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_uart1 bit.
     */
    inline void clear_WAKE_EN1_clk_sys_uart1() volatile
    {
        WAKE_EN1 &= ~(1u << 9u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_uart1 bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_uart1() volatile
    {
        WAKE_EN1 ^= 1u << 9u;
    }

    /**
     * Get WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline bool get_WAKE_EN1_clk_sys_usbctrl() volatile
    {
        return WAKE_EN1 & (1u << 10u);
    }

    /**
     * Set WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline void set_WAKE_EN1_clk_sys_usbctrl() volatile
    {
        WAKE_EN1 |= 1u << 10u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline void clear_WAKE_EN1_clk_sys_usbctrl() volatile
    {
        WAKE_EN1 &= ~(1u << 10u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_usbctrl bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_usbctrl() volatile
    {
        WAKE_EN1 ^= 1u << 10u;
    }

    /**
     * Get WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline bool get_WAKE_EN1_clk_usb_usbctrl() volatile
    {
        return WAKE_EN1 & (1u << 11u);
    }

    /**
     * Set WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline void set_WAKE_EN1_clk_usb_usbctrl() volatile
    {
        WAKE_EN1 |= 1u << 11u;
    }

    /**
     * Clear WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline void clear_WAKE_EN1_clk_usb_usbctrl() volatile
    {
        WAKE_EN1 &= ~(1u << 11u);
    }

    /**
     * Toggle WAKE_EN1's clk_usb_usbctrl bit.
     */
    inline void toggle_WAKE_EN1_clk_usb_usbctrl() volatile
    {
        WAKE_EN1 ^= 1u << 11u;
    }

    /**
     * Get WAKE_EN1's clk_sys_watchdog bit.
     */
    inline bool get_WAKE_EN1_clk_sys_watchdog() volatile
    {
        return WAKE_EN1 & (1u << 12u);
    }

    /**
     * Set WAKE_EN1's clk_sys_watchdog bit.
     */
    inline void set_WAKE_EN1_clk_sys_watchdog() volatile
    {
        WAKE_EN1 |= 1u << 12u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_watchdog bit.
     */
    inline void clear_WAKE_EN1_clk_sys_watchdog() volatile
    {
        WAKE_EN1 &= ~(1u << 12u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_watchdog bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_watchdog() volatile
    {
        WAKE_EN1 ^= 1u << 12u;
    }

    /**
     * Get WAKE_EN1's clk_sys_xip bit.
     */
    inline bool get_WAKE_EN1_clk_sys_xip() volatile
    {
        return WAKE_EN1 & (1u << 13u);
    }

    /**
     * Set WAKE_EN1's clk_sys_xip bit.
     */
    inline void set_WAKE_EN1_clk_sys_xip() volatile
    {
        WAKE_EN1 |= 1u << 13u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_xip bit.
     */
    inline void clear_WAKE_EN1_clk_sys_xip() volatile
    {
        WAKE_EN1 &= ~(1u << 13u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_xip bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_xip() volatile
    {
        WAKE_EN1 ^= 1u << 13u;
    }

    /**
     * Get WAKE_EN1's clk_sys_xosc bit.
     */
    inline bool get_WAKE_EN1_clk_sys_xosc() volatile
    {
        return WAKE_EN1 & (1u << 14u);
    }

    /**
     * Set WAKE_EN1's clk_sys_xosc bit.
     */
    inline void set_WAKE_EN1_clk_sys_xosc() volatile
    {
        WAKE_EN1 |= 1u << 14u;
    }

    /**
     * Clear WAKE_EN1's clk_sys_xosc bit.
     */
    inline void clear_WAKE_EN1_clk_sys_xosc() volatile
    {
        WAKE_EN1 &= ~(1u << 14u);
    }

    /**
     * Toggle WAKE_EN1's clk_sys_xosc bit.
     */
    inline void toggle_WAKE_EN1_clk_sys_xosc() volatile
    {
        WAKE_EN1 ^= 1u << 14u;
    }

    /**
     * Get all of WAKE_EN1's bit fields.
     *
     * (read-write) enable clock in wake mode
     */
    inline void get_WAKE_EN1(bool &clk_sys_sram4, bool &clk_sys_sram5,
                             bool &clk_sys_syscfg, bool &clk_sys_sysinfo,
                             bool &clk_sys_tbman, bool &clk_sys_timer,
                             bool &clk_peri_uart0, bool &clk_sys_uart0,
                             bool &clk_peri_uart1, bool &clk_sys_uart1,
                             bool &clk_sys_usbctrl, bool &clk_usb_usbctrl,
                             bool &clk_sys_watchdog, bool &clk_sys_xip,
                             bool &clk_sys_xosc) volatile
    {
        uint32_t curr = WAKE_EN1;

        clk_sys_sram4 = curr & (1u << 0u);
        clk_sys_sram5 = curr & (1u << 1u);
        clk_sys_syscfg = curr & (1u << 2u);
        clk_sys_sysinfo = curr & (1u << 3u);
        clk_sys_tbman = curr & (1u << 4u);
        clk_sys_timer = curr & (1u << 5u);
        clk_peri_uart0 = curr & (1u << 6u);
        clk_sys_uart0 = curr & (1u << 7u);
        clk_peri_uart1 = curr & (1u << 8u);
        clk_sys_uart1 = curr & (1u << 9u);
        clk_sys_usbctrl = curr & (1u << 10u);
        clk_usb_usbctrl = curr & (1u << 11u);
        clk_sys_watchdog = curr & (1u << 12u);
        clk_sys_xip = curr & (1u << 13u);
        clk_sys_xosc = curr & (1u << 14u);
    }

    /**
     * Set all of WAKE_EN1's bit fields.
     *
     * (read-write) enable clock in wake mode
     */
    inline void set_WAKE_EN1(bool clk_sys_sram4, bool clk_sys_sram5,
                             bool clk_sys_syscfg, bool clk_sys_sysinfo,
                             bool clk_sys_tbman, bool clk_sys_timer,
                             bool clk_peri_uart0, bool clk_sys_uart0,
                             bool clk_peri_uart1, bool clk_sys_uart1,
                             bool clk_sys_usbctrl, bool clk_usb_usbctrl,
                             bool clk_sys_watchdog, bool clk_sys_xip,
                             bool clk_sys_xosc) volatile
    {
        uint32_t curr = WAKE_EN1;

        curr &= ~(0b1u << 0u);
        curr |= (clk_sys_sram4 & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (clk_sys_sram5 & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clk_sys_syscfg & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (clk_sys_sysinfo & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (clk_sys_tbman & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (clk_sys_timer & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (clk_peri_uart0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (clk_sys_uart0 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (clk_peri_uart1 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (clk_sys_uart1 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (clk_sys_usbctrl & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (clk_usb_usbctrl & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (clk_sys_watchdog & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (clk_sys_xip & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (clk_sys_xosc & 0b1u) << 14u;

        WAKE_EN1 = curr;
    }

    /**
     * Get SLEEP_EN0's clk_sys_clocks bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_clocks() volatile
    {
        return SLEEP_EN0 & (1u << 0u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_clocks bit.
     */
    inline void set_SLEEP_EN0_clk_sys_clocks() volatile
    {
        SLEEP_EN0 |= 1u << 0u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_clocks bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_clocks() volatile
    {
        SLEEP_EN0 &= ~(1u << 0u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_clocks bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_clocks() volatile
    {
        SLEEP_EN0 ^= 1u << 0u;
    }

    /**
     * Get SLEEP_EN0's clk_adc_adc bit.
     */
    inline bool get_SLEEP_EN0_clk_adc_adc() volatile
    {
        return SLEEP_EN0 & (1u << 1u);
    }

    /**
     * Set SLEEP_EN0's clk_adc_adc bit.
     */
    inline void set_SLEEP_EN0_clk_adc_adc() volatile
    {
        SLEEP_EN0 |= 1u << 1u;
    }

    /**
     * Clear SLEEP_EN0's clk_adc_adc bit.
     */
    inline void clear_SLEEP_EN0_clk_adc_adc() volatile
    {
        SLEEP_EN0 &= ~(1u << 1u);
    }

    /**
     * Toggle SLEEP_EN0's clk_adc_adc bit.
     */
    inline void toggle_SLEEP_EN0_clk_adc_adc() volatile
    {
        SLEEP_EN0 ^= 1u << 1u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_adc bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_adc() volatile
    {
        return SLEEP_EN0 & (1u << 2u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_adc bit.
     */
    inline void set_SLEEP_EN0_clk_sys_adc() volatile
    {
        SLEEP_EN0 |= 1u << 2u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_adc bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_adc() volatile
    {
        SLEEP_EN0 &= ~(1u << 2u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_adc bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_adc() volatile
    {
        SLEEP_EN0 ^= 1u << 2u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_busctrl() volatile
    {
        return SLEEP_EN0 & (1u << 3u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline void set_SLEEP_EN0_clk_sys_busctrl() volatile
    {
        SLEEP_EN0 |= 1u << 3u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_busctrl() volatile
    {
        SLEEP_EN0 &= ~(1u << 3u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_busctrl bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_busctrl() volatile
    {
        SLEEP_EN0 ^= 1u << 3u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_busfabric() volatile
    {
        return SLEEP_EN0 & (1u << 4u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline void set_SLEEP_EN0_clk_sys_busfabric() volatile
    {
        SLEEP_EN0 |= 1u << 4u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_busfabric() volatile
    {
        SLEEP_EN0 &= ~(1u << 4u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_busfabric bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_busfabric() volatile
    {
        SLEEP_EN0 ^= 1u << 4u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_dma bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_dma() volatile
    {
        return SLEEP_EN0 & (1u << 5u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_dma bit.
     */
    inline void set_SLEEP_EN0_clk_sys_dma() volatile
    {
        SLEEP_EN0 |= 1u << 5u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_dma bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_dma() volatile
    {
        SLEEP_EN0 &= ~(1u << 5u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_dma bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_dma() volatile
    {
        SLEEP_EN0 ^= 1u << 5u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_i2c0() volatile
    {
        return SLEEP_EN0 & (1u << 6u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_i2c0() volatile
    {
        SLEEP_EN0 |= 1u << 6u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_i2c0() volatile
    {
        SLEEP_EN0 &= ~(1u << 6u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_i2c0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_i2c0() volatile
    {
        SLEEP_EN0 ^= 1u << 6u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_i2c1() volatile
    {
        return SLEEP_EN0 & (1u << 7u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_i2c1() volatile
    {
        SLEEP_EN0 |= 1u << 7u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_i2c1() volatile
    {
        SLEEP_EN0 &= ~(1u << 7u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_i2c1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_i2c1() volatile
    {
        SLEEP_EN0 ^= 1u << 7u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_io bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_io() volatile
    {
        return SLEEP_EN0 & (1u << 8u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_io bit.
     */
    inline void set_SLEEP_EN0_clk_sys_io() volatile
    {
        SLEEP_EN0 |= 1u << 8u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_io bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_io() volatile
    {
        SLEEP_EN0 &= ~(1u << 8u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_io bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_io() volatile
    {
        SLEEP_EN0 ^= 1u << 8u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_jtag bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_jtag() volatile
    {
        return SLEEP_EN0 & (1u << 9u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_jtag bit.
     */
    inline void set_SLEEP_EN0_clk_sys_jtag() volatile
    {
        SLEEP_EN0 |= 1u << 9u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_jtag bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_jtag() volatile
    {
        SLEEP_EN0 &= ~(1u << 9u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_jtag bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_jtag() volatile
    {
        SLEEP_EN0 ^= 1u << 9u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        return SLEEP_EN0 & (1u << 10u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void set_SLEEP_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        SLEEP_EN0 |= 1u << 10u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        SLEEP_EN0 &= ~(1u << 10u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_vreg_and_chip_reset bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_vreg_and_chip_reset() volatile
    {
        SLEEP_EN0 ^= 1u << 10u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pads bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_pads() volatile
    {
        return SLEEP_EN0 & (1u << 11u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pads bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pads() volatile
    {
        SLEEP_EN0 |= 1u << 11u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pads bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pads() volatile
    {
        SLEEP_EN0 &= ~(1u << 11u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pads bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pads() volatile
    {
        SLEEP_EN0 ^= 1u << 11u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_pio0() volatile
    {
        return SLEEP_EN0 & (1u << 12u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pio0() volatile
    {
        SLEEP_EN0 |= 1u << 12u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pio0() volatile
    {
        SLEEP_EN0 &= ~(1u << 12u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pio0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pio0() volatile
    {
        SLEEP_EN0 ^= 1u << 12u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_pio1() volatile
    {
        return SLEEP_EN0 & (1u << 13u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pio1() volatile
    {
        SLEEP_EN0 |= 1u << 13u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pio1() volatile
    {
        SLEEP_EN0 &= ~(1u << 13u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pio1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pio1() volatile
    {
        SLEEP_EN0 ^= 1u << 13u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_pll_sys() volatile
    {
        return SLEEP_EN0 & (1u << 14u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pll_sys() volatile
    {
        SLEEP_EN0 |= 1u << 14u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pll_sys() volatile
    {
        SLEEP_EN0 &= ~(1u << 14u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pll_sys bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pll_sys() volatile
    {
        SLEEP_EN0 ^= 1u << 14u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_pll_usb() volatile
    {
        return SLEEP_EN0 & (1u << 15u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pll_usb() volatile
    {
        SLEEP_EN0 |= 1u << 15u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pll_usb() volatile
    {
        SLEEP_EN0 &= ~(1u << 15u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pll_usb bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pll_usb() volatile
    {
        SLEEP_EN0 ^= 1u << 15u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_psm bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_psm() volatile
    {
        return SLEEP_EN0 & (1u << 16u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_psm bit.
     */
    inline void set_SLEEP_EN0_clk_sys_psm() volatile
    {
        SLEEP_EN0 |= 1u << 16u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_psm bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_psm() volatile
    {
        SLEEP_EN0 &= ~(1u << 16u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_psm bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_psm() volatile
    {
        SLEEP_EN0 ^= 1u << 16u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_pwm bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_pwm() volatile
    {
        return SLEEP_EN0 & (1u << 17u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_pwm bit.
     */
    inline void set_SLEEP_EN0_clk_sys_pwm() volatile
    {
        SLEEP_EN0 |= 1u << 17u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_pwm bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_pwm() volatile
    {
        SLEEP_EN0 &= ~(1u << 17u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_pwm bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_pwm() volatile
    {
        SLEEP_EN0 ^= 1u << 17u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_resets bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_resets() volatile
    {
        return SLEEP_EN0 & (1u << 18u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_resets bit.
     */
    inline void set_SLEEP_EN0_clk_sys_resets() volatile
    {
        SLEEP_EN0 |= 1u << 18u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_resets bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_resets() volatile
    {
        SLEEP_EN0 &= ~(1u << 18u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_resets bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_resets() volatile
    {
        SLEEP_EN0 ^= 1u << 18u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_rom bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_rom() volatile
    {
        return SLEEP_EN0 & (1u << 19u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_rom bit.
     */
    inline void set_SLEEP_EN0_clk_sys_rom() volatile
    {
        SLEEP_EN0 |= 1u << 19u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_rom bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_rom() volatile
    {
        SLEEP_EN0 &= ~(1u << 19u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_rom bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_rom() volatile
    {
        SLEEP_EN0 ^= 1u << 19u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_rosc bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_rosc() volatile
    {
        return SLEEP_EN0 & (1u << 20u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_rosc bit.
     */
    inline void set_SLEEP_EN0_clk_sys_rosc() volatile
    {
        SLEEP_EN0 |= 1u << 20u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_rosc bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_rosc() volatile
    {
        SLEEP_EN0 &= ~(1u << 20u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_rosc bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_rosc() volatile
    {
        SLEEP_EN0 ^= 1u << 20u;
    }

    /**
     * Get SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline bool get_SLEEP_EN0_clk_rtc_rtc() volatile
    {
        return SLEEP_EN0 & (1u << 21u);
    }

    /**
     * Set SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline void set_SLEEP_EN0_clk_rtc_rtc() volatile
    {
        SLEEP_EN0 |= 1u << 21u;
    }

    /**
     * Clear SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline void clear_SLEEP_EN0_clk_rtc_rtc() volatile
    {
        SLEEP_EN0 &= ~(1u << 21u);
    }

    /**
     * Toggle SLEEP_EN0's clk_rtc_rtc bit.
     */
    inline void toggle_SLEEP_EN0_clk_rtc_rtc() volatile
    {
        SLEEP_EN0 ^= 1u << 21u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_rtc bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_rtc() volatile
    {
        return SLEEP_EN0 & (1u << 22u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_rtc bit.
     */
    inline void set_SLEEP_EN0_clk_sys_rtc() volatile
    {
        SLEEP_EN0 |= 1u << 22u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_rtc bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_rtc() volatile
    {
        SLEEP_EN0 &= ~(1u << 22u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_rtc bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_rtc() volatile
    {
        SLEEP_EN0 ^= 1u << 22u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sio bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_sio() volatile
    {
        return SLEEP_EN0 & (1u << 23u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sio bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sio() volatile
    {
        SLEEP_EN0 |= 1u << 23u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sio bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sio() volatile
    {
        SLEEP_EN0 &= ~(1u << 23u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sio bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sio() volatile
    {
        SLEEP_EN0 ^= 1u << 23u;
    }

    /**
     * Get SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline bool get_SLEEP_EN0_clk_peri_spi0() volatile
    {
        return SLEEP_EN0 & (1u << 24u);
    }

    /**
     * Set SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline void set_SLEEP_EN0_clk_peri_spi0() volatile
    {
        SLEEP_EN0 |= 1u << 24u;
    }

    /**
     * Clear SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline void clear_SLEEP_EN0_clk_peri_spi0() volatile
    {
        SLEEP_EN0 &= ~(1u << 24u);
    }

    /**
     * Toggle SLEEP_EN0's clk_peri_spi0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_peri_spi0() volatile
    {
        SLEEP_EN0 ^= 1u << 24u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_spi0() volatile
    {
        return SLEEP_EN0 & (1u << 25u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_spi0() volatile
    {
        SLEEP_EN0 |= 1u << 25u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_spi0() volatile
    {
        SLEEP_EN0 &= ~(1u << 25u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_spi0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_spi0() volatile
    {
        SLEEP_EN0 ^= 1u << 25u;
    }

    /**
     * Get SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline bool get_SLEEP_EN0_clk_peri_spi1() volatile
    {
        return SLEEP_EN0 & (1u << 26u);
    }

    /**
     * Set SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline void set_SLEEP_EN0_clk_peri_spi1() volatile
    {
        SLEEP_EN0 |= 1u << 26u;
    }

    /**
     * Clear SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline void clear_SLEEP_EN0_clk_peri_spi1() volatile
    {
        SLEEP_EN0 &= ~(1u << 26u);
    }

    /**
     * Toggle SLEEP_EN0's clk_peri_spi1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_peri_spi1() volatile
    {
        SLEEP_EN0 ^= 1u << 26u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_spi1() volatile
    {
        return SLEEP_EN0 & (1u << 27u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_spi1() volatile
    {
        SLEEP_EN0 |= 1u << 27u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_spi1() volatile
    {
        SLEEP_EN0 &= ~(1u << 27u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_spi1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_spi1() volatile
    {
        SLEEP_EN0 ^= 1u << 27u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_sram0() volatile
    {
        return SLEEP_EN0 & (1u << 28u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram0() volatile
    {
        SLEEP_EN0 |= 1u << 28u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram0() volatile
    {
        SLEEP_EN0 &= ~(1u << 28u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram0 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram0() volatile
    {
        SLEEP_EN0 ^= 1u << 28u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_sram1() volatile
    {
        return SLEEP_EN0 & (1u << 29u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram1() volatile
    {
        SLEEP_EN0 |= 1u << 29u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram1() volatile
    {
        SLEEP_EN0 &= ~(1u << 29u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram1 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram1() volatile
    {
        SLEEP_EN0 ^= 1u << 29u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_sram2() volatile
    {
        return SLEEP_EN0 & (1u << 30u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram2() volatile
    {
        SLEEP_EN0 |= 1u << 30u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram2() volatile
    {
        SLEEP_EN0 &= ~(1u << 30u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram2 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram2() volatile
    {
        SLEEP_EN0 ^= 1u << 30u;
    }

    /**
     * Get SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline bool get_SLEEP_EN0_clk_sys_sram3() volatile
    {
        return SLEEP_EN0 & (1u << 31u);
    }

    /**
     * Set SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline void set_SLEEP_EN0_clk_sys_sram3() volatile
    {
        SLEEP_EN0 |= 1u << 31u;
    }

    /**
     * Clear SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline void clear_SLEEP_EN0_clk_sys_sram3() volatile
    {
        SLEEP_EN0 &= ~(1u << 31u);
    }

    /**
     * Toggle SLEEP_EN0's clk_sys_sram3 bit.
     */
    inline void toggle_SLEEP_EN0_clk_sys_sram3() volatile
    {
        SLEEP_EN0 ^= 1u << 31u;
    }

    /**
     * Get all of SLEEP_EN0's bit fields.
     *
     * (read-write) enable clock in sleep mode
     */
    inline void get_SLEEP_EN0(
        bool &clk_sys_clocks, bool &clk_adc_adc, bool &clk_sys_adc,
        bool &clk_sys_busctrl, bool &clk_sys_busfabric, bool &clk_sys_dma,
        bool &clk_sys_i2c0, bool &clk_sys_i2c1, bool &clk_sys_io,
        bool &clk_sys_jtag, bool &clk_sys_vreg_and_chip_reset,
        bool &clk_sys_pads, bool &clk_sys_pio0, bool &clk_sys_pio1,
        bool &clk_sys_pll_sys, bool &clk_sys_pll_usb, bool &clk_sys_psm,
        bool &clk_sys_pwm, bool &clk_sys_resets, bool &clk_sys_rom,
        bool &clk_sys_rosc, bool &clk_rtc_rtc, bool &clk_sys_rtc,
        bool &clk_sys_sio, bool &clk_peri_spi0, bool &clk_sys_spi0,
        bool &clk_peri_spi1, bool &clk_sys_spi1, bool &clk_sys_sram0,
        bool &clk_sys_sram1, bool &clk_sys_sram2, bool &clk_sys_sram3) volatile
    {
        uint32_t curr = SLEEP_EN0;

        clk_sys_clocks = curr & (1u << 0u);
        clk_adc_adc = curr & (1u << 1u);
        clk_sys_adc = curr & (1u << 2u);
        clk_sys_busctrl = curr & (1u << 3u);
        clk_sys_busfabric = curr & (1u << 4u);
        clk_sys_dma = curr & (1u << 5u);
        clk_sys_i2c0 = curr & (1u << 6u);
        clk_sys_i2c1 = curr & (1u << 7u);
        clk_sys_io = curr & (1u << 8u);
        clk_sys_jtag = curr & (1u << 9u);
        clk_sys_vreg_and_chip_reset = curr & (1u << 10u);
        clk_sys_pads = curr & (1u << 11u);
        clk_sys_pio0 = curr & (1u << 12u);
        clk_sys_pio1 = curr & (1u << 13u);
        clk_sys_pll_sys = curr & (1u << 14u);
        clk_sys_pll_usb = curr & (1u << 15u);
        clk_sys_psm = curr & (1u << 16u);
        clk_sys_pwm = curr & (1u << 17u);
        clk_sys_resets = curr & (1u << 18u);
        clk_sys_rom = curr & (1u << 19u);
        clk_sys_rosc = curr & (1u << 20u);
        clk_rtc_rtc = curr & (1u << 21u);
        clk_sys_rtc = curr & (1u << 22u);
        clk_sys_sio = curr & (1u << 23u);
        clk_peri_spi0 = curr & (1u << 24u);
        clk_sys_spi0 = curr & (1u << 25u);
        clk_peri_spi1 = curr & (1u << 26u);
        clk_sys_spi1 = curr & (1u << 27u);
        clk_sys_sram0 = curr & (1u << 28u);
        clk_sys_sram1 = curr & (1u << 29u);
        clk_sys_sram2 = curr & (1u << 30u);
        clk_sys_sram3 = curr & (1u << 31u);
    }

    /**
     * Set all of SLEEP_EN0's bit fields.
     *
     * (read-write) enable clock in sleep mode
     */
    inline void set_SLEEP_EN0(
        bool clk_sys_clocks, bool clk_adc_adc, bool clk_sys_adc,
        bool clk_sys_busctrl, bool clk_sys_busfabric, bool clk_sys_dma,
        bool clk_sys_i2c0, bool clk_sys_i2c1, bool clk_sys_io,
        bool clk_sys_jtag, bool clk_sys_vreg_and_chip_reset, bool clk_sys_pads,
        bool clk_sys_pio0, bool clk_sys_pio1, bool clk_sys_pll_sys,
        bool clk_sys_pll_usb, bool clk_sys_psm, bool clk_sys_pwm,
        bool clk_sys_resets, bool clk_sys_rom, bool clk_sys_rosc,
        bool clk_rtc_rtc, bool clk_sys_rtc, bool clk_sys_sio,
        bool clk_peri_spi0, bool clk_sys_spi0, bool clk_peri_spi1,
        bool clk_sys_spi1, bool clk_sys_sram0, bool clk_sys_sram1,
        bool clk_sys_sram2, bool clk_sys_sram3) volatile
    {
        uint32_t curr = SLEEP_EN0;

        curr &= ~(0b1u << 0u);
        curr |= (clk_sys_clocks & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (clk_adc_adc & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clk_sys_adc & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (clk_sys_busctrl & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (clk_sys_busfabric & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (clk_sys_dma & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (clk_sys_i2c0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (clk_sys_i2c1 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (clk_sys_io & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (clk_sys_jtag & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (clk_sys_vreg_and_chip_reset & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (clk_sys_pads & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (clk_sys_pio0 & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (clk_sys_pio1 & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (clk_sys_pll_sys & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (clk_sys_pll_usb & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (clk_sys_psm & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (clk_sys_pwm & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (clk_sys_resets & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (clk_sys_rom & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (clk_sys_rosc & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (clk_rtc_rtc & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (clk_sys_rtc & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (clk_sys_sio & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (clk_peri_spi0 & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (clk_sys_spi0 & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (clk_peri_spi1 & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (clk_sys_spi1 & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (clk_sys_sram0 & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (clk_sys_sram1 & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (clk_sys_sram2 & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (clk_sys_sram3 & 0b1u) << 31u;

        SLEEP_EN0 = curr;
    }

    /**
     * Get SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_sram4() volatile
    {
        return SLEEP_EN1 & (1u << 0u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_sram4() volatile
    {
        SLEEP_EN1 |= 1u << 0u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_sram4() volatile
    {
        SLEEP_EN1 &= ~(1u << 0u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_sram4 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_sram4() volatile
    {
        SLEEP_EN1 ^= 1u << 0u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_sram5() volatile
    {
        return SLEEP_EN1 & (1u << 1u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_sram5() volatile
    {
        SLEEP_EN1 |= 1u << 1u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_sram5() volatile
    {
        SLEEP_EN1 &= ~(1u << 1u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_sram5 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_sram5() volatile
    {
        SLEEP_EN1 ^= 1u << 1u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_syscfg() volatile
    {
        return SLEEP_EN1 & (1u << 2u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline void set_SLEEP_EN1_clk_sys_syscfg() volatile
    {
        SLEEP_EN1 |= 1u << 2u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_syscfg() volatile
    {
        SLEEP_EN1 &= ~(1u << 2u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_syscfg bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_syscfg() volatile
    {
        SLEEP_EN1 ^= 1u << 2u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_sysinfo() volatile
    {
        return SLEEP_EN1 & (1u << 3u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline void set_SLEEP_EN1_clk_sys_sysinfo() volatile
    {
        SLEEP_EN1 |= 1u << 3u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_sysinfo() volatile
    {
        SLEEP_EN1 &= ~(1u << 3u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_sysinfo bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_sysinfo() volatile
    {
        SLEEP_EN1 ^= 1u << 3u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_tbman bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_tbman() volatile
    {
        return SLEEP_EN1 & (1u << 4u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_tbman bit.
     */
    inline void set_SLEEP_EN1_clk_sys_tbman() volatile
    {
        SLEEP_EN1 |= 1u << 4u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_tbman bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_tbman() volatile
    {
        SLEEP_EN1 &= ~(1u << 4u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_tbman bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_tbman() volatile
    {
        SLEEP_EN1 ^= 1u << 4u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_timer bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_timer() volatile
    {
        return SLEEP_EN1 & (1u << 5u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_timer bit.
     */
    inline void set_SLEEP_EN1_clk_sys_timer() volatile
    {
        SLEEP_EN1 |= 1u << 5u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_timer bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_timer() volatile
    {
        SLEEP_EN1 &= ~(1u << 5u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_timer bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_timer() volatile
    {
        SLEEP_EN1 ^= 1u << 5u;
    }

    /**
     * Get SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline bool get_SLEEP_EN1_clk_peri_uart0() volatile
    {
        return SLEEP_EN1 & (1u << 6u);
    }

    /**
     * Set SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline void set_SLEEP_EN1_clk_peri_uart0() volatile
    {
        SLEEP_EN1 |= 1u << 6u;
    }

    /**
     * Clear SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline void clear_SLEEP_EN1_clk_peri_uart0() volatile
    {
        SLEEP_EN1 &= ~(1u << 6u);
    }

    /**
     * Toggle SLEEP_EN1's clk_peri_uart0 bit.
     */
    inline void toggle_SLEEP_EN1_clk_peri_uart0() volatile
    {
        SLEEP_EN1 ^= 1u << 6u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_uart0() volatile
    {
        return SLEEP_EN1 & (1u << 7u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_uart0() volatile
    {
        SLEEP_EN1 |= 1u << 7u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_uart0() volatile
    {
        SLEEP_EN1 &= ~(1u << 7u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_uart0 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_uart0() volatile
    {
        SLEEP_EN1 ^= 1u << 7u;
    }

    /**
     * Get SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline bool get_SLEEP_EN1_clk_peri_uart1() volatile
    {
        return SLEEP_EN1 & (1u << 8u);
    }

    /**
     * Set SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline void set_SLEEP_EN1_clk_peri_uart1() volatile
    {
        SLEEP_EN1 |= 1u << 8u;
    }

    /**
     * Clear SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline void clear_SLEEP_EN1_clk_peri_uart1() volatile
    {
        SLEEP_EN1 &= ~(1u << 8u);
    }

    /**
     * Toggle SLEEP_EN1's clk_peri_uart1 bit.
     */
    inline void toggle_SLEEP_EN1_clk_peri_uart1() volatile
    {
        SLEEP_EN1 ^= 1u << 8u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_uart1() volatile
    {
        return SLEEP_EN1 & (1u << 9u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline void set_SLEEP_EN1_clk_sys_uart1() volatile
    {
        SLEEP_EN1 |= 1u << 9u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_uart1() volatile
    {
        SLEEP_EN1 &= ~(1u << 9u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_uart1 bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_uart1() volatile
    {
        SLEEP_EN1 ^= 1u << 9u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_usbctrl() volatile
    {
        return SLEEP_EN1 & (1u << 10u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline void set_SLEEP_EN1_clk_sys_usbctrl() volatile
    {
        SLEEP_EN1 |= 1u << 10u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_usbctrl() volatile
    {
        SLEEP_EN1 &= ~(1u << 10u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_usbctrl bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_usbctrl() volatile
    {
        SLEEP_EN1 ^= 1u << 10u;
    }

    /**
     * Get SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline bool get_SLEEP_EN1_clk_usb_usbctrl() volatile
    {
        return SLEEP_EN1 & (1u << 11u);
    }

    /**
     * Set SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline void set_SLEEP_EN1_clk_usb_usbctrl() volatile
    {
        SLEEP_EN1 |= 1u << 11u;
    }

    /**
     * Clear SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline void clear_SLEEP_EN1_clk_usb_usbctrl() volatile
    {
        SLEEP_EN1 &= ~(1u << 11u);
    }

    /**
     * Toggle SLEEP_EN1's clk_usb_usbctrl bit.
     */
    inline void toggle_SLEEP_EN1_clk_usb_usbctrl() volatile
    {
        SLEEP_EN1 ^= 1u << 11u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_watchdog() volatile
    {
        return SLEEP_EN1 & (1u << 12u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline void set_SLEEP_EN1_clk_sys_watchdog() volatile
    {
        SLEEP_EN1 |= 1u << 12u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_watchdog() volatile
    {
        SLEEP_EN1 &= ~(1u << 12u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_watchdog bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_watchdog() volatile
    {
        SLEEP_EN1 ^= 1u << 12u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_xip bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_xip() volatile
    {
        return SLEEP_EN1 & (1u << 13u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_xip bit.
     */
    inline void set_SLEEP_EN1_clk_sys_xip() volatile
    {
        SLEEP_EN1 |= 1u << 13u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_xip bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_xip() volatile
    {
        SLEEP_EN1 &= ~(1u << 13u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_xip bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_xip() volatile
    {
        SLEEP_EN1 ^= 1u << 13u;
    }

    /**
     * Get SLEEP_EN1's clk_sys_xosc bit.
     */
    inline bool get_SLEEP_EN1_clk_sys_xosc() volatile
    {
        return SLEEP_EN1 & (1u << 14u);
    }

    /**
     * Set SLEEP_EN1's clk_sys_xosc bit.
     */
    inline void set_SLEEP_EN1_clk_sys_xosc() volatile
    {
        SLEEP_EN1 |= 1u << 14u;
    }

    /**
     * Clear SLEEP_EN1's clk_sys_xosc bit.
     */
    inline void clear_SLEEP_EN1_clk_sys_xosc() volatile
    {
        SLEEP_EN1 &= ~(1u << 14u);
    }

    /**
     * Toggle SLEEP_EN1's clk_sys_xosc bit.
     */
    inline void toggle_SLEEP_EN1_clk_sys_xosc() volatile
    {
        SLEEP_EN1 ^= 1u << 14u;
    }

    /**
     * Get all of SLEEP_EN1's bit fields.
     *
     * (read-write) enable clock in sleep mode
     */
    inline void get_SLEEP_EN1(bool &clk_sys_sram4, bool &clk_sys_sram5,
                              bool &clk_sys_syscfg, bool &clk_sys_sysinfo,
                              bool &clk_sys_tbman, bool &clk_sys_timer,
                              bool &clk_peri_uart0, bool &clk_sys_uart0,
                              bool &clk_peri_uart1, bool &clk_sys_uart1,
                              bool &clk_sys_usbctrl, bool &clk_usb_usbctrl,
                              bool &clk_sys_watchdog, bool &clk_sys_xip,
                              bool &clk_sys_xosc) volatile
    {
        uint32_t curr = SLEEP_EN1;

        clk_sys_sram4 = curr & (1u << 0u);
        clk_sys_sram5 = curr & (1u << 1u);
        clk_sys_syscfg = curr & (1u << 2u);
        clk_sys_sysinfo = curr & (1u << 3u);
        clk_sys_tbman = curr & (1u << 4u);
        clk_sys_timer = curr & (1u << 5u);
        clk_peri_uart0 = curr & (1u << 6u);
        clk_sys_uart0 = curr & (1u << 7u);
        clk_peri_uart1 = curr & (1u << 8u);
        clk_sys_uart1 = curr & (1u << 9u);
        clk_sys_usbctrl = curr & (1u << 10u);
        clk_usb_usbctrl = curr & (1u << 11u);
        clk_sys_watchdog = curr & (1u << 12u);
        clk_sys_xip = curr & (1u << 13u);
        clk_sys_xosc = curr & (1u << 14u);
    }

    /**
     * Set all of SLEEP_EN1's bit fields.
     *
     * (read-write) enable clock in sleep mode
     */
    inline void set_SLEEP_EN1(bool clk_sys_sram4, bool clk_sys_sram5,
                              bool clk_sys_syscfg, bool clk_sys_sysinfo,
                              bool clk_sys_tbman, bool clk_sys_timer,
                              bool clk_peri_uart0, bool clk_sys_uart0,
                              bool clk_peri_uart1, bool clk_sys_uart1,
                              bool clk_sys_usbctrl, bool clk_usb_usbctrl,
                              bool clk_sys_watchdog, bool clk_sys_xip,
                              bool clk_sys_xosc) volatile
    {
        uint32_t curr = SLEEP_EN1;

        curr &= ~(0b1u << 0u);
        curr |= (clk_sys_sram4 & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (clk_sys_sram5 & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clk_sys_syscfg & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (clk_sys_sysinfo & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (clk_sys_tbman & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (clk_sys_timer & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (clk_peri_uart0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (clk_sys_uart0 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (clk_peri_uart1 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (clk_sys_uart1 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (clk_sys_usbctrl & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (clk_usb_usbctrl & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (clk_sys_watchdog & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (clk_sys_xip & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (clk_sys_xosc & 0b1u) << 14u;

        SLEEP_EN1 = curr;
    }

    /**
     * Get ENABLED0's clk_sys_clocks bit.
     */
    inline bool get_ENABLED0_clk_sys_clocks() volatile
    {
        return ENABLED0 & (1u << 0u);
    }

    /**
     * Get ENABLED0's clk_adc_adc bit.
     */
    inline bool get_ENABLED0_clk_adc_adc() volatile
    {
        return ENABLED0 & (1u << 1u);
    }

    /**
     * Get ENABLED0's clk_sys_adc bit.
     */
    inline bool get_ENABLED0_clk_sys_adc() volatile
    {
        return ENABLED0 & (1u << 2u);
    }

    /**
     * Get ENABLED0's clk_sys_busctrl bit.
     */
    inline bool get_ENABLED0_clk_sys_busctrl() volatile
    {
        return ENABLED0 & (1u << 3u);
    }

    /**
     * Get ENABLED0's clk_sys_busfabric bit.
     */
    inline bool get_ENABLED0_clk_sys_busfabric() volatile
    {
        return ENABLED0 & (1u << 4u);
    }

    /**
     * Get ENABLED0's clk_sys_dma bit.
     */
    inline bool get_ENABLED0_clk_sys_dma() volatile
    {
        return ENABLED0 & (1u << 5u);
    }

    /**
     * Get ENABLED0's clk_sys_i2c0 bit.
     */
    inline bool get_ENABLED0_clk_sys_i2c0() volatile
    {
        return ENABLED0 & (1u << 6u);
    }

    /**
     * Get ENABLED0's clk_sys_i2c1 bit.
     */
    inline bool get_ENABLED0_clk_sys_i2c1() volatile
    {
        return ENABLED0 & (1u << 7u);
    }

    /**
     * Get ENABLED0's clk_sys_io bit.
     */
    inline bool get_ENABLED0_clk_sys_io() volatile
    {
        return ENABLED0 & (1u << 8u);
    }

    /**
     * Get ENABLED0's clk_sys_jtag bit.
     */
    inline bool get_ENABLED0_clk_sys_jtag() volatile
    {
        return ENABLED0 & (1u << 9u);
    }

    /**
     * Get ENABLED0's clk_sys_vreg_and_chip_reset bit.
     */
    inline bool get_ENABLED0_clk_sys_vreg_and_chip_reset() volatile
    {
        return ENABLED0 & (1u << 10u);
    }

    /**
     * Get ENABLED0's clk_sys_pads bit.
     */
    inline bool get_ENABLED0_clk_sys_pads() volatile
    {
        return ENABLED0 & (1u << 11u);
    }

    /**
     * Get ENABLED0's clk_sys_pio0 bit.
     */
    inline bool get_ENABLED0_clk_sys_pio0() volatile
    {
        return ENABLED0 & (1u << 12u);
    }

    /**
     * Get ENABLED0's clk_sys_pio1 bit.
     */
    inline bool get_ENABLED0_clk_sys_pio1() volatile
    {
        return ENABLED0 & (1u << 13u);
    }

    /**
     * Get ENABLED0's clk_sys_pll_sys bit.
     */
    inline bool get_ENABLED0_clk_sys_pll_sys() volatile
    {
        return ENABLED0 & (1u << 14u);
    }

    /**
     * Get ENABLED0's clk_sys_pll_usb bit.
     */
    inline bool get_ENABLED0_clk_sys_pll_usb() volatile
    {
        return ENABLED0 & (1u << 15u);
    }

    /**
     * Get ENABLED0's clk_sys_psm bit.
     */
    inline bool get_ENABLED0_clk_sys_psm() volatile
    {
        return ENABLED0 & (1u << 16u);
    }

    /**
     * Get ENABLED0's clk_sys_pwm bit.
     */
    inline bool get_ENABLED0_clk_sys_pwm() volatile
    {
        return ENABLED0 & (1u << 17u);
    }

    /**
     * Get ENABLED0's clk_sys_resets bit.
     */
    inline bool get_ENABLED0_clk_sys_resets() volatile
    {
        return ENABLED0 & (1u << 18u);
    }

    /**
     * Get ENABLED0's clk_sys_rom bit.
     */
    inline bool get_ENABLED0_clk_sys_rom() volatile
    {
        return ENABLED0 & (1u << 19u);
    }

    /**
     * Get ENABLED0's clk_sys_rosc bit.
     */
    inline bool get_ENABLED0_clk_sys_rosc() volatile
    {
        return ENABLED0 & (1u << 20u);
    }

    /**
     * Get ENABLED0's clk_rtc_rtc bit.
     */
    inline bool get_ENABLED0_clk_rtc_rtc() volatile
    {
        return ENABLED0 & (1u << 21u);
    }

    /**
     * Get ENABLED0's clk_sys_rtc bit.
     */
    inline bool get_ENABLED0_clk_sys_rtc() volatile
    {
        return ENABLED0 & (1u << 22u);
    }

    /**
     * Get ENABLED0's clk_sys_sio bit.
     */
    inline bool get_ENABLED0_clk_sys_sio() volatile
    {
        return ENABLED0 & (1u << 23u);
    }

    /**
     * Get ENABLED0's clk_peri_spi0 bit.
     */
    inline bool get_ENABLED0_clk_peri_spi0() volatile
    {
        return ENABLED0 & (1u << 24u);
    }

    /**
     * Get ENABLED0's clk_sys_spi0 bit.
     */
    inline bool get_ENABLED0_clk_sys_spi0() volatile
    {
        return ENABLED0 & (1u << 25u);
    }

    /**
     * Get ENABLED0's clk_peri_spi1 bit.
     */
    inline bool get_ENABLED0_clk_peri_spi1() volatile
    {
        return ENABLED0 & (1u << 26u);
    }

    /**
     * Get ENABLED0's clk_sys_spi1 bit.
     */
    inline bool get_ENABLED0_clk_sys_spi1() volatile
    {
        return ENABLED0 & (1u << 27u);
    }

    /**
     * Get ENABLED0's clk_sys_sram0 bit.
     */
    inline bool get_ENABLED0_clk_sys_sram0() volatile
    {
        return ENABLED0 & (1u << 28u);
    }

    /**
     * Get ENABLED0's clk_sys_sram1 bit.
     */
    inline bool get_ENABLED0_clk_sys_sram1() volatile
    {
        return ENABLED0 & (1u << 29u);
    }

    /**
     * Get ENABLED0's clk_sys_sram2 bit.
     */
    inline bool get_ENABLED0_clk_sys_sram2() volatile
    {
        return ENABLED0 & (1u << 30u);
    }

    /**
     * Get ENABLED0's clk_sys_sram3 bit.
     */
    inline bool get_ENABLED0_clk_sys_sram3() volatile
    {
        return ENABLED0 & (1u << 31u);
    }

    /**
     * Get all of ENABLED0's bit fields.
     *
     * (read-only) indicates the state of the clock enable
     */
    inline void get_ENABLED0(
        bool &clk_sys_clocks, bool &clk_adc_adc, bool &clk_sys_adc,
        bool &clk_sys_busctrl, bool &clk_sys_busfabric, bool &clk_sys_dma,
        bool &clk_sys_i2c0, bool &clk_sys_i2c1, bool &clk_sys_io,
        bool &clk_sys_jtag, bool &clk_sys_vreg_and_chip_reset,
        bool &clk_sys_pads, bool &clk_sys_pio0, bool &clk_sys_pio1,
        bool &clk_sys_pll_sys, bool &clk_sys_pll_usb, bool &clk_sys_psm,
        bool &clk_sys_pwm, bool &clk_sys_resets, bool &clk_sys_rom,
        bool &clk_sys_rosc, bool &clk_rtc_rtc, bool &clk_sys_rtc,
        bool &clk_sys_sio, bool &clk_peri_spi0, bool &clk_sys_spi0,
        bool &clk_peri_spi1, bool &clk_sys_spi1, bool &clk_sys_sram0,
        bool &clk_sys_sram1, bool &clk_sys_sram2, bool &clk_sys_sram3) volatile
    {
        uint32_t curr = ENABLED0;

        clk_sys_clocks = curr & (1u << 0u);
        clk_adc_adc = curr & (1u << 1u);
        clk_sys_adc = curr & (1u << 2u);
        clk_sys_busctrl = curr & (1u << 3u);
        clk_sys_busfabric = curr & (1u << 4u);
        clk_sys_dma = curr & (1u << 5u);
        clk_sys_i2c0 = curr & (1u << 6u);
        clk_sys_i2c1 = curr & (1u << 7u);
        clk_sys_io = curr & (1u << 8u);
        clk_sys_jtag = curr & (1u << 9u);
        clk_sys_vreg_and_chip_reset = curr & (1u << 10u);
        clk_sys_pads = curr & (1u << 11u);
        clk_sys_pio0 = curr & (1u << 12u);
        clk_sys_pio1 = curr & (1u << 13u);
        clk_sys_pll_sys = curr & (1u << 14u);
        clk_sys_pll_usb = curr & (1u << 15u);
        clk_sys_psm = curr & (1u << 16u);
        clk_sys_pwm = curr & (1u << 17u);
        clk_sys_resets = curr & (1u << 18u);
        clk_sys_rom = curr & (1u << 19u);
        clk_sys_rosc = curr & (1u << 20u);
        clk_rtc_rtc = curr & (1u << 21u);
        clk_sys_rtc = curr & (1u << 22u);
        clk_sys_sio = curr & (1u << 23u);
        clk_peri_spi0 = curr & (1u << 24u);
        clk_sys_spi0 = curr & (1u << 25u);
        clk_peri_spi1 = curr & (1u << 26u);
        clk_sys_spi1 = curr & (1u << 27u);
        clk_sys_sram0 = curr & (1u << 28u);
        clk_sys_sram1 = curr & (1u << 29u);
        clk_sys_sram2 = curr & (1u << 30u);
        clk_sys_sram3 = curr & (1u << 31u);
    }

    /**
     * Get ENABLED1's clk_sys_sram4 bit.
     */
    inline bool get_ENABLED1_clk_sys_sram4() volatile
    {
        return ENABLED1 & (1u << 0u);
    }

    /**
     * Get ENABLED1's clk_sys_sram5 bit.
     */
    inline bool get_ENABLED1_clk_sys_sram5() volatile
    {
        return ENABLED1 & (1u << 1u);
    }

    /**
     * Get ENABLED1's clk_sys_syscfg bit.
     */
    inline bool get_ENABLED1_clk_sys_syscfg() volatile
    {
        return ENABLED1 & (1u << 2u);
    }

    /**
     * Get ENABLED1's clk_sys_sysinfo bit.
     */
    inline bool get_ENABLED1_clk_sys_sysinfo() volatile
    {
        return ENABLED1 & (1u << 3u);
    }

    /**
     * Get ENABLED1's clk_sys_tbman bit.
     */
    inline bool get_ENABLED1_clk_sys_tbman() volatile
    {
        return ENABLED1 & (1u << 4u);
    }

    /**
     * Get ENABLED1's clk_sys_timer bit.
     */
    inline bool get_ENABLED1_clk_sys_timer() volatile
    {
        return ENABLED1 & (1u << 5u);
    }

    /**
     * Get ENABLED1's clk_peri_uart0 bit.
     */
    inline bool get_ENABLED1_clk_peri_uart0() volatile
    {
        return ENABLED1 & (1u << 6u);
    }

    /**
     * Get ENABLED1's clk_sys_uart0 bit.
     */
    inline bool get_ENABLED1_clk_sys_uart0() volatile
    {
        return ENABLED1 & (1u << 7u);
    }

    /**
     * Get ENABLED1's clk_peri_uart1 bit.
     */
    inline bool get_ENABLED1_clk_peri_uart1() volatile
    {
        return ENABLED1 & (1u << 8u);
    }

    /**
     * Get ENABLED1's clk_sys_uart1 bit.
     */
    inline bool get_ENABLED1_clk_sys_uart1() volatile
    {
        return ENABLED1 & (1u << 9u);
    }

    /**
     * Get ENABLED1's clk_sys_usbctrl bit.
     */
    inline bool get_ENABLED1_clk_sys_usbctrl() volatile
    {
        return ENABLED1 & (1u << 10u);
    }

    /**
     * Get ENABLED1's clk_usb_usbctrl bit.
     */
    inline bool get_ENABLED1_clk_usb_usbctrl() volatile
    {
        return ENABLED1 & (1u << 11u);
    }

    /**
     * Get ENABLED1's clk_sys_watchdog bit.
     */
    inline bool get_ENABLED1_clk_sys_watchdog() volatile
    {
        return ENABLED1 & (1u << 12u);
    }

    /**
     * Get ENABLED1's clk_sys_xip bit.
     */
    inline bool get_ENABLED1_clk_sys_xip() volatile
    {
        return ENABLED1 & (1u << 13u);
    }

    /**
     * Get ENABLED1's clk_sys_xosc bit.
     */
    inline bool get_ENABLED1_clk_sys_xosc() volatile
    {
        return ENABLED1 & (1u << 14u);
    }

    /**
     * Get all of ENABLED1's bit fields.
     *
     * (read-only) indicates the state of the clock enable
     */
    inline void get_ENABLED1(bool &clk_sys_sram4, bool &clk_sys_sram5,
                             bool &clk_sys_syscfg, bool &clk_sys_sysinfo,
                             bool &clk_sys_tbman, bool &clk_sys_timer,
                             bool &clk_peri_uart0, bool &clk_sys_uart0,
                             bool &clk_peri_uart1, bool &clk_sys_uart1,
                             bool &clk_sys_usbctrl, bool &clk_usb_usbctrl,
                             bool &clk_sys_watchdog, bool &clk_sys_xip,
                             bool &clk_sys_xosc) volatile
    {
        uint32_t curr = ENABLED1;

        clk_sys_sram4 = curr & (1u << 0u);
        clk_sys_sram5 = curr & (1u << 1u);
        clk_sys_syscfg = curr & (1u << 2u);
        clk_sys_sysinfo = curr & (1u << 3u);
        clk_sys_tbman = curr & (1u << 4u);
        clk_sys_timer = curr & (1u << 5u);
        clk_peri_uart0 = curr & (1u << 6u);
        clk_sys_uart0 = curr & (1u << 7u);
        clk_peri_uart1 = curr & (1u << 8u);
        clk_sys_uart1 = curr & (1u << 9u);
        clk_sys_usbctrl = curr & (1u << 10u);
        clk_usb_usbctrl = curr & (1u << 11u);
        clk_sys_watchdog = curr & (1u << 12u);
        clk_sys_xip = curr & (1u << 13u);
        clk_sys_xosc = curr & (1u << 14u);
    }

    /**
     * Get INTR's CLK_SYS_RESUS bit.
     */
    inline bool get_INTR_CLK_SYS_RESUS() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Get INTE's CLK_SYS_RESUS bit.
     */
    inline bool get_INTE_CLK_SYS_RESUS() volatile
    {
        return INTE & (1u << 0u);
    }

    /**
     * Set INTE's CLK_SYS_RESUS bit.
     */
    inline void set_INTE_CLK_SYS_RESUS() volatile
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's CLK_SYS_RESUS bit.
     */
    inline void clear_INTE_CLK_SYS_RESUS() volatile
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's CLK_SYS_RESUS bit.
     */
    inline void toggle_INTE_CLK_SYS_RESUS() volatile
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get INTF's CLK_SYS_RESUS bit.
     */
    inline bool get_INTF_CLK_SYS_RESUS() volatile
    {
        return INTF & (1u << 0u);
    }

    /**
     * Set INTF's CLK_SYS_RESUS bit.
     */
    inline void set_INTF_CLK_SYS_RESUS() volatile
    {
        INTF |= 1u << 0u;
    }

    /**
     * Clear INTF's CLK_SYS_RESUS bit.
     */
    inline void clear_INTF_CLK_SYS_RESUS() volatile
    {
        INTF &= ~(1u << 0u);
    }

    /**
     * Toggle INTF's CLK_SYS_RESUS bit.
     */
    inline void toggle_INTF_CLK_SYS_RESUS() volatile
    {
        INTF ^= 1u << 0u;
    }

    /**
     * Get INTS's CLK_SYS_RESUS bit.
     */
    inline bool get_INTS_CLK_SYS_RESUS() volatile
    {
        return INTS & (1u << 0u);
    }
};

static_assert(sizeof(clocks) == clocks::size);

static volatile clocks *const CLOCKS = reinterpret_cast<clocks *>(0x40008000);

}; // namespace RP2040
