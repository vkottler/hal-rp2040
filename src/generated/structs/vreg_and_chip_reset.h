/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

/**
 * control and status for on-chip voltage regulator and chip level reset
 * subsystem
 */
struct [[gnu::packed]] vreg_and_chip_reset
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        12; /*!< vreg_and_chip_reset's size in bytes. */

    /* Fields. */
    uint32_t VREG; /*!< (read-write) Voltage regulator control and status */
    uint32_t BOD;  /*!< (read-write) brown-out detection control */
    uint32_t CHIP_RESET; /*!< (read-write) Chip reset control and status */

    /* Methods. */

    /**
     * Get VREG's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline bool get_VREG_EN() volatile
    {
        return VREG & (1u << 0u);
    }

    /**
     * Set VREG's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline void set_VREG_EN() volatile
    {
        VREG |= 1u << 0u;
    }

    /**
     * Clear VREG's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline void clear_VREG_EN() volatile
    {
        VREG &= ~(1u << 0u);
    }

    /**
     * Toggle VREG's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline void toggle_VREG_EN() volatile
    {
        VREG ^= 1u << 0u;
    }

    /**
     * Get VREG's HIZ bit.
     *
     * high impedance mode select\n
     *                 0=not in high impedance mode, 1=in high impedance mode
     */
    inline bool get_VREG_HIZ() volatile
    {
        return VREG & (1u << 1u);
    }

    /**
     * Set VREG's HIZ bit.
     *
     * high impedance mode select\n
     *                 0=not in high impedance mode, 1=in high impedance mode
     */
    inline void set_VREG_HIZ() volatile
    {
        VREG |= 1u << 1u;
    }

    /**
     * Clear VREG's HIZ bit.
     *
     * high impedance mode select\n
     *                 0=not in high impedance mode, 1=in high impedance mode
     */
    inline void clear_VREG_HIZ() volatile
    {
        VREG &= ~(1u << 1u);
    }

    /**
     * Toggle VREG's HIZ bit.
     *
     * high impedance mode select\n
     *                 0=not in high impedance mode, 1=in high impedance mode
     */
    inline void toggle_VREG_HIZ() volatile
    {
        VREG ^= 1u << 1u;
    }

    /**
     * Get VREG's VSEL field.
     *
     * output voltage select\n
     *                 0000 to 0101 - 0.80V\n
     *                 0110         - 0.85V\n
     *                 0111         - 0.90V\n
     *                 1000         - 0.95V\n
     *                 1001         - 1.00V\n
     *                 1010         - 1.05V\n
     *                 1011         - 1.10V (default)\n
     *                 1100         - 1.15V\n
     *                 1101         - 1.20V\n
     *                 1110         - 1.25V\n
     *                 1111         - 1.30V
     */
    inline uint8_t get_VREG_VSEL() volatile
    {
        return (VREG >> 4u) & 0b1111u;
    }

    /**
     * Set VREG's VSEL field.
     *
     * output voltage select\n
     *                 0000 to 0101 - 0.80V\n
     *                 0110         - 0.85V\n
     *                 0111         - 0.90V\n
     *                 1000         - 0.95V\n
     *                 1001         - 1.00V\n
     *                 1010         - 1.05V\n
     *                 1011         - 1.10V (default)\n
     *                 1100         - 1.15V\n
     *                 1101         - 1.20V\n
     *                 1110         - 1.25V\n
     *                 1111         - 1.30V
     */
    inline void set_VREG_VSEL(uint8_t value) volatile
    {
        uint32_t curr = VREG;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        VREG = curr;
    }

    /**
     * Get VREG's ROK bit.
     *
     * regulation status\n
     *                 0=not in regulation, 1=in regulation
     */
    inline bool get_VREG_ROK() volatile
    {
        return VREG & (1u << 12u);
    }

    /**
     * Get all of VREG's bit fields.
     *
     * (read-write) Voltage regulator control and status
     */
    inline void get_VREG(bool &EN, bool &HIZ, uint8_t &VSEL,
                         bool &ROK) volatile
    {
        uint32_t curr = VREG;

        EN = curr & (1u << 0u);
        HIZ = curr & (1u << 1u);
        VSEL = (curr >> 4u) & 0b1111u;
        ROK = curr & (1u << 12u);
    }

    /**
     * Set all of VREG's bit fields.
     *
     * (read-write) Voltage regulator control and status
     */
    inline void set_VREG(bool EN, bool HIZ, uint8_t VSEL) volatile
    {
        uint32_t curr = VREG;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HIZ & 0b1u) << 1u;
        curr &= ~(0b1111u << 4u);
        curr |= (VSEL & 0b1111u) << 4u;

        VREG = curr;
    }

    /**
     * Get BOD's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline bool get_BOD_EN() volatile
    {
        return BOD & (1u << 0u);
    }

    /**
     * Set BOD's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline void set_BOD_EN() volatile
    {
        BOD |= 1u << 0u;
    }

    /**
     * Clear BOD's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline void clear_BOD_EN() volatile
    {
        BOD &= ~(1u << 0u);
    }

    /**
     * Toggle BOD's EN bit.
     *
     * enable\n
     *                 0=not enabled, 1=enabled
     */
    inline void toggle_BOD_EN() volatile
    {
        BOD ^= 1u << 0u;
    }

    /**
     * Get BOD's VSEL field.
     *
     * threshold select\n
     *                 0000 - 0.473V\n
     *                 0001 - 0.516V\n
     *                 0010 - 0.559V\n
     *                 0011 - 0.602V\n
     *                 0100 - 0.645V\n
     *                 0101 - 0.688V\n
     *                 0110 - 0.731V\n
     *                 0111 - 0.774V\n
     *                 1000 - 0.817V\n
     *                 1001 - 0.860V (default)\n
     *                 1010 - 0.903V\n
     *                 1011 - 0.946V\n
     *                 1100 - 0.989V\n
     *                 1101 - 1.032V\n
     *                 1110 - 1.075V\n
     *                 1111 - 1.118V
     */
    inline uint8_t get_BOD_VSEL() volatile
    {
        return (BOD >> 4u) & 0b1111u;
    }

    /**
     * Set BOD's VSEL field.
     *
     * threshold select\n
     *                 0000 - 0.473V\n
     *                 0001 - 0.516V\n
     *                 0010 - 0.559V\n
     *                 0011 - 0.602V\n
     *                 0100 - 0.645V\n
     *                 0101 - 0.688V\n
     *                 0110 - 0.731V\n
     *                 0111 - 0.774V\n
     *                 1000 - 0.817V\n
     *                 1001 - 0.860V (default)\n
     *                 1010 - 0.903V\n
     *                 1011 - 0.946V\n
     *                 1100 - 0.989V\n
     *                 1101 - 1.032V\n
     *                 1110 - 1.075V\n
     *                 1111 - 1.118V
     */
    inline void set_BOD_VSEL(uint8_t value) volatile
    {
        uint32_t curr = BOD;

        curr &= ~(0b1111u << 4u);
        curr |= (value & 0b1111u) << 4u;

        BOD = curr;
    }

    /**
     * Get all of BOD's bit fields.
     *
     * (read-write) brown-out detection control
     */
    inline void get_BOD(bool &EN, uint8_t &VSEL) volatile
    {
        uint32_t curr = BOD;

        EN = curr & (1u << 0u);
        VSEL = (curr >> 4u) & 0b1111u;
    }

    /**
     * Set all of BOD's bit fields.
     *
     * (read-write) brown-out detection control
     */
    inline void set_BOD(bool EN, uint8_t VSEL) volatile
    {
        uint32_t curr = BOD;

        curr &= ~(0b1u << 0u);
        curr |= (EN & 0b1u) << 0u;
        curr &= ~(0b1111u << 4u);
        curr |= (VSEL & 0b1111u) << 4u;

        BOD = curr;
    }

    /**
     * Get CHIP_RESET's HAD_POR bit.
     *
     * Last reset was from the power-on reset or brown-out detection blocks
     */
    inline bool get_CHIP_RESET_HAD_POR() volatile
    {
        return CHIP_RESET & (1u << 8u);
    }

    /**
     * Get CHIP_RESET's HAD_RUN bit.
     *
     * Last reset was from the RUN pin
     */
    inline bool get_CHIP_RESET_HAD_RUN() volatile
    {
        return CHIP_RESET & (1u << 16u);
    }

    /**
     * Get CHIP_RESET's HAD_PSM_RESTART bit.
     *
     * Last reset was from the debug port
     */
    inline bool get_CHIP_RESET_HAD_PSM_RESTART() volatile
    {
        return CHIP_RESET & (1u << 20u);
    }

    /**
     * Get CHIP_RESET's PSM_RESTART_FLAG bit.
     *
     * This is set by psm_restart from the debugger.\n
     *                 Its purpose is to branch bootcode to a safe mode when
     * the debugger has issued a psm_restart in order to recover from a boot
     * lock-up.\n In the safe mode the debugger can repair the boot code, clear
     * this flag then reboot the processor.
     */
    inline bool get_CHIP_RESET_PSM_RESTART_FLAG() volatile
    {
        return CHIP_RESET & (1u << 24u);
    }

    /**
     * Set CHIP_RESET's PSM_RESTART_FLAG bit.
     *
     * This is set by psm_restart from the debugger.\n
     *                 Its purpose is to branch bootcode to a safe mode when
     * the debugger has issued a psm_restart in order to recover from a boot
     * lock-up.\n In the safe mode the debugger can repair the boot code, clear
     * this flag then reboot the processor.
     */
    inline void set_CHIP_RESET_PSM_RESTART_FLAG() volatile
    {
        CHIP_RESET |= 1u << 24u;
    }

    /**
     * Clear CHIP_RESET's PSM_RESTART_FLAG bit.
     *
     * This is set by psm_restart from the debugger.\n
     *                 Its purpose is to branch bootcode to a safe mode when
     * the debugger has issued a psm_restart in order to recover from a boot
     * lock-up.\n In the safe mode the debugger can repair the boot code, clear
     * this flag then reboot the processor.
     */
    inline void clear_CHIP_RESET_PSM_RESTART_FLAG() volatile
    {
        CHIP_RESET &= ~(1u << 24u);
    }

    /**
     * Toggle CHIP_RESET's PSM_RESTART_FLAG bit.
     *
     * This is set by psm_restart from the debugger.\n
     *                 Its purpose is to branch bootcode to a safe mode when
     * the debugger has issued a psm_restart in order to recover from a boot
     * lock-up.\n In the safe mode the debugger can repair the boot code, clear
     * this flag then reboot the processor.
     */
    inline void toggle_CHIP_RESET_PSM_RESTART_FLAG() volatile
    {
        CHIP_RESET ^= 1u << 24u;
    }

    /**
     * Get all of CHIP_RESET's bit fields.
     *
     * (read-write) Chip reset control and status
     */
    inline void get_CHIP_RESET(bool &HAD_POR, bool &HAD_RUN,
                               bool &HAD_PSM_RESTART,
                               bool &PSM_RESTART_FLAG) volatile
    {
        uint32_t curr = CHIP_RESET;

        HAD_POR = curr & (1u << 8u);
        HAD_RUN = curr & (1u << 16u);
        HAD_PSM_RESTART = curr & (1u << 20u);
        PSM_RESTART_FLAG = curr & (1u << 24u);
    }
};

static_assert(sizeof(vreg_and_chip_reset) == vreg_and_chip_reset::size);

static volatile vreg_and_chip_reset *const VREG_AND_CHIP_RESET =
    reinterpret_cast<vreg_and_chip_reset *>(0x40064000);

}; // namespace RP2040
