/**
 * \file
 * \brief Generated by ifgen (2.6.3).
 */
#pragma once

#include "../enums/XOSC_CTRL_ENABLE.h"
#include "../enums/XOSC_CTRL_FREQ_RANGE.h"
#include "../enums/XOSC_STATUS_FREQ_RANGE.h"
#include "../ifgen/common.h"

namespace RP2040
{

/**
 * Controls the crystal oscillator
 */
struct [[gnu::packed]] xosc
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;       /*!< xosc's identifier. */
    static constexpr std::size_t size = 32; /*!< xosc's size in bytes. */

    /* Fields. */
    uint32_t CTRL;    /*!< (read-write) Crystal Oscillator Control */
    uint32_t STATUS;  /*!< (read-write) Crystal Oscillator Status */
    uint32_t DORMANT; /*!< (read-write) Crystal Oscillator pause control\n
This is used to save power by pausing the XOSC\n
On power-up this field is initialised to WAKE\n
An invalid write will also select WAKE\n
WARNING: stop the PLLs before selecting dormant mode\n
WARNING: setup the irq before selecting dormant mode */
    uint32_t STARTUP; /*!< (read-write) Controls the startup delay */
    static constexpr std::size_t reserved_padding0_length = 3;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t COUNT; /*!< (read-write) A down counter running at the xosc
frequency which counts to zero and stops.\n To start the counter write a
non-zero value.\n Can be used for short software pauses when setting up time
sensitive hardware. */

    /* Methods. */

    /**
     * Get CTRL's FREQ_RANGE field.
     */
    XOSC_CTRL_FREQ_RANGE get_CTRL_FREQ_RANGE()
    {
        return XOSC_CTRL_FREQ_RANGE((CTRL >> 0u) & 0b111111111111u);
    }

    /**
     * Set CTRL's FREQ_RANGE field.
     */
    inline void set_CTRL_FREQ_RANGE(XOSC_CTRL_FREQ_RANGE value)
    {
        uint32_t curr = CTRL;

        curr &= ~(0b111111111111u << 0u);
        curr |= (std::to_underlying(value) & 0b111111111111u) << 0u;

        CTRL = curr;
    }

    /**
     * Get CTRL's ENABLE field.
     */
    XOSC_CTRL_ENABLE get_CTRL_ENABLE()
    {
        return XOSC_CTRL_ENABLE((CTRL >> 12u) & 0b111111111111u);
    }

    /**
     * Set CTRL's ENABLE field.
     */
    inline void set_CTRL_ENABLE(XOSC_CTRL_ENABLE value)
    {
        uint32_t curr = CTRL;

        curr &= ~(0b111111111111u << 12u);
        curr |= (std::to_underlying(value) & 0b111111111111u) << 12u;

        CTRL = curr;
    }

    /**
     * Get STATUS's FREQ_RANGE field.
     */
    XOSC_STATUS_FREQ_RANGE get_STATUS_FREQ_RANGE()
    {
        return XOSC_STATUS_FREQ_RANGE((STATUS >> 0u) & 0b11u);
    }

    /**
     * Get STATUS's ENABLED bit.
     */
    bool get_STATUS_ENABLED()
    {
        return STATUS & (1u << 12u);
    }

    /**
     * Get STATUS's BADWRITE bit.
     */
    bool get_STATUS_BADWRITE()
    {
        return STATUS & (1u << 24u);
    }

    /**
     * Set STATUS's BADWRITE bit.
     */
    inline void set_STATUS_BADWRITE()
    {
        STATUS |= 1u << 24u;
    }

    /**
     * Clear STATUS's BADWRITE bit.
     */
    inline void clear_STATUS_BADWRITE()
    {
        STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle STATUS's BADWRITE bit.
     */
    inline void toggle_STATUS_BADWRITE()
    {
        STATUS ^= 1u << 24u;
    }

    /**
     * Get STATUS's STABLE bit.
     */
    bool get_STATUS_STABLE()
    {
        return STATUS & (1u << 31u);
    }

    /**
     * Get STARTUP's DELAY field.
     */
    uint16_t get_STARTUP_DELAY()
    {
        return (STARTUP >> 0u) & 0b11111111111111u;
    }

    /**
     * Set STARTUP's DELAY field.
     */
    inline void set_STARTUP_DELAY(uint16_t value)
    {
        uint32_t curr = STARTUP;

        curr &= ~(0b11111111111111u << 0u);
        curr |= (value & 0b11111111111111u) << 0u;

        STARTUP = curr;
    }

    /**
     * Get STARTUP's X4 bit.
     */
    bool get_STARTUP_X4()
    {
        return STARTUP & (1u << 20u);
    }

    /**
     * Set STARTUP's X4 bit.
     */
    inline void set_STARTUP_X4()
    {
        STARTUP |= 1u << 20u;
    }

    /**
     * Clear STARTUP's X4 bit.
     */
    inline void clear_STARTUP_X4()
    {
        STARTUP &= ~(1u << 20u);
    }

    /**
     * Toggle STARTUP's X4 bit.
     */
    inline void toggle_STARTUP_X4()
    {
        STARTUP ^= 1u << 20u;
    }

    /**
     * Get COUNT's COUNT field.
     */
    uint8_t get_COUNT_COUNT()
    {
        return (COUNT >> 0u) & 0b11111111u;
    }

    /**
     * Set COUNT's COUNT field.
     */
    inline void set_COUNT_COUNT(uint8_t value)
    {
        uint32_t curr = COUNT;

        curr &= ~(0b11111111u << 0u);
        curr |= (value & 0b11111111u) << 0u;

        COUNT = curr;
    }
};

static_assert(sizeof(xosc) == xosc::size);

static volatile xosc *const XOSC = reinterpret_cast<xosc *>(0x40024000);

}; // namespace RP2040
