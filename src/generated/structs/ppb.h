/**
 * \file
 * \brief Generated by ifgen (2.6.3).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] ppb
{
    /* Constant attributes. */
    static constexpr uint16_t id = 1;          /*!< ppb's identifier. */
    static constexpr std::size_t size = 60836; /*!< ppb's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 14340;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t SYST_CSR;                                               /*!< (read-write) Use the SysTick Control and Status Register to enable the SysTick features. */
    uint32_t SYST_RVR;                                               /*!< (read-write) Use the SysTick Reload Value Register to specify the start value to load into the current value register when the counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG are activated when counting from 1 to 0. The reset value of this register is UNKNOWN.\n
                To generate a multi-shot timer with a period of N processor clock cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is required every 100 clock pulses, set RELOAD to 99. */
    uint32_t SYST_CVR;                                               /*!< (read-write) Use the SysTick Current Value Register to find the current value in the register. The reset value of this register is UNKNOWN. */
    const uint32_t SYST_CALIB = {};                                  /*!< (read-only) Use the SysTick Calibration Value Register to enable software to scale to any required speed using divide and multiply. */
    static constexpr std::size_t reserved_padding1_length = 56;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t NVIC_ISER;                                              /*!< (read-write) Use the Interrupt Set-Enable Register to enable interrupts and determine which interrupts are currently enabled.\n
                If a pending interrupt is enabled, the NVIC activates the interrupt based on its priority. If an interrupt is not enabled, asserting its interrupt signal changes the interrupt state to pending, but the NVIC never activates the interrupt, regardless of its priority. */
    static constexpr std::size_t reserved_padding2_length = 31;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t NVIC_ICER;                                              /*!< (read-write) Use the Interrupt Clear-Enable Registers to disable interrupts and determine which interrupts are currently enabled. */
    static constexpr std::size_t reserved_padding3_length = 31;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t NVIC_ISPR;                                              /*!< (read-write) The NVIC_ISPR forces interrupts into the pending state, and shows which interrupts are pending. */
    static constexpr std::size_t reserved_padding4_length = 31;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t NVIC_ICPR;                                              /*!< (read-write) Use the Interrupt Clear-Pending Register to clear pending interrupts and determine which interrupts are currently pending. */
    static constexpr std::size_t reserved_padding5_length = 95;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t NVIC_IPR0;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest.\n
                Note: Writing 1 to an NVIC_ICPR bit does not affect the active state of the corresponding interrupt.\n
                These registers are only word-accessible */
    uint32_t NVIC_IPR1;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    uint32_t NVIC_IPR2;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    uint32_t NVIC_IPR3;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    uint32_t NVIC_IPR4;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    uint32_t NVIC_IPR5;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    uint32_t NVIC_IPR6;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    uint32_t NVIC_IPR7;                                              /*!< (read-write) Use the Interrupt Priority Registers to assign a priority from 0 to 3 to each of the available interrupts. 0 is the highest priority, and 3 is the lowest. */
    static constexpr std::size_t reserved_padding6_length = 568;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    const uint32_t CPUID = {};                                       /*!< (read-only) Read the CPU ID Base Register to determine: the ID number of the processor core, the version number of the processor core, the implementation details of the processor core. */
    uint32_t ICSR;                                                   /*!< (read-write) Use the Interrupt Control State Register to set a pending Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or clear a pending SysTick, check for pending exceptions, check the vector number of the highest priority pended exception, check the vector number of the active exception. */
    uint32_t VTOR;                                                   /*!< (read-write) The VTOR holds the vector table offset address. */
    uint32_t AIRCR;                                                  /*!< (read-write) Use the Application Interrupt and Reset Control Register to: determine data endianness, clear all active state information from debug halt mode, request a system reset. */
    uint32_t SCR;                                                    /*!< (read-write) System Control Register. Use the System Control Register for power-management functions: signal to the system when the processor can enter a low power state, control how the processor enters and exits low power states. */
    const uint32_t CCR = {};                                         /*!< (read-only) The Configuration and Control Register permanently enables stack alignment and causes unaligned accesses to result in a Hard Fault. */
    const uint32_t reserved_padding7 = {};
    uint32_t SHPR2;                                                  /*!< (read-write) System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 2 to set the priority of SVCall. */
    uint32_t SHPR3;                                                  /*!< (read-write) System handlers are a special class of exception handler that can have their priority set to any of the priority levels. Use the System Handler Priority Register 3 to set the priority of PendSV and SysTick. */
    uint32_t SHCSR;                                                  /*!< (read-write) Use the System Handler Control and State Register to determine or clear the pending status of SVCall. */
    static constexpr std::size_t reserved_padding8_length = 26;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    const uint32_t MPU_TYPE = {};                                    /*!< (read-only) Read the MPU Type Register to determine if the processor implements an MPU, and how many regions the MPU supports. */
    uint32_t MPU_CTRL;                                               /*!< (read-write) Use the MPU Control Register to enable and disable the MPU, and to control whether the default memory map is enabled as a background region for privileged accesses, and whether the MPU is enabled for HardFaults and NMIs. */
    uint32_t MPU_RNR;                                                /*!< (read-write) Use the MPU Region Number Register to select the region currently accessed by MPU_RBAR and MPU_RASR. */
    uint32_t MPU_RBAR;                                               /*!< (read-write) Read the MPU Region Base Address Register to determine the base address of the region identified by MPU_RNR. Write to update the base address of said region or that of a specified region, with whose number MPU_RNR will also be updated. */
    uint32_t MPU_RASR;                                               /*!< (read-write) Use the MPU Region Attribute and Size Register to define the size, access behaviour and memory type of the region identified by MPU_RNR, and enable that region. */

    /* Methods. */

    /**
     * Get SYST_CSR's ENABLE bit.
     */
    bool get_SYST_CSR_ENABLE()
    {
        return SYST_CSR & (1u << 0u);
    }

    /**
     * Set SYST_CSR's ENABLE bit.
     */
    inline void set_SYST_CSR_ENABLE()
    {
        SYST_CSR |= 1u << 0u;
    }

    /**
     * Clear SYST_CSR's ENABLE bit.
     */
    inline void clear_SYST_CSR_ENABLE()
    {
        SYST_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle SYST_CSR's ENABLE bit.
     */
    inline void toggle_SYST_CSR_ENABLE()
    {
        SYST_CSR ^= 1u << 0u;
    }

    /**
     * Get SYST_CSR's TICKINT bit.
     */
    bool get_SYST_CSR_TICKINT()
    {
        return SYST_CSR & (1u << 1u);
    }

    /**
     * Set SYST_CSR's TICKINT bit.
     */
    inline void set_SYST_CSR_TICKINT()
    {
        SYST_CSR |= 1u << 1u;
    }

    /**
     * Clear SYST_CSR's TICKINT bit.
     */
    inline void clear_SYST_CSR_TICKINT()
    {
        SYST_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle SYST_CSR's TICKINT bit.
     */
    inline void toggle_SYST_CSR_TICKINT()
    {
        SYST_CSR ^= 1u << 1u;
    }

    /**
     * Get SYST_CSR's CLKSOURCE bit.
     */
    bool get_SYST_CSR_CLKSOURCE()
    {
        return SYST_CSR & (1u << 2u);
    }

    /**
     * Set SYST_CSR's CLKSOURCE bit.
     */
    inline void set_SYST_CSR_CLKSOURCE()
    {
        SYST_CSR |= 1u << 2u;
    }

    /**
     * Clear SYST_CSR's CLKSOURCE bit.
     */
    inline void clear_SYST_CSR_CLKSOURCE()
    {
        SYST_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle SYST_CSR's CLKSOURCE bit.
     */
    inline void toggle_SYST_CSR_CLKSOURCE()
    {
        SYST_CSR ^= 1u << 2u;
    }

    /**
     * Get SYST_CSR's COUNTFLAG bit.
     */
    bool get_SYST_CSR_COUNTFLAG()
    {
        return SYST_CSR & (1u << 16u);
    }

    /**
     * Get SYST_RVR's RELOAD field.
     */
    uint32_t get_SYST_RVR_RELOAD()
    {
        return (SYST_RVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_RVR's RELOAD field.
     */
    inline void set_SYST_RVR_RELOAD(uint32_t value)
    {
        uint32_t curr = SYST_RVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_RVR = curr;
    }

    /**
     * Get SYST_CVR's CURRENT field.
     */
    uint32_t get_SYST_CVR_CURRENT()
    {
        return (SYST_CVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_CVR's CURRENT field.
     */
    inline void set_SYST_CVR_CURRENT(uint32_t value)
    {
        uint32_t curr = SYST_CVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_CVR = curr;
    }

    /**
     * Get SYST_CALIB's TENMS field.
     */
    uint32_t get_SYST_CALIB_TENMS()
    {
        return (SYST_CALIB >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get SYST_CALIB's SKEW bit.
     */
    bool get_SYST_CALIB_SKEW()
    {
        return SYST_CALIB & (1u << 30u);
    }

    /**
     * Get SYST_CALIB's NOREF bit.
     */
    bool get_SYST_CALIB_NOREF()
    {
        return SYST_CALIB & (1u << 31u);
    }

    /**
     * Get NVIC_ISER's SETENA field.
     */
    uint32_t get_NVIC_ISER_SETENA()
    {
        return (NVIC_ISER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ISER's SETENA field.
     */
    inline void set_NVIC_ISER_SETENA(uint32_t value)
    {
        uint32_t curr = NVIC_ISER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ISER = curr;
    }

    /**
     * Get NVIC_ICER's CLRENA field.
     */
    uint32_t get_NVIC_ICER_CLRENA()
    {
        return (NVIC_ICER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ICER's CLRENA field.
     */
    inline void set_NVIC_ICER_CLRENA(uint32_t value)
    {
        uint32_t curr = NVIC_ICER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ICER = curr;
    }

    /**
     * Get NVIC_ISPR's SETPEND field.
     */
    uint32_t get_NVIC_ISPR_SETPEND()
    {
        return (NVIC_ISPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ISPR's SETPEND field.
     */
    inline void set_NVIC_ISPR_SETPEND(uint32_t value)
    {
        uint32_t curr = NVIC_ISPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ISPR = curr;
    }

    /**
     * Get NVIC_ICPR's CLRPEND field.
     */
    uint32_t get_NVIC_ICPR_CLRPEND()
    {
        return (NVIC_ICPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ICPR's CLRPEND field.
     */
    inline void set_NVIC_ICPR_CLRPEND(uint32_t value)
    {
        uint32_t curr = NVIC_ICPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ICPR = curr;
    }

    /**
     * Get NVIC_IPR0's IP_0 field.
     */
    uint8_t get_NVIC_IPR0_IP_0()
    {
        return (NVIC_IPR0 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_0 field.
     */
    inline void set_NVIC_IPR0_IP_0(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_1 field.
     */
    uint8_t get_NVIC_IPR0_IP_1()
    {
        return (NVIC_IPR0 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_1 field.
     */
    inline void set_NVIC_IPR0_IP_1(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_2 field.
     */
    uint8_t get_NVIC_IPR0_IP_2()
    {
        return (NVIC_IPR0 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_2 field.
     */
    inline void set_NVIC_IPR0_IP_2(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_3 field.
     */
    uint8_t get_NVIC_IPR0_IP_3()
    {
        return (NVIC_IPR0 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_3 field.
     */
    inline void set_NVIC_IPR0_IP_3(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_4 field.
     */
    uint8_t get_NVIC_IPR1_IP_4()
    {
        return (NVIC_IPR1 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_4 field.
     */
    inline void set_NVIC_IPR1_IP_4(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_5 field.
     */
    uint8_t get_NVIC_IPR1_IP_5()
    {
        return (NVIC_IPR1 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_5 field.
     */
    inline void set_NVIC_IPR1_IP_5(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_6 field.
     */
    uint8_t get_NVIC_IPR1_IP_6()
    {
        return (NVIC_IPR1 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_6 field.
     */
    inline void set_NVIC_IPR1_IP_6(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_7 field.
     */
    uint8_t get_NVIC_IPR1_IP_7()
    {
        return (NVIC_IPR1 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_7 field.
     */
    inline void set_NVIC_IPR1_IP_7(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_8 field.
     */
    uint8_t get_NVIC_IPR2_IP_8()
    {
        return (NVIC_IPR2 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_8 field.
     */
    inline void set_NVIC_IPR2_IP_8(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_9 field.
     */
    uint8_t get_NVIC_IPR2_IP_9()
    {
        return (NVIC_IPR2 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_9 field.
     */
    inline void set_NVIC_IPR2_IP_9(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_10 field.
     */
    uint8_t get_NVIC_IPR2_IP_10()
    {
        return (NVIC_IPR2 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_10 field.
     */
    inline void set_NVIC_IPR2_IP_10(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_11 field.
     */
    uint8_t get_NVIC_IPR2_IP_11()
    {
        return (NVIC_IPR2 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_11 field.
     */
    inline void set_NVIC_IPR2_IP_11(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_12 field.
     */
    uint8_t get_NVIC_IPR3_IP_12()
    {
        return (NVIC_IPR3 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_12 field.
     */
    inline void set_NVIC_IPR3_IP_12(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_13 field.
     */
    uint8_t get_NVIC_IPR3_IP_13()
    {
        return (NVIC_IPR3 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_13 field.
     */
    inline void set_NVIC_IPR3_IP_13(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_14 field.
     */
    uint8_t get_NVIC_IPR3_IP_14()
    {
        return (NVIC_IPR3 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_14 field.
     */
    inline void set_NVIC_IPR3_IP_14(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_15 field.
     */
    uint8_t get_NVIC_IPR3_IP_15()
    {
        return (NVIC_IPR3 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_15 field.
     */
    inline void set_NVIC_IPR3_IP_15(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_16 field.
     */
    uint8_t get_NVIC_IPR4_IP_16()
    {
        return (NVIC_IPR4 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_16 field.
     */
    inline void set_NVIC_IPR4_IP_16(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_17 field.
     */
    uint8_t get_NVIC_IPR4_IP_17()
    {
        return (NVIC_IPR4 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_17 field.
     */
    inline void set_NVIC_IPR4_IP_17(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_18 field.
     */
    uint8_t get_NVIC_IPR4_IP_18()
    {
        return (NVIC_IPR4 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_18 field.
     */
    inline void set_NVIC_IPR4_IP_18(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_19 field.
     */
    uint8_t get_NVIC_IPR4_IP_19()
    {
        return (NVIC_IPR4 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_19 field.
     */
    inline void set_NVIC_IPR4_IP_19(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_20 field.
     */
    uint8_t get_NVIC_IPR5_IP_20()
    {
        return (NVIC_IPR5 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_20 field.
     */
    inline void set_NVIC_IPR5_IP_20(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_21 field.
     */
    uint8_t get_NVIC_IPR5_IP_21()
    {
        return (NVIC_IPR5 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_21 field.
     */
    inline void set_NVIC_IPR5_IP_21(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_22 field.
     */
    uint8_t get_NVIC_IPR5_IP_22()
    {
        return (NVIC_IPR5 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_22 field.
     */
    inline void set_NVIC_IPR5_IP_22(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_23 field.
     */
    uint8_t get_NVIC_IPR5_IP_23()
    {
        return (NVIC_IPR5 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_23 field.
     */
    inline void set_NVIC_IPR5_IP_23(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_24 field.
     */
    uint8_t get_NVIC_IPR6_IP_24()
    {
        return (NVIC_IPR6 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_24 field.
     */
    inline void set_NVIC_IPR6_IP_24(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_25 field.
     */
    uint8_t get_NVIC_IPR6_IP_25()
    {
        return (NVIC_IPR6 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_25 field.
     */
    inline void set_NVIC_IPR6_IP_25(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_26 field.
     */
    uint8_t get_NVIC_IPR6_IP_26()
    {
        return (NVIC_IPR6 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_26 field.
     */
    inline void set_NVIC_IPR6_IP_26(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_27 field.
     */
    uint8_t get_NVIC_IPR6_IP_27()
    {
        return (NVIC_IPR6 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_27 field.
     */
    inline void set_NVIC_IPR6_IP_27(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_28 field.
     */
    uint8_t get_NVIC_IPR7_IP_28()
    {
        return (NVIC_IPR7 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_28 field.
     */
    inline void set_NVIC_IPR7_IP_28(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_29 field.
     */
    uint8_t get_NVIC_IPR7_IP_29()
    {
        return (NVIC_IPR7 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_29 field.
     */
    inline void set_NVIC_IPR7_IP_29(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_30 field.
     */
    uint8_t get_NVIC_IPR7_IP_30()
    {
        return (NVIC_IPR7 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_30 field.
     */
    inline void set_NVIC_IPR7_IP_30(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_31 field.
     */
    uint8_t get_NVIC_IPR7_IP_31()
    {
        return (NVIC_IPR7 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_31 field.
     */
    inline void set_NVIC_IPR7_IP_31(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get CPUID's REVISION field.
     */
    uint8_t get_CPUID_REVISION()
    {
        return (CPUID >> 0u) & 0b1111u;
    }

    /**
     * Get CPUID's PARTNO field.
     */
    uint16_t get_CPUID_PARTNO()
    {
        return (CPUID >> 4u) & 0b111111111111u;
    }

    /**
     * Get CPUID's ARCHITECTURE field.
     */
    uint8_t get_CPUID_ARCHITECTURE()
    {
        return (CPUID >> 16u) & 0b1111u;
    }

    /**
     * Get CPUID's VARIANT field.
     */
    uint8_t get_CPUID_VARIANT()
    {
        return (CPUID >> 20u) & 0b1111u;
    }

    /**
     * Get CPUID's IMPLEMENTER field.
     */
    uint8_t get_CPUID_IMPLEMENTER()
    {
        return (CPUID >> 24u) & 0b11111111u;
    }

    /**
     * Get ICSR's VECTACTIVE field.
     */
    uint16_t get_ICSR_VECTACTIVE()
    {
        return (ICSR >> 0u) & 0b111111111u;
    }

    /**
     * Get ICSR's VECTPENDING field.
     */
    uint16_t get_ICSR_VECTPENDING()
    {
        return (ICSR >> 12u) & 0b111111111u;
    }

    /**
     * Get ICSR's ISRPENDING bit.
     */
    bool get_ICSR_ISRPENDING()
    {
        return ICSR & (1u << 22u);
    }

    /**
     * Get ICSR's ISRPREEMPT bit.
     */
    bool get_ICSR_ISRPREEMPT()
    {
        return ICSR & (1u << 23u);
    }

    /**
     * Get ICSR's PENDSTCLR bit.
     */
    bool get_ICSR_PENDSTCLR()
    {
        return ICSR & (1u << 25u);
    }

    /**
     * Set ICSR's PENDSTCLR bit.
     */
    inline void set_ICSR_PENDSTCLR()
    {
        ICSR |= 1u << 25u;
    }

    /**
     * Clear ICSR's PENDSTCLR bit.
     */
    inline void clear_ICSR_PENDSTCLR()
    {
        ICSR &= ~(1u << 25u);
    }

    /**
     * Toggle ICSR's PENDSTCLR bit.
     */
    inline void toggle_ICSR_PENDSTCLR()
    {
        ICSR ^= 1u << 25u;
    }

    /**
     * Get ICSR's PENDSTSET bit.
     */
    bool get_ICSR_PENDSTSET()
    {
        return ICSR & (1u << 26u);
    }

    /**
     * Set ICSR's PENDSTSET bit.
     */
    inline void set_ICSR_PENDSTSET()
    {
        ICSR |= 1u << 26u;
    }

    /**
     * Clear ICSR's PENDSTSET bit.
     */
    inline void clear_ICSR_PENDSTSET()
    {
        ICSR &= ~(1u << 26u);
    }

    /**
     * Toggle ICSR's PENDSTSET bit.
     */
    inline void toggle_ICSR_PENDSTSET()
    {
        ICSR ^= 1u << 26u;
    }

    /**
     * Get ICSR's PENDSVCLR bit.
     */
    bool get_ICSR_PENDSVCLR()
    {
        return ICSR & (1u << 27u);
    }

    /**
     * Set ICSR's PENDSVCLR bit.
     */
    inline void set_ICSR_PENDSVCLR()
    {
        ICSR |= 1u << 27u;
    }

    /**
     * Clear ICSR's PENDSVCLR bit.
     */
    inline void clear_ICSR_PENDSVCLR()
    {
        ICSR &= ~(1u << 27u);
    }

    /**
     * Toggle ICSR's PENDSVCLR bit.
     */
    inline void toggle_ICSR_PENDSVCLR()
    {
        ICSR ^= 1u << 27u;
    }

    /**
     * Get ICSR's PENDSVSET bit.
     */
    bool get_ICSR_PENDSVSET()
    {
        return ICSR & (1u << 28u);
    }

    /**
     * Set ICSR's PENDSVSET bit.
     */
    inline void set_ICSR_PENDSVSET()
    {
        ICSR |= 1u << 28u;
    }

    /**
     * Clear ICSR's PENDSVSET bit.
     */
    inline void clear_ICSR_PENDSVSET()
    {
        ICSR &= ~(1u << 28u);
    }

    /**
     * Toggle ICSR's PENDSVSET bit.
     */
    inline void toggle_ICSR_PENDSVSET()
    {
        ICSR ^= 1u << 28u;
    }

    /**
     * Get ICSR's NMIPENDSET bit.
     */
    bool get_ICSR_NMIPENDSET()
    {
        return ICSR & (1u << 31u);
    }

    /**
     * Set ICSR's NMIPENDSET bit.
     */
    inline void set_ICSR_NMIPENDSET()
    {
        ICSR |= 1u << 31u;
    }

    /**
     * Clear ICSR's NMIPENDSET bit.
     */
    inline void clear_ICSR_NMIPENDSET()
    {
        ICSR &= ~(1u << 31u);
    }

    /**
     * Toggle ICSR's NMIPENDSET bit.
     */
    inline void toggle_ICSR_NMIPENDSET()
    {
        ICSR ^= 1u << 31u;
    }

    /**
     * Get VTOR's TBLOFF field.
     */
    uint32_t get_VTOR_TBLOFF()
    {
        return (VTOR >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set VTOR's TBLOFF field.
     */
    inline void set_VTOR_TBLOFF(uint32_t value)
    {
        uint32_t curr = VTOR;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        VTOR = curr;
    }

    /**
     * Get AIRCR's VECTCLRACTIVE bit.
     */
    bool get_AIRCR_VECTCLRACTIVE()
    {
        return AIRCR & (1u << 1u);
    }

    /**
     * Set AIRCR's VECTCLRACTIVE bit.
     */
    inline void set_AIRCR_VECTCLRACTIVE()
    {
        AIRCR |= 1u << 1u;
    }

    /**
     * Clear AIRCR's VECTCLRACTIVE bit.
     */
    inline void clear_AIRCR_VECTCLRACTIVE()
    {
        AIRCR &= ~(1u << 1u);
    }

    /**
     * Toggle AIRCR's VECTCLRACTIVE bit.
     */
    inline void toggle_AIRCR_VECTCLRACTIVE()
    {
        AIRCR ^= 1u << 1u;
    }

    /**
     * Get AIRCR's SYSRESETREQ bit.
     */
    bool get_AIRCR_SYSRESETREQ()
    {
        return AIRCR & (1u << 2u);
    }

    /**
     * Set AIRCR's SYSRESETREQ bit.
     */
    inline void set_AIRCR_SYSRESETREQ()
    {
        AIRCR |= 1u << 2u;
    }

    /**
     * Clear AIRCR's SYSRESETREQ bit.
     */
    inline void clear_AIRCR_SYSRESETREQ()
    {
        AIRCR &= ~(1u << 2u);
    }

    /**
     * Toggle AIRCR's SYSRESETREQ bit.
     */
    inline void toggle_AIRCR_SYSRESETREQ()
    {
        AIRCR ^= 1u << 2u;
    }

    /**
     * Get AIRCR's ENDIANESS bit.
     */
    bool get_AIRCR_ENDIANESS()
    {
        return AIRCR & (1u << 15u);
    }

    /**
     * Get AIRCR's VECTKEY field.
     */
    uint16_t get_AIRCR_VECTKEY()
    {
        return (AIRCR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set AIRCR's VECTKEY field.
     */
    inline void set_AIRCR_VECTKEY(uint16_t value)
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get SCR's SLEEPONEXIT bit.
     */
    bool get_SCR_SLEEPONEXIT()
    {
        return SCR & (1u << 1u);
    }

    /**
     * Set SCR's SLEEPONEXIT bit.
     */
    inline void set_SCR_SLEEPONEXIT()
    {
        SCR |= 1u << 1u;
    }

    /**
     * Clear SCR's SLEEPONEXIT bit.
     */
    inline void clear_SCR_SLEEPONEXIT()
    {
        SCR &= ~(1u << 1u);
    }

    /**
     * Toggle SCR's SLEEPONEXIT bit.
     */
    inline void toggle_SCR_SLEEPONEXIT()
    {
        SCR ^= 1u << 1u;
    }

    /**
     * Get SCR's SLEEPDEEP bit.
     */
    bool get_SCR_SLEEPDEEP()
    {
        return SCR & (1u << 2u);
    }

    /**
     * Set SCR's SLEEPDEEP bit.
     */
    inline void set_SCR_SLEEPDEEP()
    {
        SCR |= 1u << 2u;
    }

    /**
     * Clear SCR's SLEEPDEEP bit.
     */
    inline void clear_SCR_SLEEPDEEP()
    {
        SCR &= ~(1u << 2u);
    }

    /**
     * Toggle SCR's SLEEPDEEP bit.
     */
    inline void toggle_SCR_SLEEPDEEP()
    {
        SCR ^= 1u << 2u;
    }

    /**
     * Get SCR's SEVONPEND bit.
     */
    bool get_SCR_SEVONPEND()
    {
        return SCR & (1u << 4u);
    }

    /**
     * Set SCR's SEVONPEND bit.
     */
    inline void set_SCR_SEVONPEND()
    {
        SCR |= 1u << 4u;
    }

    /**
     * Clear SCR's SEVONPEND bit.
     */
    inline void clear_SCR_SEVONPEND()
    {
        SCR &= ~(1u << 4u);
    }

    /**
     * Toggle SCR's SEVONPEND bit.
     */
    inline void toggle_SCR_SEVONPEND()
    {
        SCR ^= 1u << 4u;
    }

    /**
     * Get CCR's UNALIGN_TRP bit.
     */
    bool get_CCR_UNALIGN_TRP()
    {
        return CCR & (1u << 3u);
    }

    /**
     * Get CCR's STKALIGN bit.
     */
    bool get_CCR_STKALIGN()
    {
        return CCR & (1u << 9u);
    }

    /**
     * Get SHPR2's PRI_11 field.
     */
    uint8_t get_SHPR2_PRI_11()
    {
        return (SHPR2 >> 30u) & 0b11u;
    }

    /**
     * Set SHPR2's PRI_11 field.
     */
    inline void set_SHPR2_PRI_11(uint8_t value)
    {
        uint32_t curr = SHPR2;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        SHPR2 = curr;
    }

    /**
     * Get SHPR3's PRI_14 field.
     */
    uint8_t get_SHPR3_PRI_14()
    {
        return (SHPR3 >> 22u) & 0b11u;
    }

    /**
     * Set SHPR3's PRI_14 field.
     */
    inline void set_SHPR3_PRI_14(uint8_t value)
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        SHPR3 = curr;
    }

    /**
     * Get SHPR3's PRI_15 field.
     */
    uint8_t get_SHPR3_PRI_15()
    {
        return (SHPR3 >> 30u) & 0b11u;
    }

    /**
     * Set SHPR3's PRI_15 field.
     */
    inline void set_SHPR3_PRI_15(uint8_t value)
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        SHPR3 = curr;
    }

    /**
     * Get SHCSR's SVCALLPENDED bit.
     */
    bool get_SHCSR_SVCALLPENDED()
    {
        return SHCSR & (1u << 15u);
    }

    /**
     * Set SHCSR's SVCALLPENDED bit.
     */
    inline void set_SHCSR_SVCALLPENDED()
    {
        SHCSR |= 1u << 15u;
    }

    /**
     * Clear SHCSR's SVCALLPENDED bit.
     */
    inline void clear_SHCSR_SVCALLPENDED()
    {
        SHCSR &= ~(1u << 15u);
    }

    /**
     * Toggle SHCSR's SVCALLPENDED bit.
     */
    inline void toggle_SHCSR_SVCALLPENDED()
    {
        SHCSR ^= 1u << 15u;
    }

    /**
     * Get MPU_TYPE's SEPARATE bit.
     */
    bool get_MPU_TYPE_SEPARATE()
    {
        return MPU_TYPE & (1u << 0u);
    }

    /**
     * Get MPU_TYPE's DREGION field.
     */
    uint8_t get_MPU_TYPE_DREGION()
    {
        return (MPU_TYPE >> 8u) & 0b11111111u;
    }

    /**
     * Get MPU_TYPE's IREGION field.
     */
    uint8_t get_MPU_TYPE_IREGION()
    {
        return (MPU_TYPE >> 16u) & 0b11111111u;
    }

    /**
     * Get MPU_CTRL's ENABLE bit.
     */
    bool get_MPU_CTRL_ENABLE()
    {
        return MPU_CTRL & (1u << 0u);
    }

    /**
     * Set MPU_CTRL's ENABLE bit.
     */
    inline void set_MPU_CTRL_ENABLE()
    {
        MPU_CTRL |= 1u << 0u;
    }

    /**
     * Clear MPU_CTRL's ENABLE bit.
     */
    inline void clear_MPU_CTRL_ENABLE()
    {
        MPU_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_CTRL's ENABLE bit.
     */
    inline void toggle_MPU_CTRL_ENABLE()
    {
        MPU_CTRL ^= 1u << 0u;
    }

    /**
     * Get MPU_CTRL's HFNMIENA bit.
     */
    bool get_MPU_CTRL_HFNMIENA()
    {
        return MPU_CTRL & (1u << 1u);
    }

    /**
     * Set MPU_CTRL's HFNMIENA bit.
     */
    inline void set_MPU_CTRL_HFNMIENA()
    {
        MPU_CTRL |= 1u << 1u;
    }

    /**
     * Clear MPU_CTRL's HFNMIENA bit.
     */
    inline void clear_MPU_CTRL_HFNMIENA()
    {
        MPU_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MPU_CTRL's HFNMIENA bit.
     */
    inline void toggle_MPU_CTRL_HFNMIENA()
    {
        MPU_CTRL ^= 1u << 1u;
    }

    /**
     * Get MPU_CTRL's PRIVDEFENA bit.
     */
    bool get_MPU_CTRL_PRIVDEFENA()
    {
        return MPU_CTRL & (1u << 2u);
    }

    /**
     * Set MPU_CTRL's PRIVDEFENA bit.
     */
    inline void set_MPU_CTRL_PRIVDEFENA()
    {
        MPU_CTRL |= 1u << 2u;
    }

    /**
     * Clear MPU_CTRL's PRIVDEFENA bit.
     */
    inline void clear_MPU_CTRL_PRIVDEFENA()
    {
        MPU_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle MPU_CTRL's PRIVDEFENA bit.
     */
    inline void toggle_MPU_CTRL_PRIVDEFENA()
    {
        MPU_CTRL ^= 1u << 2u;
    }

    /**
     * Get MPU_RNR's REGION field.
     */
    uint8_t get_MPU_RNR_REGION()
    {
        return (MPU_RNR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RNR's REGION field.
     */
    inline void set_MPU_RNR_REGION(uint8_t value)
    {
        uint32_t curr = MPU_RNR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RNR = curr;
    }

    /**
     * Get MPU_RBAR's REGION field.
     */
    uint8_t get_MPU_RBAR_REGION()
    {
        return (MPU_RBAR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR's REGION field.
     */
    inline void set_MPU_RBAR_REGION(uint8_t value)
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RBAR's VALID bit.
     */
    bool get_MPU_RBAR_VALID()
    {
        return MPU_RBAR & (1u << 4u);
    }

    /**
     * Set MPU_RBAR's VALID bit.
     */
    inline void set_MPU_RBAR_VALID()
    {
        MPU_RBAR |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR's VALID bit.
     */
    inline void clear_MPU_RBAR_VALID()
    {
        MPU_RBAR &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR's VALID bit.
     */
    inline void toggle_MPU_RBAR_VALID()
    {
        MPU_RBAR ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR's ADDR field.
     */
    uint32_t get_MPU_RBAR_ADDR()
    {
        return (MPU_RBAR >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set MPU_RBAR's ADDR field.
     */
    inline void set_MPU_RBAR_ADDR(uint32_t value)
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RASR's ENABLE bit.
     */
    bool get_MPU_RASR_ENABLE()
    {
        return MPU_RASR & (1u << 0u);
    }

    /**
     * Set MPU_RASR's ENABLE bit.
     */
    inline void set_MPU_RASR_ENABLE()
    {
        MPU_RASR |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR's ENABLE bit.
     */
    inline void clear_MPU_RASR_ENABLE()
    {
        MPU_RASR &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR's ENABLE bit.
     */
    inline void toggle_MPU_RASR_ENABLE()
    {
        MPU_RASR ^= 1u << 0u;
    }

    /**
     * Get MPU_RASR's SIZE field.
     */
    uint8_t get_MPU_RASR_SIZE()
    {
        return (MPU_RASR >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR's SIZE field.
     */
    inline void set_MPU_RASR_SIZE(uint8_t value)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's SRD field.
     */
    uint8_t get_MPU_RASR_SRD()
    {
        return (MPU_RASR >> 8u) & 0b11111111u;
    }

    /**
     * Set MPU_RASR's SRD field.
     */
    inline void set_MPU_RASR_SRD(uint8_t value)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's ATTRS field.
     */
    uint16_t get_MPU_RASR_ATTRS()
    {
        return (MPU_RASR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MPU_RASR's ATTRS field.
     */
    inline void set_MPU_RASR_ATTRS(uint16_t value)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MPU_RASR = curr;
    }
};

static_assert(sizeof(ppb) == ppb::size);

static volatile ppb *const PPB = reinterpret_cast<ppb *>(0xe0000000);

}; // namespace RP2040
