/**
 * \file
 * \brief Generated by ifgen (3.2.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] ppb
{
    /* Constant attributes. */
    static constexpr std::size_t size = 60836; /*!< ppb's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 14340;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t SYST_CSR; /*!< (read-write) Use the SysTick Control and Status
                          Register to enable the SysTick features. */
    uint32_t SYST_RVR; /*!< (read-write) Use the SysTick Reload Value Register
to specify the start value to load into the current value register when the
counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value
of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG
are activated when counting from 1 to 0. The reset value of this register is
UNKNOWN.\n To generate a multi-shot timer with a period of N processor clock
cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is
required every 100 clock pulses, set RELOAD to 99. */
    uint32_t SYST_CVR; /*!< (read-write) Use the SysTick Current Value Register
                          to find the current value in the register. The reset
                          value of this register is UNKNOWN. */
    const uint32_t SYST_CALIB =
        {}; /*!< (read-only) Use the SysTick Calibration Value Register to
               enable software to scale to any required speed using divide and
               multiply. */
    static constexpr std::size_t reserved_padding1_length = 56;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t NVIC_ISER; /*!< (read-write) Use the Interrupt Set-Enable Register
to enable interrupts and determine which interrupts are currently enabled.\n If
a pending interrupt is enabled, the NVIC activates the interrupt based on its
priority. If an interrupt is not enabled, asserting its interrupt signal
changes the interrupt state to pending, but the NVIC never activates the
interrupt, regardless of its priority. */
    static constexpr std::size_t reserved_padding2_length = 31;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t NVIC_ICER; /*!< (read-write) Use the Interrupt Clear-Enable
                           Registers to disable interrupts and determine which
                           interrupts are currently enabled. */
    static constexpr std::size_t reserved_padding3_length = 31;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t
        NVIC_ISPR; /*!< (read-write) The NVIC_ISPR forces interrupts into the
                      pending state, and shows which interrupts are pending. */
    static constexpr std::size_t reserved_padding4_length = 31;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t NVIC_ICPR; /*!< (read-write) Use the Interrupt Clear-Pending
                           Register to clear pending interrupts and determine
                           which interrupts are currently pending. */
    static constexpr std::size_t reserved_padding5_length = 95;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t NVIC_IPR0; /*!< (read-write) Use the Interrupt Priority Registers
to assign a priority from 0 to 3 to each of the available interrupts. 0 is the
highest priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit
does not affect the active state of the corresponding interrupt.\n These
registers are only word-accessible */
    uint32_t NVIC_IPR1; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR2; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR3; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR4; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR5; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR6; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR7; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    static constexpr std::size_t reserved_padding6_length = 568;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    const uint32_t CPUID =
        {}; /*!< (read-only) Read the CPU ID Base Register to determine: the ID
               number of the processor core, the version number of the
               processor core, the implementation details of the processor
               core. */
    uint32_t ICSR;  /*!< (read-write) Use the Interrupt Control State Register
                       to set a pending Non-Maskable Interrupt (NMI), set or
                       clear a pending PendSV, set or clear a pending SysTick,
                       check for pending exceptions, check the vector number of
                       the highest priority pended exception, check the vector
                       number of the active exception. */
    uint32_t VTOR;  /*!< (read-write) The VTOR holds the vector table offset
                       address. */
    uint32_t AIRCR; /*!< (read-write) Use the Application Interrupt and Reset
                       Control Register to: determine data endianness, clear
                       all active state information from debug halt mode,
                       request a system reset. */
    uint32_t
        SCR; /*!< (read-write) System Control Register. Use the System Control
                Register for power-management functions: signal to the system
                when the processor can enter a low power state, control how the
                processor enters and exits low power states. */
    const uint32_t CCR =
        {}; /*!< (read-only) The Configuration and Control Register permanently
               enables stack alignment and causes unaligned accesses to result
               in a Hard Fault. */
    const uint32_t reserved_padding7 = {};
    uint32_t SHPR2; /*!< (read-write) System handlers are a special class of
                       exception handler that can have their priority set to
                       any of the priority levels. Use the System Handler
                       Priority Register 2 to set the priority of SVCall. */
    uint32_t
        SHPR3;      /*!< (read-write) System handlers are a special class of
                       exception handler that can have their priority set to any of
                       the priority levels. Use the System Handler Priority Register
                       3 to set the priority of PendSV and SysTick. */
    uint32_t SHCSR; /*!< (read-write) Use the System Handler Control and State
                       Register to determine or clear the pending status of
                       SVCall. */
    static constexpr std::size_t reserved_padding8_length = 26;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    const uint32_t MPU_TYPE =
        {}; /*!< (read-only) Read the MPU Type Register to determine if the
               processor implements an MPU, and how many regions the MPU
               supports. */
    uint32_t MPU_CTRL; /*!< (read-write) Use the MPU Control Register to enable
                          and disable the MPU, and to control whether the
                          default memory map is enabled as a background region
                          for privileged accesses, and whether the MPU is
                          enabled for HardFaults and NMIs. */
    uint32_t
        MPU_RNR; /*!< (read-write) Use the MPU Region Number Register to select
                    the region currently accessed by MPU_RBAR and MPU_RASR. */
    uint32_t MPU_RBAR; /*!< (read-write) Read the MPU Region Base Address
                          Register to determine the base address of the region
                          identified by MPU_RNR. Write to update the base
                          address of said region or that of a specified region,
                          with whose number MPU_RNR will also be updated. */
    uint32_t MPU_RASR; /*!< (read-write) Use the MPU Region Attribute and Size
                          Register to define the size, access behaviour and
                          memory type of the region identified by MPU_RNR, and
                          enable that region. */

    /* Methods. */

    /**
     * Get SYST_CSR's ENABLE bit.
     *
     * Enable SysTick counter:\n
     *                 0 = Counter disabled.\n
     *                 1 = Counter enabled.
     */
    inline bool get_SYST_CSR_ENABLE() volatile
    {
        return SYST_CSR & (1u << 0u);
    }

    /**
     * Set SYST_CSR's ENABLE bit.
     *
     * Enable SysTick counter:\n
     *                 0 = Counter disabled.\n
     *                 1 = Counter enabled.
     */
    inline void set_SYST_CSR_ENABLE() volatile
    {
        SYST_CSR |= 1u << 0u;
    }

    /**
     * Clear SYST_CSR's ENABLE bit.
     *
     * Enable SysTick counter:\n
     *                 0 = Counter disabled.\n
     *                 1 = Counter enabled.
     */
    inline void clear_SYST_CSR_ENABLE() volatile
    {
        SYST_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle SYST_CSR's ENABLE bit.
     *
     * Enable SysTick counter:\n
     *                 0 = Counter disabled.\n
     *                 1 = Counter enabled.
     */
    inline void toggle_SYST_CSR_ENABLE() volatile
    {
        SYST_CSR ^= 1u << 0u;
    }

    /**
     * Get SYST_CSR's TICKINT bit.
     *
     * Enables SysTick exception request:\n
     *                 0 = Counting down to zero does not assert the SysTick
     * exception request.\n 1 = Counting down to zero to asserts the SysTick
     * exception request.
     */
    inline bool get_SYST_CSR_TICKINT() volatile
    {
        return SYST_CSR & (1u << 1u);
    }

    /**
     * Set SYST_CSR's TICKINT bit.
     *
     * Enables SysTick exception request:\n
     *                 0 = Counting down to zero does not assert the SysTick
     * exception request.\n 1 = Counting down to zero to asserts the SysTick
     * exception request.
     */
    inline void set_SYST_CSR_TICKINT() volatile
    {
        SYST_CSR |= 1u << 1u;
    }

    /**
     * Clear SYST_CSR's TICKINT bit.
     *
     * Enables SysTick exception request:\n
     *                 0 = Counting down to zero does not assert the SysTick
     * exception request.\n 1 = Counting down to zero to asserts the SysTick
     * exception request.
     */
    inline void clear_SYST_CSR_TICKINT() volatile
    {
        SYST_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle SYST_CSR's TICKINT bit.
     *
     * Enables SysTick exception request:\n
     *                 0 = Counting down to zero does not assert the SysTick
     * exception request.\n 1 = Counting down to zero to asserts the SysTick
     * exception request.
     */
    inline void toggle_SYST_CSR_TICKINT() volatile
    {
        SYST_CSR ^= 1u << 1u;
    }

    /**
     * Get SYST_CSR's CLKSOURCE bit.
     *
     * SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.\n
     *                 Selects the SysTick timer clock source:\n
     *                 0 = External reference clock.\n
     *                 1 = Processor clock.
     */
    inline bool get_SYST_CSR_CLKSOURCE() volatile
    {
        return SYST_CSR & (1u << 2u);
    }

    /**
     * Set SYST_CSR's CLKSOURCE bit.
     *
     * SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.\n
     *                 Selects the SysTick timer clock source:\n
     *                 0 = External reference clock.\n
     *                 1 = Processor clock.
     */
    inline void set_SYST_CSR_CLKSOURCE() volatile
    {
        SYST_CSR |= 1u << 2u;
    }

    /**
     * Clear SYST_CSR's CLKSOURCE bit.
     *
     * SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.\n
     *                 Selects the SysTick timer clock source:\n
     *                 0 = External reference clock.\n
     *                 1 = Processor clock.
     */
    inline void clear_SYST_CSR_CLKSOURCE() volatile
    {
        SYST_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle SYST_CSR's CLKSOURCE bit.
     *
     * SysTick clock source. Always reads as one if SYST_CALIB reports NOREF.\n
     *                 Selects the SysTick timer clock source:\n
     *                 0 = External reference clock.\n
     *                 1 = Processor clock.
     */
    inline void toggle_SYST_CSR_CLKSOURCE() volatile
    {
        SYST_CSR ^= 1u << 2u;
    }

    /**
     * Get SYST_CSR's COUNTFLAG bit.
     *
     * Returns 1 if timer counted to 0 since last time this was read. Clears on
     * read by application or debugger.
     */
    inline bool get_SYST_CSR_COUNTFLAG() volatile
    {
        return SYST_CSR & (1u << 16u);
    }

    /**
     * Get all of SYST_CSR's bit fields.
     *
     * (read-write) Use the SysTick Control and Status Register to enable the
     * SysTick features.
     */
    inline void get_SYST_CSR(bool &ENABLE, bool &TICKINT, bool &CLKSOURCE,
                             bool &COUNTFLAG) volatile
    {
        uint32_t curr = SYST_CSR;

        ENABLE = curr & (1u << 0u);
        TICKINT = curr & (1u << 1u);
        CLKSOURCE = curr & (1u << 2u);
        COUNTFLAG = curr & (1u << 16u);
    }

    /**
     * Set all of SYST_CSR's bit fields.
     *
     * (read-write) Use the SysTick Control and Status Register to enable the
     * SysTick features.
     */
    inline void set_SYST_CSR(bool ENABLE, bool TICKINT,
                             bool CLKSOURCE) volatile
    {
        uint32_t curr = SYST_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TICKINT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CLKSOURCE & 0b1u) << 2u;

        SYST_CSR = curr;
    }

    /**
     * Get SYST_RVR's RELOAD field.
     *
     * Value to load into the SysTick Current Value Register when the counter
     * reaches 0.
     */
    inline uint32_t get_SYST_RVR_RELOAD() volatile
    {
        return (SYST_RVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_RVR's RELOAD field.
     *
     * Value to load into the SysTick Current Value Register when the counter
     * reaches 0.
     */
    inline void set_SYST_RVR_RELOAD(uint32_t value) volatile
    {
        uint32_t curr = SYST_RVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_RVR = curr;
    }

    /**
     * Get SYST_CVR's CURRENT field.
     *
     * Reads return the current value of the SysTick counter. This register is
     * write-clear. Writing to it with any value clears the register to 0.
     * Clearing this register also clears the COUNTFLAG bit of the SysTick
     * Control and Status Register.
     */
    inline uint32_t get_SYST_CVR_CURRENT() volatile
    {
        return (SYST_CVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_CVR's CURRENT field.
     *
     * Reads return the current value of the SysTick counter. This register is
     * write-clear. Writing to it with any value clears the register to 0.
     * Clearing this register also clears the COUNTFLAG bit of the SysTick
     * Control and Status Register.
     */
    inline void set_SYST_CVR_CURRENT(uint32_t value) volatile
    {
        uint32_t curr = SYST_CVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_CVR = curr;
    }

    /**
     * Get SYST_CALIB's TENMS field.
     *
     * An optional Reload value to be used for 10ms (100Hz) timing, subject to
     * system clock skew errors. If the value reads as 0, the calibration value
     * is not known.
     */
    inline uint32_t get_SYST_CALIB_TENMS() volatile
    {
        return (SYST_CALIB >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get SYST_CALIB's SKEW bit.
     *
     * If reads as 1, the calibration value for 10ms is inexact (due to clock
     * frequency).
     */
    inline bool get_SYST_CALIB_SKEW() volatile
    {
        return SYST_CALIB & (1u << 30u);
    }

    /**
     * Get SYST_CALIB's NOREF bit.
     *
     * If reads as 1, the Reference clock is not provided - the CLKSOURCE bit
     * of the SysTick Control and Status register will be forced to 1 and
     * cannot be cleared to 0.
     */
    inline bool get_SYST_CALIB_NOREF() volatile
    {
        return SYST_CALIB & (1u << 31u);
    }

    /**
     * Get all of SYST_CALIB's bit fields.
     *
     * (read-only) Use the SysTick Calibration Value Register to enable
     * software to scale to any required speed using divide and multiply.
     */
    inline void get_SYST_CALIB(uint32_t &TENMS, bool &SKEW,
                               bool &NOREF) volatile
    {
        uint32_t curr = SYST_CALIB;

        TENMS = (curr >> 0u) & 0b111111111111111111111111u;
        SKEW = curr & (1u << 30u);
        NOREF = curr & (1u << 31u);
    }

    /**
     * Get NVIC_ISER's SETENA field.
     *
     * Interrupt set-enable bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Enable interrupt.\n
     *                 Read:\n
     *                 0 = Interrupt disabled.\n
     *                 1 = Interrupt enabled.
     */
    inline uint32_t get_NVIC_ISER_SETENA() volatile
    {
        return (NVIC_ISER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ISER's SETENA field.
     *
     * Interrupt set-enable bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Enable interrupt.\n
     *                 Read:\n
     *                 0 = Interrupt disabled.\n
     *                 1 = Interrupt enabled.
     */
    inline void set_NVIC_ISER_SETENA(uint32_t value) volatile
    {
        uint32_t curr = NVIC_ISER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ISER = curr;
    }

    /**
     * Get NVIC_ICER's CLRENA field.
     *
     * Interrupt clear-enable bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Disable interrupt.\n
     *                 Read:\n
     *                 0 = Interrupt disabled.\n
     *                 1 = Interrupt enabled.
     */
    inline uint32_t get_NVIC_ICER_CLRENA() volatile
    {
        return (NVIC_ICER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ICER's CLRENA field.
     *
     * Interrupt clear-enable bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Disable interrupt.\n
     *                 Read:\n
     *                 0 = Interrupt disabled.\n
     *                 1 = Interrupt enabled.
     */
    inline void set_NVIC_ICER_CLRENA(uint32_t value) volatile
    {
        uint32_t curr = NVIC_ICER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ICER = curr;
    }

    /**
     * Get NVIC_ISPR's SETPEND field.
     *
     * Interrupt set-pending bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes interrupt state to pending.\n
     *                 Read:\n
     *                 0 = Interrupt is not pending.\n
     *                 1 = Interrupt is pending.\n
     *                 Note: Writing 1 to the NVIC_ISPR bit corresponding to:\n
     *                 An interrupt that is pending has no effect.\n
     *                 A disabled interrupt sets the state of that interrupt to
     * pending.
     */
    inline uint32_t get_NVIC_ISPR_SETPEND() volatile
    {
        return (NVIC_ISPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ISPR's SETPEND field.
     *
     * Interrupt set-pending bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes interrupt state to pending.\n
     *                 Read:\n
     *                 0 = Interrupt is not pending.\n
     *                 1 = Interrupt is pending.\n
     *                 Note: Writing 1 to the NVIC_ISPR bit corresponding to:\n
     *                 An interrupt that is pending has no effect.\n
     *                 A disabled interrupt sets the state of that interrupt to
     * pending.
     */
    inline void set_NVIC_ISPR_SETPEND(uint32_t value) volatile
    {
        uint32_t curr = NVIC_ISPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ISPR = curr;
    }

    /**
     * Get NVIC_ICPR's CLRPEND field.
     *
     * Interrupt clear-pending bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes pending state and interrupt.\n
     *                 Read:\n
     *                 0 = Interrupt is not pending.\n
     *                 1 = Interrupt is pending.
     */
    inline uint32_t get_NVIC_ICPR_CLRPEND() volatile
    {
        return (NVIC_ICPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ICPR's CLRPEND field.
     *
     * Interrupt clear-pending bits.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes pending state and interrupt.\n
     *                 Read:\n
     *                 0 = Interrupt is not pending.\n
     *                 1 = Interrupt is pending.
     */
    inline void set_NVIC_ICPR_CLRPEND(uint32_t value) volatile
    {
        uint32_t curr = NVIC_ICPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ICPR = curr;
    }

    /**
     * Get NVIC_IPR0's IP_0 field.
     *
     * Priority of interrupt 0
     */
    inline uint8_t get_NVIC_IPR0_IP_0() volatile
    {
        return (NVIC_IPR0 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_0 field.
     *
     * Priority of interrupt 0
     */
    inline void set_NVIC_IPR0_IP_0(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_1 field.
     *
     * Priority of interrupt 1
     */
    inline uint8_t get_NVIC_IPR0_IP_1() volatile
    {
        return (NVIC_IPR0 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_1 field.
     *
     * Priority of interrupt 1
     */
    inline void set_NVIC_IPR0_IP_1(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_2 field.
     *
     * Priority of interrupt 2
     */
    inline uint8_t get_NVIC_IPR0_IP_2() volatile
    {
        return (NVIC_IPR0 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_2 field.
     *
     * Priority of interrupt 2
     */
    inline void set_NVIC_IPR0_IP_2(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_3 field.
     *
     * Priority of interrupt 3
     */
    inline uint8_t get_NVIC_IPR0_IP_3() volatile
    {
        return (NVIC_IPR0 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_3 field.
     *
     * Priority of interrupt 3
     */
    inline void set_NVIC_IPR0_IP_3(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get all of NVIC_IPR0's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit
     * does not affect the active state of the corresponding interrupt.\n These
     * registers are only word-accessible
     */
    inline void get_NVIC_IPR0(uint8_t &IP_0, uint8_t &IP_1, uint8_t &IP_2,
                              uint8_t &IP_3) volatile
    {
        uint32_t curr = NVIC_IPR0;

        IP_0 = (curr >> 6u) & 0b11u;
        IP_1 = (curr >> 14u) & 0b11u;
        IP_2 = (curr >> 22u) & 0b11u;
        IP_3 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR0's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit
     * does not affect the active state of the corresponding interrupt.\n These
     * registers are only word-accessible
     */
    inline void set_NVIC_IPR0(uint8_t IP_0, uint8_t IP_1, uint8_t IP_2,
                              uint8_t IP_3) volatile
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 6u);
        curr |= (IP_0 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_1 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_2 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_3 & 0b11u) << 30u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_4 field.
     *
     * Priority of interrupt 4
     */
    inline uint8_t get_NVIC_IPR1_IP_4() volatile
    {
        return (NVIC_IPR1 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_4 field.
     *
     * Priority of interrupt 4
     */
    inline void set_NVIC_IPR1_IP_4(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_5 field.
     *
     * Priority of interrupt 5
     */
    inline uint8_t get_NVIC_IPR1_IP_5() volatile
    {
        return (NVIC_IPR1 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_5 field.
     *
     * Priority of interrupt 5
     */
    inline void set_NVIC_IPR1_IP_5(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_6 field.
     *
     * Priority of interrupt 6
     */
    inline uint8_t get_NVIC_IPR1_IP_6() volatile
    {
        return (NVIC_IPR1 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_6 field.
     *
     * Priority of interrupt 6
     */
    inline void set_NVIC_IPR1_IP_6(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_7 field.
     *
     * Priority of interrupt 7
     */
    inline uint8_t get_NVIC_IPR1_IP_7() volatile
    {
        return (NVIC_IPR1 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_7 field.
     *
     * Priority of interrupt 7
     */
    inline void set_NVIC_IPR1_IP_7(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get all of NVIC_IPR1's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR1(uint8_t &IP_4, uint8_t &IP_5, uint8_t &IP_6,
                              uint8_t &IP_7) volatile
    {
        uint32_t curr = NVIC_IPR1;

        IP_4 = (curr >> 6u) & 0b11u;
        IP_5 = (curr >> 14u) & 0b11u;
        IP_6 = (curr >> 22u) & 0b11u;
        IP_7 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR1's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR1(uint8_t IP_4, uint8_t IP_5, uint8_t IP_6,
                              uint8_t IP_7) volatile
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 6u);
        curr |= (IP_4 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_5 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_6 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_7 & 0b11u) << 30u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_8 field.
     *
     * Priority of interrupt 8
     */
    inline uint8_t get_NVIC_IPR2_IP_8() volatile
    {
        return (NVIC_IPR2 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_8 field.
     *
     * Priority of interrupt 8
     */
    inline void set_NVIC_IPR2_IP_8(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_9 field.
     *
     * Priority of interrupt 9
     */
    inline uint8_t get_NVIC_IPR2_IP_9() volatile
    {
        return (NVIC_IPR2 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_9 field.
     *
     * Priority of interrupt 9
     */
    inline void set_NVIC_IPR2_IP_9(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_10 field.
     *
     * Priority of interrupt 10
     */
    inline uint8_t get_NVIC_IPR2_IP_10() volatile
    {
        return (NVIC_IPR2 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_10 field.
     *
     * Priority of interrupt 10
     */
    inline void set_NVIC_IPR2_IP_10(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_11 field.
     *
     * Priority of interrupt 11
     */
    inline uint8_t get_NVIC_IPR2_IP_11() volatile
    {
        return (NVIC_IPR2 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_11 field.
     *
     * Priority of interrupt 11
     */
    inline void set_NVIC_IPR2_IP_11(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get all of NVIC_IPR2's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR2(uint8_t &IP_8, uint8_t &IP_9, uint8_t &IP_10,
                              uint8_t &IP_11) volatile
    {
        uint32_t curr = NVIC_IPR2;

        IP_8 = (curr >> 6u) & 0b11u;
        IP_9 = (curr >> 14u) & 0b11u;
        IP_10 = (curr >> 22u) & 0b11u;
        IP_11 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR2's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR2(uint8_t IP_8, uint8_t IP_9, uint8_t IP_10,
                              uint8_t IP_11) volatile
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 6u);
        curr |= (IP_8 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_9 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_10 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_11 & 0b11u) << 30u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_12 field.
     *
     * Priority of interrupt 12
     */
    inline uint8_t get_NVIC_IPR3_IP_12() volatile
    {
        return (NVIC_IPR3 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_12 field.
     *
     * Priority of interrupt 12
     */
    inline void set_NVIC_IPR3_IP_12(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_13 field.
     *
     * Priority of interrupt 13
     */
    inline uint8_t get_NVIC_IPR3_IP_13() volatile
    {
        return (NVIC_IPR3 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_13 field.
     *
     * Priority of interrupt 13
     */
    inline void set_NVIC_IPR3_IP_13(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_14 field.
     *
     * Priority of interrupt 14
     */
    inline uint8_t get_NVIC_IPR3_IP_14() volatile
    {
        return (NVIC_IPR3 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_14 field.
     *
     * Priority of interrupt 14
     */
    inline void set_NVIC_IPR3_IP_14(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_15 field.
     *
     * Priority of interrupt 15
     */
    inline uint8_t get_NVIC_IPR3_IP_15() volatile
    {
        return (NVIC_IPR3 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_15 field.
     *
     * Priority of interrupt 15
     */
    inline void set_NVIC_IPR3_IP_15(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get all of NVIC_IPR3's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR3(uint8_t &IP_12, uint8_t &IP_13, uint8_t &IP_14,
                              uint8_t &IP_15) volatile
    {
        uint32_t curr = NVIC_IPR3;

        IP_12 = (curr >> 6u) & 0b11u;
        IP_13 = (curr >> 14u) & 0b11u;
        IP_14 = (curr >> 22u) & 0b11u;
        IP_15 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR3's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR3(uint8_t IP_12, uint8_t IP_13, uint8_t IP_14,
                              uint8_t IP_15) volatile
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 6u);
        curr |= (IP_12 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_13 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_14 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_15 & 0b11u) << 30u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_16 field.
     *
     * Priority of interrupt 16
     */
    inline uint8_t get_NVIC_IPR4_IP_16() volatile
    {
        return (NVIC_IPR4 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_16 field.
     *
     * Priority of interrupt 16
     */
    inline void set_NVIC_IPR4_IP_16(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_17 field.
     *
     * Priority of interrupt 17
     */
    inline uint8_t get_NVIC_IPR4_IP_17() volatile
    {
        return (NVIC_IPR4 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_17 field.
     *
     * Priority of interrupt 17
     */
    inline void set_NVIC_IPR4_IP_17(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_18 field.
     *
     * Priority of interrupt 18
     */
    inline uint8_t get_NVIC_IPR4_IP_18() volatile
    {
        return (NVIC_IPR4 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_18 field.
     *
     * Priority of interrupt 18
     */
    inline void set_NVIC_IPR4_IP_18(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_19 field.
     *
     * Priority of interrupt 19
     */
    inline uint8_t get_NVIC_IPR4_IP_19() volatile
    {
        return (NVIC_IPR4 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_19 field.
     *
     * Priority of interrupt 19
     */
    inline void set_NVIC_IPR4_IP_19(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get all of NVIC_IPR4's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR4(uint8_t &IP_16, uint8_t &IP_17, uint8_t &IP_18,
                              uint8_t &IP_19) volatile
    {
        uint32_t curr = NVIC_IPR4;

        IP_16 = (curr >> 6u) & 0b11u;
        IP_17 = (curr >> 14u) & 0b11u;
        IP_18 = (curr >> 22u) & 0b11u;
        IP_19 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR4's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR4(uint8_t IP_16, uint8_t IP_17, uint8_t IP_18,
                              uint8_t IP_19) volatile
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 6u);
        curr |= (IP_16 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_17 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_18 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_19 & 0b11u) << 30u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_20 field.
     *
     * Priority of interrupt 20
     */
    inline uint8_t get_NVIC_IPR5_IP_20() volatile
    {
        return (NVIC_IPR5 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_20 field.
     *
     * Priority of interrupt 20
     */
    inline void set_NVIC_IPR5_IP_20(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_21 field.
     *
     * Priority of interrupt 21
     */
    inline uint8_t get_NVIC_IPR5_IP_21() volatile
    {
        return (NVIC_IPR5 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_21 field.
     *
     * Priority of interrupt 21
     */
    inline void set_NVIC_IPR5_IP_21(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_22 field.
     *
     * Priority of interrupt 22
     */
    inline uint8_t get_NVIC_IPR5_IP_22() volatile
    {
        return (NVIC_IPR5 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_22 field.
     *
     * Priority of interrupt 22
     */
    inline void set_NVIC_IPR5_IP_22(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_23 field.
     *
     * Priority of interrupt 23
     */
    inline uint8_t get_NVIC_IPR5_IP_23() volatile
    {
        return (NVIC_IPR5 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_23 field.
     *
     * Priority of interrupt 23
     */
    inline void set_NVIC_IPR5_IP_23(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get all of NVIC_IPR5's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR5(uint8_t &IP_20, uint8_t &IP_21, uint8_t &IP_22,
                              uint8_t &IP_23) volatile
    {
        uint32_t curr = NVIC_IPR5;

        IP_20 = (curr >> 6u) & 0b11u;
        IP_21 = (curr >> 14u) & 0b11u;
        IP_22 = (curr >> 22u) & 0b11u;
        IP_23 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR5's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR5(uint8_t IP_20, uint8_t IP_21, uint8_t IP_22,
                              uint8_t IP_23) volatile
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 6u);
        curr |= (IP_20 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_21 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_22 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_23 & 0b11u) << 30u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_24 field.
     *
     * Priority of interrupt 24
     */
    inline uint8_t get_NVIC_IPR6_IP_24() volatile
    {
        return (NVIC_IPR6 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_24 field.
     *
     * Priority of interrupt 24
     */
    inline void set_NVIC_IPR6_IP_24(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_25 field.
     *
     * Priority of interrupt 25
     */
    inline uint8_t get_NVIC_IPR6_IP_25() volatile
    {
        return (NVIC_IPR6 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_25 field.
     *
     * Priority of interrupt 25
     */
    inline void set_NVIC_IPR6_IP_25(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_26 field.
     *
     * Priority of interrupt 26
     */
    inline uint8_t get_NVIC_IPR6_IP_26() volatile
    {
        return (NVIC_IPR6 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_26 field.
     *
     * Priority of interrupt 26
     */
    inline void set_NVIC_IPR6_IP_26(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_27 field.
     *
     * Priority of interrupt 27
     */
    inline uint8_t get_NVIC_IPR6_IP_27() volatile
    {
        return (NVIC_IPR6 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_27 field.
     *
     * Priority of interrupt 27
     */
    inline void set_NVIC_IPR6_IP_27(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get all of NVIC_IPR6's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR6(uint8_t &IP_24, uint8_t &IP_25, uint8_t &IP_26,
                              uint8_t &IP_27) volatile
    {
        uint32_t curr = NVIC_IPR6;

        IP_24 = (curr >> 6u) & 0b11u;
        IP_25 = (curr >> 14u) & 0b11u;
        IP_26 = (curr >> 22u) & 0b11u;
        IP_27 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR6's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR6(uint8_t IP_24, uint8_t IP_25, uint8_t IP_26,
                              uint8_t IP_27) volatile
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 6u);
        curr |= (IP_24 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_25 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_26 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_27 & 0b11u) << 30u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_28 field.
     *
     * Priority of interrupt 28
     */
    inline uint8_t get_NVIC_IPR7_IP_28() volatile
    {
        return (NVIC_IPR7 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_28 field.
     *
     * Priority of interrupt 28
     */
    inline void set_NVIC_IPR7_IP_28(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_29 field.
     *
     * Priority of interrupt 29
     */
    inline uint8_t get_NVIC_IPR7_IP_29() volatile
    {
        return (NVIC_IPR7 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_29 field.
     *
     * Priority of interrupt 29
     */
    inline void set_NVIC_IPR7_IP_29(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_30 field.
     *
     * Priority of interrupt 30
     */
    inline uint8_t get_NVIC_IPR7_IP_30() volatile
    {
        return (NVIC_IPR7 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_30 field.
     *
     * Priority of interrupt 30
     */
    inline void set_NVIC_IPR7_IP_30(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_31 field.
     *
     * Priority of interrupt 31
     */
    inline uint8_t get_NVIC_IPR7_IP_31() volatile
    {
        return (NVIC_IPR7 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_31 field.
     *
     * Priority of interrupt 31
     */
    inline void set_NVIC_IPR7_IP_31(uint8_t value) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get all of NVIC_IPR7's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void get_NVIC_IPR7(uint8_t &IP_28, uint8_t &IP_29, uint8_t &IP_30,
                              uint8_t &IP_31) volatile
    {
        uint32_t curr = NVIC_IPR7;

        IP_28 = (curr >> 6u) & 0b11u;
        IP_29 = (curr >> 14u) & 0b11u;
        IP_30 = (curr >> 22u) & 0b11u;
        IP_31 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR7's bit fields.
     *
     * (read-write) Use the Interrupt Priority Registers to assign a priority
     * from 0 to 3 to each of the available interrupts. 0 is the highest
     * priority, and 3 is the lowest.
     */
    inline void set_NVIC_IPR7(uint8_t IP_28, uint8_t IP_29, uint8_t IP_30,
                              uint8_t IP_31) volatile
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 6u);
        curr |= (IP_28 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_29 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_30 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_31 & 0b11u) << 30u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get CPUID's REVISION field.
     *
     * Minor revision number m in the rnpm revision status:\n
     *                 0x1 = Patch 1.
     */
    inline uint8_t get_CPUID_REVISION() volatile
    {
        return (CPUID >> 0u) & 0b1111u;
    }

    /**
     * Get CPUID's PARTNO field.
     *
     * Number of processor within family: 0xC60 = Cortex-M0+
     */
    inline uint16_t get_CPUID_PARTNO() volatile
    {
        return (CPUID >> 4u) & 0b111111111111u;
    }

    /**
     * Get CPUID's ARCHITECTURE field.
     *
     * Constant that defines the architecture of the processor:\n
     *                 0xC = ARMv6-M architecture.
     */
    inline uint8_t get_CPUID_ARCHITECTURE() volatile
    {
        return (CPUID >> 16u) & 0b1111u;
    }

    /**
     * Get CPUID's VARIANT field.
     *
     * Major revision number n in the rnpm revision status:\n
     *                 0x0 = Revision 0.
     */
    inline uint8_t get_CPUID_VARIANT() volatile
    {
        return (CPUID >> 20u) & 0b1111u;
    }

    /**
     * Get CPUID's IMPLEMENTER field.
     *
     * Implementor code: 0x41 = ARM
     */
    inline uint8_t get_CPUID_IMPLEMENTER() volatile
    {
        return (CPUID >> 24u) & 0b11111111u;
    }

    /**
     * Get all of CPUID's bit fields.
     *
     * (read-only) Read the CPU ID Base Register to determine: the ID number of
     * the processor core, the version number of the processor core, the
     * implementation details of the processor core.
     */
    inline void get_CPUID(uint8_t &REVISION, uint16_t &PARTNO,
                          uint8_t &ARCHITECTURE, uint8_t &VARIANT,
                          uint8_t &IMPLEMENTER) volatile
    {
        uint32_t curr = CPUID;

        REVISION = (curr >> 0u) & 0b1111u;
        PARTNO = (curr >> 4u) & 0b111111111111u;
        ARCHITECTURE = (curr >> 16u) & 0b1111u;
        VARIANT = (curr >> 20u) & 0b1111u;
        IMPLEMENTER = (curr >> 24u) & 0b11111111u;
    }

    /**
     * Get ICSR's VECTACTIVE field.
     *
     * Active exception number field. Reset clears the VECTACTIVE field.
     */
    inline uint16_t get_ICSR_VECTACTIVE() volatile
    {
        return (ICSR >> 0u) & 0b111111111u;
    }

    /**
     * Get ICSR's VECTPENDING field.
     *
     * Indicates the exception number for the highest priority pending
     * exception: 0 = no pending exceptions. Non zero = The pending state
     * includes the effect of memory-mapped enable and mask registers. It does
     * not include the PRIMASK special-purpose register qualifier.
     */
    inline uint16_t get_ICSR_VECTPENDING() volatile
    {
        return (ICSR >> 12u) & 0b111111111u;
    }

    /**
     * Get ICSR's ISRPENDING bit.
     *
     * External interrupt pending flag
     */
    inline bool get_ICSR_ISRPENDING() volatile
    {
        return ICSR & (1u << 22u);
    }

    /**
     * Get ICSR's ISRPREEMPT bit.
     *
     * The system can only access this bit when the core is halted. It
     * indicates that a pending interrupt is to be taken in the next running
     * cycle. If C_MASKINTS is clear in the Debug Halting Control and Status
     * Register, the interrupt is serviced.
     */
    inline bool get_ICSR_ISRPREEMPT() volatile
    {
        return ICSR & (1u << 23u);
    }

    /**
     * Get ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the SysTick
     * exception.\n This bit is WO. On a register read its value is Unknown.
     */
    inline bool get_ICSR_PENDSTCLR() volatile
    {
        return ICSR & (1u << 25u);
    }

    /**
     * Set ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the SysTick
     * exception.\n This bit is WO. On a register read its value is Unknown.
     */
    inline void set_ICSR_PENDSTCLR() volatile
    {
        ICSR |= 1u << 25u;
    }

    /**
     * Clear ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the SysTick
     * exception.\n This bit is WO. On a register read its value is Unknown.
     */
    inline void clear_ICSR_PENDSTCLR() volatile
    {
        ICSR &= ~(1u << 25u);
    }

    /**
     * Toggle ICSR's PENDSTCLR bit.
     *
     * SysTick exception clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the SysTick
     * exception.\n This bit is WO. On a register read its value is Unknown.
     */
    inline void toggle_ICSR_PENDSTCLR() volatile
    {
        ICSR ^= 1u << 25u;
    }

    /**
     * Get ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes SysTick exception state to pending.\n
     *                 Read:\n
     *                 0 = SysTick exception is not pending.\n
     *                 1 = SysTick exception is pending.
     */
    inline bool get_ICSR_PENDSTSET() volatile
    {
        return ICSR & (1u << 26u);
    }

    /**
     * Set ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes SysTick exception state to pending.\n
     *                 Read:\n
     *                 0 = SysTick exception is not pending.\n
     *                 1 = SysTick exception is pending.
     */
    inline void set_ICSR_PENDSTSET() volatile
    {
        ICSR |= 1u << 26u;
    }

    /**
     * Clear ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes SysTick exception state to pending.\n
     *                 Read:\n
     *                 0 = SysTick exception is not pending.\n
     *                 1 = SysTick exception is pending.
     */
    inline void clear_ICSR_PENDSTSET() volatile
    {
        ICSR &= ~(1u << 26u);
    }

    /**
     * Toggle ICSR's PENDSTSET bit.
     *
     * SysTick exception set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes SysTick exception state to pending.\n
     *                 Read:\n
     *                 0 = SysTick exception is not pending.\n
     *                 1 = SysTick exception is pending.
     */
    inline void toggle_ICSR_PENDSTSET() volatile
    {
        ICSR ^= 1u << 26u;
    }

    /**
     * Get ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the PendSV exception.
     */
    inline bool get_ICSR_PENDSVCLR() volatile
    {
        return ICSR & (1u << 27u);
    }

    /**
     * Set ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the PendSV exception.
     */
    inline void set_ICSR_PENDSVCLR() volatile
    {
        ICSR |= 1u << 27u;
    }

    /**
     * Clear ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the PendSV exception.
     */
    inline void clear_ICSR_PENDSVCLR() volatile
    {
        ICSR &= ~(1u << 27u);
    }

    /**
     * Toggle ICSR's PENDSVCLR bit.
     *
     * PendSV clear-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Removes the pending state from the PendSV exception.
     */
    inline void toggle_ICSR_PENDSVCLR() volatile
    {
        ICSR ^= 1u << 27u;
    }

    /**
     * Get ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes PendSV exception state to pending.\n
     *                 Read:\n
     *                 0 = PendSV exception is not pending.\n
     *                 1 = PendSV exception is pending.\n
     *                 Writing 1 to this bit is the only way to set the PendSV
     * exception state to pending.
     */
    inline bool get_ICSR_PENDSVSET() volatile
    {
        return ICSR & (1u << 28u);
    }

    /**
     * Set ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes PendSV exception state to pending.\n
     *                 Read:\n
     *                 0 = PendSV exception is not pending.\n
     *                 1 = PendSV exception is pending.\n
     *                 Writing 1 to this bit is the only way to set the PendSV
     * exception state to pending.
     */
    inline void set_ICSR_PENDSVSET() volatile
    {
        ICSR |= 1u << 28u;
    }

    /**
     * Clear ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes PendSV exception state to pending.\n
     *                 Read:\n
     *                 0 = PendSV exception is not pending.\n
     *                 1 = PendSV exception is pending.\n
     *                 Writing 1 to this bit is the only way to set the PendSV
     * exception state to pending.
     */
    inline void clear_ICSR_PENDSVSET() volatile
    {
        ICSR &= ~(1u << 28u);
    }

    /**
     * Toggle ICSR's PENDSVSET bit.
     *
     * PendSV set-pending bit.\n
     *                 Write:\n
     *                 0 = No effect.\n
     *                 1 = Changes PendSV exception state to pending.\n
     *                 Read:\n
     *                 0 = PendSV exception is not pending.\n
     *                 1 = PendSV exception is pending.\n
     *                 Writing 1 to this bit is the only way to set the PendSV
     * exception state to pending.
     */
    inline void toggle_ICSR_PENDSVSET() volatile
    {
        ICSR ^= 1u << 28u;
    }

    /**
     * Get ICSR's NMIPENDSET bit.
     *
     * Setting this bit will activate an NMI. Since NMI is the highest priority
     * exception, it will activate as soon as it is registered.\n NMI
     * set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes NMI exception
     * state to pending.\n Read:\n 0 = NMI exception is not pending.\n 1 = NMI
     * exception is pending.\n Because NMI is the highest-priority exception,
     * normally the processor enters the NMI\n exception handler as soon as it
     * detects a write of 1 to this bit. Entering the handler then clears\n
     *                 this bit to 0. This means a read of this bit by the NMI
     * exception handler returns 1 only if the\n NMI signal is reasserted while
     * the processor is executing that handler.
     */
    inline bool get_ICSR_NMIPENDSET() volatile
    {
        return ICSR & (1u << 31u);
    }

    /**
     * Set ICSR's NMIPENDSET bit.
     *
     * Setting this bit will activate an NMI. Since NMI is the highest priority
     * exception, it will activate as soon as it is registered.\n NMI
     * set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes NMI exception
     * state to pending.\n Read:\n 0 = NMI exception is not pending.\n 1 = NMI
     * exception is pending.\n Because NMI is the highest-priority exception,
     * normally the processor enters the NMI\n exception handler as soon as it
     * detects a write of 1 to this bit. Entering the handler then clears\n
     *                 this bit to 0. This means a read of this bit by the NMI
     * exception handler returns 1 only if the\n NMI signal is reasserted while
     * the processor is executing that handler.
     */
    inline void set_ICSR_NMIPENDSET() volatile
    {
        ICSR |= 1u << 31u;
    }

    /**
     * Clear ICSR's NMIPENDSET bit.
     *
     * Setting this bit will activate an NMI. Since NMI is the highest priority
     * exception, it will activate as soon as it is registered.\n NMI
     * set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes NMI exception
     * state to pending.\n Read:\n 0 = NMI exception is not pending.\n 1 = NMI
     * exception is pending.\n Because NMI is the highest-priority exception,
     * normally the processor enters the NMI\n exception handler as soon as it
     * detects a write of 1 to this bit. Entering the handler then clears\n
     *                 this bit to 0. This means a read of this bit by the NMI
     * exception handler returns 1 only if the\n NMI signal is reasserted while
     * the processor is executing that handler.
     */
    inline void clear_ICSR_NMIPENDSET() volatile
    {
        ICSR &= ~(1u << 31u);
    }

    /**
     * Toggle ICSR's NMIPENDSET bit.
     *
     * Setting this bit will activate an NMI. Since NMI is the highest priority
     * exception, it will activate as soon as it is registered.\n NMI
     * set-pending bit.\n Write:\n 0 = No effect.\n 1 = Changes NMI exception
     * state to pending.\n Read:\n 0 = NMI exception is not pending.\n 1 = NMI
     * exception is pending.\n Because NMI is the highest-priority exception,
     * normally the processor enters the NMI\n exception handler as soon as it
     * detects a write of 1 to this bit. Entering the handler then clears\n
     *                 this bit to 0. This means a read of this bit by the NMI
     * exception handler returns 1 only if the\n NMI signal is reasserted while
     * the processor is executing that handler.
     */
    inline void toggle_ICSR_NMIPENDSET() volatile
    {
        ICSR ^= 1u << 31u;
    }

    /**
     * Get all of ICSR's bit fields.
     *
     * (read-write) Use the Interrupt Control State Register to set a pending
     * Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or
     * clear a pending SysTick, check for pending exceptions, check the vector
     * number of the highest priority pended exception, check the vector number
     * of the active exception.
     */
    inline void get_ICSR(uint16_t &VECTACTIVE, uint16_t &VECTPENDING,
                         bool &ISRPENDING, bool &ISRPREEMPT, bool &PENDSTCLR,
                         bool &PENDSTSET, bool &PENDSVCLR, bool &PENDSVSET,
                         bool &NMIPENDSET) volatile
    {
        uint32_t curr = ICSR;

        VECTACTIVE = (curr >> 0u) & 0b111111111u;
        VECTPENDING = (curr >> 12u) & 0b111111111u;
        ISRPENDING = curr & (1u << 22u);
        ISRPREEMPT = curr & (1u << 23u);
        PENDSTCLR = curr & (1u << 25u);
        PENDSTSET = curr & (1u << 26u);
        PENDSVCLR = curr & (1u << 27u);
        PENDSVSET = curr & (1u << 28u);
        NMIPENDSET = curr & (1u << 31u);
    }

    /**
     * Set all of ICSR's bit fields.
     *
     * (read-write) Use the Interrupt Control State Register to set a pending
     * Non-Maskable Interrupt (NMI), set or clear a pending PendSV, set or
     * clear a pending SysTick, check for pending exceptions, check the vector
     * number of the highest priority pended exception, check the vector number
     * of the active exception.
     */
    inline void set_ICSR(bool PENDSTCLR, bool PENDSTSET, bool PENDSVCLR,
                         bool PENDSVSET, bool NMIPENDSET) volatile
    {
        uint32_t curr = ICSR;

        curr &= ~(0b1u << 25u);
        curr |= (PENDSTCLR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (PENDSTSET & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (PENDSVCLR & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (PENDSVSET & 0b1u) << 28u;
        curr &= ~(0b1u << 31u);
        curr |= (NMIPENDSET & 0b1u) << 31u;

        ICSR = curr;
    }

    /**
     * Get VTOR's TBLOFF field.
     *
     * Bits [31:8] of the indicate the vector table offset address.
     */
    inline uint32_t get_VTOR_TBLOFF() volatile
    {
        return (VTOR >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set VTOR's TBLOFF field.
     *
     * Bits [31:8] of the indicate the vector table offset address.
     */
    inline void set_VTOR_TBLOFF(uint32_t value) volatile
    {
        uint32_t curr = VTOR;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        VTOR = curr;
    }

    /**
     * Get AIRCR's VECTCLRACTIVE bit.
     *
     * Clears all active state information for fixed and configurable
     * exceptions. This bit: is self-clearing, can only be set by the DAP when
     * the core is halted.  When set: clears all active exception status of the
     * processor, forces a return to Thread mode, forces an IPSR of 0. A
     * debugger must re-initialize the stack.
     */
    inline bool get_AIRCR_VECTCLRACTIVE() volatile
    {
        return AIRCR & (1u << 1u);
    }

    /**
     * Set AIRCR's VECTCLRACTIVE bit.
     *
     * Clears all active state information for fixed and configurable
     * exceptions. This bit: is self-clearing, can only be set by the DAP when
     * the core is halted.  When set: clears all active exception status of the
     * processor, forces a return to Thread mode, forces an IPSR of 0. A
     * debugger must re-initialize the stack.
     */
    inline void set_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR |= 1u << 1u;
    }

    /**
     * Clear AIRCR's VECTCLRACTIVE bit.
     *
     * Clears all active state information for fixed and configurable
     * exceptions. This bit: is self-clearing, can only be set by the DAP when
     * the core is halted.  When set: clears all active exception status of the
     * processor, forces a return to Thread mode, forces an IPSR of 0. A
     * debugger must re-initialize the stack.
     */
    inline void clear_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR &= ~(1u << 1u);
    }

    /**
     * Toggle AIRCR's VECTCLRACTIVE bit.
     *
     * Clears all active state information for fixed and configurable
     * exceptions. This bit: is self-clearing, can only be set by the DAP when
     * the core is halted.  When set: clears all active exception status of the
     * processor, forces a return to Thread mode, forces an IPSR of 0. A
     * debugger must re-initialize the stack.
     */
    inline void toggle_AIRCR_VECTCLRACTIVE() volatile
    {
        AIRCR ^= 1u << 1u;
    }

    /**
     * Get AIRCR's SYSRESETREQ bit.
     *
     * Writing 1 to this bit causes the SYSRESETREQ signal to the outer system
     * to be asserted to request a reset. The intention is to force a large
     * system reset of all major components except for debug. The C_HALT bit in
     * the DHCSR is cleared as a result of the system reset requested. The
     * debugger does not lose contact with the device.
     */
    inline bool get_AIRCR_SYSRESETREQ() volatile
    {
        return AIRCR & (1u << 2u);
    }

    /**
     * Set AIRCR's SYSRESETREQ bit.
     *
     * Writing 1 to this bit causes the SYSRESETREQ signal to the outer system
     * to be asserted to request a reset. The intention is to force a large
     * system reset of all major components except for debug. The C_HALT bit in
     * the DHCSR is cleared as a result of the system reset requested. The
     * debugger does not lose contact with the device.
     */
    inline void set_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR |= 1u << 2u;
    }

    /**
     * Clear AIRCR's SYSRESETREQ bit.
     *
     * Writing 1 to this bit causes the SYSRESETREQ signal to the outer system
     * to be asserted to request a reset. The intention is to force a large
     * system reset of all major components except for debug. The C_HALT bit in
     * the DHCSR is cleared as a result of the system reset requested. The
     * debugger does not lose contact with the device.
     */
    inline void clear_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR &= ~(1u << 2u);
    }

    /**
     * Toggle AIRCR's SYSRESETREQ bit.
     *
     * Writing 1 to this bit causes the SYSRESETREQ signal to the outer system
     * to be asserted to request a reset. The intention is to force a large
     * system reset of all major components except for debug. The C_HALT bit in
     * the DHCSR is cleared as a result of the system reset requested. The
     * debugger does not lose contact with the device.
     */
    inline void toggle_AIRCR_SYSRESETREQ() volatile
    {
        AIRCR ^= 1u << 2u;
    }

    /**
     * Get AIRCR's ENDIANESS bit.
     *
     * Data endianness implemented:\n
     *                 0 = Little-endian.
     */
    inline bool get_AIRCR_ENDIANESS() volatile
    {
        return AIRCR & (1u << 15u);
    }

    /**
     * Get AIRCR's VECTKEY field.
     *
     * Register key:\n
     *                 Reads as Unknown\n
     *                 On writes, write 0x05FA to VECTKEY, otherwise the write
     * is ignored.
     */
    inline uint16_t get_AIRCR_VECTKEY() volatile
    {
        return (AIRCR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set AIRCR's VECTKEY field.
     *
     * Register key:\n
     *                 Reads as Unknown\n
     *                 On writes, write 0x05FA to VECTKEY, otherwise the write
     * is ignored.
     */
    inline void set_AIRCR_VECTKEY(uint16_t value) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get all of AIRCR's bit fields.
     *
     * (read-write) Use the Application Interrupt and Reset Control Register
     * to: determine data endianness, clear all active state information from
     * debug halt mode, request a system reset.
     */
    inline void get_AIRCR(bool &VECTCLRACTIVE, bool &SYSRESETREQ,
                          bool &ENDIANESS, uint16_t &VECTKEY) volatile
    {
        uint32_t curr = AIRCR;

        VECTCLRACTIVE = curr & (1u << 1u);
        SYSRESETREQ = curr & (1u << 2u);
        ENDIANESS = curr & (1u << 15u);
        VECTKEY = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of AIRCR's bit fields.
     *
     * (read-write) Use the Application Interrupt and Reset Control Register
     * to: determine data endianness, clear all active state information from
     * debug halt mode, request a system reset.
     */
    inline void set_AIRCR(bool VECTCLRACTIVE, bool SYSRESETREQ,
                          uint16_t VECTKEY) volatile
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1u << 1u);
        curr |= (VECTCLRACTIVE & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SYSRESETREQ & 0b1u) << 2u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (VECTKEY & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread
     * mode:\n 0 = Do not sleep when returning to Thread mode.\n 1 = Enter
     * sleep, or deep sleep, on return from an ISR to Thread mode.\n Setting
     * this bit to 1 enables an interrupt driven application to avoid returning
     * to an empty main application.
     */
    inline bool get_SCR_SLEEPONEXIT() volatile
    {
        return SCR & (1u << 1u);
    }

    /**
     * Set SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread
     * mode:\n 0 = Do not sleep when returning to Thread mode.\n 1 = Enter
     * sleep, or deep sleep, on return from an ISR to Thread mode.\n Setting
     * this bit to 1 enables an interrupt driven application to avoid returning
     * to an empty main application.
     */
    inline void set_SCR_SLEEPONEXIT() volatile
    {
        SCR |= 1u << 1u;
    }

    /**
     * Clear SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread
     * mode:\n 0 = Do not sleep when returning to Thread mode.\n 1 = Enter
     * sleep, or deep sleep, on return from an ISR to Thread mode.\n Setting
     * this bit to 1 enables an interrupt driven application to avoid returning
     * to an empty main application.
     */
    inline void clear_SCR_SLEEPONEXIT() volatile
    {
        SCR &= ~(1u << 1u);
    }

    /**
     * Toggle SCR's SLEEPONEXIT bit.
     *
     * Indicates sleep-on-exit when returning from Handler mode to Thread
     * mode:\n 0 = Do not sleep when returning to Thread mode.\n 1 = Enter
     * sleep, or deep sleep, on return from an ISR to Thread mode.\n Setting
     * this bit to 1 enables an interrupt driven application to avoid returning
     * to an empty main application.
     */
    inline void toggle_SCR_SLEEPONEXIT() volatile
    {
        SCR ^= 1u << 1u;
    }

    /**
     * Get SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode:\n 0 = Sleep.\n 1 = Deep sleep.
     */
    inline bool get_SCR_SLEEPDEEP() volatile
    {
        return SCR & (1u << 2u);
    }

    /**
     * Set SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode:\n 0 = Sleep.\n 1 = Deep sleep.
     */
    inline void set_SCR_SLEEPDEEP() volatile
    {
        SCR |= 1u << 2u;
    }

    /**
     * Clear SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode:\n 0 = Sleep.\n 1 = Deep sleep.
     */
    inline void clear_SCR_SLEEPDEEP() volatile
    {
        SCR &= ~(1u << 2u);
    }

    /**
     * Toggle SCR's SLEEPDEEP bit.
     *
     * Controls whether the processor uses sleep or deep sleep as its low power
     * mode:\n 0 = Sleep.\n 1 = Deep sleep.
     */
    inline void toggle_SCR_SLEEPDEEP() volatile
    {
        SCR ^= 1u << 2u;
    }

    /**
     * Get SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:\n
     *                 0 = Only enabled interrupts or events can wakeup the
     * processor, disabled interrupts are excluded.\n 1 = Enabled events and
     * all interrupts, including disabled interrupts, can wakeup the
     * processor.\n When an event or interrupt becomes pending, the event
     * signal wakes up the processor from WFE. If the\n processor is not
     * waiting for an event, the event is registered and affects the next
     * WFE.\n The processor also wakes up on execution of an SEV instruction or
     * an external event.
     */
    inline bool get_SCR_SEVONPEND() volatile
    {
        return SCR & (1u << 4u);
    }

    /**
     * Set SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:\n
     *                 0 = Only enabled interrupts or events can wakeup the
     * processor, disabled interrupts are excluded.\n 1 = Enabled events and
     * all interrupts, including disabled interrupts, can wakeup the
     * processor.\n When an event or interrupt becomes pending, the event
     * signal wakes up the processor from WFE. If the\n processor is not
     * waiting for an event, the event is registered and affects the next
     * WFE.\n The processor also wakes up on execution of an SEV instruction or
     * an external event.
     */
    inline void set_SCR_SEVONPEND() volatile
    {
        SCR |= 1u << 4u;
    }

    /**
     * Clear SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:\n
     *                 0 = Only enabled interrupts or events can wakeup the
     * processor, disabled interrupts are excluded.\n 1 = Enabled events and
     * all interrupts, including disabled interrupts, can wakeup the
     * processor.\n When an event or interrupt becomes pending, the event
     * signal wakes up the processor from WFE. If the\n processor is not
     * waiting for an event, the event is registered and affects the next
     * WFE.\n The processor also wakes up on execution of an SEV instruction or
     * an external event.
     */
    inline void clear_SCR_SEVONPEND() volatile
    {
        SCR &= ~(1u << 4u);
    }

    /**
     * Toggle SCR's SEVONPEND bit.
     *
     * Send Event on Pending bit:\n
     *                 0 = Only enabled interrupts or events can wakeup the
     * processor, disabled interrupts are excluded.\n 1 = Enabled events and
     * all interrupts, including disabled interrupts, can wakeup the
     * processor.\n When an event or interrupt becomes pending, the event
     * signal wakes up the processor from WFE. If the\n processor is not
     * waiting for an event, the event is registered and affects the next
     * WFE.\n The processor also wakes up on execution of an SEV instruction or
     * an external event.
     */
    inline void toggle_SCR_SEVONPEND() volatile
    {
        SCR ^= 1u << 4u;
    }

    /**
     * Get all of SCR's bit fields.
     *
     * (read-write) System Control Register. Use the System Control Register
     * for power-management functions: signal to the system when the processor
     * can enter a low power state, control how the processor enters and exits
     * low power states.
     */
    inline void get_SCR(bool &SLEEPONEXIT, bool &SLEEPDEEP,
                        bool &SEVONPEND) volatile
    {
        uint32_t curr = SCR;

        SLEEPONEXIT = curr & (1u << 1u);
        SLEEPDEEP = curr & (1u << 2u);
        SEVONPEND = curr & (1u << 4u);
    }

    /**
     * Set all of SCR's bit fields.
     *
     * (read-write) System Control Register. Use the System Control Register
     * for power-management functions: signal to the system when the processor
     * can enter a low power state, control how the processor enters and exits
     * low power states.
     */
    inline void set_SCR(bool SLEEPONEXIT, bool SLEEPDEEP,
                        bool SEVONPEND) volatile
    {
        uint32_t curr = SCR;

        curr &= ~(0b1u << 1u);
        curr |= (SLEEPONEXIT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SLEEPDEEP & 0b1u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (SEVONPEND & 0b1u) << 4u;

        SCR = curr;
    }

    /**
     * Get CCR's UNALIGN_TRP bit.
     *
     * Always reads as one, indicates that all unaligned accesses generate a
     * HardFault.
     */
    inline bool get_CCR_UNALIGN_TRP() volatile
    {
        return CCR & (1u << 3u);
    }

    /**
     * Get CCR's STKALIGN bit.
     *
     * Always reads as one, indicates 8-byte stack alignment on exception
     * entry. On exception entry, the processor uses bit[9] of the stacked PSR
     * to indicate the stack alignment. On return from the exception it uses
     * this stacked bit to restore the correct stack alignment.
     */
    inline bool get_CCR_STKALIGN() volatile
    {
        return CCR & (1u << 9u);
    }

    /**
     * Get all of CCR's bit fields.
     *
     * (read-only) The Configuration and Control Register permanently enables
     * stack alignment and causes unaligned accesses to result in a Hard Fault.
     */
    inline void get_CCR(bool &UNALIGN_TRP, bool &STKALIGN) volatile
    {
        uint32_t curr = CCR;

        UNALIGN_TRP = curr & (1u << 3u);
        STKALIGN = curr & (1u << 9u);
    }

    /**
     * Get SHPR2's PRI_11 field.
     *
     * Priority of system handler 11, SVCall
     */
    inline uint8_t get_SHPR2_PRI_11() volatile
    {
        return (SHPR2 >> 30u) & 0b11u;
    }

    /**
     * Set SHPR2's PRI_11 field.
     *
     * Priority of system handler 11, SVCall
     */
    inline void set_SHPR2_PRI_11(uint8_t value) volatile
    {
        uint32_t curr = SHPR2;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        SHPR2 = curr;
    }

    /**
     * Get SHPR3's PRI_14 field.
     *
     * Priority of system handler 14, PendSV
     */
    inline uint8_t get_SHPR3_PRI_14() volatile
    {
        return (SHPR3 >> 22u) & 0b11u;
    }

    /**
     * Set SHPR3's PRI_14 field.
     *
     * Priority of system handler 14, PendSV
     */
    inline void set_SHPR3_PRI_14(uint8_t value) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        SHPR3 = curr;
    }

    /**
     * Get SHPR3's PRI_15 field.
     *
     * Priority of system handler 15, SysTick
     */
    inline uint8_t get_SHPR3_PRI_15() volatile
    {
        return (SHPR3 >> 30u) & 0b11u;
    }

    /**
     * Set SHPR3's PRI_15 field.
     *
     * Priority of system handler 15, SysTick
     */
    inline void set_SHPR3_PRI_15(uint8_t value) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        SHPR3 = curr;
    }

    /**
     * Get all of SHPR3's bit fields.
     *
     * (read-write) System handlers are a special class of exception handler
     * that can have their priority set to any of the priority levels. Use the
     * System Handler Priority Register 3 to set the priority of PendSV and
     * SysTick.
     */
    inline void get_SHPR3(uint8_t &PRI_14, uint8_t &PRI_15) volatile
    {
        uint32_t curr = SHPR3;

        PRI_14 = (curr >> 22u) & 0b11u;
        PRI_15 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of SHPR3's bit fields.
     *
     * (read-write) System handlers are a special class of exception handler
     * that can have their priority set to any of the priority levels. Use the
     * System Handler Priority Register 3 to set the priority of PendSV and
     * SysTick.
     */
    inline void set_SHPR3(uint8_t PRI_14, uint8_t PRI_15) volatile
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 22u);
        curr |= (PRI_14 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (PRI_15 & 0b11u) << 30u;

        SHPR3 = curr;
    }

    /**
     * Get SHCSR's SVCALLPENDED bit.
     *
     * Reads as 1 if SVCall is Pending.  Write 1 to set pending SVCall, write 0
     * to clear pending SVCall.
     */
    inline bool get_SHCSR_SVCALLPENDED() volatile
    {
        return SHCSR & (1u << 15u);
    }

    /**
     * Set SHCSR's SVCALLPENDED bit.
     *
     * Reads as 1 if SVCall is Pending.  Write 1 to set pending SVCall, write 0
     * to clear pending SVCall.
     */
    inline void set_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR |= 1u << 15u;
    }

    /**
     * Clear SHCSR's SVCALLPENDED bit.
     *
     * Reads as 1 if SVCall is Pending.  Write 1 to set pending SVCall, write 0
     * to clear pending SVCall.
     */
    inline void clear_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR &= ~(1u << 15u);
    }

    /**
     * Toggle SHCSR's SVCALLPENDED bit.
     *
     * Reads as 1 if SVCall is Pending.  Write 1 to set pending SVCall, write 0
     * to clear pending SVCall.
     */
    inline void toggle_SHCSR_SVCALLPENDED() volatile
    {
        SHCSR ^= 1u << 15u;
    }

    /**
     * Get MPU_TYPE's SEPARATE bit.
     *
     * Indicates support for separate instruction and data address maps. Reads
     * as 0 as ARMv6-M only supports a unified MPU.
     */
    inline bool get_MPU_TYPE_SEPARATE() volatile
    {
        return MPU_TYPE & (1u << 0u);
    }

    /**
     * Get MPU_TYPE's DREGION field.
     *
     * Number of regions supported by the MPU.
     */
    inline uint8_t get_MPU_TYPE_DREGION() volatile
    {
        return (MPU_TYPE >> 8u) & 0b11111111u;
    }

    /**
     * Get MPU_TYPE's IREGION field.
     *
     * Instruction region. Reads as zero as ARMv6-M only supports a unified
     * MPU.
     */
    inline uint8_t get_MPU_TYPE_IREGION() volatile
    {
        return (MPU_TYPE >> 16u) & 0b11111111u;
    }

    /**
     * Get all of MPU_TYPE's bit fields.
     *
     * (read-only) Read the MPU Type Register to determine if the processor
     * implements an MPU, and how many regions the MPU supports.
     */
    inline void get_MPU_TYPE(bool &SEPARATE, uint8_t &DREGION,
                             uint8_t &IREGION) volatile
    {
        uint32_t curr = MPU_TYPE;

        SEPARATE = curr & (1u << 0u);
        DREGION = (curr >> 8u) & 0b11111111u;
        IREGION = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Get MPU_CTRL's ENABLE bit.
     *
     * Enables the MPU. If the MPU is disabled, privileged and unprivileged
     * accesses use the default memory map.\n 0 = MPU disabled.\n 1 = MPU
     * enabled.
     */
    inline bool get_MPU_CTRL_ENABLE() volatile
    {
        return MPU_CTRL & (1u << 0u);
    }

    /**
     * Set MPU_CTRL's ENABLE bit.
     *
     * Enables the MPU. If the MPU is disabled, privileged and unprivileged
     * accesses use the default memory map.\n 0 = MPU disabled.\n 1 = MPU
     * enabled.
     */
    inline void set_MPU_CTRL_ENABLE() volatile
    {
        MPU_CTRL |= 1u << 0u;
    }

    /**
     * Clear MPU_CTRL's ENABLE bit.
     *
     * Enables the MPU. If the MPU is disabled, privileged and unprivileged
     * accesses use the default memory map.\n 0 = MPU disabled.\n 1 = MPU
     * enabled.
     */
    inline void clear_MPU_CTRL_ENABLE() volatile
    {
        MPU_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_CTRL's ENABLE bit.
     *
     * Enables the MPU. If the MPU is disabled, privileged and unprivileged
     * accesses use the default memory map.\n 0 = MPU disabled.\n 1 = MPU
     * enabled.
     */
    inline void toggle_MPU_CTRL_ENABLE() volatile
    {
        MPU_CTRL ^= 1u << 0u;
    }

    /**
     * Get MPU_CTRL's HFNMIENA bit.
     *
     * Controls the use of the MPU for HardFaults and NMIs. Setting this bit
     * when ENABLE is clear results in UNPREDICTABLE behaviour.\n When the MPU
     * is enabled:\n 0 = MPU is disabled during HardFault and NMI handlers,
     * regardless of the value of the ENABLE bit.\n 1 = the MPU is enabled
     * during HardFault and NMI handlers.
     */
    inline bool get_MPU_CTRL_HFNMIENA() volatile
    {
        return MPU_CTRL & (1u << 1u);
    }

    /**
     * Set MPU_CTRL's HFNMIENA bit.
     *
     * Controls the use of the MPU for HardFaults and NMIs. Setting this bit
     * when ENABLE is clear results in UNPREDICTABLE behaviour.\n When the MPU
     * is enabled:\n 0 = MPU is disabled during HardFault and NMI handlers,
     * regardless of the value of the ENABLE bit.\n 1 = the MPU is enabled
     * during HardFault and NMI handlers.
     */
    inline void set_MPU_CTRL_HFNMIENA() volatile
    {
        MPU_CTRL |= 1u << 1u;
    }

    /**
     * Clear MPU_CTRL's HFNMIENA bit.
     *
     * Controls the use of the MPU for HardFaults and NMIs. Setting this bit
     * when ENABLE is clear results in UNPREDICTABLE behaviour.\n When the MPU
     * is enabled:\n 0 = MPU is disabled during HardFault and NMI handlers,
     * regardless of the value of the ENABLE bit.\n 1 = the MPU is enabled
     * during HardFault and NMI handlers.
     */
    inline void clear_MPU_CTRL_HFNMIENA() volatile
    {
        MPU_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MPU_CTRL's HFNMIENA bit.
     *
     * Controls the use of the MPU for HardFaults and NMIs. Setting this bit
     * when ENABLE is clear results in UNPREDICTABLE behaviour.\n When the MPU
     * is enabled:\n 0 = MPU is disabled during HardFault and NMI handlers,
     * regardless of the value of the ENABLE bit.\n 1 = the MPU is enabled
     * during HardFault and NMI handlers.
     */
    inline void toggle_MPU_CTRL_HFNMIENA() volatile
    {
        MPU_CTRL ^= 1u << 1u;
    }

    /**
     * Get MPU_CTRL's PRIVDEFENA bit.
     *
     * Controls whether the default memory map is enabled as a background
     * region for privileged accesses. This bit is ignored when ENABLE is
     * clear.\n 0 = If the MPU is enabled, disables use of the default memory
     * map. Any memory access to a location not\n covered by any enabled region
     * causes a fault.\n 1 = If the MPU is enabled, enables use of the default
     * memory map as a background region for privileged software accesses.\n
     *                 When enabled, the background region acts as if it is
     * region number -1. Any region that is defined and enabled has priority
     * over this default map.
     */
    inline bool get_MPU_CTRL_PRIVDEFENA() volatile
    {
        return MPU_CTRL & (1u << 2u);
    }

    /**
     * Set MPU_CTRL's PRIVDEFENA bit.
     *
     * Controls whether the default memory map is enabled as a background
     * region for privileged accesses. This bit is ignored when ENABLE is
     * clear.\n 0 = If the MPU is enabled, disables use of the default memory
     * map. Any memory access to a location not\n covered by any enabled region
     * causes a fault.\n 1 = If the MPU is enabled, enables use of the default
     * memory map as a background region for privileged software accesses.\n
     *                 When enabled, the background region acts as if it is
     * region number -1. Any region that is defined and enabled has priority
     * over this default map.
     */
    inline void set_MPU_CTRL_PRIVDEFENA() volatile
    {
        MPU_CTRL |= 1u << 2u;
    }

    /**
     * Clear MPU_CTRL's PRIVDEFENA bit.
     *
     * Controls whether the default memory map is enabled as a background
     * region for privileged accesses. This bit is ignored when ENABLE is
     * clear.\n 0 = If the MPU is enabled, disables use of the default memory
     * map. Any memory access to a location not\n covered by any enabled region
     * causes a fault.\n 1 = If the MPU is enabled, enables use of the default
     * memory map as a background region for privileged software accesses.\n
     *                 When enabled, the background region acts as if it is
     * region number -1. Any region that is defined and enabled has priority
     * over this default map.
     */
    inline void clear_MPU_CTRL_PRIVDEFENA() volatile
    {
        MPU_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle MPU_CTRL's PRIVDEFENA bit.
     *
     * Controls whether the default memory map is enabled as a background
     * region for privileged accesses. This bit is ignored when ENABLE is
     * clear.\n 0 = If the MPU is enabled, disables use of the default memory
     * map. Any memory access to a location not\n covered by any enabled region
     * causes a fault.\n 1 = If the MPU is enabled, enables use of the default
     * memory map as a background region for privileged software accesses.\n
     *                 When enabled, the background region acts as if it is
     * region number -1. Any region that is defined and enabled has priority
     * over this default map.
     */
    inline void toggle_MPU_CTRL_PRIVDEFENA() volatile
    {
        MPU_CTRL ^= 1u << 2u;
    }

    /**
     * Get all of MPU_CTRL's bit fields.
     *
     * (read-write) Use the MPU Control Register to enable and disable the MPU,
     * and to control whether the default memory map is enabled as a background
     * region for privileged accesses, and whether the MPU is enabled for
     * HardFaults and NMIs.
     */
    inline void get_MPU_CTRL(bool &ENABLE, bool &HFNMIENA,
                             bool &PRIVDEFENA) volatile
    {
        uint32_t curr = MPU_CTRL;

        ENABLE = curr & (1u << 0u);
        HFNMIENA = curr & (1u << 1u);
        PRIVDEFENA = curr & (1u << 2u);
    }

    /**
     * Set all of MPU_CTRL's bit fields.
     *
     * (read-write) Use the MPU Control Register to enable and disable the MPU,
     * and to control whether the default memory map is enabled as a background
     * region for privileged accesses, and whether the MPU is enabled for
     * HardFaults and NMIs.
     */
    inline void set_MPU_CTRL(bool ENABLE, bool HFNMIENA,
                             bool PRIVDEFENA) volatile
    {
        uint32_t curr = MPU_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HFNMIENA & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (PRIVDEFENA & 0b1u) << 2u;

        MPU_CTRL = curr;
    }

    /**
     * Get MPU_RNR's REGION field.
     *
     * Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR
     * registers.\n The MPU supports 8 memory regions, so the permitted values
     * of this field are 0-7.
     */
    inline uint8_t get_MPU_RNR_REGION() volatile
    {
        return (MPU_RNR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RNR's REGION field.
     *
     * Indicates the MPU region referenced by the MPU_RBAR and MPU_RASR
     * registers.\n The MPU supports 8 memory regions, so the permitted values
     * of this field are 0-7.
     */
    inline void set_MPU_RNR_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RNR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RNR = curr;
    }

    /**
     * Get MPU_RBAR's REGION field.
     *
     * On writes, specifies the number of the region whose base address to
     * update provided VALID is set written as 1. On reads, returns bits [3:0]
     * of MPU_RNR.
     */
    inline uint8_t get_MPU_RBAR_REGION() volatile
    {
        return (MPU_RBAR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR's REGION field.
     *
     * On writes, specifies the number of the region whose base address to
     * update provided VALID is set written as 1. On reads, returns bits [3:0]
     * of MPU_RNR.
     */
    inline void set_MPU_RBAR_REGION(uint8_t value) volatile
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RBAR's VALID bit.
     *
     * On writes, indicates whether the write must update the base address of
     * the region identified by the REGION field, updating the MPU_RNR to
     * indicate this new region.\n Write:\n 0 = MPU_RNR not changed, and the
     * processor:\n Updates the base address for the region specified in the
     * MPU_RNR.\n Ignores the value of the REGION field.\n 1 = The processor:\n
     *                 Updates the value of the MPU_RNR to the value of the
     * REGION field.\n Updates the base address for the region specified in the
     * REGION field.\n Always reads as zero.
     */
    inline bool get_MPU_RBAR_VALID() volatile
    {
        return MPU_RBAR & (1u << 4u);
    }

    /**
     * Set MPU_RBAR's VALID bit.
     *
     * On writes, indicates whether the write must update the base address of
     * the region identified by the REGION field, updating the MPU_RNR to
     * indicate this new region.\n Write:\n 0 = MPU_RNR not changed, and the
     * processor:\n Updates the base address for the region specified in the
     * MPU_RNR.\n Ignores the value of the REGION field.\n 1 = The processor:\n
     *                 Updates the value of the MPU_RNR to the value of the
     * REGION field.\n Updates the base address for the region specified in the
     * REGION field.\n Always reads as zero.
     */
    inline void set_MPU_RBAR_VALID() volatile
    {
        MPU_RBAR |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR's VALID bit.
     *
     * On writes, indicates whether the write must update the base address of
     * the region identified by the REGION field, updating the MPU_RNR to
     * indicate this new region.\n Write:\n 0 = MPU_RNR not changed, and the
     * processor:\n Updates the base address for the region specified in the
     * MPU_RNR.\n Ignores the value of the REGION field.\n 1 = The processor:\n
     *                 Updates the value of the MPU_RNR to the value of the
     * REGION field.\n Updates the base address for the region specified in the
     * REGION field.\n Always reads as zero.
     */
    inline void clear_MPU_RBAR_VALID() volatile
    {
        MPU_RBAR &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR's VALID bit.
     *
     * On writes, indicates whether the write must update the base address of
     * the region identified by the REGION field, updating the MPU_RNR to
     * indicate this new region.\n Write:\n 0 = MPU_RNR not changed, and the
     * processor:\n Updates the base address for the region specified in the
     * MPU_RNR.\n Ignores the value of the REGION field.\n 1 = The processor:\n
     *                 Updates the value of the MPU_RNR to the value of the
     * REGION field.\n Updates the base address for the region specified in the
     * REGION field.\n Always reads as zero.
     */
    inline void toggle_MPU_RBAR_VALID() volatile
    {
        MPU_RBAR ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR's ADDR field.
     *
     * Base address of the region.
     */
    inline uint32_t get_MPU_RBAR_ADDR() volatile
    {
        return (MPU_RBAR >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set MPU_RBAR's ADDR field.
     *
     * Base address of the region.
     */
    inline void set_MPU_RBAR_ADDR(uint32_t value) volatile
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        MPU_RBAR = curr;
    }

    /**
     * Get all of MPU_RBAR's bit fields.
     *
     * (read-write) Read the MPU Region Base Address Register to determine the
     * base address of the region identified by MPU_RNR. Write to update the
     * base address of said region or that of a specified region, with whose
     * number MPU_RNR will also be updated.
     */
    inline void get_MPU_RBAR(uint8_t &REGION, bool &VALID,
                             uint32_t &ADDR) volatile
    {
        uint32_t curr = MPU_RBAR;

        REGION = (curr >> 0u) & 0b1111u;
        VALID = curr & (1u << 4u);
        ADDR = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of MPU_RBAR's bit fields.
     *
     * (read-write) Read the MPU Region Base Address Register to determine the
     * base address of the region identified by MPU_RNR. Write to update the
     * base address of said region or that of a specified region, with whose
     * number MPU_RNR will also be updated.
     */
    inline void set_MPU_RBAR(uint8_t REGION, bool VALID,
                             uint32_t ADDR) volatile
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b1111u << 0u);
        curr |= (REGION & 0b1111u) << 0u;
        curr &= ~(0b1u << 4u);
        curr |= (VALID & 0b1u) << 4u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (ADDR & 0b111111111111111111111111u) << 8u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RASR's ENABLE bit.
     *
     * Enables the region.
     */
    inline bool get_MPU_RASR_ENABLE() volatile
    {
        return MPU_RASR & (1u << 0u);
    }

    /**
     * Set MPU_RASR's ENABLE bit.
     *
     * Enables the region.
     */
    inline void set_MPU_RASR_ENABLE() volatile
    {
        MPU_RASR |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR's ENABLE bit.
     *
     * Enables the region.
     */
    inline void clear_MPU_RASR_ENABLE() volatile
    {
        MPU_RASR &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR's ENABLE bit.
     *
     * Enables the region.
     */
    inline void toggle_MPU_RASR_ENABLE() volatile
    {
        MPU_RASR ^= 1u << 0u;
    }

    /**
     * Get MPU_RASR's SIZE field.
     *
     * Indicates the region size. Region size in bytes = 2^(SIZE+1). The
     * minimum permitted value is 7 (b00111) = 256Bytes
     */
    inline uint8_t get_MPU_RASR_SIZE() volatile
    {
        return (MPU_RASR >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR's SIZE field.
     *
     * Indicates the region size. Region size in bytes = 2^(SIZE+1). The
     * minimum permitted value is 7 (b00111) = 256Bytes
     */
    inline void set_MPU_RASR_SIZE(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's SRD field.
     *
     * Subregion Disable. For regions of 256 bytes or larger, each bit of this
     * field controls whether one of the eight equal subregions is enabled.
     */
    inline uint8_t get_MPU_RASR_SRD() volatile
    {
        return (MPU_RASR >> 8u) & 0b11111111u;
    }

    /**
     * Set MPU_RASR's SRD field.
     *
     * Subregion Disable. For regions of 256 bytes or larger, each bit of this
     * field controls whether one of the eight equal subregions is enabled.
     */
    inline void set_MPU_RASR_SRD(uint8_t value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's ATTRS field.
     *
     * The MPU Region Attribute field. Use to define the region attribute
     * control.\n 28 = XN: Instruction access disable bit:\n 0 = Instruction
     * fetches enabled.\n 1 = Instruction fetches disabled.\n 26:24 = AP:
     * Access permission field\n 18 = S: Shareable bit\n 17 = C: Cacheable
     * bit\n 16 = B: Bufferable bit
     */
    inline uint16_t get_MPU_RASR_ATTRS() volatile
    {
        return (MPU_RASR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MPU_RASR's ATTRS field.
     *
     * The MPU Region Attribute field. Use to define the region attribute
     * control.\n 28 = XN: Instruction access disable bit:\n 0 = Instruction
     * fetches enabled.\n 1 = Instruction fetches disabled.\n 26:24 = AP:
     * Access permission field\n 18 = S: Shareable bit\n 17 = C: Cacheable
     * bit\n 16 = B: Bufferable bit
     */
    inline void set_MPU_RASR_ATTRS(uint16_t value) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MPU_RASR = curr;
    }

    /**
     * Get all of MPU_RASR's bit fields.
     *
     * (read-write) Use the MPU Region Attribute and Size Register to define
     * the size, access behaviour and memory type of the region identified by
     * MPU_RNR, and enable that region.
     */
    inline void get_MPU_RASR(bool &ENABLE, uint8_t &SIZE, uint8_t &SRD,
                             uint16_t &ATTRS) volatile
    {
        uint32_t curr = MPU_RASR;

        ENABLE = curr & (1u << 0u);
        SIZE = (curr >> 1u) & 0b11111u;
        SRD = (curr >> 8u) & 0b11111111u;
        ATTRS = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of MPU_RASR's bit fields.
     *
     * (read-write) Use the MPU Region Attribute and Size Register to define
     * the size, access behaviour and memory type of the region identified by
     * MPU_RNR, and enable that region.
     */
    inline void set_MPU_RASR(bool ENABLE, uint8_t SIZE, uint8_t SRD,
                             uint16_t ATTRS) volatile
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;
        curr &= ~(0b11111u << 1u);
        curr |= (SIZE & 0b11111u) << 1u;
        curr &= ~(0b11111111u << 8u);
        curr |= (SRD & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (ATTRS & 0b1111111111111111u) << 16u;

        MPU_RASR = curr;
    }
};

static_assert(sizeof(ppb) == ppb::size);

static volatile ppb *const PPB = reinterpret_cast<ppb *>(0xe0000000);

}; // namespace RP2040
