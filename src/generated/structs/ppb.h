/**
 * \file
 * \brief Generated by ifgen (3.1.0).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] ppb
{
    /* Constant attributes. */
    static constexpr std::size_t size = 60836; /*!< ppb's size in bytes. */

    /* Fields. */
    static constexpr std::size_t reserved_padding0_length = 14340;
    const uint32_t reserved_padding0[reserved_padding0_length] = {};
    uint32_t SYST_CSR; /*!< (read-write) Use the SysTick Control and Status
                          Register to enable the SysTick features. */
    uint32_t SYST_RVR; /*!< (read-write) Use the SysTick Reload Value Register
to specify the start value to load into the current value register when the
counter reaches 0. It can be any value between 0 and 0x00FFFFFF. A start value
of 0 is possible, but has no effect because the SysTick interrupt and COUNTFLAG
are activated when counting from 1 to 0. The reset value of this register is
UNKNOWN.\n To generate a multi-shot timer with a period of N processor clock
cycles, use a RELOAD value of N-1. For example, if the SysTick interrupt is
required every 100 clock pulses, set RELOAD to 99. */
    uint32_t SYST_CVR; /*!< (read-write) Use the SysTick Current Value Register
                          to find the current value in the register. The reset
                          value of this register is UNKNOWN. */
    const uint32_t SYST_CALIB =
        {}; /*!< (read-only) Use the SysTick Calibration Value Register to
               enable software to scale to any required speed using divide and
               multiply. */
    static constexpr std::size_t reserved_padding1_length = 56;
    const uint32_t reserved_padding1[reserved_padding1_length] = {};
    uint32_t NVIC_ISER; /*!< (read-write) Use the Interrupt Set-Enable Register
to enable interrupts and determine which interrupts are currently enabled.\n If
a pending interrupt is enabled, the NVIC activates the interrupt based on its
priority. If an interrupt is not enabled, asserting its interrupt signal
changes the interrupt state to pending, but the NVIC never activates the
interrupt, regardless of its priority. */
    static constexpr std::size_t reserved_padding2_length = 31;
    const uint32_t reserved_padding2[reserved_padding2_length] = {};
    uint32_t NVIC_ICER; /*!< (read-write) Use the Interrupt Clear-Enable
                           Registers to disable interrupts and determine which
                           interrupts are currently enabled. */
    static constexpr std::size_t reserved_padding3_length = 31;
    const uint32_t reserved_padding3[reserved_padding3_length] = {};
    uint32_t
        NVIC_ISPR; /*!< (read-write) The NVIC_ISPR forces interrupts into the
                      pending state, and shows which interrupts are pending. */
    static constexpr std::size_t reserved_padding4_length = 31;
    const uint32_t reserved_padding4[reserved_padding4_length] = {};
    uint32_t NVIC_ICPR; /*!< (read-write) Use the Interrupt Clear-Pending
                           Register to clear pending interrupts and determine
                           which interrupts are currently pending. */
    static constexpr std::size_t reserved_padding5_length = 95;
    const uint32_t reserved_padding5[reserved_padding5_length] = {};
    uint32_t NVIC_IPR0; /*!< (read-write) Use the Interrupt Priority Registers
to assign a priority from 0 to 3 to each of the available interrupts. 0 is the
highest priority, and 3 is the lowest.\n Note: Writing 1 to an NVIC_ICPR bit
does not affect the active state of the corresponding interrupt.\n These
registers are only word-accessible */
    uint32_t NVIC_IPR1; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR2; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR3; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR4; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR5; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR6; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    uint32_t NVIC_IPR7; /*!< (read-write) Use the Interrupt Priority Registers
                           to assign a priority from 0 to 3 to each of the
                           available interrupts. 0 is the highest priority, and
                           3 is the lowest. */
    static constexpr std::size_t reserved_padding6_length = 568;
    const uint32_t reserved_padding6[reserved_padding6_length] = {};
    const uint32_t CPUID =
        {}; /*!< (read-only) Read the CPU ID Base Register to determine: the ID
               number of the processor core, the version number of the
               processor core, the implementation details of the processor
               core. */
    uint32_t ICSR;  /*!< (read-write) Use the Interrupt Control State Register
                       to set a pending Non-Maskable Interrupt (NMI), set or
                       clear a pending PendSV, set or clear a pending SysTick,
                       check for pending exceptions, check the vector number of
                       the highest priority pended exception, check the vector
                       number of the active exception. */
    uint32_t VTOR;  /*!< (read-write) The VTOR holds the vector table offset
                       address. */
    uint32_t AIRCR; /*!< (read-write) Use the Application Interrupt and Reset
                       Control Register to: determine data endianness, clear
                       all active state information from debug halt mode,
                       request a system reset. */
    uint32_t
        SCR; /*!< (read-write) System Control Register. Use the System Control
                Register for power-management functions: signal to the system
                when the processor can enter a low power state, control how the
                processor enters and exits low power states. */
    const uint32_t CCR =
        {}; /*!< (read-only) The Configuration and Control Register permanently
               enables stack alignment and causes unaligned accesses to result
               in a Hard Fault. */
    const uint32_t reserved_padding7 = {};
    uint32_t SHPR2; /*!< (read-write) System handlers are a special class of
                       exception handler that can have their priority set to
                       any of the priority levels. Use the System Handler
                       Priority Register 2 to set the priority of SVCall. */
    uint32_t
        SHPR3;      /*!< (read-write) System handlers are a special class of
                       exception handler that can have their priority set to any of
                       the priority levels. Use the System Handler Priority Register
                       3 to set the priority of PendSV and SysTick. */
    uint32_t SHCSR; /*!< (read-write) Use the System Handler Control and State
                       Register to determine or clear the pending status of
                       SVCall. */
    static constexpr std::size_t reserved_padding8_length = 26;
    const uint32_t reserved_padding8[reserved_padding8_length] = {};
    const uint32_t MPU_TYPE =
        {}; /*!< (read-only) Read the MPU Type Register to determine if the
               processor implements an MPU, and how many regions the MPU
               supports. */
    uint32_t MPU_CTRL; /*!< (read-write) Use the MPU Control Register to enable
                          and disable the MPU, and to control whether the
                          default memory map is enabled as a background region
                          for privileged accesses, and whether the MPU is
                          enabled for HardFaults and NMIs. */
    uint32_t
        MPU_RNR; /*!< (read-write) Use the MPU Region Number Register to select
                    the region currently accessed by MPU_RBAR and MPU_RASR. */
    uint32_t MPU_RBAR; /*!< (read-write) Read the MPU Region Base Address
                          Register to determine the base address of the region
                          identified by MPU_RNR. Write to update the base
                          address of said region or that of a specified region,
                          with whose number MPU_RNR will also be updated. */
    uint32_t MPU_RASR; /*!< (read-write) Use the MPU Region Attribute and Size
                          Register to define the size, access behaviour and
                          memory type of the region identified by MPU_RNR, and
                          enable that region. */

    /* Methods. */

    /**
     * Get SYST_CSR's ENABLE bit.
     */
    inline bool get_SYST_CSR_ENABLE()
    {
        return SYST_CSR & (1u << 0u);
    }

    /**
     * Set SYST_CSR's ENABLE bit.
     */
    inline void set_SYST_CSR_ENABLE()
    {
        SYST_CSR |= 1u << 0u;
    }

    /**
     * Clear SYST_CSR's ENABLE bit.
     */
    inline void clear_SYST_CSR_ENABLE()
    {
        SYST_CSR &= ~(1u << 0u);
    }

    /**
     * Toggle SYST_CSR's ENABLE bit.
     */
    inline void toggle_SYST_CSR_ENABLE()
    {
        SYST_CSR ^= 1u << 0u;
    }

    /**
     * Get SYST_CSR's TICKINT bit.
     */
    inline bool get_SYST_CSR_TICKINT()
    {
        return SYST_CSR & (1u << 1u);
    }

    /**
     * Set SYST_CSR's TICKINT bit.
     */
    inline void set_SYST_CSR_TICKINT()
    {
        SYST_CSR |= 1u << 1u;
    }

    /**
     * Clear SYST_CSR's TICKINT bit.
     */
    inline void clear_SYST_CSR_TICKINT()
    {
        SYST_CSR &= ~(1u << 1u);
    }

    /**
     * Toggle SYST_CSR's TICKINT bit.
     */
    inline void toggle_SYST_CSR_TICKINT()
    {
        SYST_CSR ^= 1u << 1u;
    }

    /**
     * Get SYST_CSR's CLKSOURCE bit.
     */
    inline bool get_SYST_CSR_CLKSOURCE()
    {
        return SYST_CSR & (1u << 2u);
    }

    /**
     * Set SYST_CSR's CLKSOURCE bit.
     */
    inline void set_SYST_CSR_CLKSOURCE()
    {
        SYST_CSR |= 1u << 2u;
    }

    /**
     * Clear SYST_CSR's CLKSOURCE bit.
     */
    inline void clear_SYST_CSR_CLKSOURCE()
    {
        SYST_CSR &= ~(1u << 2u);
    }

    /**
     * Toggle SYST_CSR's CLKSOURCE bit.
     */
    inline void toggle_SYST_CSR_CLKSOURCE()
    {
        SYST_CSR ^= 1u << 2u;
    }

    /**
     * Get SYST_CSR's COUNTFLAG bit.
     */
    inline bool get_SYST_CSR_COUNTFLAG()
    {
        return SYST_CSR & (1u << 16u);
    }

    /**
     * Get all of SYST_CSR's bit fields.
     */
    inline void get_SYST_CSR(bool &ENABLE, bool &TICKINT, bool &CLKSOURCE,
                             bool &COUNTFLAG)
    {
        uint32_t curr = SYST_CSR;

        ENABLE = curr & (1u << 0u);
        TICKINT = curr & (1u << 1u);
        CLKSOURCE = curr & (1u << 2u);
        COUNTFLAG = curr & (1u << 16u);
    }

    /**
     * Set all of SYST_CSR's bit fields.
     */
    inline void set_SYST_CSR(bool ENABLE, bool TICKINT, bool CLKSOURCE)
    {
        uint32_t curr = SYST_CSR;

        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TICKINT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (CLKSOURCE & 0b1u) << 2u;

        SYST_CSR = curr;
    }

    /**
     * Get SYST_RVR's RELOAD field.
     */
    inline uint32_t get_SYST_RVR_RELOAD()
    {
        return (SYST_RVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_RVR's RELOAD field.
     */
    inline void set_SYST_RVR_RELOAD(uint32_t value)
    {
        uint32_t curr = SYST_RVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_RVR = curr;
    }

    /**
     * Get SYST_CVR's CURRENT field.
     */
    inline uint32_t get_SYST_CVR_CURRENT()
    {
        return (SYST_CVR >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Set SYST_CVR's CURRENT field.
     */
    inline void set_SYST_CVR_CURRENT(uint32_t value)
    {
        uint32_t curr = SYST_CVR;

        curr &= ~(0b111111111111111111111111u << 0u);
        curr |= (value & 0b111111111111111111111111u) << 0u;

        SYST_CVR = curr;
    }

    /**
     * Get SYST_CALIB's TENMS field.
     */
    inline uint32_t get_SYST_CALIB_TENMS()
    {
        return (SYST_CALIB >> 0u) & 0b111111111111111111111111u;
    }

    /**
     * Get SYST_CALIB's SKEW bit.
     */
    inline bool get_SYST_CALIB_SKEW()
    {
        return SYST_CALIB & (1u << 30u);
    }

    /**
     * Get SYST_CALIB's NOREF bit.
     */
    inline bool get_SYST_CALIB_NOREF()
    {
        return SYST_CALIB & (1u << 31u);
    }

    /**
     * Get all of SYST_CALIB's bit fields.
     */
    inline void get_SYST_CALIB(uint32_t &TENMS, bool &SKEW, bool &NOREF)
    {
        uint32_t curr = SYST_CALIB;

        TENMS = (curr >> 0u) & 0b111111111111111111111111u;
        SKEW = curr & (1u << 30u);
        NOREF = curr & (1u << 31u);
    }

    /**
     * Get NVIC_ISER's SETENA field.
     */
    inline uint32_t get_NVIC_ISER_SETENA()
    {
        return (NVIC_ISER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ISER's SETENA field.
     */
    inline void set_NVIC_ISER_SETENA(uint32_t value)
    {
        uint32_t curr = NVIC_ISER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ISER = curr;
    }

    /**
     * Get NVIC_ICER's CLRENA field.
     */
    inline uint32_t get_NVIC_ICER_CLRENA()
    {
        return (NVIC_ICER >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ICER's CLRENA field.
     */
    inline void set_NVIC_ICER_CLRENA(uint32_t value)
    {
        uint32_t curr = NVIC_ICER;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ICER = curr;
    }

    /**
     * Get NVIC_ISPR's SETPEND field.
     */
    inline uint32_t get_NVIC_ISPR_SETPEND()
    {
        return (NVIC_ISPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ISPR's SETPEND field.
     */
    inline void set_NVIC_ISPR_SETPEND(uint32_t value)
    {
        uint32_t curr = NVIC_ISPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ISPR = curr;
    }

    /**
     * Get NVIC_ICPR's CLRPEND field.
     */
    inline uint32_t get_NVIC_ICPR_CLRPEND()
    {
        return (NVIC_ICPR >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set NVIC_ICPR's CLRPEND field.
     */
    inline void set_NVIC_ICPR_CLRPEND(uint32_t value)
    {
        uint32_t curr = NVIC_ICPR;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        NVIC_ICPR = curr;
    }

    /**
     * Get NVIC_IPR0's IP_0 field.
     */
    inline uint8_t get_NVIC_IPR0_IP_0()
    {
        return (NVIC_IPR0 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_0 field.
     */
    inline void set_NVIC_IPR0_IP_0(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_1 field.
     */
    inline uint8_t get_NVIC_IPR0_IP_1()
    {
        return (NVIC_IPR0 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_1 field.
     */
    inline void set_NVIC_IPR0_IP_1(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_2 field.
     */
    inline uint8_t get_NVIC_IPR0_IP_2()
    {
        return (NVIC_IPR0 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_2 field.
     */
    inline void set_NVIC_IPR0_IP_2(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR0's IP_3 field.
     */
    inline uint8_t get_NVIC_IPR0_IP_3()
    {
        return (NVIC_IPR0 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR0's IP_3 field.
     */
    inline void set_NVIC_IPR0_IP_3(uint8_t value)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get all of NVIC_IPR0's bit fields.
     */
    inline void get_NVIC_IPR0(uint8_t &IP_0, uint8_t &IP_1, uint8_t &IP_2,
                              uint8_t &IP_3)
    {
        uint32_t curr = NVIC_IPR0;

        IP_0 = (curr >> 6u) & 0b11u;
        IP_1 = (curr >> 14u) & 0b11u;
        IP_2 = (curr >> 22u) & 0b11u;
        IP_3 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR0's bit fields.
     */
    inline void set_NVIC_IPR0(uint8_t IP_0, uint8_t IP_1, uint8_t IP_2,
                              uint8_t IP_3)
    {
        uint32_t curr = NVIC_IPR0;

        curr &= ~(0b11u << 6u);
        curr |= (IP_0 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_1 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_2 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_3 & 0b11u) << 30u;

        NVIC_IPR0 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_4 field.
     */
    inline uint8_t get_NVIC_IPR1_IP_4()
    {
        return (NVIC_IPR1 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_4 field.
     */
    inline void set_NVIC_IPR1_IP_4(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_5 field.
     */
    inline uint8_t get_NVIC_IPR1_IP_5()
    {
        return (NVIC_IPR1 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_5 field.
     */
    inline void set_NVIC_IPR1_IP_5(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_6 field.
     */
    inline uint8_t get_NVIC_IPR1_IP_6()
    {
        return (NVIC_IPR1 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_6 field.
     */
    inline void set_NVIC_IPR1_IP_6(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR1's IP_7 field.
     */
    inline uint8_t get_NVIC_IPR1_IP_7()
    {
        return (NVIC_IPR1 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR1's IP_7 field.
     */
    inline void set_NVIC_IPR1_IP_7(uint8_t value)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get all of NVIC_IPR1's bit fields.
     */
    inline void get_NVIC_IPR1(uint8_t &IP_4, uint8_t &IP_5, uint8_t &IP_6,
                              uint8_t &IP_7)
    {
        uint32_t curr = NVIC_IPR1;

        IP_4 = (curr >> 6u) & 0b11u;
        IP_5 = (curr >> 14u) & 0b11u;
        IP_6 = (curr >> 22u) & 0b11u;
        IP_7 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR1's bit fields.
     */
    inline void set_NVIC_IPR1(uint8_t IP_4, uint8_t IP_5, uint8_t IP_6,
                              uint8_t IP_7)
    {
        uint32_t curr = NVIC_IPR1;

        curr &= ~(0b11u << 6u);
        curr |= (IP_4 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_5 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_6 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_7 & 0b11u) << 30u;

        NVIC_IPR1 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_8 field.
     */
    inline uint8_t get_NVIC_IPR2_IP_8()
    {
        return (NVIC_IPR2 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_8 field.
     */
    inline void set_NVIC_IPR2_IP_8(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_9 field.
     */
    inline uint8_t get_NVIC_IPR2_IP_9()
    {
        return (NVIC_IPR2 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_9 field.
     */
    inline void set_NVIC_IPR2_IP_9(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_10 field.
     */
    inline uint8_t get_NVIC_IPR2_IP_10()
    {
        return (NVIC_IPR2 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_10 field.
     */
    inline void set_NVIC_IPR2_IP_10(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR2's IP_11 field.
     */
    inline uint8_t get_NVIC_IPR2_IP_11()
    {
        return (NVIC_IPR2 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR2's IP_11 field.
     */
    inline void set_NVIC_IPR2_IP_11(uint8_t value)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get all of NVIC_IPR2's bit fields.
     */
    inline void get_NVIC_IPR2(uint8_t &IP_8, uint8_t &IP_9, uint8_t &IP_10,
                              uint8_t &IP_11)
    {
        uint32_t curr = NVIC_IPR2;

        IP_8 = (curr >> 6u) & 0b11u;
        IP_9 = (curr >> 14u) & 0b11u;
        IP_10 = (curr >> 22u) & 0b11u;
        IP_11 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR2's bit fields.
     */
    inline void set_NVIC_IPR2(uint8_t IP_8, uint8_t IP_9, uint8_t IP_10,
                              uint8_t IP_11)
    {
        uint32_t curr = NVIC_IPR2;

        curr &= ~(0b11u << 6u);
        curr |= (IP_8 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_9 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_10 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_11 & 0b11u) << 30u;

        NVIC_IPR2 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_12 field.
     */
    inline uint8_t get_NVIC_IPR3_IP_12()
    {
        return (NVIC_IPR3 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_12 field.
     */
    inline void set_NVIC_IPR3_IP_12(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_13 field.
     */
    inline uint8_t get_NVIC_IPR3_IP_13()
    {
        return (NVIC_IPR3 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_13 field.
     */
    inline void set_NVIC_IPR3_IP_13(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_14 field.
     */
    inline uint8_t get_NVIC_IPR3_IP_14()
    {
        return (NVIC_IPR3 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_14 field.
     */
    inline void set_NVIC_IPR3_IP_14(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR3's IP_15 field.
     */
    inline uint8_t get_NVIC_IPR3_IP_15()
    {
        return (NVIC_IPR3 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR3's IP_15 field.
     */
    inline void set_NVIC_IPR3_IP_15(uint8_t value)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get all of NVIC_IPR3's bit fields.
     */
    inline void get_NVIC_IPR3(uint8_t &IP_12, uint8_t &IP_13, uint8_t &IP_14,
                              uint8_t &IP_15)
    {
        uint32_t curr = NVIC_IPR3;

        IP_12 = (curr >> 6u) & 0b11u;
        IP_13 = (curr >> 14u) & 0b11u;
        IP_14 = (curr >> 22u) & 0b11u;
        IP_15 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR3's bit fields.
     */
    inline void set_NVIC_IPR3(uint8_t IP_12, uint8_t IP_13, uint8_t IP_14,
                              uint8_t IP_15)
    {
        uint32_t curr = NVIC_IPR3;

        curr &= ~(0b11u << 6u);
        curr |= (IP_12 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_13 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_14 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_15 & 0b11u) << 30u;

        NVIC_IPR3 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_16 field.
     */
    inline uint8_t get_NVIC_IPR4_IP_16()
    {
        return (NVIC_IPR4 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_16 field.
     */
    inline void set_NVIC_IPR4_IP_16(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_17 field.
     */
    inline uint8_t get_NVIC_IPR4_IP_17()
    {
        return (NVIC_IPR4 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_17 field.
     */
    inline void set_NVIC_IPR4_IP_17(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_18 field.
     */
    inline uint8_t get_NVIC_IPR4_IP_18()
    {
        return (NVIC_IPR4 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_18 field.
     */
    inline void set_NVIC_IPR4_IP_18(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR4's IP_19 field.
     */
    inline uint8_t get_NVIC_IPR4_IP_19()
    {
        return (NVIC_IPR4 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR4's IP_19 field.
     */
    inline void set_NVIC_IPR4_IP_19(uint8_t value)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get all of NVIC_IPR4's bit fields.
     */
    inline void get_NVIC_IPR4(uint8_t &IP_16, uint8_t &IP_17, uint8_t &IP_18,
                              uint8_t &IP_19)
    {
        uint32_t curr = NVIC_IPR4;

        IP_16 = (curr >> 6u) & 0b11u;
        IP_17 = (curr >> 14u) & 0b11u;
        IP_18 = (curr >> 22u) & 0b11u;
        IP_19 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR4's bit fields.
     */
    inline void set_NVIC_IPR4(uint8_t IP_16, uint8_t IP_17, uint8_t IP_18,
                              uint8_t IP_19)
    {
        uint32_t curr = NVIC_IPR4;

        curr &= ~(0b11u << 6u);
        curr |= (IP_16 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_17 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_18 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_19 & 0b11u) << 30u;

        NVIC_IPR4 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_20 field.
     */
    inline uint8_t get_NVIC_IPR5_IP_20()
    {
        return (NVIC_IPR5 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_20 field.
     */
    inline void set_NVIC_IPR5_IP_20(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_21 field.
     */
    inline uint8_t get_NVIC_IPR5_IP_21()
    {
        return (NVIC_IPR5 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_21 field.
     */
    inline void set_NVIC_IPR5_IP_21(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_22 field.
     */
    inline uint8_t get_NVIC_IPR5_IP_22()
    {
        return (NVIC_IPR5 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_22 field.
     */
    inline void set_NVIC_IPR5_IP_22(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR5's IP_23 field.
     */
    inline uint8_t get_NVIC_IPR5_IP_23()
    {
        return (NVIC_IPR5 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR5's IP_23 field.
     */
    inline void set_NVIC_IPR5_IP_23(uint8_t value)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get all of NVIC_IPR5's bit fields.
     */
    inline void get_NVIC_IPR5(uint8_t &IP_20, uint8_t &IP_21, uint8_t &IP_22,
                              uint8_t &IP_23)
    {
        uint32_t curr = NVIC_IPR5;

        IP_20 = (curr >> 6u) & 0b11u;
        IP_21 = (curr >> 14u) & 0b11u;
        IP_22 = (curr >> 22u) & 0b11u;
        IP_23 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR5's bit fields.
     */
    inline void set_NVIC_IPR5(uint8_t IP_20, uint8_t IP_21, uint8_t IP_22,
                              uint8_t IP_23)
    {
        uint32_t curr = NVIC_IPR5;

        curr &= ~(0b11u << 6u);
        curr |= (IP_20 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_21 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_22 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_23 & 0b11u) << 30u;

        NVIC_IPR5 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_24 field.
     */
    inline uint8_t get_NVIC_IPR6_IP_24()
    {
        return (NVIC_IPR6 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_24 field.
     */
    inline void set_NVIC_IPR6_IP_24(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_25 field.
     */
    inline uint8_t get_NVIC_IPR6_IP_25()
    {
        return (NVIC_IPR6 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_25 field.
     */
    inline void set_NVIC_IPR6_IP_25(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_26 field.
     */
    inline uint8_t get_NVIC_IPR6_IP_26()
    {
        return (NVIC_IPR6 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_26 field.
     */
    inline void set_NVIC_IPR6_IP_26(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR6's IP_27 field.
     */
    inline uint8_t get_NVIC_IPR6_IP_27()
    {
        return (NVIC_IPR6 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR6's IP_27 field.
     */
    inline void set_NVIC_IPR6_IP_27(uint8_t value)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get all of NVIC_IPR6's bit fields.
     */
    inline void get_NVIC_IPR6(uint8_t &IP_24, uint8_t &IP_25, uint8_t &IP_26,
                              uint8_t &IP_27)
    {
        uint32_t curr = NVIC_IPR6;

        IP_24 = (curr >> 6u) & 0b11u;
        IP_25 = (curr >> 14u) & 0b11u;
        IP_26 = (curr >> 22u) & 0b11u;
        IP_27 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR6's bit fields.
     */
    inline void set_NVIC_IPR6(uint8_t IP_24, uint8_t IP_25, uint8_t IP_26,
                              uint8_t IP_27)
    {
        uint32_t curr = NVIC_IPR6;

        curr &= ~(0b11u << 6u);
        curr |= (IP_24 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_25 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_26 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_27 & 0b11u) << 30u;

        NVIC_IPR6 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_28 field.
     */
    inline uint8_t get_NVIC_IPR7_IP_28()
    {
        return (NVIC_IPR7 >> 6u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_28 field.
     */
    inline void set_NVIC_IPR7_IP_28(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 6u);
        curr |= (value & 0b11u) << 6u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_29 field.
     */
    inline uint8_t get_NVIC_IPR7_IP_29()
    {
        return (NVIC_IPR7 >> 14u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_29 field.
     */
    inline void set_NVIC_IPR7_IP_29(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 14u);
        curr |= (value & 0b11u) << 14u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_30 field.
     */
    inline uint8_t get_NVIC_IPR7_IP_30()
    {
        return (NVIC_IPR7 >> 22u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_30 field.
     */
    inline void set_NVIC_IPR7_IP_30(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get NVIC_IPR7's IP_31 field.
     */
    inline uint8_t get_NVIC_IPR7_IP_31()
    {
        return (NVIC_IPR7 >> 30u) & 0b11u;
    }

    /**
     * Set NVIC_IPR7's IP_31 field.
     */
    inline void set_NVIC_IPR7_IP_31(uint8_t value)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get all of NVIC_IPR7's bit fields.
     */
    inline void get_NVIC_IPR7(uint8_t &IP_28, uint8_t &IP_29, uint8_t &IP_30,
                              uint8_t &IP_31)
    {
        uint32_t curr = NVIC_IPR7;

        IP_28 = (curr >> 6u) & 0b11u;
        IP_29 = (curr >> 14u) & 0b11u;
        IP_30 = (curr >> 22u) & 0b11u;
        IP_31 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of NVIC_IPR7's bit fields.
     */
    inline void set_NVIC_IPR7(uint8_t IP_28, uint8_t IP_29, uint8_t IP_30,
                              uint8_t IP_31)
    {
        uint32_t curr = NVIC_IPR7;

        curr &= ~(0b11u << 6u);
        curr |= (IP_28 & 0b11u) << 6u;
        curr &= ~(0b11u << 14u);
        curr |= (IP_29 & 0b11u) << 14u;
        curr &= ~(0b11u << 22u);
        curr |= (IP_30 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (IP_31 & 0b11u) << 30u;

        NVIC_IPR7 = curr;
    }

    /**
     * Get CPUID's REVISION field.
     */
    inline uint8_t get_CPUID_REVISION()
    {
        return (CPUID >> 0u) & 0b1111u;
    }

    /**
     * Get CPUID's PARTNO field.
     */
    inline uint16_t get_CPUID_PARTNO()
    {
        return (CPUID >> 4u) & 0b111111111111u;
    }

    /**
     * Get CPUID's ARCHITECTURE field.
     */
    inline uint8_t get_CPUID_ARCHITECTURE()
    {
        return (CPUID >> 16u) & 0b1111u;
    }

    /**
     * Get CPUID's VARIANT field.
     */
    inline uint8_t get_CPUID_VARIANT()
    {
        return (CPUID >> 20u) & 0b1111u;
    }

    /**
     * Get CPUID's IMPLEMENTER field.
     */
    inline uint8_t get_CPUID_IMPLEMENTER()
    {
        return (CPUID >> 24u) & 0b11111111u;
    }

    /**
     * Get all of CPUID's bit fields.
     */
    inline void get_CPUID(uint8_t &REVISION, uint16_t &PARTNO,
                          uint8_t &ARCHITECTURE, uint8_t &VARIANT,
                          uint8_t &IMPLEMENTER)
    {
        uint32_t curr = CPUID;

        REVISION = (curr >> 0u) & 0b1111u;
        PARTNO = (curr >> 4u) & 0b111111111111u;
        ARCHITECTURE = (curr >> 16u) & 0b1111u;
        VARIANT = (curr >> 20u) & 0b1111u;
        IMPLEMENTER = (curr >> 24u) & 0b11111111u;
    }

    /**
     * Get ICSR's VECTACTIVE field.
     */
    inline uint16_t get_ICSR_VECTACTIVE()
    {
        return (ICSR >> 0u) & 0b111111111u;
    }

    /**
     * Get ICSR's VECTPENDING field.
     */
    inline uint16_t get_ICSR_VECTPENDING()
    {
        return (ICSR >> 12u) & 0b111111111u;
    }

    /**
     * Get ICSR's ISRPENDING bit.
     */
    inline bool get_ICSR_ISRPENDING()
    {
        return ICSR & (1u << 22u);
    }

    /**
     * Get ICSR's ISRPREEMPT bit.
     */
    inline bool get_ICSR_ISRPREEMPT()
    {
        return ICSR & (1u << 23u);
    }

    /**
     * Get ICSR's PENDSTCLR bit.
     */
    inline bool get_ICSR_PENDSTCLR()
    {
        return ICSR & (1u << 25u);
    }

    /**
     * Set ICSR's PENDSTCLR bit.
     */
    inline void set_ICSR_PENDSTCLR()
    {
        ICSR |= 1u << 25u;
    }

    /**
     * Clear ICSR's PENDSTCLR bit.
     */
    inline void clear_ICSR_PENDSTCLR()
    {
        ICSR &= ~(1u << 25u);
    }

    /**
     * Toggle ICSR's PENDSTCLR bit.
     */
    inline void toggle_ICSR_PENDSTCLR()
    {
        ICSR ^= 1u << 25u;
    }

    /**
     * Get ICSR's PENDSTSET bit.
     */
    inline bool get_ICSR_PENDSTSET()
    {
        return ICSR & (1u << 26u);
    }

    /**
     * Set ICSR's PENDSTSET bit.
     */
    inline void set_ICSR_PENDSTSET()
    {
        ICSR |= 1u << 26u;
    }

    /**
     * Clear ICSR's PENDSTSET bit.
     */
    inline void clear_ICSR_PENDSTSET()
    {
        ICSR &= ~(1u << 26u);
    }

    /**
     * Toggle ICSR's PENDSTSET bit.
     */
    inline void toggle_ICSR_PENDSTSET()
    {
        ICSR ^= 1u << 26u;
    }

    /**
     * Get ICSR's PENDSVCLR bit.
     */
    inline bool get_ICSR_PENDSVCLR()
    {
        return ICSR & (1u << 27u);
    }

    /**
     * Set ICSR's PENDSVCLR bit.
     */
    inline void set_ICSR_PENDSVCLR()
    {
        ICSR |= 1u << 27u;
    }

    /**
     * Clear ICSR's PENDSVCLR bit.
     */
    inline void clear_ICSR_PENDSVCLR()
    {
        ICSR &= ~(1u << 27u);
    }

    /**
     * Toggle ICSR's PENDSVCLR bit.
     */
    inline void toggle_ICSR_PENDSVCLR()
    {
        ICSR ^= 1u << 27u;
    }

    /**
     * Get ICSR's PENDSVSET bit.
     */
    inline bool get_ICSR_PENDSVSET()
    {
        return ICSR & (1u << 28u);
    }

    /**
     * Set ICSR's PENDSVSET bit.
     */
    inline void set_ICSR_PENDSVSET()
    {
        ICSR |= 1u << 28u;
    }

    /**
     * Clear ICSR's PENDSVSET bit.
     */
    inline void clear_ICSR_PENDSVSET()
    {
        ICSR &= ~(1u << 28u);
    }

    /**
     * Toggle ICSR's PENDSVSET bit.
     */
    inline void toggle_ICSR_PENDSVSET()
    {
        ICSR ^= 1u << 28u;
    }

    /**
     * Get ICSR's NMIPENDSET bit.
     */
    inline bool get_ICSR_NMIPENDSET()
    {
        return ICSR & (1u << 31u);
    }

    /**
     * Set ICSR's NMIPENDSET bit.
     */
    inline void set_ICSR_NMIPENDSET()
    {
        ICSR |= 1u << 31u;
    }

    /**
     * Clear ICSR's NMIPENDSET bit.
     */
    inline void clear_ICSR_NMIPENDSET()
    {
        ICSR &= ~(1u << 31u);
    }

    /**
     * Toggle ICSR's NMIPENDSET bit.
     */
    inline void toggle_ICSR_NMIPENDSET()
    {
        ICSR ^= 1u << 31u;
    }

    /**
     * Get all of ICSR's bit fields.
     */
    inline void get_ICSR(uint16_t &VECTACTIVE, uint16_t &VECTPENDING,
                         bool &ISRPENDING, bool &ISRPREEMPT, bool &PENDSTCLR,
                         bool &PENDSTSET, bool &PENDSVCLR, bool &PENDSVSET,
                         bool &NMIPENDSET)
    {
        uint32_t curr = ICSR;

        VECTACTIVE = (curr >> 0u) & 0b111111111u;
        VECTPENDING = (curr >> 12u) & 0b111111111u;
        ISRPENDING = curr & (1u << 22u);
        ISRPREEMPT = curr & (1u << 23u);
        PENDSTCLR = curr & (1u << 25u);
        PENDSTSET = curr & (1u << 26u);
        PENDSVCLR = curr & (1u << 27u);
        PENDSVSET = curr & (1u << 28u);
        NMIPENDSET = curr & (1u << 31u);
    }

    /**
     * Set all of ICSR's bit fields.
     */
    inline void set_ICSR(bool PENDSTCLR, bool PENDSTSET, bool PENDSVCLR,
                         bool PENDSVSET, bool NMIPENDSET)
    {
        uint32_t curr = ICSR;

        curr &= ~(0b1u << 25u);
        curr |= (PENDSTCLR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (PENDSTSET & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (PENDSVCLR & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (PENDSVSET & 0b1u) << 28u;
        curr &= ~(0b1u << 31u);
        curr |= (NMIPENDSET & 0b1u) << 31u;

        ICSR = curr;
    }

    /**
     * Get VTOR's TBLOFF field.
     */
    inline uint32_t get_VTOR_TBLOFF()
    {
        return (VTOR >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set VTOR's TBLOFF field.
     */
    inline void set_VTOR_TBLOFF(uint32_t value)
    {
        uint32_t curr = VTOR;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        VTOR = curr;
    }

    /**
     * Get AIRCR's VECTCLRACTIVE bit.
     */
    inline bool get_AIRCR_VECTCLRACTIVE()
    {
        return AIRCR & (1u << 1u);
    }

    /**
     * Set AIRCR's VECTCLRACTIVE bit.
     */
    inline void set_AIRCR_VECTCLRACTIVE()
    {
        AIRCR |= 1u << 1u;
    }

    /**
     * Clear AIRCR's VECTCLRACTIVE bit.
     */
    inline void clear_AIRCR_VECTCLRACTIVE()
    {
        AIRCR &= ~(1u << 1u);
    }

    /**
     * Toggle AIRCR's VECTCLRACTIVE bit.
     */
    inline void toggle_AIRCR_VECTCLRACTIVE()
    {
        AIRCR ^= 1u << 1u;
    }

    /**
     * Get AIRCR's SYSRESETREQ bit.
     */
    inline bool get_AIRCR_SYSRESETREQ()
    {
        return AIRCR & (1u << 2u);
    }

    /**
     * Set AIRCR's SYSRESETREQ bit.
     */
    inline void set_AIRCR_SYSRESETREQ()
    {
        AIRCR |= 1u << 2u;
    }

    /**
     * Clear AIRCR's SYSRESETREQ bit.
     */
    inline void clear_AIRCR_SYSRESETREQ()
    {
        AIRCR &= ~(1u << 2u);
    }

    /**
     * Toggle AIRCR's SYSRESETREQ bit.
     */
    inline void toggle_AIRCR_SYSRESETREQ()
    {
        AIRCR ^= 1u << 2u;
    }

    /**
     * Get AIRCR's ENDIANESS bit.
     */
    inline bool get_AIRCR_ENDIANESS()
    {
        return AIRCR & (1u << 15u);
    }

    /**
     * Get AIRCR's VECTKEY field.
     */
    inline uint16_t get_AIRCR_VECTKEY()
    {
        return (AIRCR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set AIRCR's VECTKEY field.
     */
    inline void set_AIRCR_VECTKEY(uint16_t value)
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get all of AIRCR's bit fields.
     */
    inline void get_AIRCR(bool &VECTCLRACTIVE, bool &SYSRESETREQ,
                          bool &ENDIANESS, uint16_t &VECTKEY)
    {
        uint32_t curr = AIRCR;

        VECTCLRACTIVE = curr & (1u << 1u);
        SYSRESETREQ = curr & (1u << 2u);
        ENDIANESS = curr & (1u << 15u);
        VECTKEY = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of AIRCR's bit fields.
     */
    inline void set_AIRCR(bool VECTCLRACTIVE, bool SYSRESETREQ,
                          uint16_t VECTKEY)
    {
        uint32_t curr = AIRCR;

        curr &= ~(0b1u << 1u);
        curr |= (VECTCLRACTIVE & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SYSRESETREQ & 0b1u) << 2u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (VECTKEY & 0b1111111111111111u) << 16u;

        AIRCR = curr;
    }

    /**
     * Get SCR's SLEEPONEXIT bit.
     */
    inline bool get_SCR_SLEEPONEXIT()
    {
        return SCR & (1u << 1u);
    }

    /**
     * Set SCR's SLEEPONEXIT bit.
     */
    inline void set_SCR_SLEEPONEXIT()
    {
        SCR |= 1u << 1u;
    }

    /**
     * Clear SCR's SLEEPONEXIT bit.
     */
    inline void clear_SCR_SLEEPONEXIT()
    {
        SCR &= ~(1u << 1u);
    }

    /**
     * Toggle SCR's SLEEPONEXIT bit.
     */
    inline void toggle_SCR_SLEEPONEXIT()
    {
        SCR ^= 1u << 1u;
    }

    /**
     * Get SCR's SLEEPDEEP bit.
     */
    inline bool get_SCR_SLEEPDEEP()
    {
        return SCR & (1u << 2u);
    }

    /**
     * Set SCR's SLEEPDEEP bit.
     */
    inline void set_SCR_SLEEPDEEP()
    {
        SCR |= 1u << 2u;
    }

    /**
     * Clear SCR's SLEEPDEEP bit.
     */
    inline void clear_SCR_SLEEPDEEP()
    {
        SCR &= ~(1u << 2u);
    }

    /**
     * Toggle SCR's SLEEPDEEP bit.
     */
    inline void toggle_SCR_SLEEPDEEP()
    {
        SCR ^= 1u << 2u;
    }

    /**
     * Get SCR's SEVONPEND bit.
     */
    inline bool get_SCR_SEVONPEND()
    {
        return SCR & (1u << 4u);
    }

    /**
     * Set SCR's SEVONPEND bit.
     */
    inline void set_SCR_SEVONPEND()
    {
        SCR |= 1u << 4u;
    }

    /**
     * Clear SCR's SEVONPEND bit.
     */
    inline void clear_SCR_SEVONPEND()
    {
        SCR &= ~(1u << 4u);
    }

    /**
     * Toggle SCR's SEVONPEND bit.
     */
    inline void toggle_SCR_SEVONPEND()
    {
        SCR ^= 1u << 4u;
    }

    /**
     * Get all of SCR's bit fields.
     */
    inline void get_SCR(bool &SLEEPONEXIT, bool &SLEEPDEEP, bool &SEVONPEND)
    {
        uint32_t curr = SCR;

        SLEEPONEXIT = curr & (1u << 1u);
        SLEEPDEEP = curr & (1u << 2u);
        SEVONPEND = curr & (1u << 4u);
    }

    /**
     * Set all of SCR's bit fields.
     */
    inline void set_SCR(bool SLEEPONEXIT, bool SLEEPDEEP, bool SEVONPEND)
    {
        uint32_t curr = SCR;

        curr &= ~(0b1u << 1u);
        curr |= (SLEEPONEXIT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SLEEPDEEP & 0b1u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (SEVONPEND & 0b1u) << 4u;

        SCR = curr;
    }

    /**
     * Get CCR's UNALIGN_TRP bit.
     */
    inline bool get_CCR_UNALIGN_TRP()
    {
        return CCR & (1u << 3u);
    }

    /**
     * Get CCR's STKALIGN bit.
     */
    inline bool get_CCR_STKALIGN()
    {
        return CCR & (1u << 9u);
    }

    /**
     * Get all of CCR's bit fields.
     */
    inline void get_CCR(bool &UNALIGN_TRP, bool &STKALIGN)
    {
        uint32_t curr = CCR;

        UNALIGN_TRP = curr & (1u << 3u);
        STKALIGN = curr & (1u << 9u);
    }

    /**
     * Get SHPR2's PRI_11 field.
     */
    inline uint8_t get_SHPR2_PRI_11()
    {
        return (SHPR2 >> 30u) & 0b11u;
    }

    /**
     * Set SHPR2's PRI_11 field.
     */
    inline void set_SHPR2_PRI_11(uint8_t value)
    {
        uint32_t curr = SHPR2;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        SHPR2 = curr;
    }

    /**
     * Get SHPR3's PRI_14 field.
     */
    inline uint8_t get_SHPR3_PRI_14()
    {
        return (SHPR3 >> 22u) & 0b11u;
    }

    /**
     * Set SHPR3's PRI_14 field.
     */
    inline void set_SHPR3_PRI_14(uint8_t value)
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 22u);
        curr |= (value & 0b11u) << 22u;

        SHPR3 = curr;
    }

    /**
     * Get SHPR3's PRI_15 field.
     */
    inline uint8_t get_SHPR3_PRI_15()
    {
        return (SHPR3 >> 30u) & 0b11u;
    }

    /**
     * Set SHPR3's PRI_15 field.
     */
    inline void set_SHPR3_PRI_15(uint8_t value)
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 30u);
        curr |= (value & 0b11u) << 30u;

        SHPR3 = curr;
    }

    /**
     * Get all of SHPR3's bit fields.
     */
    inline void get_SHPR3(uint8_t &PRI_14, uint8_t &PRI_15)
    {
        uint32_t curr = SHPR3;

        PRI_14 = (curr >> 22u) & 0b11u;
        PRI_15 = (curr >> 30u) & 0b11u;
    }

    /**
     * Set all of SHPR3's bit fields.
     */
    inline void set_SHPR3(uint8_t PRI_14, uint8_t PRI_15)
    {
        uint32_t curr = SHPR3;

        curr &= ~(0b11u << 22u);
        curr |= (PRI_14 & 0b11u) << 22u;
        curr &= ~(0b11u << 30u);
        curr |= (PRI_15 & 0b11u) << 30u;

        SHPR3 = curr;
    }

    /**
     * Get SHCSR's SVCALLPENDED bit.
     */
    inline bool get_SHCSR_SVCALLPENDED()
    {
        return SHCSR & (1u << 15u);
    }

    /**
     * Set SHCSR's SVCALLPENDED bit.
     */
    inline void set_SHCSR_SVCALLPENDED()
    {
        SHCSR |= 1u << 15u;
    }

    /**
     * Clear SHCSR's SVCALLPENDED bit.
     */
    inline void clear_SHCSR_SVCALLPENDED()
    {
        SHCSR &= ~(1u << 15u);
    }

    /**
     * Toggle SHCSR's SVCALLPENDED bit.
     */
    inline void toggle_SHCSR_SVCALLPENDED()
    {
        SHCSR ^= 1u << 15u;
    }

    /**
     * Get MPU_TYPE's SEPARATE bit.
     */
    inline bool get_MPU_TYPE_SEPARATE()
    {
        return MPU_TYPE & (1u << 0u);
    }

    /**
     * Get MPU_TYPE's DREGION field.
     */
    inline uint8_t get_MPU_TYPE_DREGION()
    {
        return (MPU_TYPE >> 8u) & 0b11111111u;
    }

    /**
     * Get MPU_TYPE's IREGION field.
     */
    inline uint8_t get_MPU_TYPE_IREGION()
    {
        return (MPU_TYPE >> 16u) & 0b11111111u;
    }

    /**
     * Get all of MPU_TYPE's bit fields.
     */
    inline void get_MPU_TYPE(bool &SEPARATE, uint8_t &DREGION,
                             uint8_t &IREGION)
    {
        uint32_t curr = MPU_TYPE;

        SEPARATE = curr & (1u << 0u);
        DREGION = (curr >> 8u) & 0b11111111u;
        IREGION = (curr >> 16u) & 0b11111111u;
    }

    /**
     * Get MPU_CTRL's ENABLE bit.
     */
    inline bool get_MPU_CTRL_ENABLE()
    {
        return MPU_CTRL & (1u << 0u);
    }

    /**
     * Set MPU_CTRL's ENABLE bit.
     */
    inline void set_MPU_CTRL_ENABLE()
    {
        MPU_CTRL |= 1u << 0u;
    }

    /**
     * Clear MPU_CTRL's ENABLE bit.
     */
    inline void clear_MPU_CTRL_ENABLE()
    {
        MPU_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_CTRL's ENABLE bit.
     */
    inline void toggle_MPU_CTRL_ENABLE()
    {
        MPU_CTRL ^= 1u << 0u;
    }

    /**
     * Get MPU_CTRL's HFNMIENA bit.
     */
    inline bool get_MPU_CTRL_HFNMIENA()
    {
        return MPU_CTRL & (1u << 1u);
    }

    /**
     * Set MPU_CTRL's HFNMIENA bit.
     */
    inline void set_MPU_CTRL_HFNMIENA()
    {
        MPU_CTRL |= 1u << 1u;
    }

    /**
     * Clear MPU_CTRL's HFNMIENA bit.
     */
    inline void clear_MPU_CTRL_HFNMIENA()
    {
        MPU_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MPU_CTRL's HFNMIENA bit.
     */
    inline void toggle_MPU_CTRL_HFNMIENA()
    {
        MPU_CTRL ^= 1u << 1u;
    }

    /**
     * Get MPU_CTRL's PRIVDEFENA bit.
     */
    inline bool get_MPU_CTRL_PRIVDEFENA()
    {
        return MPU_CTRL & (1u << 2u);
    }

    /**
     * Set MPU_CTRL's PRIVDEFENA bit.
     */
    inline void set_MPU_CTRL_PRIVDEFENA()
    {
        MPU_CTRL |= 1u << 2u;
    }

    /**
     * Clear MPU_CTRL's PRIVDEFENA bit.
     */
    inline void clear_MPU_CTRL_PRIVDEFENA()
    {
        MPU_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle MPU_CTRL's PRIVDEFENA bit.
     */
    inline void toggle_MPU_CTRL_PRIVDEFENA()
    {
        MPU_CTRL ^= 1u << 2u;
    }

    /**
     * Get all of MPU_CTRL's bit fields.
     */
    inline void get_MPU_CTRL(bool &ENABLE, bool &HFNMIENA, bool &PRIVDEFENA)
    {
        uint32_t curr = MPU_CTRL;

        ENABLE = curr & (1u << 0u);
        HFNMIENA = curr & (1u << 1u);
        PRIVDEFENA = curr & (1u << 2u);
    }

    /**
     * Set all of MPU_CTRL's bit fields.
     */
    inline void set_MPU_CTRL(bool ENABLE, bool HFNMIENA, bool PRIVDEFENA)
    {
        uint32_t curr = MPU_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HFNMIENA & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (PRIVDEFENA & 0b1u) << 2u;

        MPU_CTRL = curr;
    }

    /**
     * Get MPU_RNR's REGION field.
     */
    inline uint8_t get_MPU_RNR_REGION()
    {
        return (MPU_RNR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RNR's REGION field.
     */
    inline void set_MPU_RNR_REGION(uint8_t value)
    {
        uint32_t curr = MPU_RNR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RNR = curr;
    }

    /**
     * Get MPU_RBAR's REGION field.
     */
    inline uint8_t get_MPU_RBAR_REGION()
    {
        return (MPU_RBAR >> 0u) & 0b1111u;
    }

    /**
     * Set MPU_RBAR's REGION field.
     */
    inline void set_MPU_RBAR_REGION(uint8_t value)
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b1111u << 0u);
        curr |= (value & 0b1111u) << 0u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RBAR's VALID bit.
     */
    inline bool get_MPU_RBAR_VALID()
    {
        return MPU_RBAR & (1u << 4u);
    }

    /**
     * Set MPU_RBAR's VALID bit.
     */
    inline void set_MPU_RBAR_VALID()
    {
        MPU_RBAR |= 1u << 4u;
    }

    /**
     * Clear MPU_RBAR's VALID bit.
     */
    inline void clear_MPU_RBAR_VALID()
    {
        MPU_RBAR &= ~(1u << 4u);
    }

    /**
     * Toggle MPU_RBAR's VALID bit.
     */
    inline void toggle_MPU_RBAR_VALID()
    {
        MPU_RBAR ^= 1u << 4u;
    }

    /**
     * Get MPU_RBAR's ADDR field.
     */
    inline uint32_t get_MPU_RBAR_ADDR()
    {
        return (MPU_RBAR >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set MPU_RBAR's ADDR field.
     */
    inline void set_MPU_RBAR_ADDR(uint32_t value)
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (value & 0b111111111111111111111111u) << 8u;

        MPU_RBAR = curr;
    }

    /**
     * Get all of MPU_RBAR's bit fields.
     */
    inline void get_MPU_RBAR(uint8_t &REGION, bool &VALID, uint32_t &ADDR)
    {
        uint32_t curr = MPU_RBAR;

        REGION = (curr >> 0u) & 0b1111u;
        VALID = curr & (1u << 4u);
        ADDR = (curr >> 8u) & 0b111111111111111111111111u;
    }

    /**
     * Set all of MPU_RBAR's bit fields.
     */
    inline void set_MPU_RBAR(uint8_t REGION, bool VALID, uint32_t ADDR)
    {
        uint32_t curr = MPU_RBAR;

        curr &= ~(0b1111u << 0u);
        curr |= (REGION & 0b1111u) << 0u;
        curr &= ~(0b1u << 4u);
        curr |= (VALID & 0b1u) << 4u;
        curr &= ~(0b111111111111111111111111u << 8u);
        curr |= (ADDR & 0b111111111111111111111111u) << 8u;

        MPU_RBAR = curr;
    }

    /**
     * Get MPU_RASR's ENABLE bit.
     */
    inline bool get_MPU_RASR_ENABLE()
    {
        return MPU_RASR & (1u << 0u);
    }

    /**
     * Set MPU_RASR's ENABLE bit.
     */
    inline void set_MPU_RASR_ENABLE()
    {
        MPU_RASR |= 1u << 0u;
    }

    /**
     * Clear MPU_RASR's ENABLE bit.
     */
    inline void clear_MPU_RASR_ENABLE()
    {
        MPU_RASR &= ~(1u << 0u);
    }

    /**
     * Toggle MPU_RASR's ENABLE bit.
     */
    inline void toggle_MPU_RASR_ENABLE()
    {
        MPU_RASR ^= 1u << 0u;
    }

    /**
     * Get MPU_RASR's SIZE field.
     */
    inline uint8_t get_MPU_RASR_SIZE()
    {
        return (MPU_RASR >> 1u) & 0b11111u;
    }

    /**
     * Set MPU_RASR's SIZE field.
     */
    inline void set_MPU_RASR_SIZE(uint8_t value)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111u << 1u);
        curr |= (value & 0b11111u) << 1u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's SRD field.
     */
    inline uint8_t get_MPU_RASR_SRD()
    {
        return (MPU_RASR >> 8u) & 0b11111111u;
    }

    /**
     * Set MPU_RASR's SRD field.
     */
    inline void set_MPU_RASR_SRD(uint8_t value)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b11111111u << 8u);
        curr |= (value & 0b11111111u) << 8u;

        MPU_RASR = curr;
    }

    /**
     * Get MPU_RASR's ATTRS field.
     */
    inline uint16_t get_MPU_RASR_ATTRS()
    {
        return (MPU_RASR >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set MPU_RASR's ATTRS field.
     */
    inline void set_MPU_RASR_ATTRS(uint16_t value)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b1111111111111111u << 16u);
        curr |= (value & 0b1111111111111111u) << 16u;

        MPU_RASR = curr;
    }

    /**
     * Get all of MPU_RASR's bit fields.
     */
    inline void get_MPU_RASR(bool &ENABLE, uint8_t &SIZE, uint8_t &SRD,
                             uint16_t &ATTRS)
    {
        uint32_t curr = MPU_RASR;

        ENABLE = curr & (1u << 0u);
        SIZE = (curr >> 1u) & 0b11111u;
        SRD = (curr >> 8u) & 0b11111111u;
        ATTRS = (curr >> 16u) & 0b1111111111111111u;
    }

    /**
     * Set all of MPU_RASR's bit fields.
     */
    inline void set_MPU_RASR(bool ENABLE, uint8_t SIZE, uint8_t SRD,
                             uint16_t ATTRS)
    {
        uint32_t curr = MPU_RASR;

        curr &= ~(0b1u << 0u);
        curr |= (ENABLE & 0b1u) << 0u;
        curr &= ~(0b11111u << 1u);
        curr |= (SIZE & 0b11111u) << 1u;
        curr &= ~(0b11111111u << 8u);
        curr |= (SRD & 0b11111111u) << 8u;
        curr &= ~(0b1111111111111111u << 16u);
        curr |= (ATTRS & 0b1111111111111111u) << 16u;

        MPU_RASR = curr;
    }
};

static_assert(sizeof(ppb) == ppb::size);

static volatile ppb *const PPB = reinterpret_cast<ppb *>(0xe0000000);

}; // namespace RP2040
