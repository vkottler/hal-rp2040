/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

/**
 * USB FS/LS controller device registers
 */
struct [[gnu::packed]] usbctrl_regs
{
    /* Constant attributes. */
    static constexpr std::size_t size =
        156; /*!< usbctrl_regs's size in bytes. */

    /* Fields. */
    uint32_t
        ADDR_ENDP; /*!< (read-write) Device address and endpoint control */
    uint32_t ADDR_ENDP1; /*!< (read-write) Interrupt endpoint 1. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP2; /*!< (read-write) Interrupt endpoint 2. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP3; /*!< (read-write) Interrupt endpoint 3. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP4; /*!< (read-write) Interrupt endpoint 4. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP5; /*!< (read-write) Interrupt endpoint 5. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP6; /*!< (read-write) Interrupt endpoint 6. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP7; /*!< (read-write) Interrupt endpoint 7. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP8; /*!< (read-write) Interrupt endpoint 8. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP9; /*!< (read-write) Interrupt endpoint 9. Only valid for
                            HOST mode. */
    uint32_t ADDR_ENDP10; /*!< (read-write) Interrupt endpoint 10. Only valid
                             for HOST mode. */
    uint32_t ADDR_ENDP11; /*!< (read-write) Interrupt endpoint 11. Only valid
                             for HOST mode. */
    uint32_t ADDR_ENDP12; /*!< (read-write) Interrupt endpoint 12. Only valid
                             for HOST mode. */
    uint32_t ADDR_ENDP13; /*!< (read-write) Interrupt endpoint 13. Only valid
                             for HOST mode. */
    uint32_t ADDR_ENDP14; /*!< (read-write) Interrupt endpoint 14. Only valid
                             for HOST mode. */
    uint32_t ADDR_ENDP15; /*!< (read-write) Interrupt endpoint 15. Only valid
                             for HOST mode. */
    uint32_t MAIN_CTRL;   /*!< (read-write) Main control register */
    uint32_t
        SOF_WR; /*!< (write-only) Set the SOF (Start of Frame) frame number in
                   the host controller. The SOF packet is sent every 1ms and
                   the host will increment the frame number by 1 each time. */
    const uint32_t SOF_RD =
        {}; /*!< (read-only) Read the last SOF (Start of Frame) frame number
               seen. In device mode the last SOF received from the host. In
               host mode the last SOF sent by the host. */
    uint32_t SIE_CTRL;   /*!< (read-write) SIE control register */
    uint32_t SIE_STATUS; /*!< (read-write) SIE status register */
    uint32_t
        INT_EP_CTRL; /*!< (read-write) interrupt endpoint control register */
    uint32_t BUFF_STATUS; /*!< (read-write) Buffer status register. A bit set
                             here indicates that a buffer has completed on the
                             endpoint (if the buffer interrupt is enabled). It
                             is possible for 2 buffers to be completed, so
                             clearing the buffer status bit may instantly re
                             set it on the next clock cycle. */
    const uint32_t BUFF_CPU_SHOULD_HANDLE =
        {}; /*!< (read-only) Which of the double buffers should be handled.
               Only valid if using an interrupt per buffer (i.e. not per 2
               buffers). Not valid for host interrupt endpoint polling because
               they are only single buffered. */
    uint32_t
        EP_ABORT; /*!< (read-write) Device only: Can be set to ignore the
                     buffer control register for this endpoint in case you
                     would like to revoke a buffer. A NAK will be sent for
                     every access to the endpoint until this bit is cleared. A
                     corresponding bit in `EP_ABORT_DONE` is set when it is
                     safe to modify the buffer control register. */
    uint32_t EP_ABORT_DONE; /*!< (read-write) Device only: Used in conjunction
                               with `EP_ABORT`. Set once an endpoint is idle so
                               the programmer knows it is safe to modify the
                               buffer control register. */
    uint32_t
        EP_STALL_ARM;  /*!< (read-write) Device: this bit must be set in
                          conjunction with the `STALL` bit in the buffer control
                          register to send a STALL on EP0. The device controller
                          clears these bits when a SETUP packet is received
                          because the USB spec requires that a STALL condition
                          is cleared when a SETUP packet is received. */
    uint32_t NAK_POLL; /*!< (read-write) Used by the host controller. Sets the
                          wait time in microseconds before trying again if the
                          device replies with a NAK. */
    uint32_t
        EP_STATUS_STALL_NAK; /*!< (read-write) Device: bits are set when the
                                `IRQ_ON_NAK` or `IRQ_ON_STALL` bits are set.
                                For EP0 this comes from `SIE_CTRL`. For all
                                other endpoints it comes from the endpoint
                                control register. */
    uint32_t USB_MUXING; /*!< (read-write) Where to connect the USB controller.
                            Should be to_phy by default. */
    uint32_t USB_PWR; /*!< (read-write) Overrides for the power signals in the
                         event that the VBUS signals are not hooked up to GPIO.
                         Set the value of the override and then the override
                         enable to switch over to the override value. */
    uint32_t USBPHY_DIRECT; /*!< (read-write) This register allows for direct
                               control of the USB phy. Use in conjunction with
                               usbphy_direct_override register to enable each
                               override bit. */
    uint32_t USBPHY_DIRECT_OVERRIDE; /*!< (read-write) Override enable for each
                                        control in usbphy_direct */
    uint32_t USBPHY_TRIM; /*!< (read-write) Used to adjust trim values of USB
                             phy pull down resistors. */
    const uint32_t reserved_padding0 = {};
    const uint32_t INTR = {}; /*!< (read-only) Raw Interrupts */
    uint32_t INTE;            /*!< (read-write) Interrupt Enable */
    uint32_t INTF;            /*!< (read-write) Interrupt Force */
    const uint32_t INTS =
        {}; /*!< (read-only) Interrupt status after masking & forcing */

    /* Methods. */

    /**
     * Get ADDR_ENDP's ADDRESS field.
     *
     * In device mode, the address that the device should respond to. Set in
     * response to a SET_ADDR setup packet from the host. In host mode set to
     * the address of the device to communicate with.
     */
    inline uint8_t get_ADDR_ENDP_ADDRESS() volatile
    {
        return (ADDR_ENDP >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP's ADDRESS field.
     *
     * In device mode, the address that the device should respond to. Set in
     * response to a SET_ADDR setup packet from the host. In host mode set to
     * the address of the device to communicate with.
     */
    inline void set_ADDR_ENDP_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP = curr;
    }

    /**
     * Get ADDR_ENDP's ENDPOINT field.
     *
     * Device endpoint to send data to. Only valid for HOST mode.
     */
    inline uint8_t get_ADDR_ENDP_ENDPOINT() volatile
    {
        return (ADDR_ENDP >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP's ENDPOINT field.
     *
     * Device endpoint to send data to. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP = curr;
    }

    /**
     * Get all of ADDR_ENDP's bit fields.
     *
     * (read-write) Device address and endpoint control
     */
    inline void get_ADDR_ENDP(uint8_t &ADDRESS, uint8_t &ENDPOINT) volatile
    {
        uint32_t curr = ADDR_ENDP;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
    }

    /**
     * Set all of ADDR_ENDP's bit fields.
     *
     * (read-write) Device address and endpoint control
     */
    inline void set_ADDR_ENDP(uint8_t ADDRESS, uint8_t ENDPOINT) volatile
    {
        uint32_t curr = ADDR_ENDP;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;

        ADDR_ENDP = curr;
    }

    /**
     * Get ADDR_ENDP1's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP1_ADDRESS() volatile
    {
        return (ADDR_ENDP1 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP1's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP1_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP1;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP1 = curr;
    }

    /**
     * Get ADDR_ENDP1's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP1_ENDPOINT() volatile
    {
        return (ADDR_ENDP1 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP1's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP1_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP1;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP1 = curr;
    }

    /**
     * Get ADDR_ENDP1's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP1_INTEP_DIR() volatile
    {
        return ADDR_ENDP1 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP1's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP1_INTEP_DIR() volatile
    {
        ADDR_ENDP1 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP1's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP1_INTEP_DIR() volatile
    {
        ADDR_ENDP1 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP1's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP1_INTEP_DIR() volatile
    {
        ADDR_ENDP1 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP1's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP1_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP1 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP1's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP1_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP1 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP1's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP1_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP1 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP1's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP1_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP1 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP1's bit fields.
     *
     * (read-write) Interrupt endpoint 1. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP1(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP1;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP1's bit fields.
     *
     * (read-write) Interrupt endpoint 1. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP1(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP1;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP1 = curr;
    }

    /**
     * Get ADDR_ENDP2's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP2_ADDRESS() volatile
    {
        return (ADDR_ENDP2 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP2's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP2_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP2;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP2 = curr;
    }

    /**
     * Get ADDR_ENDP2's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP2_ENDPOINT() volatile
    {
        return (ADDR_ENDP2 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP2's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP2_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP2;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP2 = curr;
    }

    /**
     * Get ADDR_ENDP2's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP2_INTEP_DIR() volatile
    {
        return ADDR_ENDP2 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP2's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP2_INTEP_DIR() volatile
    {
        ADDR_ENDP2 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP2's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP2_INTEP_DIR() volatile
    {
        ADDR_ENDP2 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP2's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP2_INTEP_DIR() volatile
    {
        ADDR_ENDP2 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP2's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP2_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP2 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP2's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP2_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP2 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP2's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP2_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP2 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP2's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP2_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP2 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP2's bit fields.
     *
     * (read-write) Interrupt endpoint 2. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP2(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP2;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP2's bit fields.
     *
     * (read-write) Interrupt endpoint 2. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP2(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP2;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP2 = curr;
    }

    /**
     * Get ADDR_ENDP3's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP3_ADDRESS() volatile
    {
        return (ADDR_ENDP3 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP3's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP3_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP3;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP3 = curr;
    }

    /**
     * Get ADDR_ENDP3's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP3_ENDPOINT() volatile
    {
        return (ADDR_ENDP3 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP3's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP3_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP3;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP3 = curr;
    }

    /**
     * Get ADDR_ENDP3's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP3_INTEP_DIR() volatile
    {
        return ADDR_ENDP3 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP3's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP3_INTEP_DIR() volatile
    {
        ADDR_ENDP3 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP3's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP3_INTEP_DIR() volatile
    {
        ADDR_ENDP3 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP3's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP3_INTEP_DIR() volatile
    {
        ADDR_ENDP3 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP3's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP3_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP3 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP3's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP3_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP3 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP3's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP3_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP3 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP3's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP3_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP3 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP3's bit fields.
     *
     * (read-write) Interrupt endpoint 3. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP3(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP3;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP3's bit fields.
     *
     * (read-write) Interrupt endpoint 3. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP3(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP3;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP3 = curr;
    }

    /**
     * Get ADDR_ENDP4's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP4_ADDRESS() volatile
    {
        return (ADDR_ENDP4 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP4's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP4_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP4;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP4 = curr;
    }

    /**
     * Get ADDR_ENDP4's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP4_ENDPOINT() volatile
    {
        return (ADDR_ENDP4 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP4's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP4_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP4;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP4 = curr;
    }

    /**
     * Get ADDR_ENDP4's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP4_INTEP_DIR() volatile
    {
        return ADDR_ENDP4 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP4's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP4_INTEP_DIR() volatile
    {
        ADDR_ENDP4 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP4's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP4_INTEP_DIR() volatile
    {
        ADDR_ENDP4 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP4's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP4_INTEP_DIR() volatile
    {
        ADDR_ENDP4 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP4's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP4_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP4 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP4's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP4_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP4 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP4's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP4_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP4 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP4's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP4_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP4 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP4's bit fields.
     *
     * (read-write) Interrupt endpoint 4. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP4(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP4;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP4's bit fields.
     *
     * (read-write) Interrupt endpoint 4. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP4(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP4;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP4 = curr;
    }

    /**
     * Get ADDR_ENDP5's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP5_ADDRESS() volatile
    {
        return (ADDR_ENDP5 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP5's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP5_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP5;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP5 = curr;
    }

    /**
     * Get ADDR_ENDP5's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP5_ENDPOINT() volatile
    {
        return (ADDR_ENDP5 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP5's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP5_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP5;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP5 = curr;
    }

    /**
     * Get ADDR_ENDP5's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP5_INTEP_DIR() volatile
    {
        return ADDR_ENDP5 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP5's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP5_INTEP_DIR() volatile
    {
        ADDR_ENDP5 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP5's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP5_INTEP_DIR() volatile
    {
        ADDR_ENDP5 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP5's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP5_INTEP_DIR() volatile
    {
        ADDR_ENDP5 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP5's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP5_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP5 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP5's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP5_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP5 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP5's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP5_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP5 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP5's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP5_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP5 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP5's bit fields.
     *
     * (read-write) Interrupt endpoint 5. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP5(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP5;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP5's bit fields.
     *
     * (read-write) Interrupt endpoint 5. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP5(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP5;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP5 = curr;
    }

    /**
     * Get ADDR_ENDP6's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP6_ADDRESS() volatile
    {
        return (ADDR_ENDP6 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP6's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP6_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP6;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP6 = curr;
    }

    /**
     * Get ADDR_ENDP6's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP6_ENDPOINT() volatile
    {
        return (ADDR_ENDP6 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP6's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP6_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP6;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP6 = curr;
    }

    /**
     * Get ADDR_ENDP6's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP6_INTEP_DIR() volatile
    {
        return ADDR_ENDP6 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP6's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP6_INTEP_DIR() volatile
    {
        ADDR_ENDP6 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP6's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP6_INTEP_DIR() volatile
    {
        ADDR_ENDP6 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP6's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP6_INTEP_DIR() volatile
    {
        ADDR_ENDP6 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP6's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP6_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP6 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP6's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP6_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP6 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP6's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP6_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP6 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP6's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP6_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP6 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP6's bit fields.
     *
     * (read-write) Interrupt endpoint 6. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP6(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP6;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP6's bit fields.
     *
     * (read-write) Interrupt endpoint 6. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP6(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP6;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP6 = curr;
    }

    /**
     * Get ADDR_ENDP7's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP7_ADDRESS() volatile
    {
        return (ADDR_ENDP7 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP7's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP7_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP7;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP7 = curr;
    }

    /**
     * Get ADDR_ENDP7's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP7_ENDPOINT() volatile
    {
        return (ADDR_ENDP7 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP7's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP7_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP7;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP7 = curr;
    }

    /**
     * Get ADDR_ENDP7's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP7_INTEP_DIR() volatile
    {
        return ADDR_ENDP7 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP7's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP7_INTEP_DIR() volatile
    {
        ADDR_ENDP7 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP7's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP7_INTEP_DIR() volatile
    {
        ADDR_ENDP7 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP7's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP7_INTEP_DIR() volatile
    {
        ADDR_ENDP7 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP7's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP7_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP7 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP7's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP7_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP7 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP7's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP7_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP7 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP7's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP7_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP7 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP7's bit fields.
     *
     * (read-write) Interrupt endpoint 7. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP7(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP7;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP7's bit fields.
     *
     * (read-write) Interrupt endpoint 7. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP7(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP7;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP7 = curr;
    }

    /**
     * Get ADDR_ENDP8's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP8_ADDRESS() volatile
    {
        return (ADDR_ENDP8 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP8's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP8_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP8;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP8 = curr;
    }

    /**
     * Get ADDR_ENDP8's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP8_ENDPOINT() volatile
    {
        return (ADDR_ENDP8 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP8's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP8_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP8;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP8 = curr;
    }

    /**
     * Get ADDR_ENDP8's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP8_INTEP_DIR() volatile
    {
        return ADDR_ENDP8 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP8's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP8_INTEP_DIR() volatile
    {
        ADDR_ENDP8 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP8's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP8_INTEP_DIR() volatile
    {
        ADDR_ENDP8 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP8's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP8_INTEP_DIR() volatile
    {
        ADDR_ENDP8 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP8's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP8_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP8 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP8's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP8_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP8 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP8's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP8_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP8 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP8's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP8_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP8 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP8's bit fields.
     *
     * (read-write) Interrupt endpoint 8. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP8(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP8;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP8's bit fields.
     *
     * (read-write) Interrupt endpoint 8. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP8(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP8;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP8 = curr;
    }

    /**
     * Get ADDR_ENDP9's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP9_ADDRESS() volatile
    {
        return (ADDR_ENDP9 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP9's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP9_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP9;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP9 = curr;
    }

    /**
     * Get ADDR_ENDP9's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP9_ENDPOINT() volatile
    {
        return (ADDR_ENDP9 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP9's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP9_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP9;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP9 = curr;
    }

    /**
     * Get ADDR_ENDP9's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP9_INTEP_DIR() volatile
    {
        return ADDR_ENDP9 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP9's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP9_INTEP_DIR() volatile
    {
        ADDR_ENDP9 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP9's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP9_INTEP_DIR() volatile
    {
        ADDR_ENDP9 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP9's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP9_INTEP_DIR() volatile
    {
        ADDR_ENDP9 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP9's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP9_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP9 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP9's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP9_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP9 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP9's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP9_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP9 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP9's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP9_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP9 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP9's bit fields.
     *
     * (read-write) Interrupt endpoint 9. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP9(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                               bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP9;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP9's bit fields.
     *
     * (read-write) Interrupt endpoint 9. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP9(uint8_t ADDRESS, uint8_t ENDPOINT,
                               bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP9;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP9 = curr;
    }

    /**
     * Get ADDR_ENDP10's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP10_ADDRESS() volatile
    {
        return (ADDR_ENDP10 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP10's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP10_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP10;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP10 = curr;
    }

    /**
     * Get ADDR_ENDP10's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP10_ENDPOINT() volatile
    {
        return (ADDR_ENDP10 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP10's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP10_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP10;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP10 = curr;
    }

    /**
     * Get ADDR_ENDP10's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP10_INTEP_DIR() volatile
    {
        return ADDR_ENDP10 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP10's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP10_INTEP_DIR() volatile
    {
        ADDR_ENDP10 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP10's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP10_INTEP_DIR() volatile
    {
        ADDR_ENDP10 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP10's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP10_INTEP_DIR() volatile
    {
        ADDR_ENDP10 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP10's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP10_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP10 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP10's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP10_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP10 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP10's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP10_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP10 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP10's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP10_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP10 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP10's bit fields.
     *
     * (read-write) Interrupt endpoint 10. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP10(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                                bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP10;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP10's bit fields.
     *
     * (read-write) Interrupt endpoint 10. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP10(uint8_t ADDRESS, uint8_t ENDPOINT,
                                bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP10;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP10 = curr;
    }

    /**
     * Get ADDR_ENDP11's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP11_ADDRESS() volatile
    {
        return (ADDR_ENDP11 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP11's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP11_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP11;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP11 = curr;
    }

    /**
     * Get ADDR_ENDP11's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP11_ENDPOINT() volatile
    {
        return (ADDR_ENDP11 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP11's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP11_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP11;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP11 = curr;
    }

    /**
     * Get ADDR_ENDP11's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP11_INTEP_DIR() volatile
    {
        return ADDR_ENDP11 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP11's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP11_INTEP_DIR() volatile
    {
        ADDR_ENDP11 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP11's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP11_INTEP_DIR() volatile
    {
        ADDR_ENDP11 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP11's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP11_INTEP_DIR() volatile
    {
        ADDR_ENDP11 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP11's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP11_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP11 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP11's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP11_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP11 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP11's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP11_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP11 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP11's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP11_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP11 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP11's bit fields.
     *
     * (read-write) Interrupt endpoint 11. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP11(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                                bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP11;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP11's bit fields.
     *
     * (read-write) Interrupt endpoint 11. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP11(uint8_t ADDRESS, uint8_t ENDPOINT,
                                bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP11;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP11 = curr;
    }

    /**
     * Get ADDR_ENDP12's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP12_ADDRESS() volatile
    {
        return (ADDR_ENDP12 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP12's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP12_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP12;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP12 = curr;
    }

    /**
     * Get ADDR_ENDP12's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP12_ENDPOINT() volatile
    {
        return (ADDR_ENDP12 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP12's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP12_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP12;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP12 = curr;
    }

    /**
     * Get ADDR_ENDP12's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP12_INTEP_DIR() volatile
    {
        return ADDR_ENDP12 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP12's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP12_INTEP_DIR() volatile
    {
        ADDR_ENDP12 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP12's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP12_INTEP_DIR() volatile
    {
        ADDR_ENDP12 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP12's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP12_INTEP_DIR() volatile
    {
        ADDR_ENDP12 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP12's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP12_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP12 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP12's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP12_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP12 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP12's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP12_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP12 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP12's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP12_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP12 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP12's bit fields.
     *
     * (read-write) Interrupt endpoint 12. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP12(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                                bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP12;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP12's bit fields.
     *
     * (read-write) Interrupt endpoint 12. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP12(uint8_t ADDRESS, uint8_t ENDPOINT,
                                bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP12;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP12 = curr;
    }

    /**
     * Get ADDR_ENDP13's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP13_ADDRESS() volatile
    {
        return (ADDR_ENDP13 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP13's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP13_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP13;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP13 = curr;
    }

    /**
     * Get ADDR_ENDP13's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP13_ENDPOINT() volatile
    {
        return (ADDR_ENDP13 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP13's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP13_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP13;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP13 = curr;
    }

    /**
     * Get ADDR_ENDP13's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP13_INTEP_DIR() volatile
    {
        return ADDR_ENDP13 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP13's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP13_INTEP_DIR() volatile
    {
        ADDR_ENDP13 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP13's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP13_INTEP_DIR() volatile
    {
        ADDR_ENDP13 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP13's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP13_INTEP_DIR() volatile
    {
        ADDR_ENDP13 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP13's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP13_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP13 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP13's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP13_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP13 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP13's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP13_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP13 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP13's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP13_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP13 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP13's bit fields.
     *
     * (read-write) Interrupt endpoint 13. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP13(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                                bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP13;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP13's bit fields.
     *
     * (read-write) Interrupt endpoint 13. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP13(uint8_t ADDRESS, uint8_t ENDPOINT,
                                bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP13;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP13 = curr;
    }

    /**
     * Get ADDR_ENDP14's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP14_ADDRESS() volatile
    {
        return (ADDR_ENDP14 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP14's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP14_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP14;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP14 = curr;
    }

    /**
     * Get ADDR_ENDP14's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP14_ENDPOINT() volatile
    {
        return (ADDR_ENDP14 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP14's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP14_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP14;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP14 = curr;
    }

    /**
     * Get ADDR_ENDP14's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP14_INTEP_DIR() volatile
    {
        return ADDR_ENDP14 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP14's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP14_INTEP_DIR() volatile
    {
        ADDR_ENDP14 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP14's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP14_INTEP_DIR() volatile
    {
        ADDR_ENDP14 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP14's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP14_INTEP_DIR() volatile
    {
        ADDR_ENDP14 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP14's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP14_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP14 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP14's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP14_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP14 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP14's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP14_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP14 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP14's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP14_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP14 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP14's bit fields.
     *
     * (read-write) Interrupt endpoint 14. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP14(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                                bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP14;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP14's bit fields.
     *
     * (read-write) Interrupt endpoint 14. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP14(uint8_t ADDRESS, uint8_t ENDPOINT,
                                bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP14;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP14 = curr;
    }

    /**
     * Get ADDR_ENDP15's ADDRESS field.
     *
     * Device address
     */
    inline uint8_t get_ADDR_ENDP15_ADDRESS() volatile
    {
        return (ADDR_ENDP15 >> 0u) & 0b1111111u;
    }

    /**
     * Set ADDR_ENDP15's ADDRESS field.
     *
     * Device address
     */
    inline void set_ADDR_ENDP15_ADDRESS(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP15;

        curr &= ~(0b1111111u << 0u);
        curr |= (value & 0b1111111u) << 0u;

        ADDR_ENDP15 = curr;
    }

    /**
     * Get ADDR_ENDP15's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline uint8_t get_ADDR_ENDP15_ENDPOINT() volatile
    {
        return (ADDR_ENDP15 >> 16u) & 0b1111u;
    }

    /**
     * Set ADDR_ENDP15's ENDPOINT field.
     *
     * Endpoint number of the interrupt endpoint
     */
    inline void set_ADDR_ENDP15_ENDPOINT(uint8_t value) volatile
    {
        uint32_t curr = ADDR_ENDP15;

        curr &= ~(0b1111u << 16u);
        curr |= (value & 0b1111u) << 16u;

        ADDR_ENDP15 = curr;
    }

    /**
     * Get ADDR_ENDP15's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline bool get_ADDR_ENDP15_INTEP_DIR() volatile
    {
        return ADDR_ENDP15 & (1u << 25u);
    }

    /**
     * Set ADDR_ENDP15's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void set_ADDR_ENDP15_INTEP_DIR() volatile
    {
        ADDR_ENDP15 |= 1u << 25u;
    }

    /**
     * Clear ADDR_ENDP15's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void clear_ADDR_ENDP15_INTEP_DIR() volatile
    {
        ADDR_ENDP15 &= ~(1u << 25u);
    }

    /**
     * Toggle ADDR_ENDP15's INTEP_DIR bit.
     *
     * Direction of the interrupt endpoint. In=0, Out=1
     */
    inline void toggle_ADDR_ENDP15_INTEP_DIR() volatile
    {
        ADDR_ENDP15 ^= 1u << 25u;
    }

    /**
     * Get ADDR_ENDP15's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline bool get_ADDR_ENDP15_INTEP_PREAMBLE() volatile
    {
        return ADDR_ENDP15 & (1u << 26u);
    }

    /**
     * Set ADDR_ENDP15's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void set_ADDR_ENDP15_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP15 |= 1u << 26u;
    }

    /**
     * Clear ADDR_ENDP15's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void clear_ADDR_ENDP15_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP15 &= ~(1u << 26u);
    }

    /**
     * Toggle ADDR_ENDP15's INTEP_PREAMBLE bit.
     *
     * Interrupt EP requires preamble (is a low speed device on a full speed
     * hub)
     */
    inline void toggle_ADDR_ENDP15_INTEP_PREAMBLE() volatile
    {
        ADDR_ENDP15 ^= 1u << 26u;
    }

    /**
     * Get all of ADDR_ENDP15's bit fields.
     *
     * (read-write) Interrupt endpoint 15. Only valid for HOST mode.
     */
    inline void get_ADDR_ENDP15(uint8_t &ADDRESS, uint8_t &ENDPOINT,
                                bool &INTEP_DIR, bool &INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP15;

        ADDRESS = (curr >> 0u) & 0b1111111u;
        ENDPOINT = (curr >> 16u) & 0b1111u;
        INTEP_DIR = curr & (1u << 25u);
        INTEP_PREAMBLE = curr & (1u << 26u);
    }

    /**
     * Set all of ADDR_ENDP15's bit fields.
     *
     * (read-write) Interrupt endpoint 15. Only valid for HOST mode.
     */
    inline void set_ADDR_ENDP15(uint8_t ADDRESS, uint8_t ENDPOINT,
                                bool INTEP_DIR, bool INTEP_PREAMBLE) volatile
    {
        uint32_t curr = ADDR_ENDP15;

        curr &= ~(0b1111111u << 0u);
        curr |= (ADDRESS & 0b1111111u) << 0u;
        curr &= ~(0b1111u << 16u);
        curr |= (ENDPOINT & 0b1111u) << 16u;
        curr &= ~(0b1u << 25u);
        curr |= (INTEP_DIR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (INTEP_PREAMBLE & 0b1u) << 26u;

        ADDR_ENDP15 = curr;
    }

    /**
     * Get MAIN_CTRL's CONTROLLER_EN bit.
     *
     * Enable controller
     */
    inline bool get_MAIN_CTRL_CONTROLLER_EN() volatile
    {
        return MAIN_CTRL & (1u << 0u);
    }

    /**
     * Set MAIN_CTRL's CONTROLLER_EN bit.
     *
     * Enable controller
     */
    inline void set_MAIN_CTRL_CONTROLLER_EN() volatile
    {
        MAIN_CTRL |= 1u << 0u;
    }

    /**
     * Clear MAIN_CTRL's CONTROLLER_EN bit.
     *
     * Enable controller
     */
    inline void clear_MAIN_CTRL_CONTROLLER_EN() volatile
    {
        MAIN_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle MAIN_CTRL's CONTROLLER_EN bit.
     *
     * Enable controller
     */
    inline void toggle_MAIN_CTRL_CONTROLLER_EN() volatile
    {
        MAIN_CTRL ^= 1u << 0u;
    }

    /**
     * Get MAIN_CTRL's HOST_NDEVICE bit.
     *
     * Device mode = 0, Host mode = 1
     */
    inline bool get_MAIN_CTRL_HOST_NDEVICE() volatile
    {
        return MAIN_CTRL & (1u << 1u);
    }

    /**
     * Set MAIN_CTRL's HOST_NDEVICE bit.
     *
     * Device mode = 0, Host mode = 1
     */
    inline void set_MAIN_CTRL_HOST_NDEVICE() volatile
    {
        MAIN_CTRL |= 1u << 1u;
    }

    /**
     * Clear MAIN_CTRL's HOST_NDEVICE bit.
     *
     * Device mode = 0, Host mode = 1
     */
    inline void clear_MAIN_CTRL_HOST_NDEVICE() volatile
    {
        MAIN_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle MAIN_CTRL's HOST_NDEVICE bit.
     *
     * Device mode = 0, Host mode = 1
     */
    inline void toggle_MAIN_CTRL_HOST_NDEVICE() volatile
    {
        MAIN_CTRL ^= 1u << 1u;
    }

    /**
     * Get MAIN_CTRL's SIM_TIMING bit.
     *
     * Reduced timings for simulation
     */
    inline bool get_MAIN_CTRL_SIM_TIMING() volatile
    {
        return MAIN_CTRL & (1u << 31u);
    }

    /**
     * Set MAIN_CTRL's SIM_TIMING bit.
     *
     * Reduced timings for simulation
     */
    inline void set_MAIN_CTRL_SIM_TIMING() volatile
    {
        MAIN_CTRL |= 1u << 31u;
    }

    /**
     * Clear MAIN_CTRL's SIM_TIMING bit.
     *
     * Reduced timings for simulation
     */
    inline void clear_MAIN_CTRL_SIM_TIMING() volatile
    {
        MAIN_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle MAIN_CTRL's SIM_TIMING bit.
     *
     * Reduced timings for simulation
     */
    inline void toggle_MAIN_CTRL_SIM_TIMING() volatile
    {
        MAIN_CTRL ^= 1u << 31u;
    }

    /**
     * Get all of MAIN_CTRL's bit fields.
     *
     * (read-write) Main control register
     */
    inline void get_MAIN_CTRL(bool &CONTROLLER_EN, bool &HOST_NDEVICE,
                              bool &SIM_TIMING) volatile
    {
        uint32_t curr = MAIN_CTRL;

        CONTROLLER_EN = curr & (1u << 0u);
        HOST_NDEVICE = curr & (1u << 1u);
        SIM_TIMING = curr & (1u << 31u);
    }

    /**
     * Set all of MAIN_CTRL's bit fields.
     *
     * (read-write) Main control register
     */
    inline void set_MAIN_CTRL(bool CONTROLLER_EN, bool HOST_NDEVICE,
                              bool SIM_TIMING) volatile
    {
        uint32_t curr = MAIN_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (CONTROLLER_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HOST_NDEVICE & 0b1u) << 1u;
        curr &= ~(0b1u << 31u);
        curr |= (SIM_TIMING & 0b1u) << 31u;

        MAIN_CTRL = curr;
    }

    /**
     * Set SOF_WR's COUNT field.
     */
    inline void set_SOF_WR_COUNT(uint16_t value) volatile
    {
        uint32_t curr = SOF_WR;

        curr &= ~(0b11111111111u << 0u);
        curr |= (value & 0b11111111111u) << 0u;

        SOF_WR = curr;
    }

    /**
     * Get SOF_RD's COUNT field.
     */
    inline uint16_t get_SOF_RD_COUNT() volatile
    {
        return (SOF_RD >> 0u) & 0b11111111111u;
    }

    /**
     * Get SIE_CTRL's START_TRANS bit.
     *
     * Host: Start transaction
     */
    inline bool get_SIE_CTRL_START_TRANS() volatile
    {
        return SIE_CTRL & (1u << 0u);
    }

    /**
     * Set SIE_CTRL's START_TRANS bit.
     *
     * Host: Start transaction
     */
    inline void set_SIE_CTRL_START_TRANS() volatile
    {
        SIE_CTRL |= 1u << 0u;
    }

    /**
     * Clear SIE_CTRL's START_TRANS bit.
     *
     * Host: Start transaction
     */
    inline void clear_SIE_CTRL_START_TRANS() volatile
    {
        SIE_CTRL &= ~(1u << 0u);
    }

    /**
     * Toggle SIE_CTRL's START_TRANS bit.
     *
     * Host: Start transaction
     */
    inline void toggle_SIE_CTRL_START_TRANS() volatile
    {
        SIE_CTRL ^= 1u << 0u;
    }

    /**
     * Get SIE_CTRL's SEND_SETUP bit.
     *
     * Host: Send Setup packet
     */
    inline bool get_SIE_CTRL_SEND_SETUP() volatile
    {
        return SIE_CTRL & (1u << 1u);
    }

    /**
     * Set SIE_CTRL's SEND_SETUP bit.
     *
     * Host: Send Setup packet
     */
    inline void set_SIE_CTRL_SEND_SETUP() volatile
    {
        SIE_CTRL |= 1u << 1u;
    }

    /**
     * Clear SIE_CTRL's SEND_SETUP bit.
     *
     * Host: Send Setup packet
     */
    inline void clear_SIE_CTRL_SEND_SETUP() volatile
    {
        SIE_CTRL &= ~(1u << 1u);
    }

    /**
     * Toggle SIE_CTRL's SEND_SETUP bit.
     *
     * Host: Send Setup packet
     */
    inline void toggle_SIE_CTRL_SEND_SETUP() volatile
    {
        SIE_CTRL ^= 1u << 1u;
    }

    /**
     * Get SIE_CTRL's SEND_DATA bit.
     *
     * Host: Send transaction (OUT from host)
     */
    inline bool get_SIE_CTRL_SEND_DATA() volatile
    {
        return SIE_CTRL & (1u << 2u);
    }

    /**
     * Set SIE_CTRL's SEND_DATA bit.
     *
     * Host: Send transaction (OUT from host)
     */
    inline void set_SIE_CTRL_SEND_DATA() volatile
    {
        SIE_CTRL |= 1u << 2u;
    }

    /**
     * Clear SIE_CTRL's SEND_DATA bit.
     *
     * Host: Send transaction (OUT from host)
     */
    inline void clear_SIE_CTRL_SEND_DATA() volatile
    {
        SIE_CTRL &= ~(1u << 2u);
    }

    /**
     * Toggle SIE_CTRL's SEND_DATA bit.
     *
     * Host: Send transaction (OUT from host)
     */
    inline void toggle_SIE_CTRL_SEND_DATA() volatile
    {
        SIE_CTRL ^= 1u << 2u;
    }

    /**
     * Get SIE_CTRL's RECEIVE_DATA bit.
     *
     * Host: Receive transaction (IN to host)
     */
    inline bool get_SIE_CTRL_RECEIVE_DATA() volatile
    {
        return SIE_CTRL & (1u << 3u);
    }

    /**
     * Set SIE_CTRL's RECEIVE_DATA bit.
     *
     * Host: Receive transaction (IN to host)
     */
    inline void set_SIE_CTRL_RECEIVE_DATA() volatile
    {
        SIE_CTRL |= 1u << 3u;
    }

    /**
     * Clear SIE_CTRL's RECEIVE_DATA bit.
     *
     * Host: Receive transaction (IN to host)
     */
    inline void clear_SIE_CTRL_RECEIVE_DATA() volatile
    {
        SIE_CTRL &= ~(1u << 3u);
    }

    /**
     * Toggle SIE_CTRL's RECEIVE_DATA bit.
     *
     * Host: Receive transaction (IN to host)
     */
    inline void toggle_SIE_CTRL_RECEIVE_DATA() volatile
    {
        SIE_CTRL ^= 1u << 3u;
    }

    /**
     * Get SIE_CTRL's STOP_TRANS bit.
     *
     * Host: Stop transaction
     */
    inline bool get_SIE_CTRL_STOP_TRANS() volatile
    {
        return SIE_CTRL & (1u << 4u);
    }

    /**
     * Set SIE_CTRL's STOP_TRANS bit.
     *
     * Host: Stop transaction
     */
    inline void set_SIE_CTRL_STOP_TRANS() volatile
    {
        SIE_CTRL |= 1u << 4u;
    }

    /**
     * Clear SIE_CTRL's STOP_TRANS bit.
     *
     * Host: Stop transaction
     */
    inline void clear_SIE_CTRL_STOP_TRANS() volatile
    {
        SIE_CTRL &= ~(1u << 4u);
    }

    /**
     * Toggle SIE_CTRL's STOP_TRANS bit.
     *
     * Host: Stop transaction
     */
    inline void toggle_SIE_CTRL_STOP_TRANS() volatile
    {
        SIE_CTRL ^= 1u << 4u;
    }

    /**
     * Get SIE_CTRL's PREAMBLE_EN bit.
     *
     * Host: Preable enable for LS device on FS hub
     */
    inline bool get_SIE_CTRL_PREAMBLE_EN() volatile
    {
        return SIE_CTRL & (1u << 6u);
    }

    /**
     * Set SIE_CTRL's PREAMBLE_EN bit.
     *
     * Host: Preable enable for LS device on FS hub
     */
    inline void set_SIE_CTRL_PREAMBLE_EN() volatile
    {
        SIE_CTRL |= 1u << 6u;
    }

    /**
     * Clear SIE_CTRL's PREAMBLE_EN bit.
     *
     * Host: Preable enable for LS device on FS hub
     */
    inline void clear_SIE_CTRL_PREAMBLE_EN() volatile
    {
        SIE_CTRL &= ~(1u << 6u);
    }

    /**
     * Toggle SIE_CTRL's PREAMBLE_EN bit.
     *
     * Host: Preable enable for LS device on FS hub
     */
    inline void toggle_SIE_CTRL_PREAMBLE_EN() volatile
    {
        SIE_CTRL ^= 1u << 6u;
    }

    /**
     * Get SIE_CTRL's SOF_SYNC bit.
     *
     * Host: Delay packet(s) until after SOF
     */
    inline bool get_SIE_CTRL_SOF_SYNC() volatile
    {
        return SIE_CTRL & (1u << 8u);
    }

    /**
     * Set SIE_CTRL's SOF_SYNC bit.
     *
     * Host: Delay packet(s) until after SOF
     */
    inline void set_SIE_CTRL_SOF_SYNC() volatile
    {
        SIE_CTRL |= 1u << 8u;
    }

    /**
     * Clear SIE_CTRL's SOF_SYNC bit.
     *
     * Host: Delay packet(s) until after SOF
     */
    inline void clear_SIE_CTRL_SOF_SYNC() volatile
    {
        SIE_CTRL &= ~(1u << 8u);
    }

    /**
     * Toggle SIE_CTRL's SOF_SYNC bit.
     *
     * Host: Delay packet(s) until after SOF
     */
    inline void toggle_SIE_CTRL_SOF_SYNC() volatile
    {
        SIE_CTRL ^= 1u << 8u;
    }

    /**
     * Get SIE_CTRL's SOF_EN bit.
     *
     * Host: Enable SOF generation (for full speed bus)
     */
    inline bool get_SIE_CTRL_SOF_EN() volatile
    {
        return SIE_CTRL & (1u << 9u);
    }

    /**
     * Set SIE_CTRL's SOF_EN bit.
     *
     * Host: Enable SOF generation (for full speed bus)
     */
    inline void set_SIE_CTRL_SOF_EN() volatile
    {
        SIE_CTRL |= 1u << 9u;
    }

    /**
     * Clear SIE_CTRL's SOF_EN bit.
     *
     * Host: Enable SOF generation (for full speed bus)
     */
    inline void clear_SIE_CTRL_SOF_EN() volatile
    {
        SIE_CTRL &= ~(1u << 9u);
    }

    /**
     * Toggle SIE_CTRL's SOF_EN bit.
     *
     * Host: Enable SOF generation (for full speed bus)
     */
    inline void toggle_SIE_CTRL_SOF_EN() volatile
    {
        SIE_CTRL ^= 1u << 9u;
    }

    /**
     * Get SIE_CTRL's KEEP_ALIVE_EN bit.
     *
     * Host: Enable keep alive packet (for low speed bus)
     */
    inline bool get_SIE_CTRL_KEEP_ALIVE_EN() volatile
    {
        return SIE_CTRL & (1u << 10u);
    }

    /**
     * Set SIE_CTRL's KEEP_ALIVE_EN bit.
     *
     * Host: Enable keep alive packet (for low speed bus)
     */
    inline void set_SIE_CTRL_KEEP_ALIVE_EN() volatile
    {
        SIE_CTRL |= 1u << 10u;
    }

    /**
     * Clear SIE_CTRL's KEEP_ALIVE_EN bit.
     *
     * Host: Enable keep alive packet (for low speed bus)
     */
    inline void clear_SIE_CTRL_KEEP_ALIVE_EN() volatile
    {
        SIE_CTRL &= ~(1u << 10u);
    }

    /**
     * Toggle SIE_CTRL's KEEP_ALIVE_EN bit.
     *
     * Host: Enable keep alive packet (for low speed bus)
     */
    inline void toggle_SIE_CTRL_KEEP_ALIVE_EN() volatile
    {
        SIE_CTRL ^= 1u << 10u;
    }

    /**
     * Get SIE_CTRL's VBUS_EN bit.
     *
     * Host: Enable VBUS
     */
    inline bool get_SIE_CTRL_VBUS_EN() volatile
    {
        return SIE_CTRL & (1u << 11u);
    }

    /**
     * Set SIE_CTRL's VBUS_EN bit.
     *
     * Host: Enable VBUS
     */
    inline void set_SIE_CTRL_VBUS_EN() volatile
    {
        SIE_CTRL |= 1u << 11u;
    }

    /**
     * Clear SIE_CTRL's VBUS_EN bit.
     *
     * Host: Enable VBUS
     */
    inline void clear_SIE_CTRL_VBUS_EN() volatile
    {
        SIE_CTRL &= ~(1u << 11u);
    }

    /**
     * Toggle SIE_CTRL's VBUS_EN bit.
     *
     * Host: Enable VBUS
     */
    inline void toggle_SIE_CTRL_VBUS_EN() volatile
    {
        SIE_CTRL ^= 1u << 11u;
    }

    /**
     * Get SIE_CTRL's RESUME bit.
     *
     * Device: Remote wakeup. Device can initiate its own resume after suspend.
     */
    inline bool get_SIE_CTRL_RESUME() volatile
    {
        return SIE_CTRL & (1u << 12u);
    }

    /**
     * Set SIE_CTRL's RESUME bit.
     *
     * Device: Remote wakeup. Device can initiate its own resume after suspend.
     */
    inline void set_SIE_CTRL_RESUME() volatile
    {
        SIE_CTRL |= 1u << 12u;
    }

    /**
     * Clear SIE_CTRL's RESUME bit.
     *
     * Device: Remote wakeup. Device can initiate its own resume after suspend.
     */
    inline void clear_SIE_CTRL_RESUME() volatile
    {
        SIE_CTRL &= ~(1u << 12u);
    }

    /**
     * Toggle SIE_CTRL's RESUME bit.
     *
     * Device: Remote wakeup. Device can initiate its own resume after suspend.
     */
    inline void toggle_SIE_CTRL_RESUME() volatile
    {
        SIE_CTRL ^= 1u << 12u;
    }

    /**
     * Get SIE_CTRL's RESET_BUS bit.
     *
     * Host: Reset bus
     */
    inline bool get_SIE_CTRL_RESET_BUS() volatile
    {
        return SIE_CTRL & (1u << 13u);
    }

    /**
     * Set SIE_CTRL's RESET_BUS bit.
     *
     * Host: Reset bus
     */
    inline void set_SIE_CTRL_RESET_BUS() volatile
    {
        SIE_CTRL |= 1u << 13u;
    }

    /**
     * Clear SIE_CTRL's RESET_BUS bit.
     *
     * Host: Reset bus
     */
    inline void clear_SIE_CTRL_RESET_BUS() volatile
    {
        SIE_CTRL &= ~(1u << 13u);
    }

    /**
     * Toggle SIE_CTRL's RESET_BUS bit.
     *
     * Host: Reset bus
     */
    inline void toggle_SIE_CTRL_RESET_BUS() volatile
    {
        SIE_CTRL ^= 1u << 13u;
    }

    /**
     * Get SIE_CTRL's PULLDOWN_EN bit.
     *
     * Host: Enable pull down resistors
     */
    inline bool get_SIE_CTRL_PULLDOWN_EN() volatile
    {
        return SIE_CTRL & (1u << 15u);
    }

    /**
     * Set SIE_CTRL's PULLDOWN_EN bit.
     *
     * Host: Enable pull down resistors
     */
    inline void set_SIE_CTRL_PULLDOWN_EN() volatile
    {
        SIE_CTRL |= 1u << 15u;
    }

    /**
     * Clear SIE_CTRL's PULLDOWN_EN bit.
     *
     * Host: Enable pull down resistors
     */
    inline void clear_SIE_CTRL_PULLDOWN_EN() volatile
    {
        SIE_CTRL &= ~(1u << 15u);
    }

    /**
     * Toggle SIE_CTRL's PULLDOWN_EN bit.
     *
     * Host: Enable pull down resistors
     */
    inline void toggle_SIE_CTRL_PULLDOWN_EN() volatile
    {
        SIE_CTRL ^= 1u << 15u;
    }

    /**
     * Get SIE_CTRL's PULLUP_EN bit.
     *
     * Device: Enable pull up resistor
     */
    inline bool get_SIE_CTRL_PULLUP_EN() volatile
    {
        return SIE_CTRL & (1u << 16u);
    }

    /**
     * Set SIE_CTRL's PULLUP_EN bit.
     *
     * Device: Enable pull up resistor
     */
    inline void set_SIE_CTRL_PULLUP_EN() volatile
    {
        SIE_CTRL |= 1u << 16u;
    }

    /**
     * Clear SIE_CTRL's PULLUP_EN bit.
     *
     * Device: Enable pull up resistor
     */
    inline void clear_SIE_CTRL_PULLUP_EN() volatile
    {
        SIE_CTRL &= ~(1u << 16u);
    }

    /**
     * Toggle SIE_CTRL's PULLUP_EN bit.
     *
     * Device: Enable pull up resistor
     */
    inline void toggle_SIE_CTRL_PULLUP_EN() volatile
    {
        SIE_CTRL ^= 1u << 16u;
    }

    /**
     * Get SIE_CTRL's RPU_OPT bit.
     *
     * Device: Pull-up strength (0=1K2, 1=2k3)
     */
    inline bool get_SIE_CTRL_RPU_OPT() volatile
    {
        return SIE_CTRL & (1u << 17u);
    }

    /**
     * Set SIE_CTRL's RPU_OPT bit.
     *
     * Device: Pull-up strength (0=1K2, 1=2k3)
     */
    inline void set_SIE_CTRL_RPU_OPT() volatile
    {
        SIE_CTRL |= 1u << 17u;
    }

    /**
     * Clear SIE_CTRL's RPU_OPT bit.
     *
     * Device: Pull-up strength (0=1K2, 1=2k3)
     */
    inline void clear_SIE_CTRL_RPU_OPT() volatile
    {
        SIE_CTRL &= ~(1u << 17u);
    }

    /**
     * Toggle SIE_CTRL's RPU_OPT bit.
     *
     * Device: Pull-up strength (0=1K2, 1=2k3)
     */
    inline void toggle_SIE_CTRL_RPU_OPT() volatile
    {
        SIE_CTRL ^= 1u << 17u;
    }

    /**
     * Get SIE_CTRL's TRANSCEIVER_PD bit.
     *
     * Power down bus transceiver
     */
    inline bool get_SIE_CTRL_TRANSCEIVER_PD() volatile
    {
        return SIE_CTRL & (1u << 18u);
    }

    /**
     * Set SIE_CTRL's TRANSCEIVER_PD bit.
     *
     * Power down bus transceiver
     */
    inline void set_SIE_CTRL_TRANSCEIVER_PD() volatile
    {
        SIE_CTRL |= 1u << 18u;
    }

    /**
     * Clear SIE_CTRL's TRANSCEIVER_PD bit.
     *
     * Power down bus transceiver
     */
    inline void clear_SIE_CTRL_TRANSCEIVER_PD() volatile
    {
        SIE_CTRL &= ~(1u << 18u);
    }

    /**
     * Toggle SIE_CTRL's TRANSCEIVER_PD bit.
     *
     * Power down bus transceiver
     */
    inline void toggle_SIE_CTRL_TRANSCEIVER_PD() volatile
    {
        SIE_CTRL ^= 1u << 18u;
    }

    /**
     * Get SIE_CTRL's DIRECT_DM bit.
     *
     * Direct control of DM
     */
    inline bool get_SIE_CTRL_DIRECT_DM() volatile
    {
        return SIE_CTRL & (1u << 24u);
    }

    /**
     * Set SIE_CTRL's DIRECT_DM bit.
     *
     * Direct control of DM
     */
    inline void set_SIE_CTRL_DIRECT_DM() volatile
    {
        SIE_CTRL |= 1u << 24u;
    }

    /**
     * Clear SIE_CTRL's DIRECT_DM bit.
     *
     * Direct control of DM
     */
    inline void clear_SIE_CTRL_DIRECT_DM() volatile
    {
        SIE_CTRL &= ~(1u << 24u);
    }

    /**
     * Toggle SIE_CTRL's DIRECT_DM bit.
     *
     * Direct control of DM
     */
    inline void toggle_SIE_CTRL_DIRECT_DM() volatile
    {
        SIE_CTRL ^= 1u << 24u;
    }

    /**
     * Get SIE_CTRL's DIRECT_DP bit.
     *
     * Direct control of DP
     */
    inline bool get_SIE_CTRL_DIRECT_DP() volatile
    {
        return SIE_CTRL & (1u << 25u);
    }

    /**
     * Set SIE_CTRL's DIRECT_DP bit.
     *
     * Direct control of DP
     */
    inline void set_SIE_CTRL_DIRECT_DP() volatile
    {
        SIE_CTRL |= 1u << 25u;
    }

    /**
     * Clear SIE_CTRL's DIRECT_DP bit.
     *
     * Direct control of DP
     */
    inline void clear_SIE_CTRL_DIRECT_DP() volatile
    {
        SIE_CTRL &= ~(1u << 25u);
    }

    /**
     * Toggle SIE_CTRL's DIRECT_DP bit.
     *
     * Direct control of DP
     */
    inline void toggle_SIE_CTRL_DIRECT_DP() volatile
    {
        SIE_CTRL ^= 1u << 25u;
    }

    /**
     * Get SIE_CTRL's DIRECT_EN bit.
     *
     * Direct bus drive enable
     */
    inline bool get_SIE_CTRL_DIRECT_EN() volatile
    {
        return SIE_CTRL & (1u << 26u);
    }

    /**
     * Set SIE_CTRL's DIRECT_EN bit.
     *
     * Direct bus drive enable
     */
    inline void set_SIE_CTRL_DIRECT_EN() volatile
    {
        SIE_CTRL |= 1u << 26u;
    }

    /**
     * Clear SIE_CTRL's DIRECT_EN bit.
     *
     * Direct bus drive enable
     */
    inline void clear_SIE_CTRL_DIRECT_EN() volatile
    {
        SIE_CTRL &= ~(1u << 26u);
    }

    /**
     * Toggle SIE_CTRL's DIRECT_EN bit.
     *
     * Direct bus drive enable
     */
    inline void toggle_SIE_CTRL_DIRECT_EN() volatile
    {
        SIE_CTRL ^= 1u << 26u;
    }

    /**
     * Get SIE_CTRL's EP0_INT_NAK bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
     */
    inline bool get_SIE_CTRL_EP0_INT_NAK() volatile
    {
        return SIE_CTRL & (1u << 27u);
    }

    /**
     * Set SIE_CTRL's EP0_INT_NAK bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
     */
    inline void set_SIE_CTRL_EP0_INT_NAK() volatile
    {
        SIE_CTRL |= 1u << 27u;
    }

    /**
     * Clear SIE_CTRL's EP0_INT_NAK bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
     */
    inline void clear_SIE_CTRL_EP0_INT_NAK() volatile
    {
        SIE_CTRL &= ~(1u << 27u);
    }

    /**
     * Toggle SIE_CTRL's EP0_INT_NAK bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a NAK
     */
    inline void toggle_SIE_CTRL_EP0_INT_NAK() volatile
    {
        SIE_CTRL ^= 1u << 27u;
    }

    /**
     * Get SIE_CTRL's EP0_INT_2BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
     */
    inline bool get_SIE_CTRL_EP0_INT_2BUF() volatile
    {
        return SIE_CTRL & (1u << 28u);
    }

    /**
     * Set SIE_CTRL's EP0_INT_2BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
     */
    inline void set_SIE_CTRL_EP0_INT_2BUF() volatile
    {
        SIE_CTRL |= 1u << 28u;
    }

    /**
     * Clear SIE_CTRL's EP0_INT_2BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
     */
    inline void clear_SIE_CTRL_EP0_INT_2BUF() volatile
    {
        SIE_CTRL &= ~(1u << 28u);
    }

    /**
     * Toggle SIE_CTRL's EP0_INT_2BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every 2 buffers completed on EP0
     */
    inline void toggle_SIE_CTRL_EP0_INT_2BUF() volatile
    {
        SIE_CTRL ^= 1u << 28u;
    }

    /**
     * Get SIE_CTRL's EP0_INT_1BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every buffer completed on EP0
     */
    inline bool get_SIE_CTRL_EP0_INT_1BUF() volatile
    {
        return SIE_CTRL & (1u << 29u);
    }

    /**
     * Set SIE_CTRL's EP0_INT_1BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every buffer completed on EP0
     */
    inline void set_SIE_CTRL_EP0_INT_1BUF() volatile
    {
        SIE_CTRL |= 1u << 29u;
    }

    /**
     * Clear SIE_CTRL's EP0_INT_1BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every buffer completed on EP0
     */
    inline void clear_SIE_CTRL_EP0_INT_1BUF() volatile
    {
        SIE_CTRL &= ~(1u << 29u);
    }

    /**
     * Toggle SIE_CTRL's EP0_INT_1BUF bit.
     *
     * Device: Set bit in BUFF_STATUS for every buffer completed on EP0
     */
    inline void toggle_SIE_CTRL_EP0_INT_1BUF() volatile
    {
        SIE_CTRL ^= 1u << 29u;
    }

    /**
     * Get SIE_CTRL's EP0_DOUBLE_BUF bit.
     *
     * Device: EP0 single buffered = 0, double buffered = 1
     */
    inline bool get_SIE_CTRL_EP0_DOUBLE_BUF() volatile
    {
        return SIE_CTRL & (1u << 30u);
    }

    /**
     * Set SIE_CTRL's EP0_DOUBLE_BUF bit.
     *
     * Device: EP0 single buffered = 0, double buffered = 1
     */
    inline void set_SIE_CTRL_EP0_DOUBLE_BUF() volatile
    {
        SIE_CTRL |= 1u << 30u;
    }

    /**
     * Clear SIE_CTRL's EP0_DOUBLE_BUF bit.
     *
     * Device: EP0 single buffered = 0, double buffered = 1
     */
    inline void clear_SIE_CTRL_EP0_DOUBLE_BUF() volatile
    {
        SIE_CTRL &= ~(1u << 30u);
    }

    /**
     * Toggle SIE_CTRL's EP0_DOUBLE_BUF bit.
     *
     * Device: EP0 single buffered = 0, double buffered = 1
     */
    inline void toggle_SIE_CTRL_EP0_DOUBLE_BUF() volatile
    {
        SIE_CTRL ^= 1u << 30u;
    }

    /**
     * Get SIE_CTRL's EP0_INT_STALL bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
     */
    inline bool get_SIE_CTRL_EP0_INT_STALL() volatile
    {
        return SIE_CTRL & (1u << 31u);
    }

    /**
     * Set SIE_CTRL's EP0_INT_STALL bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
     */
    inline void set_SIE_CTRL_EP0_INT_STALL() volatile
    {
        SIE_CTRL |= 1u << 31u;
    }

    /**
     * Clear SIE_CTRL's EP0_INT_STALL bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
     */
    inline void clear_SIE_CTRL_EP0_INT_STALL() volatile
    {
        SIE_CTRL &= ~(1u << 31u);
    }

    /**
     * Toggle SIE_CTRL's EP0_INT_STALL bit.
     *
     * Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends a STALL
     */
    inline void toggle_SIE_CTRL_EP0_INT_STALL() volatile
    {
        SIE_CTRL ^= 1u << 31u;
    }

    /**
     * Get all of SIE_CTRL's bit fields.
     *
     * (read-write) SIE control register
     */
    inline void get_SIE_CTRL(
        bool &START_TRANS, bool &SEND_SETUP, bool &SEND_DATA,
        bool &RECEIVE_DATA, bool &STOP_TRANS, bool &PREAMBLE_EN,
        bool &SOF_SYNC, bool &SOF_EN, bool &KEEP_ALIVE_EN, bool &VBUS_EN,
        bool &RESUME, bool &RESET_BUS, bool &PULLDOWN_EN, bool &PULLUP_EN,
        bool &RPU_OPT, bool &TRANSCEIVER_PD, bool &DIRECT_DM, bool &DIRECT_DP,
        bool &DIRECT_EN, bool &EP0_INT_NAK, bool &EP0_INT_2BUF,
        bool &EP0_INT_1BUF, bool &EP0_DOUBLE_BUF, bool &EP0_INT_STALL) volatile
    {
        uint32_t curr = SIE_CTRL;

        START_TRANS = curr & (1u << 0u);
        SEND_SETUP = curr & (1u << 1u);
        SEND_DATA = curr & (1u << 2u);
        RECEIVE_DATA = curr & (1u << 3u);
        STOP_TRANS = curr & (1u << 4u);
        PREAMBLE_EN = curr & (1u << 6u);
        SOF_SYNC = curr & (1u << 8u);
        SOF_EN = curr & (1u << 9u);
        KEEP_ALIVE_EN = curr & (1u << 10u);
        VBUS_EN = curr & (1u << 11u);
        RESUME = curr & (1u << 12u);
        RESET_BUS = curr & (1u << 13u);
        PULLDOWN_EN = curr & (1u << 15u);
        PULLUP_EN = curr & (1u << 16u);
        RPU_OPT = curr & (1u << 17u);
        TRANSCEIVER_PD = curr & (1u << 18u);
        DIRECT_DM = curr & (1u << 24u);
        DIRECT_DP = curr & (1u << 25u);
        DIRECT_EN = curr & (1u << 26u);
        EP0_INT_NAK = curr & (1u << 27u);
        EP0_INT_2BUF = curr & (1u << 28u);
        EP0_INT_1BUF = curr & (1u << 29u);
        EP0_DOUBLE_BUF = curr & (1u << 30u);
        EP0_INT_STALL = curr & (1u << 31u);
    }

    /**
     * Set all of SIE_CTRL's bit fields.
     *
     * (read-write) SIE control register
     */
    inline void set_SIE_CTRL(bool START_TRANS, bool SEND_SETUP, bool SEND_DATA,
                             bool RECEIVE_DATA, bool STOP_TRANS,
                             bool PREAMBLE_EN, bool SOF_SYNC, bool SOF_EN,
                             bool KEEP_ALIVE_EN, bool VBUS_EN, bool RESUME,
                             bool RESET_BUS, bool PULLDOWN_EN, bool PULLUP_EN,
                             bool RPU_OPT, bool TRANSCEIVER_PD, bool DIRECT_DM,
                             bool DIRECT_DP, bool DIRECT_EN, bool EP0_INT_NAK,
                             bool EP0_INT_2BUF, bool EP0_INT_1BUF,
                             bool EP0_DOUBLE_BUF, bool EP0_INT_STALL) volatile
    {
        uint32_t curr = SIE_CTRL;

        curr &= ~(0b1u << 0u);
        curr |= (START_TRANS & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (SEND_SETUP & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (SEND_DATA & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (RECEIVE_DATA & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (STOP_TRANS & 0b1u) << 4u;
        curr &= ~(0b1u << 6u);
        curr |= (PREAMBLE_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 8u);
        curr |= (SOF_SYNC & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (SOF_EN & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (KEEP_ALIVE_EN & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (VBUS_EN & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RESUME & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (RESET_BUS & 0b1u) << 13u;
        curr &= ~(0b1u << 15u);
        curr |= (PULLDOWN_EN & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (PULLUP_EN & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (RPU_OPT & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (TRANSCEIVER_PD & 0b1u) << 18u;
        curr &= ~(0b1u << 24u);
        curr |= (DIRECT_DM & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (DIRECT_DP & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (DIRECT_EN & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (EP0_INT_NAK & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (EP0_INT_2BUF & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (EP0_INT_1BUF & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (EP0_DOUBLE_BUF & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (EP0_INT_STALL & 0b1u) << 31u;

        SIE_CTRL = curr;
    }

    /**
     * Get SIE_STATUS's VBUS_DETECTED bit.
     *
     * Device: VBUS Detected
     */
    inline bool get_SIE_STATUS_VBUS_DETECTED() volatile
    {
        return SIE_STATUS & (1u << 0u);
    }

    /**
     * Get SIE_STATUS's LINE_STATE field.
     *
     * USB bus line state
     */
    inline uint8_t get_SIE_STATUS_LINE_STATE() volatile
    {
        return (SIE_STATUS >> 2u) & 0b11u;
    }

    /**
     * Get SIE_STATUS's SUSPENDED bit.
     *
     * Bus in suspended state. Valid for device and host. Host and device will
     * go into suspend if neither Keep Alive / SOF frames are enabled.
     */
    inline bool get_SIE_STATUS_SUSPENDED() volatile
    {
        return SIE_STATUS & (1u << 4u);
    }

    /**
     * Set SIE_STATUS's SUSPENDED bit.
     *
     * Bus in suspended state. Valid for device and host. Host and device will
     * go into suspend if neither Keep Alive / SOF frames are enabled.
     */
    inline void set_SIE_STATUS_SUSPENDED() volatile
    {
        SIE_STATUS |= 1u << 4u;
    }

    /**
     * Clear SIE_STATUS's SUSPENDED bit.
     *
     * Bus in suspended state. Valid for device and host. Host and device will
     * go into suspend if neither Keep Alive / SOF frames are enabled.
     */
    inline void clear_SIE_STATUS_SUSPENDED() volatile
    {
        SIE_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle SIE_STATUS's SUSPENDED bit.
     *
     * Bus in suspended state. Valid for device and host. Host and device will
     * go into suspend if neither Keep Alive / SOF frames are enabled.
     */
    inline void toggle_SIE_STATUS_SUSPENDED() volatile
    {
        SIE_STATUS ^= 1u << 4u;
    }

    /**
     * Get SIE_STATUS's SPEED field.
     *
     * Host: device speed. Disconnected = 00, LS = 01, FS = 10
     */
    inline uint8_t get_SIE_STATUS_SPEED() volatile
    {
        return (SIE_STATUS >> 8u) & 0b11u;
    }

    /**
     * Set SIE_STATUS's SPEED field.
     *
     * Host: device speed. Disconnected = 00, LS = 01, FS = 10
     */
    inline void set_SIE_STATUS_SPEED(uint8_t value) volatile
    {
        uint32_t curr = SIE_STATUS;

        curr &= ~(0b11u << 8u);
        curr |= (value & 0b11u) << 8u;

        SIE_STATUS = curr;
    }

    /**
     * Get SIE_STATUS's VBUS_OVER_CURR bit.
     *
     * VBUS over current detected
     */
    inline bool get_SIE_STATUS_VBUS_OVER_CURR() volatile
    {
        return SIE_STATUS & (1u << 10u);
    }

    /**
     * Get SIE_STATUS's RESUME bit.
     *
     * Host: Device has initiated a remote resume. Device: host has initiated a
     * resume.
     */
    inline bool get_SIE_STATUS_RESUME() volatile
    {
        return SIE_STATUS & (1u << 11u);
    }

    /**
     * Set SIE_STATUS's RESUME bit.
     *
     * Host: Device has initiated a remote resume. Device: host has initiated a
     * resume.
     */
    inline void set_SIE_STATUS_RESUME() volatile
    {
        SIE_STATUS |= 1u << 11u;
    }

    /**
     * Clear SIE_STATUS's RESUME bit.
     *
     * Host: Device has initiated a remote resume. Device: host has initiated a
     * resume.
     */
    inline void clear_SIE_STATUS_RESUME() volatile
    {
        SIE_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle SIE_STATUS's RESUME bit.
     *
     * Host: Device has initiated a remote resume. Device: host has initiated a
     * resume.
     */
    inline void toggle_SIE_STATUS_RESUME() volatile
    {
        SIE_STATUS ^= 1u << 11u;
    }

    /**
     * Get SIE_STATUS's CONNECTED bit.
     *
     * Device: connected
     */
    inline bool get_SIE_STATUS_CONNECTED() volatile
    {
        return SIE_STATUS & (1u << 16u);
    }

    /**
     * Set SIE_STATUS's CONNECTED bit.
     *
     * Device: connected
     */
    inline void set_SIE_STATUS_CONNECTED() volatile
    {
        SIE_STATUS |= 1u << 16u;
    }

    /**
     * Clear SIE_STATUS's CONNECTED bit.
     *
     * Device: connected
     */
    inline void clear_SIE_STATUS_CONNECTED() volatile
    {
        SIE_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle SIE_STATUS's CONNECTED bit.
     *
     * Device: connected
     */
    inline void toggle_SIE_STATUS_CONNECTED() volatile
    {
        SIE_STATUS ^= 1u << 16u;
    }

    /**
     * Get SIE_STATUS's SETUP_REC bit.
     *
     * Device: Setup packet received
     */
    inline bool get_SIE_STATUS_SETUP_REC() volatile
    {
        return SIE_STATUS & (1u << 17u);
    }

    /**
     * Set SIE_STATUS's SETUP_REC bit.
     *
     * Device: Setup packet received
     */
    inline void set_SIE_STATUS_SETUP_REC() volatile
    {
        SIE_STATUS |= 1u << 17u;
    }

    /**
     * Clear SIE_STATUS's SETUP_REC bit.
     *
     * Device: Setup packet received
     */
    inline void clear_SIE_STATUS_SETUP_REC() volatile
    {
        SIE_STATUS &= ~(1u << 17u);
    }

    /**
     * Toggle SIE_STATUS's SETUP_REC bit.
     *
     * Device: Setup packet received
     */
    inline void toggle_SIE_STATUS_SETUP_REC() volatile
    {
        SIE_STATUS ^= 1u << 17u;
    }

    /**
     * Get SIE_STATUS's TRANS_COMPLETE bit.
     *
     * Transaction complete.\n\n
     *                 Raised by device if:\n\n
     *                 * An IN or OUT packet is sent with the `LAST_BUFF` bit
     * set in the buffer control register\n\n Raised by host if:\n\n
     *                 * A setup packet is sent when no data in or data out
     * transaction follows * An IN packet is received and the `LAST_BUFF` bit
     * is set in the buffer control register * An IN packet is received with
     * zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
     */
    inline bool get_SIE_STATUS_TRANS_COMPLETE() volatile
    {
        return SIE_STATUS & (1u << 18u);
    }

    /**
     * Set SIE_STATUS's TRANS_COMPLETE bit.
     *
     * Transaction complete.\n\n
     *                 Raised by device if:\n\n
     *                 * An IN or OUT packet is sent with the `LAST_BUFF` bit
     * set in the buffer control register\n\n Raised by host if:\n\n
     *                 * A setup packet is sent when no data in or data out
     * transaction follows * An IN packet is received and the `LAST_BUFF` bit
     * is set in the buffer control register * An IN packet is received with
     * zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
     */
    inline void set_SIE_STATUS_TRANS_COMPLETE() volatile
    {
        SIE_STATUS |= 1u << 18u;
    }

    /**
     * Clear SIE_STATUS's TRANS_COMPLETE bit.
     *
     * Transaction complete.\n\n
     *                 Raised by device if:\n\n
     *                 * An IN or OUT packet is sent with the `LAST_BUFF` bit
     * set in the buffer control register\n\n Raised by host if:\n\n
     *                 * A setup packet is sent when no data in or data out
     * transaction follows * An IN packet is received and the `LAST_BUFF` bit
     * is set in the buffer control register * An IN packet is received with
     * zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
     */
    inline void clear_SIE_STATUS_TRANS_COMPLETE() volatile
    {
        SIE_STATUS &= ~(1u << 18u);
    }

    /**
     * Toggle SIE_STATUS's TRANS_COMPLETE bit.
     *
     * Transaction complete.\n\n
     *                 Raised by device if:\n\n
     *                 * An IN or OUT packet is sent with the `LAST_BUFF` bit
     * set in the buffer control register\n\n Raised by host if:\n\n
     *                 * A setup packet is sent when no data in or data out
     * transaction follows * An IN packet is received and the `LAST_BUFF` bit
     * is set in the buffer control register * An IN packet is received with
     * zero length * An OUT packet is sent and the `LAST_BUFF` bit is set
     */
    inline void toggle_SIE_STATUS_TRANS_COMPLETE() volatile
    {
        SIE_STATUS ^= 1u << 18u;
    }

    /**
     * Get SIE_STATUS's BUS_RESET bit.
     *
     * Device: bus reset received
     */
    inline bool get_SIE_STATUS_BUS_RESET() volatile
    {
        return SIE_STATUS & (1u << 19u);
    }

    /**
     * Set SIE_STATUS's BUS_RESET bit.
     *
     * Device: bus reset received
     */
    inline void set_SIE_STATUS_BUS_RESET() volatile
    {
        SIE_STATUS |= 1u << 19u;
    }

    /**
     * Clear SIE_STATUS's BUS_RESET bit.
     *
     * Device: bus reset received
     */
    inline void clear_SIE_STATUS_BUS_RESET() volatile
    {
        SIE_STATUS &= ~(1u << 19u);
    }

    /**
     * Toggle SIE_STATUS's BUS_RESET bit.
     *
     * Device: bus reset received
     */
    inline void toggle_SIE_STATUS_BUS_RESET() volatile
    {
        SIE_STATUS ^= 1u << 19u;
    }

    /**
     * Get SIE_STATUS's CRC_ERROR bit.
     *
     * CRC Error. Raised by the Serial RX engine.
     */
    inline bool get_SIE_STATUS_CRC_ERROR() volatile
    {
        return SIE_STATUS & (1u << 24u);
    }

    /**
     * Set SIE_STATUS's CRC_ERROR bit.
     *
     * CRC Error. Raised by the Serial RX engine.
     */
    inline void set_SIE_STATUS_CRC_ERROR() volatile
    {
        SIE_STATUS |= 1u << 24u;
    }

    /**
     * Clear SIE_STATUS's CRC_ERROR bit.
     *
     * CRC Error. Raised by the Serial RX engine.
     */
    inline void clear_SIE_STATUS_CRC_ERROR() volatile
    {
        SIE_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle SIE_STATUS's CRC_ERROR bit.
     *
     * CRC Error. Raised by the Serial RX engine.
     */
    inline void toggle_SIE_STATUS_CRC_ERROR() volatile
    {
        SIE_STATUS ^= 1u << 24u;
    }

    /**
     * Get SIE_STATUS's BIT_STUFF_ERROR bit.
     *
     * Bit Stuff Error. Raised by the Serial RX engine.
     */
    inline bool get_SIE_STATUS_BIT_STUFF_ERROR() volatile
    {
        return SIE_STATUS & (1u << 25u);
    }

    /**
     * Set SIE_STATUS's BIT_STUFF_ERROR bit.
     *
     * Bit Stuff Error. Raised by the Serial RX engine.
     */
    inline void set_SIE_STATUS_BIT_STUFF_ERROR() volatile
    {
        SIE_STATUS |= 1u << 25u;
    }

    /**
     * Clear SIE_STATUS's BIT_STUFF_ERROR bit.
     *
     * Bit Stuff Error. Raised by the Serial RX engine.
     */
    inline void clear_SIE_STATUS_BIT_STUFF_ERROR() volatile
    {
        SIE_STATUS &= ~(1u << 25u);
    }

    /**
     * Toggle SIE_STATUS's BIT_STUFF_ERROR bit.
     *
     * Bit Stuff Error. Raised by the Serial RX engine.
     */
    inline void toggle_SIE_STATUS_BIT_STUFF_ERROR() volatile
    {
        SIE_STATUS ^= 1u << 25u;
    }

    /**
     * Get SIE_STATUS's RX_OVERFLOW bit.
     *
     * RX overflow is raised by the Serial RX engine if the incoming data is
     * too fast.
     */
    inline bool get_SIE_STATUS_RX_OVERFLOW() volatile
    {
        return SIE_STATUS & (1u << 26u);
    }

    /**
     * Set SIE_STATUS's RX_OVERFLOW bit.
     *
     * RX overflow is raised by the Serial RX engine if the incoming data is
     * too fast.
     */
    inline void set_SIE_STATUS_RX_OVERFLOW() volatile
    {
        SIE_STATUS |= 1u << 26u;
    }

    /**
     * Clear SIE_STATUS's RX_OVERFLOW bit.
     *
     * RX overflow is raised by the Serial RX engine if the incoming data is
     * too fast.
     */
    inline void clear_SIE_STATUS_RX_OVERFLOW() volatile
    {
        SIE_STATUS &= ~(1u << 26u);
    }

    /**
     * Toggle SIE_STATUS's RX_OVERFLOW bit.
     *
     * RX overflow is raised by the Serial RX engine if the incoming data is
     * too fast.
     */
    inline void toggle_SIE_STATUS_RX_OVERFLOW() volatile
    {
        SIE_STATUS ^= 1u << 26u;
    }

    /**
     * Get SIE_STATUS's RX_TIMEOUT bit.
     *
     * RX timeout is raised by both the host and device if an ACK is not
     * received in the maximum time specified by the USB spec.
     */
    inline bool get_SIE_STATUS_RX_TIMEOUT() volatile
    {
        return SIE_STATUS & (1u << 27u);
    }

    /**
     * Set SIE_STATUS's RX_TIMEOUT bit.
     *
     * RX timeout is raised by both the host and device if an ACK is not
     * received in the maximum time specified by the USB spec.
     */
    inline void set_SIE_STATUS_RX_TIMEOUT() volatile
    {
        SIE_STATUS |= 1u << 27u;
    }

    /**
     * Clear SIE_STATUS's RX_TIMEOUT bit.
     *
     * RX timeout is raised by both the host and device if an ACK is not
     * received in the maximum time specified by the USB spec.
     */
    inline void clear_SIE_STATUS_RX_TIMEOUT() volatile
    {
        SIE_STATUS &= ~(1u << 27u);
    }

    /**
     * Toggle SIE_STATUS's RX_TIMEOUT bit.
     *
     * RX timeout is raised by both the host and device if an ACK is not
     * received in the maximum time specified by the USB spec.
     */
    inline void toggle_SIE_STATUS_RX_TIMEOUT() volatile
    {
        SIE_STATUS ^= 1u << 27u;
    }

    /**
     * Get SIE_STATUS's NAK_REC bit.
     *
     * Host: NAK received
     */
    inline bool get_SIE_STATUS_NAK_REC() volatile
    {
        return SIE_STATUS & (1u << 28u);
    }

    /**
     * Set SIE_STATUS's NAK_REC bit.
     *
     * Host: NAK received
     */
    inline void set_SIE_STATUS_NAK_REC() volatile
    {
        SIE_STATUS |= 1u << 28u;
    }

    /**
     * Clear SIE_STATUS's NAK_REC bit.
     *
     * Host: NAK received
     */
    inline void clear_SIE_STATUS_NAK_REC() volatile
    {
        SIE_STATUS &= ~(1u << 28u);
    }

    /**
     * Toggle SIE_STATUS's NAK_REC bit.
     *
     * Host: NAK received
     */
    inline void toggle_SIE_STATUS_NAK_REC() volatile
    {
        SIE_STATUS ^= 1u << 28u;
    }

    /**
     * Get SIE_STATUS's STALL_REC bit.
     *
     * Host: STALL received
     */
    inline bool get_SIE_STATUS_STALL_REC() volatile
    {
        return SIE_STATUS & (1u << 29u);
    }

    /**
     * Set SIE_STATUS's STALL_REC bit.
     *
     * Host: STALL received
     */
    inline void set_SIE_STATUS_STALL_REC() volatile
    {
        SIE_STATUS |= 1u << 29u;
    }

    /**
     * Clear SIE_STATUS's STALL_REC bit.
     *
     * Host: STALL received
     */
    inline void clear_SIE_STATUS_STALL_REC() volatile
    {
        SIE_STATUS &= ~(1u << 29u);
    }

    /**
     * Toggle SIE_STATUS's STALL_REC bit.
     *
     * Host: STALL received
     */
    inline void toggle_SIE_STATUS_STALL_REC() volatile
    {
        SIE_STATUS ^= 1u << 29u;
    }

    /**
     * Get SIE_STATUS's ACK_REC bit.
     *
     * ACK received. Raised by both host and device.
     */
    inline bool get_SIE_STATUS_ACK_REC() volatile
    {
        return SIE_STATUS & (1u << 30u);
    }

    /**
     * Set SIE_STATUS's ACK_REC bit.
     *
     * ACK received. Raised by both host and device.
     */
    inline void set_SIE_STATUS_ACK_REC() volatile
    {
        SIE_STATUS |= 1u << 30u;
    }

    /**
     * Clear SIE_STATUS's ACK_REC bit.
     *
     * ACK received. Raised by both host and device.
     */
    inline void clear_SIE_STATUS_ACK_REC() volatile
    {
        SIE_STATUS &= ~(1u << 30u);
    }

    /**
     * Toggle SIE_STATUS's ACK_REC bit.
     *
     * ACK received. Raised by both host and device.
     */
    inline void toggle_SIE_STATUS_ACK_REC() volatile
    {
        SIE_STATUS ^= 1u << 30u;
    }

    /**
     * Get SIE_STATUS's DATA_SEQ_ERROR bit.
     *
     * Data Sequence Error.\n\n
     *                 The device can raise a sequence error in the following
     * conditions:\n\n
     *                 * A SETUP packet is received followed by a DATA1 packet
     * (data phase should always be DATA0) * An OUT packet is received from the
     * host but doesn't match the data pid in the buffer control register read
     * from DPSRAM\n\n The host can raise a data sequence error in the
     * following conditions:\n\n
     *                 * An IN packet from the device has the wrong data PID
     */
    inline bool get_SIE_STATUS_DATA_SEQ_ERROR() volatile
    {
        return SIE_STATUS & (1u << 31u);
    }

    /**
     * Set SIE_STATUS's DATA_SEQ_ERROR bit.
     *
     * Data Sequence Error.\n\n
     *                 The device can raise a sequence error in the following
     * conditions:\n\n
     *                 * A SETUP packet is received followed by a DATA1 packet
     * (data phase should always be DATA0) * An OUT packet is received from the
     * host but doesn't match the data pid in the buffer control register read
     * from DPSRAM\n\n The host can raise a data sequence error in the
     * following conditions:\n\n
     *                 * An IN packet from the device has the wrong data PID
     */
    inline void set_SIE_STATUS_DATA_SEQ_ERROR() volatile
    {
        SIE_STATUS |= 1u << 31u;
    }

    /**
     * Clear SIE_STATUS's DATA_SEQ_ERROR bit.
     *
     * Data Sequence Error.\n\n
     *                 The device can raise a sequence error in the following
     * conditions:\n\n
     *                 * A SETUP packet is received followed by a DATA1 packet
     * (data phase should always be DATA0) * An OUT packet is received from the
     * host but doesn't match the data pid in the buffer control register read
     * from DPSRAM\n\n The host can raise a data sequence error in the
     * following conditions:\n\n
     *                 * An IN packet from the device has the wrong data PID
     */
    inline void clear_SIE_STATUS_DATA_SEQ_ERROR() volatile
    {
        SIE_STATUS &= ~(1u << 31u);
    }

    /**
     * Toggle SIE_STATUS's DATA_SEQ_ERROR bit.
     *
     * Data Sequence Error.\n\n
     *                 The device can raise a sequence error in the following
     * conditions:\n\n
     *                 * A SETUP packet is received followed by a DATA1 packet
     * (data phase should always be DATA0) * An OUT packet is received from the
     * host but doesn't match the data pid in the buffer control register read
     * from DPSRAM\n\n The host can raise a data sequence error in the
     * following conditions:\n\n
     *                 * An IN packet from the device has the wrong data PID
     */
    inline void toggle_SIE_STATUS_DATA_SEQ_ERROR() volatile
    {
        SIE_STATUS ^= 1u << 31u;
    }

    /**
     * Get all of SIE_STATUS's bit fields.
     *
     * (read-write) SIE status register
     */
    inline void get_SIE_STATUS(bool &VBUS_DETECTED, uint8_t &LINE_STATE,
                               bool &SUSPENDED, uint8_t &SPEED,
                               bool &VBUS_OVER_CURR, bool &RESUME,
                               bool &CONNECTED, bool &SETUP_REC,
                               bool &TRANS_COMPLETE, bool &BUS_RESET,
                               bool &CRC_ERROR, bool &BIT_STUFF_ERROR,
                               bool &RX_OVERFLOW, bool &RX_TIMEOUT,
                               bool &NAK_REC, bool &STALL_REC, bool &ACK_REC,
                               bool &DATA_SEQ_ERROR) volatile
    {
        uint32_t curr = SIE_STATUS;

        VBUS_DETECTED = curr & (1u << 0u);
        LINE_STATE = (curr >> 2u) & 0b11u;
        SUSPENDED = curr & (1u << 4u);
        SPEED = (curr >> 8u) & 0b11u;
        VBUS_OVER_CURR = curr & (1u << 10u);
        RESUME = curr & (1u << 11u);
        CONNECTED = curr & (1u << 16u);
        SETUP_REC = curr & (1u << 17u);
        TRANS_COMPLETE = curr & (1u << 18u);
        BUS_RESET = curr & (1u << 19u);
        CRC_ERROR = curr & (1u << 24u);
        BIT_STUFF_ERROR = curr & (1u << 25u);
        RX_OVERFLOW = curr & (1u << 26u);
        RX_TIMEOUT = curr & (1u << 27u);
        NAK_REC = curr & (1u << 28u);
        STALL_REC = curr & (1u << 29u);
        ACK_REC = curr & (1u << 30u);
        DATA_SEQ_ERROR = curr & (1u << 31u);
    }

    /**
     * Set all of SIE_STATUS's bit fields.
     *
     * (read-write) SIE status register
     */
    inline void set_SIE_STATUS(bool SUSPENDED, uint8_t SPEED, bool RESUME,
                               bool CONNECTED, bool SETUP_REC,
                               bool TRANS_COMPLETE, bool BUS_RESET,
                               bool CRC_ERROR, bool BIT_STUFF_ERROR,
                               bool RX_OVERFLOW, bool RX_TIMEOUT, bool NAK_REC,
                               bool STALL_REC, bool ACK_REC,
                               bool DATA_SEQ_ERROR) volatile
    {
        uint32_t curr = SIE_STATUS;

        curr &= ~(0b1u << 4u);
        curr |= (SUSPENDED & 0b1u) << 4u;
        curr &= ~(0b11u << 8u);
        curr |= (SPEED & 0b11u) << 8u;
        curr &= ~(0b1u << 11u);
        curr |= (RESUME & 0b1u) << 11u;
        curr &= ~(0b1u << 16u);
        curr |= (CONNECTED & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (SETUP_REC & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (TRANS_COMPLETE & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (BUS_RESET & 0b1u) << 19u;
        curr &= ~(0b1u << 24u);
        curr |= (CRC_ERROR & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (BIT_STUFF_ERROR & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (RX_OVERFLOW & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (RX_TIMEOUT & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (NAK_REC & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (STALL_REC & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (ACK_REC & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (DATA_SEQ_ERROR & 0b1u) << 31u;

        SIE_STATUS = curr;
    }

    /**
     * Get INT_EP_CTRL's INT_EP_ACTIVE field.
     *
     * Host: Enable interrupt endpoint 1 -> 15
     */
    inline uint16_t get_INT_EP_CTRL_INT_EP_ACTIVE() volatile
    {
        return (INT_EP_CTRL >> 1u) & 0b111111111111111u;
    }

    /**
     * Set INT_EP_CTRL's INT_EP_ACTIVE field.
     *
     * Host: Enable interrupt endpoint 1 -> 15
     */
    inline void set_INT_EP_CTRL_INT_EP_ACTIVE(uint16_t value) volatile
    {
        uint32_t curr = INT_EP_CTRL;

        curr &= ~(0b111111111111111u << 1u);
        curr |= (value & 0b111111111111111u) << 1u;

        INT_EP_CTRL = curr;
    }

    /**
     * Get BUFF_STATUS's EP0_IN bit.
     */
    inline bool get_BUFF_STATUS_EP0_IN() volatile
    {
        return BUFF_STATUS & (1u << 0u);
    }

    /**
     * Set BUFF_STATUS's EP0_IN bit.
     */
    inline void set_BUFF_STATUS_EP0_IN() volatile
    {
        BUFF_STATUS |= 1u << 0u;
    }

    /**
     * Clear BUFF_STATUS's EP0_IN bit.
     */
    inline void clear_BUFF_STATUS_EP0_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 0u);
    }

    /**
     * Toggle BUFF_STATUS's EP0_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP0_IN() volatile
    {
        BUFF_STATUS ^= 1u << 0u;
    }

    /**
     * Get BUFF_STATUS's EP0_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP0_OUT() volatile
    {
        return BUFF_STATUS & (1u << 1u);
    }

    /**
     * Set BUFF_STATUS's EP0_OUT bit.
     */
    inline void set_BUFF_STATUS_EP0_OUT() volatile
    {
        BUFF_STATUS |= 1u << 1u;
    }

    /**
     * Clear BUFF_STATUS's EP0_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP0_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 1u);
    }

    /**
     * Toggle BUFF_STATUS's EP0_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP0_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 1u;
    }

    /**
     * Get BUFF_STATUS's EP1_IN bit.
     */
    inline bool get_BUFF_STATUS_EP1_IN() volatile
    {
        return BUFF_STATUS & (1u << 2u);
    }

    /**
     * Set BUFF_STATUS's EP1_IN bit.
     */
    inline void set_BUFF_STATUS_EP1_IN() volatile
    {
        BUFF_STATUS |= 1u << 2u;
    }

    /**
     * Clear BUFF_STATUS's EP1_IN bit.
     */
    inline void clear_BUFF_STATUS_EP1_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 2u);
    }

    /**
     * Toggle BUFF_STATUS's EP1_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP1_IN() volatile
    {
        BUFF_STATUS ^= 1u << 2u;
    }

    /**
     * Get BUFF_STATUS's EP1_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP1_OUT() volatile
    {
        return BUFF_STATUS & (1u << 3u);
    }

    /**
     * Set BUFF_STATUS's EP1_OUT bit.
     */
    inline void set_BUFF_STATUS_EP1_OUT() volatile
    {
        BUFF_STATUS |= 1u << 3u;
    }

    /**
     * Clear BUFF_STATUS's EP1_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP1_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 3u);
    }

    /**
     * Toggle BUFF_STATUS's EP1_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP1_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 3u;
    }

    /**
     * Get BUFF_STATUS's EP2_IN bit.
     */
    inline bool get_BUFF_STATUS_EP2_IN() volatile
    {
        return BUFF_STATUS & (1u << 4u);
    }

    /**
     * Set BUFF_STATUS's EP2_IN bit.
     */
    inline void set_BUFF_STATUS_EP2_IN() volatile
    {
        BUFF_STATUS |= 1u << 4u;
    }

    /**
     * Clear BUFF_STATUS's EP2_IN bit.
     */
    inline void clear_BUFF_STATUS_EP2_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 4u);
    }

    /**
     * Toggle BUFF_STATUS's EP2_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP2_IN() volatile
    {
        BUFF_STATUS ^= 1u << 4u;
    }

    /**
     * Get BUFF_STATUS's EP2_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP2_OUT() volatile
    {
        return BUFF_STATUS & (1u << 5u);
    }

    /**
     * Set BUFF_STATUS's EP2_OUT bit.
     */
    inline void set_BUFF_STATUS_EP2_OUT() volatile
    {
        BUFF_STATUS |= 1u << 5u;
    }

    /**
     * Clear BUFF_STATUS's EP2_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP2_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 5u);
    }

    /**
     * Toggle BUFF_STATUS's EP2_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP2_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 5u;
    }

    /**
     * Get BUFF_STATUS's EP3_IN bit.
     */
    inline bool get_BUFF_STATUS_EP3_IN() volatile
    {
        return BUFF_STATUS & (1u << 6u);
    }

    /**
     * Set BUFF_STATUS's EP3_IN bit.
     */
    inline void set_BUFF_STATUS_EP3_IN() volatile
    {
        BUFF_STATUS |= 1u << 6u;
    }

    /**
     * Clear BUFF_STATUS's EP3_IN bit.
     */
    inline void clear_BUFF_STATUS_EP3_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 6u);
    }

    /**
     * Toggle BUFF_STATUS's EP3_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP3_IN() volatile
    {
        BUFF_STATUS ^= 1u << 6u;
    }

    /**
     * Get BUFF_STATUS's EP3_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP3_OUT() volatile
    {
        return BUFF_STATUS & (1u << 7u);
    }

    /**
     * Set BUFF_STATUS's EP3_OUT bit.
     */
    inline void set_BUFF_STATUS_EP3_OUT() volatile
    {
        BUFF_STATUS |= 1u << 7u;
    }

    /**
     * Clear BUFF_STATUS's EP3_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP3_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 7u);
    }

    /**
     * Toggle BUFF_STATUS's EP3_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP3_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 7u;
    }

    /**
     * Get BUFF_STATUS's EP4_IN bit.
     */
    inline bool get_BUFF_STATUS_EP4_IN() volatile
    {
        return BUFF_STATUS & (1u << 8u);
    }

    /**
     * Set BUFF_STATUS's EP4_IN bit.
     */
    inline void set_BUFF_STATUS_EP4_IN() volatile
    {
        BUFF_STATUS |= 1u << 8u;
    }

    /**
     * Clear BUFF_STATUS's EP4_IN bit.
     */
    inline void clear_BUFF_STATUS_EP4_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 8u);
    }

    /**
     * Toggle BUFF_STATUS's EP4_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP4_IN() volatile
    {
        BUFF_STATUS ^= 1u << 8u;
    }

    /**
     * Get BUFF_STATUS's EP4_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP4_OUT() volatile
    {
        return BUFF_STATUS & (1u << 9u);
    }

    /**
     * Set BUFF_STATUS's EP4_OUT bit.
     */
    inline void set_BUFF_STATUS_EP4_OUT() volatile
    {
        BUFF_STATUS |= 1u << 9u;
    }

    /**
     * Clear BUFF_STATUS's EP4_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP4_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 9u);
    }

    /**
     * Toggle BUFF_STATUS's EP4_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP4_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 9u;
    }

    /**
     * Get BUFF_STATUS's EP5_IN bit.
     */
    inline bool get_BUFF_STATUS_EP5_IN() volatile
    {
        return BUFF_STATUS & (1u << 10u);
    }

    /**
     * Set BUFF_STATUS's EP5_IN bit.
     */
    inline void set_BUFF_STATUS_EP5_IN() volatile
    {
        BUFF_STATUS |= 1u << 10u;
    }

    /**
     * Clear BUFF_STATUS's EP5_IN bit.
     */
    inline void clear_BUFF_STATUS_EP5_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 10u);
    }

    /**
     * Toggle BUFF_STATUS's EP5_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP5_IN() volatile
    {
        BUFF_STATUS ^= 1u << 10u;
    }

    /**
     * Get BUFF_STATUS's EP5_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP5_OUT() volatile
    {
        return BUFF_STATUS & (1u << 11u);
    }

    /**
     * Set BUFF_STATUS's EP5_OUT bit.
     */
    inline void set_BUFF_STATUS_EP5_OUT() volatile
    {
        BUFF_STATUS |= 1u << 11u;
    }

    /**
     * Clear BUFF_STATUS's EP5_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP5_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 11u);
    }

    /**
     * Toggle BUFF_STATUS's EP5_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP5_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 11u;
    }

    /**
     * Get BUFF_STATUS's EP6_IN bit.
     */
    inline bool get_BUFF_STATUS_EP6_IN() volatile
    {
        return BUFF_STATUS & (1u << 12u);
    }

    /**
     * Set BUFF_STATUS's EP6_IN bit.
     */
    inline void set_BUFF_STATUS_EP6_IN() volatile
    {
        BUFF_STATUS |= 1u << 12u;
    }

    /**
     * Clear BUFF_STATUS's EP6_IN bit.
     */
    inline void clear_BUFF_STATUS_EP6_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 12u);
    }

    /**
     * Toggle BUFF_STATUS's EP6_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP6_IN() volatile
    {
        BUFF_STATUS ^= 1u << 12u;
    }

    /**
     * Get BUFF_STATUS's EP6_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP6_OUT() volatile
    {
        return BUFF_STATUS & (1u << 13u);
    }

    /**
     * Set BUFF_STATUS's EP6_OUT bit.
     */
    inline void set_BUFF_STATUS_EP6_OUT() volatile
    {
        BUFF_STATUS |= 1u << 13u;
    }

    /**
     * Clear BUFF_STATUS's EP6_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP6_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 13u);
    }

    /**
     * Toggle BUFF_STATUS's EP6_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP6_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 13u;
    }

    /**
     * Get BUFF_STATUS's EP7_IN bit.
     */
    inline bool get_BUFF_STATUS_EP7_IN() volatile
    {
        return BUFF_STATUS & (1u << 14u);
    }

    /**
     * Set BUFF_STATUS's EP7_IN bit.
     */
    inline void set_BUFF_STATUS_EP7_IN() volatile
    {
        BUFF_STATUS |= 1u << 14u;
    }

    /**
     * Clear BUFF_STATUS's EP7_IN bit.
     */
    inline void clear_BUFF_STATUS_EP7_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 14u);
    }

    /**
     * Toggle BUFF_STATUS's EP7_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP7_IN() volatile
    {
        BUFF_STATUS ^= 1u << 14u;
    }

    /**
     * Get BUFF_STATUS's EP7_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP7_OUT() volatile
    {
        return BUFF_STATUS & (1u << 15u);
    }

    /**
     * Set BUFF_STATUS's EP7_OUT bit.
     */
    inline void set_BUFF_STATUS_EP7_OUT() volatile
    {
        BUFF_STATUS |= 1u << 15u;
    }

    /**
     * Clear BUFF_STATUS's EP7_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP7_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 15u);
    }

    /**
     * Toggle BUFF_STATUS's EP7_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP7_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 15u;
    }

    /**
     * Get BUFF_STATUS's EP8_IN bit.
     */
    inline bool get_BUFF_STATUS_EP8_IN() volatile
    {
        return BUFF_STATUS & (1u << 16u);
    }

    /**
     * Set BUFF_STATUS's EP8_IN bit.
     */
    inline void set_BUFF_STATUS_EP8_IN() volatile
    {
        BUFF_STATUS |= 1u << 16u;
    }

    /**
     * Clear BUFF_STATUS's EP8_IN bit.
     */
    inline void clear_BUFF_STATUS_EP8_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 16u);
    }

    /**
     * Toggle BUFF_STATUS's EP8_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP8_IN() volatile
    {
        BUFF_STATUS ^= 1u << 16u;
    }

    /**
     * Get BUFF_STATUS's EP8_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP8_OUT() volatile
    {
        return BUFF_STATUS & (1u << 17u);
    }

    /**
     * Set BUFF_STATUS's EP8_OUT bit.
     */
    inline void set_BUFF_STATUS_EP8_OUT() volatile
    {
        BUFF_STATUS |= 1u << 17u;
    }

    /**
     * Clear BUFF_STATUS's EP8_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP8_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 17u);
    }

    /**
     * Toggle BUFF_STATUS's EP8_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP8_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 17u;
    }

    /**
     * Get BUFF_STATUS's EP9_IN bit.
     */
    inline bool get_BUFF_STATUS_EP9_IN() volatile
    {
        return BUFF_STATUS & (1u << 18u);
    }

    /**
     * Set BUFF_STATUS's EP9_IN bit.
     */
    inline void set_BUFF_STATUS_EP9_IN() volatile
    {
        BUFF_STATUS |= 1u << 18u;
    }

    /**
     * Clear BUFF_STATUS's EP9_IN bit.
     */
    inline void clear_BUFF_STATUS_EP9_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 18u);
    }

    /**
     * Toggle BUFF_STATUS's EP9_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP9_IN() volatile
    {
        BUFF_STATUS ^= 1u << 18u;
    }

    /**
     * Get BUFF_STATUS's EP9_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP9_OUT() volatile
    {
        return BUFF_STATUS & (1u << 19u);
    }

    /**
     * Set BUFF_STATUS's EP9_OUT bit.
     */
    inline void set_BUFF_STATUS_EP9_OUT() volatile
    {
        BUFF_STATUS |= 1u << 19u;
    }

    /**
     * Clear BUFF_STATUS's EP9_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP9_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 19u);
    }

    /**
     * Toggle BUFF_STATUS's EP9_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP9_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 19u;
    }

    /**
     * Get BUFF_STATUS's EP10_IN bit.
     */
    inline bool get_BUFF_STATUS_EP10_IN() volatile
    {
        return BUFF_STATUS & (1u << 20u);
    }

    /**
     * Set BUFF_STATUS's EP10_IN bit.
     */
    inline void set_BUFF_STATUS_EP10_IN() volatile
    {
        BUFF_STATUS |= 1u << 20u;
    }

    /**
     * Clear BUFF_STATUS's EP10_IN bit.
     */
    inline void clear_BUFF_STATUS_EP10_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 20u);
    }

    /**
     * Toggle BUFF_STATUS's EP10_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP10_IN() volatile
    {
        BUFF_STATUS ^= 1u << 20u;
    }

    /**
     * Get BUFF_STATUS's EP10_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP10_OUT() volatile
    {
        return BUFF_STATUS & (1u << 21u);
    }

    /**
     * Set BUFF_STATUS's EP10_OUT bit.
     */
    inline void set_BUFF_STATUS_EP10_OUT() volatile
    {
        BUFF_STATUS |= 1u << 21u;
    }

    /**
     * Clear BUFF_STATUS's EP10_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP10_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 21u);
    }

    /**
     * Toggle BUFF_STATUS's EP10_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP10_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 21u;
    }

    /**
     * Get BUFF_STATUS's EP11_IN bit.
     */
    inline bool get_BUFF_STATUS_EP11_IN() volatile
    {
        return BUFF_STATUS & (1u << 22u);
    }

    /**
     * Set BUFF_STATUS's EP11_IN bit.
     */
    inline void set_BUFF_STATUS_EP11_IN() volatile
    {
        BUFF_STATUS |= 1u << 22u;
    }

    /**
     * Clear BUFF_STATUS's EP11_IN bit.
     */
    inline void clear_BUFF_STATUS_EP11_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 22u);
    }

    /**
     * Toggle BUFF_STATUS's EP11_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP11_IN() volatile
    {
        BUFF_STATUS ^= 1u << 22u;
    }

    /**
     * Get BUFF_STATUS's EP11_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP11_OUT() volatile
    {
        return BUFF_STATUS & (1u << 23u);
    }

    /**
     * Set BUFF_STATUS's EP11_OUT bit.
     */
    inline void set_BUFF_STATUS_EP11_OUT() volatile
    {
        BUFF_STATUS |= 1u << 23u;
    }

    /**
     * Clear BUFF_STATUS's EP11_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP11_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 23u);
    }

    /**
     * Toggle BUFF_STATUS's EP11_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP11_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 23u;
    }

    /**
     * Get BUFF_STATUS's EP12_IN bit.
     */
    inline bool get_BUFF_STATUS_EP12_IN() volatile
    {
        return BUFF_STATUS & (1u << 24u);
    }

    /**
     * Set BUFF_STATUS's EP12_IN bit.
     */
    inline void set_BUFF_STATUS_EP12_IN() volatile
    {
        BUFF_STATUS |= 1u << 24u;
    }

    /**
     * Clear BUFF_STATUS's EP12_IN bit.
     */
    inline void clear_BUFF_STATUS_EP12_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 24u);
    }

    /**
     * Toggle BUFF_STATUS's EP12_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP12_IN() volatile
    {
        BUFF_STATUS ^= 1u << 24u;
    }

    /**
     * Get BUFF_STATUS's EP12_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP12_OUT() volatile
    {
        return BUFF_STATUS & (1u << 25u);
    }

    /**
     * Set BUFF_STATUS's EP12_OUT bit.
     */
    inline void set_BUFF_STATUS_EP12_OUT() volatile
    {
        BUFF_STATUS |= 1u << 25u;
    }

    /**
     * Clear BUFF_STATUS's EP12_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP12_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 25u);
    }

    /**
     * Toggle BUFF_STATUS's EP12_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP12_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 25u;
    }

    /**
     * Get BUFF_STATUS's EP13_IN bit.
     */
    inline bool get_BUFF_STATUS_EP13_IN() volatile
    {
        return BUFF_STATUS & (1u << 26u);
    }

    /**
     * Set BUFF_STATUS's EP13_IN bit.
     */
    inline void set_BUFF_STATUS_EP13_IN() volatile
    {
        BUFF_STATUS |= 1u << 26u;
    }

    /**
     * Clear BUFF_STATUS's EP13_IN bit.
     */
    inline void clear_BUFF_STATUS_EP13_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 26u);
    }

    /**
     * Toggle BUFF_STATUS's EP13_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP13_IN() volatile
    {
        BUFF_STATUS ^= 1u << 26u;
    }

    /**
     * Get BUFF_STATUS's EP13_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP13_OUT() volatile
    {
        return BUFF_STATUS & (1u << 27u);
    }

    /**
     * Set BUFF_STATUS's EP13_OUT bit.
     */
    inline void set_BUFF_STATUS_EP13_OUT() volatile
    {
        BUFF_STATUS |= 1u << 27u;
    }

    /**
     * Clear BUFF_STATUS's EP13_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP13_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 27u);
    }

    /**
     * Toggle BUFF_STATUS's EP13_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP13_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 27u;
    }

    /**
     * Get BUFF_STATUS's EP14_IN bit.
     */
    inline bool get_BUFF_STATUS_EP14_IN() volatile
    {
        return BUFF_STATUS & (1u << 28u);
    }

    /**
     * Set BUFF_STATUS's EP14_IN bit.
     */
    inline void set_BUFF_STATUS_EP14_IN() volatile
    {
        BUFF_STATUS |= 1u << 28u;
    }

    /**
     * Clear BUFF_STATUS's EP14_IN bit.
     */
    inline void clear_BUFF_STATUS_EP14_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 28u);
    }

    /**
     * Toggle BUFF_STATUS's EP14_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP14_IN() volatile
    {
        BUFF_STATUS ^= 1u << 28u;
    }

    /**
     * Get BUFF_STATUS's EP14_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP14_OUT() volatile
    {
        return BUFF_STATUS & (1u << 29u);
    }

    /**
     * Set BUFF_STATUS's EP14_OUT bit.
     */
    inline void set_BUFF_STATUS_EP14_OUT() volatile
    {
        BUFF_STATUS |= 1u << 29u;
    }

    /**
     * Clear BUFF_STATUS's EP14_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP14_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 29u);
    }

    /**
     * Toggle BUFF_STATUS's EP14_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP14_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 29u;
    }

    /**
     * Get BUFF_STATUS's EP15_IN bit.
     */
    inline bool get_BUFF_STATUS_EP15_IN() volatile
    {
        return BUFF_STATUS & (1u << 30u);
    }

    /**
     * Set BUFF_STATUS's EP15_IN bit.
     */
    inline void set_BUFF_STATUS_EP15_IN() volatile
    {
        BUFF_STATUS |= 1u << 30u;
    }

    /**
     * Clear BUFF_STATUS's EP15_IN bit.
     */
    inline void clear_BUFF_STATUS_EP15_IN() volatile
    {
        BUFF_STATUS &= ~(1u << 30u);
    }

    /**
     * Toggle BUFF_STATUS's EP15_IN bit.
     */
    inline void toggle_BUFF_STATUS_EP15_IN() volatile
    {
        BUFF_STATUS ^= 1u << 30u;
    }

    /**
     * Get BUFF_STATUS's EP15_OUT bit.
     */
    inline bool get_BUFF_STATUS_EP15_OUT() volatile
    {
        return BUFF_STATUS & (1u << 31u);
    }

    /**
     * Set BUFF_STATUS's EP15_OUT bit.
     */
    inline void set_BUFF_STATUS_EP15_OUT() volatile
    {
        BUFF_STATUS |= 1u << 31u;
    }

    /**
     * Clear BUFF_STATUS's EP15_OUT bit.
     */
    inline void clear_BUFF_STATUS_EP15_OUT() volatile
    {
        BUFF_STATUS &= ~(1u << 31u);
    }

    /**
     * Toggle BUFF_STATUS's EP15_OUT bit.
     */
    inline void toggle_BUFF_STATUS_EP15_OUT() volatile
    {
        BUFF_STATUS ^= 1u << 31u;
    }

    /**
     * Get all of BUFF_STATUS's bit fields.
     *
     * (read-write) Buffer status register. A bit set here indicates that a
     * buffer has completed on the endpoint (if the buffer interrupt is
     * enabled). It is possible for 2 buffers to be completed, so clearing the
     * buffer status bit may instantly re set it on the next clock cycle.
     */
    inline void get_BUFF_STATUS(bool &EP0_IN, bool &EP0_OUT, bool &EP1_IN,
                                bool &EP1_OUT, bool &EP2_IN, bool &EP2_OUT,
                                bool &EP3_IN, bool &EP3_OUT, bool &EP4_IN,
                                bool &EP4_OUT, bool &EP5_IN, bool &EP5_OUT,
                                bool &EP6_IN, bool &EP6_OUT, bool &EP7_IN,
                                bool &EP7_OUT, bool &EP8_IN, bool &EP8_OUT,
                                bool &EP9_IN, bool &EP9_OUT, bool &EP10_IN,
                                bool &EP10_OUT, bool &EP11_IN, bool &EP11_OUT,
                                bool &EP12_IN, bool &EP12_OUT, bool &EP13_IN,
                                bool &EP13_OUT, bool &EP14_IN, bool &EP14_OUT,
                                bool &EP15_IN, bool &EP15_OUT) volatile
    {
        uint32_t curr = BUFF_STATUS;

        EP0_IN = curr & (1u << 0u);
        EP0_OUT = curr & (1u << 1u);
        EP1_IN = curr & (1u << 2u);
        EP1_OUT = curr & (1u << 3u);
        EP2_IN = curr & (1u << 4u);
        EP2_OUT = curr & (1u << 5u);
        EP3_IN = curr & (1u << 6u);
        EP3_OUT = curr & (1u << 7u);
        EP4_IN = curr & (1u << 8u);
        EP4_OUT = curr & (1u << 9u);
        EP5_IN = curr & (1u << 10u);
        EP5_OUT = curr & (1u << 11u);
        EP6_IN = curr & (1u << 12u);
        EP6_OUT = curr & (1u << 13u);
        EP7_IN = curr & (1u << 14u);
        EP7_OUT = curr & (1u << 15u);
        EP8_IN = curr & (1u << 16u);
        EP8_OUT = curr & (1u << 17u);
        EP9_IN = curr & (1u << 18u);
        EP9_OUT = curr & (1u << 19u);
        EP10_IN = curr & (1u << 20u);
        EP10_OUT = curr & (1u << 21u);
        EP11_IN = curr & (1u << 22u);
        EP11_OUT = curr & (1u << 23u);
        EP12_IN = curr & (1u << 24u);
        EP12_OUT = curr & (1u << 25u);
        EP13_IN = curr & (1u << 26u);
        EP13_OUT = curr & (1u << 27u);
        EP14_IN = curr & (1u << 28u);
        EP14_OUT = curr & (1u << 29u);
        EP15_IN = curr & (1u << 30u);
        EP15_OUT = curr & (1u << 31u);
    }

    /**
     * Set all of BUFF_STATUS's bit fields.
     *
     * (read-write) Buffer status register. A bit set here indicates that a
     * buffer has completed on the endpoint (if the buffer interrupt is
     * enabled). It is possible for 2 buffers to be completed, so clearing the
     * buffer status bit may instantly re set it on the next clock cycle.
     */
    inline void set_BUFF_STATUS(
        bool EP0_IN, bool EP0_OUT, bool EP1_IN, bool EP1_OUT, bool EP2_IN,
        bool EP2_OUT, bool EP3_IN, bool EP3_OUT, bool EP4_IN, bool EP4_OUT,
        bool EP5_IN, bool EP5_OUT, bool EP6_IN, bool EP6_OUT, bool EP7_IN,
        bool EP7_OUT, bool EP8_IN, bool EP8_OUT, bool EP9_IN, bool EP9_OUT,
        bool EP10_IN, bool EP10_OUT, bool EP11_IN, bool EP11_OUT, bool EP12_IN,
        bool EP12_OUT, bool EP13_IN, bool EP13_OUT, bool EP14_IN,
        bool EP14_OUT, bool EP15_IN, bool EP15_OUT) volatile
    {
        uint32_t curr = BUFF_STATUS;

        curr &= ~(0b1u << 0u);
        curr |= (EP0_IN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (EP0_OUT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (EP1_IN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (EP1_OUT & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (EP2_IN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (EP2_OUT & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (EP3_IN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (EP3_OUT & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (EP4_IN & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (EP4_OUT & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (EP5_IN & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (EP5_OUT & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (EP6_IN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (EP6_OUT & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (EP7_IN & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (EP7_OUT & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (EP8_IN & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (EP8_OUT & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (EP9_IN & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (EP9_OUT & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (EP10_IN & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (EP10_OUT & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (EP11_IN & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (EP11_OUT & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (EP12_IN & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (EP12_OUT & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (EP13_IN & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (EP13_OUT & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (EP14_IN & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (EP14_OUT & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (EP15_IN & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (EP15_OUT & 0b1u) << 31u;

        BUFF_STATUS = curr;
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP0_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP0_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 0u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP0_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP0_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 1u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP1_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP1_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 2u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP1_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP1_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 3u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP2_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP2_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 4u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP2_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP2_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 5u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP3_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP3_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 6u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP3_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP3_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 7u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP4_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP4_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 8u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP4_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP4_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 9u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP5_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP5_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 10u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP5_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP5_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 11u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP6_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP6_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 12u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP6_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP6_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 13u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP7_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP7_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 14u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP7_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP7_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 15u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP8_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP8_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 16u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP8_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP8_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 17u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP9_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP9_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 18u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP9_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP9_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 19u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP10_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP10_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 20u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP10_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP10_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 21u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP11_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP11_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 22u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP11_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP11_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 23u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP12_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP12_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 24u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP12_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP12_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 25u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP13_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP13_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 26u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP13_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP13_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 27u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP14_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP14_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 28u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP14_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP14_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 29u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP15_IN bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP15_IN() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 30u);
    }

    /**
     * Get BUFF_CPU_SHOULD_HANDLE's EP15_OUT bit.
     */
    inline bool get_BUFF_CPU_SHOULD_HANDLE_EP15_OUT() volatile
    {
        return BUFF_CPU_SHOULD_HANDLE & (1u << 31u);
    }

    /**
     * Get all of BUFF_CPU_SHOULD_HANDLE's bit fields.
     *
     * (read-only) Which of the double buffers should be handled. Only valid if
     * using an interrupt per buffer (i.e. not per 2 buffers). Not valid for
     * host interrupt endpoint polling because they are only single buffered.
     */
    inline void get_BUFF_CPU_SHOULD_HANDLE(
        bool &EP0_IN, bool &EP0_OUT, bool &EP1_IN, bool &EP1_OUT, bool &EP2_IN,
        bool &EP2_OUT, bool &EP3_IN, bool &EP3_OUT, bool &EP4_IN,
        bool &EP4_OUT, bool &EP5_IN, bool &EP5_OUT, bool &EP6_IN,
        bool &EP6_OUT, bool &EP7_IN, bool &EP7_OUT, bool &EP8_IN,
        bool &EP8_OUT, bool &EP9_IN, bool &EP9_OUT, bool &EP10_IN,
        bool &EP10_OUT, bool &EP11_IN, bool &EP11_OUT, bool &EP12_IN,
        bool &EP12_OUT, bool &EP13_IN, bool &EP13_OUT, bool &EP14_IN,
        bool &EP14_OUT, bool &EP15_IN, bool &EP15_OUT) volatile
    {
        uint32_t curr = BUFF_CPU_SHOULD_HANDLE;

        EP0_IN = curr & (1u << 0u);
        EP0_OUT = curr & (1u << 1u);
        EP1_IN = curr & (1u << 2u);
        EP1_OUT = curr & (1u << 3u);
        EP2_IN = curr & (1u << 4u);
        EP2_OUT = curr & (1u << 5u);
        EP3_IN = curr & (1u << 6u);
        EP3_OUT = curr & (1u << 7u);
        EP4_IN = curr & (1u << 8u);
        EP4_OUT = curr & (1u << 9u);
        EP5_IN = curr & (1u << 10u);
        EP5_OUT = curr & (1u << 11u);
        EP6_IN = curr & (1u << 12u);
        EP6_OUT = curr & (1u << 13u);
        EP7_IN = curr & (1u << 14u);
        EP7_OUT = curr & (1u << 15u);
        EP8_IN = curr & (1u << 16u);
        EP8_OUT = curr & (1u << 17u);
        EP9_IN = curr & (1u << 18u);
        EP9_OUT = curr & (1u << 19u);
        EP10_IN = curr & (1u << 20u);
        EP10_OUT = curr & (1u << 21u);
        EP11_IN = curr & (1u << 22u);
        EP11_OUT = curr & (1u << 23u);
        EP12_IN = curr & (1u << 24u);
        EP12_OUT = curr & (1u << 25u);
        EP13_IN = curr & (1u << 26u);
        EP13_OUT = curr & (1u << 27u);
        EP14_IN = curr & (1u << 28u);
        EP14_OUT = curr & (1u << 29u);
        EP15_IN = curr & (1u << 30u);
        EP15_OUT = curr & (1u << 31u);
    }

    /**
     * Get EP_ABORT's EP0_IN bit.
     */
    inline bool get_EP_ABORT_EP0_IN() volatile
    {
        return EP_ABORT & (1u << 0u);
    }

    /**
     * Set EP_ABORT's EP0_IN bit.
     */
    inline void set_EP_ABORT_EP0_IN() volatile
    {
        EP_ABORT |= 1u << 0u;
    }

    /**
     * Clear EP_ABORT's EP0_IN bit.
     */
    inline void clear_EP_ABORT_EP0_IN() volatile
    {
        EP_ABORT &= ~(1u << 0u);
    }

    /**
     * Toggle EP_ABORT's EP0_IN bit.
     */
    inline void toggle_EP_ABORT_EP0_IN() volatile
    {
        EP_ABORT ^= 1u << 0u;
    }

    /**
     * Get EP_ABORT's EP0_OUT bit.
     */
    inline bool get_EP_ABORT_EP0_OUT() volatile
    {
        return EP_ABORT & (1u << 1u);
    }

    /**
     * Set EP_ABORT's EP0_OUT bit.
     */
    inline void set_EP_ABORT_EP0_OUT() volatile
    {
        EP_ABORT |= 1u << 1u;
    }

    /**
     * Clear EP_ABORT's EP0_OUT bit.
     */
    inline void clear_EP_ABORT_EP0_OUT() volatile
    {
        EP_ABORT &= ~(1u << 1u);
    }

    /**
     * Toggle EP_ABORT's EP0_OUT bit.
     */
    inline void toggle_EP_ABORT_EP0_OUT() volatile
    {
        EP_ABORT ^= 1u << 1u;
    }

    /**
     * Get EP_ABORT's EP1_IN bit.
     */
    inline bool get_EP_ABORT_EP1_IN() volatile
    {
        return EP_ABORT & (1u << 2u);
    }

    /**
     * Set EP_ABORT's EP1_IN bit.
     */
    inline void set_EP_ABORT_EP1_IN() volatile
    {
        EP_ABORT |= 1u << 2u;
    }

    /**
     * Clear EP_ABORT's EP1_IN bit.
     */
    inline void clear_EP_ABORT_EP1_IN() volatile
    {
        EP_ABORT &= ~(1u << 2u);
    }

    /**
     * Toggle EP_ABORT's EP1_IN bit.
     */
    inline void toggle_EP_ABORT_EP1_IN() volatile
    {
        EP_ABORT ^= 1u << 2u;
    }

    /**
     * Get EP_ABORT's EP1_OUT bit.
     */
    inline bool get_EP_ABORT_EP1_OUT() volatile
    {
        return EP_ABORT & (1u << 3u);
    }

    /**
     * Set EP_ABORT's EP1_OUT bit.
     */
    inline void set_EP_ABORT_EP1_OUT() volatile
    {
        EP_ABORT |= 1u << 3u;
    }

    /**
     * Clear EP_ABORT's EP1_OUT bit.
     */
    inline void clear_EP_ABORT_EP1_OUT() volatile
    {
        EP_ABORT &= ~(1u << 3u);
    }

    /**
     * Toggle EP_ABORT's EP1_OUT bit.
     */
    inline void toggle_EP_ABORT_EP1_OUT() volatile
    {
        EP_ABORT ^= 1u << 3u;
    }

    /**
     * Get EP_ABORT's EP2_IN bit.
     */
    inline bool get_EP_ABORT_EP2_IN() volatile
    {
        return EP_ABORT & (1u << 4u);
    }

    /**
     * Set EP_ABORT's EP2_IN bit.
     */
    inline void set_EP_ABORT_EP2_IN() volatile
    {
        EP_ABORT |= 1u << 4u;
    }

    /**
     * Clear EP_ABORT's EP2_IN bit.
     */
    inline void clear_EP_ABORT_EP2_IN() volatile
    {
        EP_ABORT &= ~(1u << 4u);
    }

    /**
     * Toggle EP_ABORT's EP2_IN bit.
     */
    inline void toggle_EP_ABORT_EP2_IN() volatile
    {
        EP_ABORT ^= 1u << 4u;
    }

    /**
     * Get EP_ABORT's EP2_OUT bit.
     */
    inline bool get_EP_ABORT_EP2_OUT() volatile
    {
        return EP_ABORT & (1u << 5u);
    }

    /**
     * Set EP_ABORT's EP2_OUT bit.
     */
    inline void set_EP_ABORT_EP2_OUT() volatile
    {
        EP_ABORT |= 1u << 5u;
    }

    /**
     * Clear EP_ABORT's EP2_OUT bit.
     */
    inline void clear_EP_ABORT_EP2_OUT() volatile
    {
        EP_ABORT &= ~(1u << 5u);
    }

    /**
     * Toggle EP_ABORT's EP2_OUT bit.
     */
    inline void toggle_EP_ABORT_EP2_OUT() volatile
    {
        EP_ABORT ^= 1u << 5u;
    }

    /**
     * Get EP_ABORT's EP3_IN bit.
     */
    inline bool get_EP_ABORT_EP3_IN() volatile
    {
        return EP_ABORT & (1u << 6u);
    }

    /**
     * Set EP_ABORT's EP3_IN bit.
     */
    inline void set_EP_ABORT_EP3_IN() volatile
    {
        EP_ABORT |= 1u << 6u;
    }

    /**
     * Clear EP_ABORT's EP3_IN bit.
     */
    inline void clear_EP_ABORT_EP3_IN() volatile
    {
        EP_ABORT &= ~(1u << 6u);
    }

    /**
     * Toggle EP_ABORT's EP3_IN bit.
     */
    inline void toggle_EP_ABORT_EP3_IN() volatile
    {
        EP_ABORT ^= 1u << 6u;
    }

    /**
     * Get EP_ABORT's EP3_OUT bit.
     */
    inline bool get_EP_ABORT_EP3_OUT() volatile
    {
        return EP_ABORT & (1u << 7u);
    }

    /**
     * Set EP_ABORT's EP3_OUT bit.
     */
    inline void set_EP_ABORT_EP3_OUT() volatile
    {
        EP_ABORT |= 1u << 7u;
    }

    /**
     * Clear EP_ABORT's EP3_OUT bit.
     */
    inline void clear_EP_ABORT_EP3_OUT() volatile
    {
        EP_ABORT &= ~(1u << 7u);
    }

    /**
     * Toggle EP_ABORT's EP3_OUT bit.
     */
    inline void toggle_EP_ABORT_EP3_OUT() volatile
    {
        EP_ABORT ^= 1u << 7u;
    }

    /**
     * Get EP_ABORT's EP4_IN bit.
     */
    inline bool get_EP_ABORT_EP4_IN() volatile
    {
        return EP_ABORT & (1u << 8u);
    }

    /**
     * Set EP_ABORT's EP4_IN bit.
     */
    inline void set_EP_ABORT_EP4_IN() volatile
    {
        EP_ABORT |= 1u << 8u;
    }

    /**
     * Clear EP_ABORT's EP4_IN bit.
     */
    inline void clear_EP_ABORT_EP4_IN() volatile
    {
        EP_ABORT &= ~(1u << 8u);
    }

    /**
     * Toggle EP_ABORT's EP4_IN bit.
     */
    inline void toggle_EP_ABORT_EP4_IN() volatile
    {
        EP_ABORT ^= 1u << 8u;
    }

    /**
     * Get EP_ABORT's EP4_OUT bit.
     */
    inline bool get_EP_ABORT_EP4_OUT() volatile
    {
        return EP_ABORT & (1u << 9u);
    }

    /**
     * Set EP_ABORT's EP4_OUT bit.
     */
    inline void set_EP_ABORT_EP4_OUT() volatile
    {
        EP_ABORT |= 1u << 9u;
    }

    /**
     * Clear EP_ABORT's EP4_OUT bit.
     */
    inline void clear_EP_ABORT_EP4_OUT() volatile
    {
        EP_ABORT &= ~(1u << 9u);
    }

    /**
     * Toggle EP_ABORT's EP4_OUT bit.
     */
    inline void toggle_EP_ABORT_EP4_OUT() volatile
    {
        EP_ABORT ^= 1u << 9u;
    }

    /**
     * Get EP_ABORT's EP5_IN bit.
     */
    inline bool get_EP_ABORT_EP5_IN() volatile
    {
        return EP_ABORT & (1u << 10u);
    }

    /**
     * Set EP_ABORT's EP5_IN bit.
     */
    inline void set_EP_ABORT_EP5_IN() volatile
    {
        EP_ABORT |= 1u << 10u;
    }

    /**
     * Clear EP_ABORT's EP5_IN bit.
     */
    inline void clear_EP_ABORT_EP5_IN() volatile
    {
        EP_ABORT &= ~(1u << 10u);
    }

    /**
     * Toggle EP_ABORT's EP5_IN bit.
     */
    inline void toggle_EP_ABORT_EP5_IN() volatile
    {
        EP_ABORT ^= 1u << 10u;
    }

    /**
     * Get EP_ABORT's EP5_OUT bit.
     */
    inline bool get_EP_ABORT_EP5_OUT() volatile
    {
        return EP_ABORT & (1u << 11u);
    }

    /**
     * Set EP_ABORT's EP5_OUT bit.
     */
    inline void set_EP_ABORT_EP5_OUT() volatile
    {
        EP_ABORT |= 1u << 11u;
    }

    /**
     * Clear EP_ABORT's EP5_OUT bit.
     */
    inline void clear_EP_ABORT_EP5_OUT() volatile
    {
        EP_ABORT &= ~(1u << 11u);
    }

    /**
     * Toggle EP_ABORT's EP5_OUT bit.
     */
    inline void toggle_EP_ABORT_EP5_OUT() volatile
    {
        EP_ABORT ^= 1u << 11u;
    }

    /**
     * Get EP_ABORT's EP6_IN bit.
     */
    inline bool get_EP_ABORT_EP6_IN() volatile
    {
        return EP_ABORT & (1u << 12u);
    }

    /**
     * Set EP_ABORT's EP6_IN bit.
     */
    inline void set_EP_ABORT_EP6_IN() volatile
    {
        EP_ABORT |= 1u << 12u;
    }

    /**
     * Clear EP_ABORT's EP6_IN bit.
     */
    inline void clear_EP_ABORT_EP6_IN() volatile
    {
        EP_ABORT &= ~(1u << 12u);
    }

    /**
     * Toggle EP_ABORT's EP6_IN bit.
     */
    inline void toggle_EP_ABORT_EP6_IN() volatile
    {
        EP_ABORT ^= 1u << 12u;
    }

    /**
     * Get EP_ABORT's EP6_OUT bit.
     */
    inline bool get_EP_ABORT_EP6_OUT() volatile
    {
        return EP_ABORT & (1u << 13u);
    }

    /**
     * Set EP_ABORT's EP6_OUT bit.
     */
    inline void set_EP_ABORT_EP6_OUT() volatile
    {
        EP_ABORT |= 1u << 13u;
    }

    /**
     * Clear EP_ABORT's EP6_OUT bit.
     */
    inline void clear_EP_ABORT_EP6_OUT() volatile
    {
        EP_ABORT &= ~(1u << 13u);
    }

    /**
     * Toggle EP_ABORT's EP6_OUT bit.
     */
    inline void toggle_EP_ABORT_EP6_OUT() volatile
    {
        EP_ABORT ^= 1u << 13u;
    }

    /**
     * Get EP_ABORT's EP7_IN bit.
     */
    inline bool get_EP_ABORT_EP7_IN() volatile
    {
        return EP_ABORT & (1u << 14u);
    }

    /**
     * Set EP_ABORT's EP7_IN bit.
     */
    inline void set_EP_ABORT_EP7_IN() volatile
    {
        EP_ABORT |= 1u << 14u;
    }

    /**
     * Clear EP_ABORT's EP7_IN bit.
     */
    inline void clear_EP_ABORT_EP7_IN() volatile
    {
        EP_ABORT &= ~(1u << 14u);
    }

    /**
     * Toggle EP_ABORT's EP7_IN bit.
     */
    inline void toggle_EP_ABORT_EP7_IN() volatile
    {
        EP_ABORT ^= 1u << 14u;
    }

    /**
     * Get EP_ABORT's EP7_OUT bit.
     */
    inline bool get_EP_ABORT_EP7_OUT() volatile
    {
        return EP_ABORT & (1u << 15u);
    }

    /**
     * Set EP_ABORT's EP7_OUT bit.
     */
    inline void set_EP_ABORT_EP7_OUT() volatile
    {
        EP_ABORT |= 1u << 15u;
    }

    /**
     * Clear EP_ABORT's EP7_OUT bit.
     */
    inline void clear_EP_ABORT_EP7_OUT() volatile
    {
        EP_ABORT &= ~(1u << 15u);
    }

    /**
     * Toggle EP_ABORT's EP7_OUT bit.
     */
    inline void toggle_EP_ABORT_EP7_OUT() volatile
    {
        EP_ABORT ^= 1u << 15u;
    }

    /**
     * Get EP_ABORT's EP8_IN bit.
     */
    inline bool get_EP_ABORT_EP8_IN() volatile
    {
        return EP_ABORT & (1u << 16u);
    }

    /**
     * Set EP_ABORT's EP8_IN bit.
     */
    inline void set_EP_ABORT_EP8_IN() volatile
    {
        EP_ABORT |= 1u << 16u;
    }

    /**
     * Clear EP_ABORT's EP8_IN bit.
     */
    inline void clear_EP_ABORT_EP8_IN() volatile
    {
        EP_ABORT &= ~(1u << 16u);
    }

    /**
     * Toggle EP_ABORT's EP8_IN bit.
     */
    inline void toggle_EP_ABORT_EP8_IN() volatile
    {
        EP_ABORT ^= 1u << 16u;
    }

    /**
     * Get EP_ABORT's EP8_OUT bit.
     */
    inline bool get_EP_ABORT_EP8_OUT() volatile
    {
        return EP_ABORT & (1u << 17u);
    }

    /**
     * Set EP_ABORT's EP8_OUT bit.
     */
    inline void set_EP_ABORT_EP8_OUT() volatile
    {
        EP_ABORT |= 1u << 17u;
    }

    /**
     * Clear EP_ABORT's EP8_OUT bit.
     */
    inline void clear_EP_ABORT_EP8_OUT() volatile
    {
        EP_ABORT &= ~(1u << 17u);
    }

    /**
     * Toggle EP_ABORT's EP8_OUT bit.
     */
    inline void toggle_EP_ABORT_EP8_OUT() volatile
    {
        EP_ABORT ^= 1u << 17u;
    }

    /**
     * Get EP_ABORT's EP9_IN bit.
     */
    inline bool get_EP_ABORT_EP9_IN() volatile
    {
        return EP_ABORT & (1u << 18u);
    }

    /**
     * Set EP_ABORT's EP9_IN bit.
     */
    inline void set_EP_ABORT_EP9_IN() volatile
    {
        EP_ABORT |= 1u << 18u;
    }

    /**
     * Clear EP_ABORT's EP9_IN bit.
     */
    inline void clear_EP_ABORT_EP9_IN() volatile
    {
        EP_ABORT &= ~(1u << 18u);
    }

    /**
     * Toggle EP_ABORT's EP9_IN bit.
     */
    inline void toggle_EP_ABORT_EP9_IN() volatile
    {
        EP_ABORT ^= 1u << 18u;
    }

    /**
     * Get EP_ABORT's EP9_OUT bit.
     */
    inline bool get_EP_ABORT_EP9_OUT() volatile
    {
        return EP_ABORT & (1u << 19u);
    }

    /**
     * Set EP_ABORT's EP9_OUT bit.
     */
    inline void set_EP_ABORT_EP9_OUT() volatile
    {
        EP_ABORT |= 1u << 19u;
    }

    /**
     * Clear EP_ABORT's EP9_OUT bit.
     */
    inline void clear_EP_ABORT_EP9_OUT() volatile
    {
        EP_ABORT &= ~(1u << 19u);
    }

    /**
     * Toggle EP_ABORT's EP9_OUT bit.
     */
    inline void toggle_EP_ABORT_EP9_OUT() volatile
    {
        EP_ABORT ^= 1u << 19u;
    }

    /**
     * Get EP_ABORT's EP10_IN bit.
     */
    inline bool get_EP_ABORT_EP10_IN() volatile
    {
        return EP_ABORT & (1u << 20u);
    }

    /**
     * Set EP_ABORT's EP10_IN bit.
     */
    inline void set_EP_ABORT_EP10_IN() volatile
    {
        EP_ABORT |= 1u << 20u;
    }

    /**
     * Clear EP_ABORT's EP10_IN bit.
     */
    inline void clear_EP_ABORT_EP10_IN() volatile
    {
        EP_ABORT &= ~(1u << 20u);
    }

    /**
     * Toggle EP_ABORT's EP10_IN bit.
     */
    inline void toggle_EP_ABORT_EP10_IN() volatile
    {
        EP_ABORT ^= 1u << 20u;
    }

    /**
     * Get EP_ABORT's EP10_OUT bit.
     */
    inline bool get_EP_ABORT_EP10_OUT() volatile
    {
        return EP_ABORT & (1u << 21u);
    }

    /**
     * Set EP_ABORT's EP10_OUT bit.
     */
    inline void set_EP_ABORT_EP10_OUT() volatile
    {
        EP_ABORT |= 1u << 21u;
    }

    /**
     * Clear EP_ABORT's EP10_OUT bit.
     */
    inline void clear_EP_ABORT_EP10_OUT() volatile
    {
        EP_ABORT &= ~(1u << 21u);
    }

    /**
     * Toggle EP_ABORT's EP10_OUT bit.
     */
    inline void toggle_EP_ABORT_EP10_OUT() volatile
    {
        EP_ABORT ^= 1u << 21u;
    }

    /**
     * Get EP_ABORT's EP11_IN bit.
     */
    inline bool get_EP_ABORT_EP11_IN() volatile
    {
        return EP_ABORT & (1u << 22u);
    }

    /**
     * Set EP_ABORT's EP11_IN bit.
     */
    inline void set_EP_ABORT_EP11_IN() volatile
    {
        EP_ABORT |= 1u << 22u;
    }

    /**
     * Clear EP_ABORT's EP11_IN bit.
     */
    inline void clear_EP_ABORT_EP11_IN() volatile
    {
        EP_ABORT &= ~(1u << 22u);
    }

    /**
     * Toggle EP_ABORT's EP11_IN bit.
     */
    inline void toggle_EP_ABORT_EP11_IN() volatile
    {
        EP_ABORT ^= 1u << 22u;
    }

    /**
     * Get EP_ABORT's EP11_OUT bit.
     */
    inline bool get_EP_ABORT_EP11_OUT() volatile
    {
        return EP_ABORT & (1u << 23u);
    }

    /**
     * Set EP_ABORT's EP11_OUT bit.
     */
    inline void set_EP_ABORT_EP11_OUT() volatile
    {
        EP_ABORT |= 1u << 23u;
    }

    /**
     * Clear EP_ABORT's EP11_OUT bit.
     */
    inline void clear_EP_ABORT_EP11_OUT() volatile
    {
        EP_ABORT &= ~(1u << 23u);
    }

    /**
     * Toggle EP_ABORT's EP11_OUT bit.
     */
    inline void toggle_EP_ABORT_EP11_OUT() volatile
    {
        EP_ABORT ^= 1u << 23u;
    }

    /**
     * Get EP_ABORT's EP12_IN bit.
     */
    inline bool get_EP_ABORT_EP12_IN() volatile
    {
        return EP_ABORT & (1u << 24u);
    }

    /**
     * Set EP_ABORT's EP12_IN bit.
     */
    inline void set_EP_ABORT_EP12_IN() volatile
    {
        EP_ABORT |= 1u << 24u;
    }

    /**
     * Clear EP_ABORT's EP12_IN bit.
     */
    inline void clear_EP_ABORT_EP12_IN() volatile
    {
        EP_ABORT &= ~(1u << 24u);
    }

    /**
     * Toggle EP_ABORT's EP12_IN bit.
     */
    inline void toggle_EP_ABORT_EP12_IN() volatile
    {
        EP_ABORT ^= 1u << 24u;
    }

    /**
     * Get EP_ABORT's EP12_OUT bit.
     */
    inline bool get_EP_ABORT_EP12_OUT() volatile
    {
        return EP_ABORT & (1u << 25u);
    }

    /**
     * Set EP_ABORT's EP12_OUT bit.
     */
    inline void set_EP_ABORT_EP12_OUT() volatile
    {
        EP_ABORT |= 1u << 25u;
    }

    /**
     * Clear EP_ABORT's EP12_OUT bit.
     */
    inline void clear_EP_ABORT_EP12_OUT() volatile
    {
        EP_ABORT &= ~(1u << 25u);
    }

    /**
     * Toggle EP_ABORT's EP12_OUT bit.
     */
    inline void toggle_EP_ABORT_EP12_OUT() volatile
    {
        EP_ABORT ^= 1u << 25u;
    }

    /**
     * Get EP_ABORT's EP13_IN bit.
     */
    inline bool get_EP_ABORT_EP13_IN() volatile
    {
        return EP_ABORT & (1u << 26u);
    }

    /**
     * Set EP_ABORT's EP13_IN bit.
     */
    inline void set_EP_ABORT_EP13_IN() volatile
    {
        EP_ABORT |= 1u << 26u;
    }

    /**
     * Clear EP_ABORT's EP13_IN bit.
     */
    inline void clear_EP_ABORT_EP13_IN() volatile
    {
        EP_ABORT &= ~(1u << 26u);
    }

    /**
     * Toggle EP_ABORT's EP13_IN bit.
     */
    inline void toggle_EP_ABORT_EP13_IN() volatile
    {
        EP_ABORT ^= 1u << 26u;
    }

    /**
     * Get EP_ABORT's EP13_OUT bit.
     */
    inline bool get_EP_ABORT_EP13_OUT() volatile
    {
        return EP_ABORT & (1u << 27u);
    }

    /**
     * Set EP_ABORT's EP13_OUT bit.
     */
    inline void set_EP_ABORT_EP13_OUT() volatile
    {
        EP_ABORT |= 1u << 27u;
    }

    /**
     * Clear EP_ABORT's EP13_OUT bit.
     */
    inline void clear_EP_ABORT_EP13_OUT() volatile
    {
        EP_ABORT &= ~(1u << 27u);
    }

    /**
     * Toggle EP_ABORT's EP13_OUT bit.
     */
    inline void toggle_EP_ABORT_EP13_OUT() volatile
    {
        EP_ABORT ^= 1u << 27u;
    }

    /**
     * Get EP_ABORT's EP14_IN bit.
     */
    inline bool get_EP_ABORT_EP14_IN() volatile
    {
        return EP_ABORT & (1u << 28u);
    }

    /**
     * Set EP_ABORT's EP14_IN bit.
     */
    inline void set_EP_ABORT_EP14_IN() volatile
    {
        EP_ABORT |= 1u << 28u;
    }

    /**
     * Clear EP_ABORT's EP14_IN bit.
     */
    inline void clear_EP_ABORT_EP14_IN() volatile
    {
        EP_ABORT &= ~(1u << 28u);
    }

    /**
     * Toggle EP_ABORT's EP14_IN bit.
     */
    inline void toggle_EP_ABORT_EP14_IN() volatile
    {
        EP_ABORT ^= 1u << 28u;
    }

    /**
     * Get EP_ABORT's EP14_OUT bit.
     */
    inline bool get_EP_ABORT_EP14_OUT() volatile
    {
        return EP_ABORT & (1u << 29u);
    }

    /**
     * Set EP_ABORT's EP14_OUT bit.
     */
    inline void set_EP_ABORT_EP14_OUT() volatile
    {
        EP_ABORT |= 1u << 29u;
    }

    /**
     * Clear EP_ABORT's EP14_OUT bit.
     */
    inline void clear_EP_ABORT_EP14_OUT() volatile
    {
        EP_ABORT &= ~(1u << 29u);
    }

    /**
     * Toggle EP_ABORT's EP14_OUT bit.
     */
    inline void toggle_EP_ABORT_EP14_OUT() volatile
    {
        EP_ABORT ^= 1u << 29u;
    }

    /**
     * Get EP_ABORT's EP15_IN bit.
     */
    inline bool get_EP_ABORT_EP15_IN() volatile
    {
        return EP_ABORT & (1u << 30u);
    }

    /**
     * Set EP_ABORT's EP15_IN bit.
     */
    inline void set_EP_ABORT_EP15_IN() volatile
    {
        EP_ABORT |= 1u << 30u;
    }

    /**
     * Clear EP_ABORT's EP15_IN bit.
     */
    inline void clear_EP_ABORT_EP15_IN() volatile
    {
        EP_ABORT &= ~(1u << 30u);
    }

    /**
     * Toggle EP_ABORT's EP15_IN bit.
     */
    inline void toggle_EP_ABORT_EP15_IN() volatile
    {
        EP_ABORT ^= 1u << 30u;
    }

    /**
     * Get EP_ABORT's EP15_OUT bit.
     */
    inline bool get_EP_ABORT_EP15_OUT() volatile
    {
        return EP_ABORT & (1u << 31u);
    }

    /**
     * Set EP_ABORT's EP15_OUT bit.
     */
    inline void set_EP_ABORT_EP15_OUT() volatile
    {
        EP_ABORT |= 1u << 31u;
    }

    /**
     * Clear EP_ABORT's EP15_OUT bit.
     */
    inline void clear_EP_ABORT_EP15_OUT() volatile
    {
        EP_ABORT &= ~(1u << 31u);
    }

    /**
     * Toggle EP_ABORT's EP15_OUT bit.
     */
    inline void toggle_EP_ABORT_EP15_OUT() volatile
    {
        EP_ABORT ^= 1u << 31u;
    }

    /**
     * Get all of EP_ABORT's bit fields.
     *
     * (read-write) Device only: Can be set to ignore the buffer control
     * register for this endpoint in case you would like to revoke a buffer. A
     * NAK will be sent for every access to the endpoint until this bit is
     * cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe
     * to modify the buffer control register.
     */
    inline void get_EP_ABORT(bool &EP0_IN, bool &EP0_OUT, bool &EP1_IN,
                             bool &EP1_OUT, bool &EP2_IN, bool &EP2_OUT,
                             bool &EP3_IN, bool &EP3_OUT, bool &EP4_IN,
                             bool &EP4_OUT, bool &EP5_IN, bool &EP5_OUT,
                             bool &EP6_IN, bool &EP6_OUT, bool &EP7_IN,
                             bool &EP7_OUT, bool &EP8_IN, bool &EP8_OUT,
                             bool &EP9_IN, bool &EP9_OUT, bool &EP10_IN,
                             bool &EP10_OUT, bool &EP11_IN, bool &EP11_OUT,
                             bool &EP12_IN, bool &EP12_OUT, bool &EP13_IN,
                             bool &EP13_OUT, bool &EP14_IN, bool &EP14_OUT,
                             bool &EP15_IN, bool &EP15_OUT) volatile
    {
        uint32_t curr = EP_ABORT;

        EP0_IN = curr & (1u << 0u);
        EP0_OUT = curr & (1u << 1u);
        EP1_IN = curr & (1u << 2u);
        EP1_OUT = curr & (1u << 3u);
        EP2_IN = curr & (1u << 4u);
        EP2_OUT = curr & (1u << 5u);
        EP3_IN = curr & (1u << 6u);
        EP3_OUT = curr & (1u << 7u);
        EP4_IN = curr & (1u << 8u);
        EP4_OUT = curr & (1u << 9u);
        EP5_IN = curr & (1u << 10u);
        EP5_OUT = curr & (1u << 11u);
        EP6_IN = curr & (1u << 12u);
        EP6_OUT = curr & (1u << 13u);
        EP7_IN = curr & (1u << 14u);
        EP7_OUT = curr & (1u << 15u);
        EP8_IN = curr & (1u << 16u);
        EP8_OUT = curr & (1u << 17u);
        EP9_IN = curr & (1u << 18u);
        EP9_OUT = curr & (1u << 19u);
        EP10_IN = curr & (1u << 20u);
        EP10_OUT = curr & (1u << 21u);
        EP11_IN = curr & (1u << 22u);
        EP11_OUT = curr & (1u << 23u);
        EP12_IN = curr & (1u << 24u);
        EP12_OUT = curr & (1u << 25u);
        EP13_IN = curr & (1u << 26u);
        EP13_OUT = curr & (1u << 27u);
        EP14_IN = curr & (1u << 28u);
        EP14_OUT = curr & (1u << 29u);
        EP15_IN = curr & (1u << 30u);
        EP15_OUT = curr & (1u << 31u);
    }

    /**
     * Set all of EP_ABORT's bit fields.
     *
     * (read-write) Device only: Can be set to ignore the buffer control
     * register for this endpoint in case you would like to revoke a buffer. A
     * NAK will be sent for every access to the endpoint until this bit is
     * cleared. A corresponding bit in `EP_ABORT_DONE` is set when it is safe
     * to modify the buffer control register.
     */
    inline void set_EP_ABORT(
        bool EP0_IN, bool EP0_OUT, bool EP1_IN, bool EP1_OUT, bool EP2_IN,
        bool EP2_OUT, bool EP3_IN, bool EP3_OUT, bool EP4_IN, bool EP4_OUT,
        bool EP5_IN, bool EP5_OUT, bool EP6_IN, bool EP6_OUT, bool EP7_IN,
        bool EP7_OUT, bool EP8_IN, bool EP8_OUT, bool EP9_IN, bool EP9_OUT,
        bool EP10_IN, bool EP10_OUT, bool EP11_IN, bool EP11_OUT, bool EP12_IN,
        bool EP12_OUT, bool EP13_IN, bool EP13_OUT, bool EP14_IN,
        bool EP14_OUT, bool EP15_IN, bool EP15_OUT) volatile
    {
        uint32_t curr = EP_ABORT;

        curr &= ~(0b1u << 0u);
        curr |= (EP0_IN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (EP0_OUT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (EP1_IN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (EP1_OUT & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (EP2_IN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (EP2_OUT & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (EP3_IN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (EP3_OUT & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (EP4_IN & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (EP4_OUT & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (EP5_IN & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (EP5_OUT & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (EP6_IN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (EP6_OUT & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (EP7_IN & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (EP7_OUT & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (EP8_IN & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (EP8_OUT & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (EP9_IN & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (EP9_OUT & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (EP10_IN & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (EP10_OUT & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (EP11_IN & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (EP11_OUT & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (EP12_IN & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (EP12_OUT & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (EP13_IN & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (EP13_OUT & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (EP14_IN & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (EP14_OUT & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (EP15_IN & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (EP15_OUT & 0b1u) << 31u;

        EP_ABORT = curr;
    }

    /**
     * Get EP_ABORT_DONE's EP0_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP0_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 0u);
    }

    /**
     * Set EP_ABORT_DONE's EP0_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP0_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 0u;
    }

    /**
     * Clear EP_ABORT_DONE's EP0_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP0_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 0u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP0_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP0_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 0u;
    }

    /**
     * Get EP_ABORT_DONE's EP0_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP0_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 1u);
    }

    /**
     * Set EP_ABORT_DONE's EP0_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP0_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 1u;
    }

    /**
     * Clear EP_ABORT_DONE's EP0_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP0_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 1u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP0_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP0_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 1u;
    }

    /**
     * Get EP_ABORT_DONE's EP1_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP1_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 2u);
    }

    /**
     * Set EP_ABORT_DONE's EP1_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP1_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 2u;
    }

    /**
     * Clear EP_ABORT_DONE's EP1_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP1_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 2u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP1_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP1_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 2u;
    }

    /**
     * Get EP_ABORT_DONE's EP1_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP1_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 3u);
    }

    /**
     * Set EP_ABORT_DONE's EP1_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP1_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 3u;
    }

    /**
     * Clear EP_ABORT_DONE's EP1_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP1_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 3u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP1_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP1_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 3u;
    }

    /**
     * Get EP_ABORT_DONE's EP2_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP2_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 4u);
    }

    /**
     * Set EP_ABORT_DONE's EP2_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP2_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 4u;
    }

    /**
     * Clear EP_ABORT_DONE's EP2_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP2_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 4u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP2_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP2_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 4u;
    }

    /**
     * Get EP_ABORT_DONE's EP2_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP2_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 5u);
    }

    /**
     * Set EP_ABORT_DONE's EP2_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP2_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 5u;
    }

    /**
     * Clear EP_ABORT_DONE's EP2_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP2_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 5u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP2_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP2_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 5u;
    }

    /**
     * Get EP_ABORT_DONE's EP3_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP3_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 6u);
    }

    /**
     * Set EP_ABORT_DONE's EP3_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP3_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 6u;
    }

    /**
     * Clear EP_ABORT_DONE's EP3_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP3_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 6u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP3_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP3_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 6u;
    }

    /**
     * Get EP_ABORT_DONE's EP3_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP3_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 7u);
    }

    /**
     * Set EP_ABORT_DONE's EP3_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP3_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 7u;
    }

    /**
     * Clear EP_ABORT_DONE's EP3_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP3_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 7u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP3_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP3_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 7u;
    }

    /**
     * Get EP_ABORT_DONE's EP4_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP4_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 8u);
    }

    /**
     * Set EP_ABORT_DONE's EP4_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP4_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 8u;
    }

    /**
     * Clear EP_ABORT_DONE's EP4_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP4_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 8u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP4_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP4_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 8u;
    }

    /**
     * Get EP_ABORT_DONE's EP4_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP4_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 9u);
    }

    /**
     * Set EP_ABORT_DONE's EP4_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP4_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 9u;
    }

    /**
     * Clear EP_ABORT_DONE's EP4_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP4_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 9u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP4_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP4_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 9u;
    }

    /**
     * Get EP_ABORT_DONE's EP5_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP5_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 10u);
    }

    /**
     * Set EP_ABORT_DONE's EP5_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP5_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 10u;
    }

    /**
     * Clear EP_ABORT_DONE's EP5_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP5_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 10u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP5_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP5_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 10u;
    }

    /**
     * Get EP_ABORT_DONE's EP5_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP5_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 11u);
    }

    /**
     * Set EP_ABORT_DONE's EP5_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP5_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 11u;
    }

    /**
     * Clear EP_ABORT_DONE's EP5_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP5_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 11u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP5_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP5_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 11u;
    }

    /**
     * Get EP_ABORT_DONE's EP6_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP6_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 12u);
    }

    /**
     * Set EP_ABORT_DONE's EP6_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP6_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 12u;
    }

    /**
     * Clear EP_ABORT_DONE's EP6_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP6_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 12u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP6_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP6_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 12u;
    }

    /**
     * Get EP_ABORT_DONE's EP6_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP6_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 13u);
    }

    /**
     * Set EP_ABORT_DONE's EP6_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP6_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 13u;
    }

    /**
     * Clear EP_ABORT_DONE's EP6_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP6_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 13u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP6_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP6_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 13u;
    }

    /**
     * Get EP_ABORT_DONE's EP7_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP7_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 14u);
    }

    /**
     * Set EP_ABORT_DONE's EP7_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP7_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 14u;
    }

    /**
     * Clear EP_ABORT_DONE's EP7_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP7_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 14u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP7_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP7_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 14u;
    }

    /**
     * Get EP_ABORT_DONE's EP7_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP7_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 15u);
    }

    /**
     * Set EP_ABORT_DONE's EP7_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP7_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 15u;
    }

    /**
     * Clear EP_ABORT_DONE's EP7_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP7_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 15u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP7_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP7_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 15u;
    }

    /**
     * Get EP_ABORT_DONE's EP8_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP8_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 16u);
    }

    /**
     * Set EP_ABORT_DONE's EP8_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP8_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 16u;
    }

    /**
     * Clear EP_ABORT_DONE's EP8_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP8_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 16u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP8_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP8_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 16u;
    }

    /**
     * Get EP_ABORT_DONE's EP8_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP8_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 17u);
    }

    /**
     * Set EP_ABORT_DONE's EP8_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP8_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 17u;
    }

    /**
     * Clear EP_ABORT_DONE's EP8_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP8_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 17u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP8_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP8_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 17u;
    }

    /**
     * Get EP_ABORT_DONE's EP9_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP9_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 18u);
    }

    /**
     * Set EP_ABORT_DONE's EP9_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP9_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 18u;
    }

    /**
     * Clear EP_ABORT_DONE's EP9_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP9_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 18u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP9_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP9_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 18u;
    }

    /**
     * Get EP_ABORT_DONE's EP9_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP9_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 19u);
    }

    /**
     * Set EP_ABORT_DONE's EP9_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP9_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 19u;
    }

    /**
     * Clear EP_ABORT_DONE's EP9_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP9_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 19u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP9_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP9_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 19u;
    }

    /**
     * Get EP_ABORT_DONE's EP10_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP10_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 20u);
    }

    /**
     * Set EP_ABORT_DONE's EP10_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP10_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 20u;
    }

    /**
     * Clear EP_ABORT_DONE's EP10_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP10_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 20u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP10_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP10_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 20u;
    }

    /**
     * Get EP_ABORT_DONE's EP10_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP10_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 21u);
    }

    /**
     * Set EP_ABORT_DONE's EP10_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP10_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 21u;
    }

    /**
     * Clear EP_ABORT_DONE's EP10_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP10_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 21u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP10_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP10_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 21u;
    }

    /**
     * Get EP_ABORT_DONE's EP11_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP11_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 22u);
    }

    /**
     * Set EP_ABORT_DONE's EP11_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP11_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 22u;
    }

    /**
     * Clear EP_ABORT_DONE's EP11_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP11_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 22u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP11_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP11_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 22u;
    }

    /**
     * Get EP_ABORT_DONE's EP11_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP11_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 23u);
    }

    /**
     * Set EP_ABORT_DONE's EP11_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP11_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 23u;
    }

    /**
     * Clear EP_ABORT_DONE's EP11_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP11_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 23u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP11_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP11_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 23u;
    }

    /**
     * Get EP_ABORT_DONE's EP12_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP12_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 24u);
    }

    /**
     * Set EP_ABORT_DONE's EP12_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP12_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 24u;
    }

    /**
     * Clear EP_ABORT_DONE's EP12_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP12_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 24u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP12_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP12_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 24u;
    }

    /**
     * Get EP_ABORT_DONE's EP12_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP12_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 25u);
    }

    /**
     * Set EP_ABORT_DONE's EP12_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP12_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 25u;
    }

    /**
     * Clear EP_ABORT_DONE's EP12_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP12_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 25u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP12_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP12_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 25u;
    }

    /**
     * Get EP_ABORT_DONE's EP13_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP13_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 26u);
    }

    /**
     * Set EP_ABORT_DONE's EP13_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP13_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 26u;
    }

    /**
     * Clear EP_ABORT_DONE's EP13_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP13_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 26u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP13_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP13_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 26u;
    }

    /**
     * Get EP_ABORT_DONE's EP13_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP13_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 27u);
    }

    /**
     * Set EP_ABORT_DONE's EP13_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP13_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 27u;
    }

    /**
     * Clear EP_ABORT_DONE's EP13_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP13_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 27u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP13_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP13_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 27u;
    }

    /**
     * Get EP_ABORT_DONE's EP14_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP14_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 28u);
    }

    /**
     * Set EP_ABORT_DONE's EP14_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP14_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 28u;
    }

    /**
     * Clear EP_ABORT_DONE's EP14_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP14_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 28u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP14_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP14_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 28u;
    }

    /**
     * Get EP_ABORT_DONE's EP14_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP14_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 29u);
    }

    /**
     * Set EP_ABORT_DONE's EP14_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP14_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 29u;
    }

    /**
     * Clear EP_ABORT_DONE's EP14_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP14_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 29u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP14_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP14_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 29u;
    }

    /**
     * Get EP_ABORT_DONE's EP15_IN bit.
     */
    inline bool get_EP_ABORT_DONE_EP15_IN() volatile
    {
        return EP_ABORT_DONE & (1u << 30u);
    }

    /**
     * Set EP_ABORT_DONE's EP15_IN bit.
     */
    inline void set_EP_ABORT_DONE_EP15_IN() volatile
    {
        EP_ABORT_DONE |= 1u << 30u;
    }

    /**
     * Clear EP_ABORT_DONE's EP15_IN bit.
     */
    inline void clear_EP_ABORT_DONE_EP15_IN() volatile
    {
        EP_ABORT_DONE &= ~(1u << 30u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP15_IN bit.
     */
    inline void toggle_EP_ABORT_DONE_EP15_IN() volatile
    {
        EP_ABORT_DONE ^= 1u << 30u;
    }

    /**
     * Get EP_ABORT_DONE's EP15_OUT bit.
     */
    inline bool get_EP_ABORT_DONE_EP15_OUT() volatile
    {
        return EP_ABORT_DONE & (1u << 31u);
    }

    /**
     * Set EP_ABORT_DONE's EP15_OUT bit.
     */
    inline void set_EP_ABORT_DONE_EP15_OUT() volatile
    {
        EP_ABORT_DONE |= 1u << 31u;
    }

    /**
     * Clear EP_ABORT_DONE's EP15_OUT bit.
     */
    inline void clear_EP_ABORT_DONE_EP15_OUT() volatile
    {
        EP_ABORT_DONE &= ~(1u << 31u);
    }

    /**
     * Toggle EP_ABORT_DONE's EP15_OUT bit.
     */
    inline void toggle_EP_ABORT_DONE_EP15_OUT() volatile
    {
        EP_ABORT_DONE ^= 1u << 31u;
    }

    /**
     * Get all of EP_ABORT_DONE's bit fields.
     *
     * (read-write) Device only: Used in conjunction with `EP_ABORT`. Set once
     * an endpoint is idle so the programmer knows it is safe to modify the
     * buffer control register.
     */
    inline void get_EP_ABORT_DONE(
        bool &EP0_IN, bool &EP0_OUT, bool &EP1_IN, bool &EP1_OUT, bool &EP2_IN,
        bool &EP2_OUT, bool &EP3_IN, bool &EP3_OUT, bool &EP4_IN,
        bool &EP4_OUT, bool &EP5_IN, bool &EP5_OUT, bool &EP6_IN,
        bool &EP6_OUT, bool &EP7_IN, bool &EP7_OUT, bool &EP8_IN,
        bool &EP8_OUT, bool &EP9_IN, bool &EP9_OUT, bool &EP10_IN,
        bool &EP10_OUT, bool &EP11_IN, bool &EP11_OUT, bool &EP12_IN,
        bool &EP12_OUT, bool &EP13_IN, bool &EP13_OUT, bool &EP14_IN,
        bool &EP14_OUT, bool &EP15_IN, bool &EP15_OUT) volatile
    {
        uint32_t curr = EP_ABORT_DONE;

        EP0_IN = curr & (1u << 0u);
        EP0_OUT = curr & (1u << 1u);
        EP1_IN = curr & (1u << 2u);
        EP1_OUT = curr & (1u << 3u);
        EP2_IN = curr & (1u << 4u);
        EP2_OUT = curr & (1u << 5u);
        EP3_IN = curr & (1u << 6u);
        EP3_OUT = curr & (1u << 7u);
        EP4_IN = curr & (1u << 8u);
        EP4_OUT = curr & (1u << 9u);
        EP5_IN = curr & (1u << 10u);
        EP5_OUT = curr & (1u << 11u);
        EP6_IN = curr & (1u << 12u);
        EP6_OUT = curr & (1u << 13u);
        EP7_IN = curr & (1u << 14u);
        EP7_OUT = curr & (1u << 15u);
        EP8_IN = curr & (1u << 16u);
        EP8_OUT = curr & (1u << 17u);
        EP9_IN = curr & (1u << 18u);
        EP9_OUT = curr & (1u << 19u);
        EP10_IN = curr & (1u << 20u);
        EP10_OUT = curr & (1u << 21u);
        EP11_IN = curr & (1u << 22u);
        EP11_OUT = curr & (1u << 23u);
        EP12_IN = curr & (1u << 24u);
        EP12_OUT = curr & (1u << 25u);
        EP13_IN = curr & (1u << 26u);
        EP13_OUT = curr & (1u << 27u);
        EP14_IN = curr & (1u << 28u);
        EP14_OUT = curr & (1u << 29u);
        EP15_IN = curr & (1u << 30u);
        EP15_OUT = curr & (1u << 31u);
    }

    /**
     * Set all of EP_ABORT_DONE's bit fields.
     *
     * (read-write) Device only: Used in conjunction with `EP_ABORT`. Set once
     * an endpoint is idle so the programmer knows it is safe to modify the
     * buffer control register.
     */
    inline void set_EP_ABORT_DONE(
        bool EP0_IN, bool EP0_OUT, bool EP1_IN, bool EP1_OUT, bool EP2_IN,
        bool EP2_OUT, bool EP3_IN, bool EP3_OUT, bool EP4_IN, bool EP4_OUT,
        bool EP5_IN, bool EP5_OUT, bool EP6_IN, bool EP6_OUT, bool EP7_IN,
        bool EP7_OUT, bool EP8_IN, bool EP8_OUT, bool EP9_IN, bool EP9_OUT,
        bool EP10_IN, bool EP10_OUT, bool EP11_IN, bool EP11_OUT, bool EP12_IN,
        bool EP12_OUT, bool EP13_IN, bool EP13_OUT, bool EP14_IN,
        bool EP14_OUT, bool EP15_IN, bool EP15_OUT) volatile
    {
        uint32_t curr = EP_ABORT_DONE;

        curr &= ~(0b1u << 0u);
        curr |= (EP0_IN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (EP0_OUT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (EP1_IN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (EP1_OUT & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (EP2_IN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (EP2_OUT & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (EP3_IN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (EP3_OUT & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (EP4_IN & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (EP4_OUT & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (EP5_IN & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (EP5_OUT & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (EP6_IN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (EP6_OUT & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (EP7_IN & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (EP7_OUT & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (EP8_IN & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (EP8_OUT & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (EP9_IN & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (EP9_OUT & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (EP10_IN & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (EP10_OUT & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (EP11_IN & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (EP11_OUT & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (EP12_IN & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (EP12_OUT & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (EP13_IN & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (EP13_OUT & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (EP14_IN & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (EP14_OUT & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (EP15_IN & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (EP15_OUT & 0b1u) << 31u;

        EP_ABORT_DONE = curr;
    }

    /**
     * Get EP_STALL_ARM's EP0_IN bit.
     */
    inline bool get_EP_STALL_ARM_EP0_IN() volatile
    {
        return EP_STALL_ARM & (1u << 0u);
    }

    /**
     * Set EP_STALL_ARM's EP0_IN bit.
     */
    inline void set_EP_STALL_ARM_EP0_IN() volatile
    {
        EP_STALL_ARM |= 1u << 0u;
    }

    /**
     * Clear EP_STALL_ARM's EP0_IN bit.
     */
    inline void clear_EP_STALL_ARM_EP0_IN() volatile
    {
        EP_STALL_ARM &= ~(1u << 0u);
    }

    /**
     * Toggle EP_STALL_ARM's EP0_IN bit.
     */
    inline void toggle_EP_STALL_ARM_EP0_IN() volatile
    {
        EP_STALL_ARM ^= 1u << 0u;
    }

    /**
     * Get EP_STALL_ARM's EP0_OUT bit.
     */
    inline bool get_EP_STALL_ARM_EP0_OUT() volatile
    {
        return EP_STALL_ARM & (1u << 1u);
    }

    /**
     * Set EP_STALL_ARM's EP0_OUT bit.
     */
    inline void set_EP_STALL_ARM_EP0_OUT() volatile
    {
        EP_STALL_ARM |= 1u << 1u;
    }

    /**
     * Clear EP_STALL_ARM's EP0_OUT bit.
     */
    inline void clear_EP_STALL_ARM_EP0_OUT() volatile
    {
        EP_STALL_ARM &= ~(1u << 1u);
    }

    /**
     * Toggle EP_STALL_ARM's EP0_OUT bit.
     */
    inline void toggle_EP_STALL_ARM_EP0_OUT() volatile
    {
        EP_STALL_ARM ^= 1u << 1u;
    }

    /**
     * Get all of EP_STALL_ARM's bit fields.
     *
     * (read-write) Device: this bit must be set in conjunction with the
     * `STALL` bit in the buffer control register to send a STALL on EP0. The
     * device controller clears these bits when a SETUP packet is received
     * because the USB spec requires that a STALL condition is cleared when a
     * SETUP packet is received.
     */
    inline void get_EP_STALL_ARM(bool &EP0_IN, bool &EP0_OUT) volatile
    {
        uint32_t curr = EP_STALL_ARM;

        EP0_IN = curr & (1u << 0u);
        EP0_OUT = curr & (1u << 1u);
    }

    /**
     * Set all of EP_STALL_ARM's bit fields.
     *
     * (read-write) Device: this bit must be set in conjunction with the
     * `STALL` bit in the buffer control register to send a STALL on EP0. The
     * device controller clears these bits when a SETUP packet is received
     * because the USB spec requires that a STALL condition is cleared when a
     * SETUP packet is received.
     */
    inline void set_EP_STALL_ARM(bool EP0_IN, bool EP0_OUT) volatile
    {
        uint32_t curr = EP_STALL_ARM;

        curr &= ~(0b1u << 0u);
        curr |= (EP0_IN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (EP0_OUT & 0b1u) << 1u;

        EP_STALL_ARM = curr;
    }

    /**
     * Get NAK_POLL's DELAY_LS field.
     *
     * NAK polling interval for a low speed device
     */
    inline uint16_t get_NAK_POLL_DELAY_LS() volatile
    {
        return (NAK_POLL >> 0u) & 0b1111111111u;
    }

    /**
     * Set NAK_POLL's DELAY_LS field.
     *
     * NAK polling interval for a low speed device
     */
    inline void set_NAK_POLL_DELAY_LS(uint16_t value) volatile
    {
        uint32_t curr = NAK_POLL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (value & 0b1111111111u) << 0u;

        NAK_POLL = curr;
    }

    /**
     * Get NAK_POLL's DELAY_FS field.
     *
     * NAK polling interval for a full speed device
     */
    inline uint16_t get_NAK_POLL_DELAY_FS() volatile
    {
        return (NAK_POLL >> 16u) & 0b1111111111u;
    }

    /**
     * Set NAK_POLL's DELAY_FS field.
     *
     * NAK polling interval for a full speed device
     */
    inline void set_NAK_POLL_DELAY_FS(uint16_t value) volatile
    {
        uint32_t curr = NAK_POLL;

        curr &= ~(0b1111111111u << 16u);
        curr |= (value & 0b1111111111u) << 16u;

        NAK_POLL = curr;
    }

    /**
     * Get all of NAK_POLL's bit fields.
     *
     * (read-write) Used by the host controller. Sets the wait time in
     * microseconds before trying again if the device replies with a NAK.
     */
    inline void get_NAK_POLL(uint16_t &DELAY_LS, uint16_t &DELAY_FS) volatile
    {
        uint32_t curr = NAK_POLL;

        DELAY_LS = (curr >> 0u) & 0b1111111111u;
        DELAY_FS = (curr >> 16u) & 0b1111111111u;
    }

    /**
     * Set all of NAK_POLL's bit fields.
     *
     * (read-write) Used by the host controller. Sets the wait time in
     * microseconds before trying again if the device replies with a NAK.
     */
    inline void set_NAK_POLL(uint16_t DELAY_LS, uint16_t DELAY_FS) volatile
    {
        uint32_t curr = NAK_POLL;

        curr &= ~(0b1111111111u << 0u);
        curr |= (DELAY_LS & 0b1111111111u) << 0u;
        curr &= ~(0b1111111111u << 16u);
        curr |= (DELAY_FS & 0b1111111111u) << 16u;

        NAK_POLL = curr;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP0_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP0_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 0u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP0_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP0_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 0u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP0_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP0_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 0u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP0_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP0_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 0u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP0_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP0_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 1u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP0_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP0_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 1u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP0_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP0_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 1u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP0_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP0_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 1u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP1_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP1_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 2u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP1_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP1_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 2u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP1_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP1_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 2u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP1_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP1_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 2u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP1_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP1_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 3u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP1_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP1_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 3u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP1_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP1_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 3u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP1_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP1_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 3u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP2_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP2_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 4u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP2_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP2_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 4u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP2_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP2_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 4u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP2_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP2_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 4u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP2_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP2_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 5u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP2_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP2_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 5u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP2_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP2_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 5u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP2_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP2_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 5u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP3_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP3_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 6u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP3_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP3_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 6u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP3_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP3_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 6u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP3_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP3_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 6u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP3_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP3_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 7u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP3_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP3_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 7u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP3_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP3_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 7u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP3_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP3_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 7u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP4_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP4_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 8u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP4_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP4_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 8u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP4_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP4_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 8u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP4_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP4_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 8u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP4_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP4_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 9u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP4_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP4_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 9u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP4_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP4_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 9u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP4_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP4_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 9u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP5_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP5_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 10u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP5_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP5_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 10u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP5_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP5_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 10u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP5_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP5_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 10u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP5_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP5_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 11u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP5_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP5_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 11u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP5_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP5_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 11u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP5_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP5_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 11u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP6_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP6_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 12u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP6_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP6_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 12u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP6_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP6_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 12u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP6_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP6_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 12u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP6_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP6_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 13u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP6_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP6_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 13u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP6_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP6_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 13u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP6_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP6_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 13u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP7_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP7_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 14u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP7_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP7_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 14u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP7_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP7_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 14u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP7_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP7_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 14u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP7_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP7_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 15u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP7_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP7_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 15u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP7_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP7_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 15u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP7_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP7_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 15u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP8_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP8_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 16u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP8_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP8_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 16u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP8_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP8_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 16u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP8_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP8_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 16u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP8_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP8_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 17u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP8_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP8_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 17u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP8_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP8_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 17u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP8_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP8_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 17u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP9_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP9_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 18u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP9_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP9_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 18u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP9_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP9_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 18u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP9_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP9_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 18u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP9_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP9_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 19u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP9_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP9_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 19u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP9_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP9_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 19u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP9_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP9_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 19u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP10_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP10_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 20u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP10_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP10_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 20u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP10_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP10_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 20u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP10_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP10_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 20u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP10_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP10_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 21u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP10_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP10_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 21u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP10_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP10_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 21u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP10_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP10_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 21u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP11_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP11_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 22u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP11_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP11_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 22u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP11_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP11_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 22u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP11_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP11_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 22u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP11_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP11_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 23u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP11_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP11_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 23u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP11_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP11_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 23u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP11_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP11_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 23u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP12_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP12_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 24u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP12_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP12_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 24u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP12_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP12_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 24u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP12_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP12_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 24u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP12_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP12_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 25u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP12_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP12_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 25u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP12_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP12_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 25u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP12_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP12_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 25u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP13_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP13_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 26u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP13_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP13_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 26u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP13_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP13_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 26u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP13_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP13_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 26u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP13_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP13_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 27u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP13_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP13_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 27u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP13_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP13_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 27u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP13_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP13_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 27u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP14_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP14_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 28u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP14_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP14_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 28u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP14_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP14_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 28u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP14_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP14_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 28u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP14_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP14_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 29u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP14_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP14_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 29u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP14_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP14_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 29u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP14_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP14_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 29u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP15_IN bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP15_IN() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 30u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP15_IN bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP15_IN() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 30u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP15_IN bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP15_IN() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 30u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP15_IN bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP15_IN() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 30u;
    }

    /**
     * Get EP_STATUS_STALL_NAK's EP15_OUT bit.
     */
    inline bool get_EP_STATUS_STALL_NAK_EP15_OUT() volatile
    {
        return EP_STATUS_STALL_NAK & (1u << 31u);
    }

    /**
     * Set EP_STATUS_STALL_NAK's EP15_OUT bit.
     */
    inline void set_EP_STATUS_STALL_NAK_EP15_OUT() volatile
    {
        EP_STATUS_STALL_NAK |= 1u << 31u;
    }

    /**
     * Clear EP_STATUS_STALL_NAK's EP15_OUT bit.
     */
    inline void clear_EP_STATUS_STALL_NAK_EP15_OUT() volatile
    {
        EP_STATUS_STALL_NAK &= ~(1u << 31u);
    }

    /**
     * Toggle EP_STATUS_STALL_NAK's EP15_OUT bit.
     */
    inline void toggle_EP_STATUS_STALL_NAK_EP15_OUT() volatile
    {
        EP_STATUS_STALL_NAK ^= 1u << 31u;
    }

    /**
     * Get all of EP_STATUS_STALL_NAK's bit fields.
     *
     * (read-write) Device: bits are set when the `IRQ_ON_NAK` or
     * `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all
     * other endpoints it comes from the endpoint control register.
     */
    inline void get_EP_STATUS_STALL_NAK(
        bool &EP0_IN, bool &EP0_OUT, bool &EP1_IN, bool &EP1_OUT, bool &EP2_IN,
        bool &EP2_OUT, bool &EP3_IN, bool &EP3_OUT, bool &EP4_IN,
        bool &EP4_OUT, bool &EP5_IN, bool &EP5_OUT, bool &EP6_IN,
        bool &EP6_OUT, bool &EP7_IN, bool &EP7_OUT, bool &EP8_IN,
        bool &EP8_OUT, bool &EP9_IN, bool &EP9_OUT, bool &EP10_IN,
        bool &EP10_OUT, bool &EP11_IN, bool &EP11_OUT, bool &EP12_IN,
        bool &EP12_OUT, bool &EP13_IN, bool &EP13_OUT, bool &EP14_IN,
        bool &EP14_OUT, bool &EP15_IN, bool &EP15_OUT) volatile
    {
        uint32_t curr = EP_STATUS_STALL_NAK;

        EP0_IN = curr & (1u << 0u);
        EP0_OUT = curr & (1u << 1u);
        EP1_IN = curr & (1u << 2u);
        EP1_OUT = curr & (1u << 3u);
        EP2_IN = curr & (1u << 4u);
        EP2_OUT = curr & (1u << 5u);
        EP3_IN = curr & (1u << 6u);
        EP3_OUT = curr & (1u << 7u);
        EP4_IN = curr & (1u << 8u);
        EP4_OUT = curr & (1u << 9u);
        EP5_IN = curr & (1u << 10u);
        EP5_OUT = curr & (1u << 11u);
        EP6_IN = curr & (1u << 12u);
        EP6_OUT = curr & (1u << 13u);
        EP7_IN = curr & (1u << 14u);
        EP7_OUT = curr & (1u << 15u);
        EP8_IN = curr & (1u << 16u);
        EP8_OUT = curr & (1u << 17u);
        EP9_IN = curr & (1u << 18u);
        EP9_OUT = curr & (1u << 19u);
        EP10_IN = curr & (1u << 20u);
        EP10_OUT = curr & (1u << 21u);
        EP11_IN = curr & (1u << 22u);
        EP11_OUT = curr & (1u << 23u);
        EP12_IN = curr & (1u << 24u);
        EP12_OUT = curr & (1u << 25u);
        EP13_IN = curr & (1u << 26u);
        EP13_OUT = curr & (1u << 27u);
        EP14_IN = curr & (1u << 28u);
        EP14_OUT = curr & (1u << 29u);
        EP15_IN = curr & (1u << 30u);
        EP15_OUT = curr & (1u << 31u);
    }

    /**
     * Set all of EP_STATUS_STALL_NAK's bit fields.
     *
     * (read-write) Device: bits are set when the `IRQ_ON_NAK` or
     * `IRQ_ON_STALL` bits are set. For EP0 this comes from `SIE_CTRL`. For all
     * other endpoints it comes from the endpoint control register.
     */
    inline void set_EP_STATUS_STALL_NAK(
        bool EP0_IN, bool EP0_OUT, bool EP1_IN, bool EP1_OUT, bool EP2_IN,
        bool EP2_OUT, bool EP3_IN, bool EP3_OUT, bool EP4_IN, bool EP4_OUT,
        bool EP5_IN, bool EP5_OUT, bool EP6_IN, bool EP6_OUT, bool EP7_IN,
        bool EP7_OUT, bool EP8_IN, bool EP8_OUT, bool EP9_IN, bool EP9_OUT,
        bool EP10_IN, bool EP10_OUT, bool EP11_IN, bool EP11_OUT, bool EP12_IN,
        bool EP12_OUT, bool EP13_IN, bool EP13_OUT, bool EP14_IN,
        bool EP14_OUT, bool EP15_IN, bool EP15_OUT) volatile
    {
        uint32_t curr = EP_STATUS_STALL_NAK;

        curr &= ~(0b1u << 0u);
        curr |= (EP0_IN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (EP0_OUT & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (EP1_IN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (EP1_OUT & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (EP2_IN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (EP2_OUT & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (EP3_IN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (EP3_OUT & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (EP4_IN & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (EP4_OUT & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (EP5_IN & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (EP5_OUT & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (EP6_IN & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (EP6_OUT & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (EP7_IN & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (EP7_OUT & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (EP8_IN & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (EP8_OUT & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (EP9_IN & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (EP9_OUT & 0b1u) << 19u;
        curr &= ~(0b1u << 20u);
        curr |= (EP10_IN & 0b1u) << 20u;
        curr &= ~(0b1u << 21u);
        curr |= (EP10_OUT & 0b1u) << 21u;
        curr &= ~(0b1u << 22u);
        curr |= (EP11_IN & 0b1u) << 22u;
        curr &= ~(0b1u << 23u);
        curr |= (EP11_OUT & 0b1u) << 23u;
        curr &= ~(0b1u << 24u);
        curr |= (EP12_IN & 0b1u) << 24u;
        curr &= ~(0b1u << 25u);
        curr |= (EP12_OUT & 0b1u) << 25u;
        curr &= ~(0b1u << 26u);
        curr |= (EP13_IN & 0b1u) << 26u;
        curr &= ~(0b1u << 27u);
        curr |= (EP13_OUT & 0b1u) << 27u;
        curr &= ~(0b1u << 28u);
        curr |= (EP14_IN & 0b1u) << 28u;
        curr &= ~(0b1u << 29u);
        curr |= (EP14_OUT & 0b1u) << 29u;
        curr &= ~(0b1u << 30u);
        curr |= (EP15_IN & 0b1u) << 30u;
        curr &= ~(0b1u << 31u);
        curr |= (EP15_OUT & 0b1u) << 31u;

        EP_STATUS_STALL_NAK = curr;
    }

    /**
     * Get USB_MUXING's TO_PHY bit.
     */
    inline bool get_USB_MUXING_TO_PHY() volatile
    {
        return USB_MUXING & (1u << 0u);
    }

    /**
     * Set USB_MUXING's TO_PHY bit.
     */
    inline void set_USB_MUXING_TO_PHY() volatile
    {
        USB_MUXING |= 1u << 0u;
    }

    /**
     * Clear USB_MUXING's TO_PHY bit.
     */
    inline void clear_USB_MUXING_TO_PHY() volatile
    {
        USB_MUXING &= ~(1u << 0u);
    }

    /**
     * Toggle USB_MUXING's TO_PHY bit.
     */
    inline void toggle_USB_MUXING_TO_PHY() volatile
    {
        USB_MUXING ^= 1u << 0u;
    }

    /**
     * Get USB_MUXING's TO_EXTPHY bit.
     */
    inline bool get_USB_MUXING_TO_EXTPHY() volatile
    {
        return USB_MUXING & (1u << 1u);
    }

    /**
     * Set USB_MUXING's TO_EXTPHY bit.
     */
    inline void set_USB_MUXING_TO_EXTPHY() volatile
    {
        USB_MUXING |= 1u << 1u;
    }

    /**
     * Clear USB_MUXING's TO_EXTPHY bit.
     */
    inline void clear_USB_MUXING_TO_EXTPHY() volatile
    {
        USB_MUXING &= ~(1u << 1u);
    }

    /**
     * Toggle USB_MUXING's TO_EXTPHY bit.
     */
    inline void toggle_USB_MUXING_TO_EXTPHY() volatile
    {
        USB_MUXING ^= 1u << 1u;
    }

    /**
     * Get USB_MUXING's TO_DIGITAL_PAD bit.
     */
    inline bool get_USB_MUXING_TO_DIGITAL_PAD() volatile
    {
        return USB_MUXING & (1u << 2u);
    }

    /**
     * Set USB_MUXING's TO_DIGITAL_PAD bit.
     */
    inline void set_USB_MUXING_TO_DIGITAL_PAD() volatile
    {
        USB_MUXING |= 1u << 2u;
    }

    /**
     * Clear USB_MUXING's TO_DIGITAL_PAD bit.
     */
    inline void clear_USB_MUXING_TO_DIGITAL_PAD() volatile
    {
        USB_MUXING &= ~(1u << 2u);
    }

    /**
     * Toggle USB_MUXING's TO_DIGITAL_PAD bit.
     */
    inline void toggle_USB_MUXING_TO_DIGITAL_PAD() volatile
    {
        USB_MUXING ^= 1u << 2u;
    }

    /**
     * Get USB_MUXING's SOFTCON bit.
     */
    inline bool get_USB_MUXING_SOFTCON() volatile
    {
        return USB_MUXING & (1u << 3u);
    }

    /**
     * Set USB_MUXING's SOFTCON bit.
     */
    inline void set_USB_MUXING_SOFTCON() volatile
    {
        USB_MUXING |= 1u << 3u;
    }

    /**
     * Clear USB_MUXING's SOFTCON bit.
     */
    inline void clear_USB_MUXING_SOFTCON() volatile
    {
        USB_MUXING &= ~(1u << 3u);
    }

    /**
     * Toggle USB_MUXING's SOFTCON bit.
     */
    inline void toggle_USB_MUXING_SOFTCON() volatile
    {
        USB_MUXING ^= 1u << 3u;
    }

    /**
     * Get all of USB_MUXING's bit fields.
     *
     * (read-write) Where to connect the USB controller. Should be to_phy by
     * default.
     */
    inline void get_USB_MUXING(bool &TO_PHY, bool &TO_EXTPHY,
                               bool &TO_DIGITAL_PAD, bool &SOFTCON) volatile
    {
        uint32_t curr = USB_MUXING;

        TO_PHY = curr & (1u << 0u);
        TO_EXTPHY = curr & (1u << 1u);
        TO_DIGITAL_PAD = curr & (1u << 2u);
        SOFTCON = curr & (1u << 3u);
    }

    /**
     * Set all of USB_MUXING's bit fields.
     *
     * (read-write) Where to connect the USB controller. Should be to_phy by
     * default.
     */
    inline void set_USB_MUXING(bool TO_PHY, bool TO_EXTPHY,
                               bool TO_DIGITAL_PAD, bool SOFTCON) volatile
    {
        uint32_t curr = USB_MUXING;

        curr &= ~(0b1u << 0u);
        curr |= (TO_PHY & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (TO_EXTPHY & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (TO_DIGITAL_PAD & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (SOFTCON & 0b1u) << 3u;

        USB_MUXING = curr;
    }

    /**
     * Get USB_PWR's VBUS_EN bit.
     */
    inline bool get_USB_PWR_VBUS_EN() volatile
    {
        return USB_PWR & (1u << 0u);
    }

    /**
     * Set USB_PWR's VBUS_EN bit.
     */
    inline void set_USB_PWR_VBUS_EN() volatile
    {
        USB_PWR |= 1u << 0u;
    }

    /**
     * Clear USB_PWR's VBUS_EN bit.
     */
    inline void clear_USB_PWR_VBUS_EN() volatile
    {
        USB_PWR &= ~(1u << 0u);
    }

    /**
     * Toggle USB_PWR's VBUS_EN bit.
     */
    inline void toggle_USB_PWR_VBUS_EN() volatile
    {
        USB_PWR ^= 1u << 0u;
    }

    /**
     * Get USB_PWR's VBUS_EN_OVERRIDE_EN bit.
     */
    inline bool get_USB_PWR_VBUS_EN_OVERRIDE_EN() volatile
    {
        return USB_PWR & (1u << 1u);
    }

    /**
     * Set USB_PWR's VBUS_EN_OVERRIDE_EN bit.
     */
    inline void set_USB_PWR_VBUS_EN_OVERRIDE_EN() volatile
    {
        USB_PWR |= 1u << 1u;
    }

    /**
     * Clear USB_PWR's VBUS_EN_OVERRIDE_EN bit.
     */
    inline void clear_USB_PWR_VBUS_EN_OVERRIDE_EN() volatile
    {
        USB_PWR &= ~(1u << 1u);
    }

    /**
     * Toggle USB_PWR's VBUS_EN_OVERRIDE_EN bit.
     */
    inline void toggle_USB_PWR_VBUS_EN_OVERRIDE_EN() volatile
    {
        USB_PWR ^= 1u << 1u;
    }

    /**
     * Get USB_PWR's VBUS_DETECT bit.
     */
    inline bool get_USB_PWR_VBUS_DETECT() volatile
    {
        return USB_PWR & (1u << 2u);
    }

    /**
     * Set USB_PWR's VBUS_DETECT bit.
     */
    inline void set_USB_PWR_VBUS_DETECT() volatile
    {
        USB_PWR |= 1u << 2u;
    }

    /**
     * Clear USB_PWR's VBUS_DETECT bit.
     */
    inline void clear_USB_PWR_VBUS_DETECT() volatile
    {
        USB_PWR &= ~(1u << 2u);
    }

    /**
     * Toggle USB_PWR's VBUS_DETECT bit.
     */
    inline void toggle_USB_PWR_VBUS_DETECT() volatile
    {
        USB_PWR ^= 1u << 2u;
    }

    /**
     * Get USB_PWR's VBUS_DETECT_OVERRIDE_EN bit.
     */
    inline bool get_USB_PWR_VBUS_DETECT_OVERRIDE_EN() volatile
    {
        return USB_PWR & (1u << 3u);
    }

    /**
     * Set USB_PWR's VBUS_DETECT_OVERRIDE_EN bit.
     */
    inline void set_USB_PWR_VBUS_DETECT_OVERRIDE_EN() volatile
    {
        USB_PWR |= 1u << 3u;
    }

    /**
     * Clear USB_PWR's VBUS_DETECT_OVERRIDE_EN bit.
     */
    inline void clear_USB_PWR_VBUS_DETECT_OVERRIDE_EN() volatile
    {
        USB_PWR &= ~(1u << 3u);
    }

    /**
     * Toggle USB_PWR's VBUS_DETECT_OVERRIDE_EN bit.
     */
    inline void toggle_USB_PWR_VBUS_DETECT_OVERRIDE_EN() volatile
    {
        USB_PWR ^= 1u << 3u;
    }

    /**
     * Get USB_PWR's OVERCURR_DETECT bit.
     */
    inline bool get_USB_PWR_OVERCURR_DETECT() volatile
    {
        return USB_PWR & (1u << 4u);
    }

    /**
     * Set USB_PWR's OVERCURR_DETECT bit.
     */
    inline void set_USB_PWR_OVERCURR_DETECT() volatile
    {
        USB_PWR |= 1u << 4u;
    }

    /**
     * Clear USB_PWR's OVERCURR_DETECT bit.
     */
    inline void clear_USB_PWR_OVERCURR_DETECT() volatile
    {
        USB_PWR &= ~(1u << 4u);
    }

    /**
     * Toggle USB_PWR's OVERCURR_DETECT bit.
     */
    inline void toggle_USB_PWR_OVERCURR_DETECT() volatile
    {
        USB_PWR ^= 1u << 4u;
    }

    /**
     * Get USB_PWR's OVERCURR_DETECT_EN bit.
     */
    inline bool get_USB_PWR_OVERCURR_DETECT_EN() volatile
    {
        return USB_PWR & (1u << 5u);
    }

    /**
     * Set USB_PWR's OVERCURR_DETECT_EN bit.
     */
    inline void set_USB_PWR_OVERCURR_DETECT_EN() volatile
    {
        USB_PWR |= 1u << 5u;
    }

    /**
     * Clear USB_PWR's OVERCURR_DETECT_EN bit.
     */
    inline void clear_USB_PWR_OVERCURR_DETECT_EN() volatile
    {
        USB_PWR &= ~(1u << 5u);
    }

    /**
     * Toggle USB_PWR's OVERCURR_DETECT_EN bit.
     */
    inline void toggle_USB_PWR_OVERCURR_DETECT_EN() volatile
    {
        USB_PWR ^= 1u << 5u;
    }

    /**
     * Get all of USB_PWR's bit fields.
     *
     * (read-write) Overrides for the power signals in the event that the VBUS
     * signals are not hooked up to GPIO. Set the value of the override and
     * then the override enable to switch over to the override value.
     */
    inline void get_USB_PWR(bool &VBUS_EN, bool &VBUS_EN_OVERRIDE_EN,
                            bool &VBUS_DETECT, bool &VBUS_DETECT_OVERRIDE_EN,
                            bool &OVERCURR_DETECT,
                            bool &OVERCURR_DETECT_EN) volatile
    {
        uint32_t curr = USB_PWR;

        VBUS_EN = curr & (1u << 0u);
        VBUS_EN_OVERRIDE_EN = curr & (1u << 1u);
        VBUS_DETECT = curr & (1u << 2u);
        VBUS_DETECT_OVERRIDE_EN = curr & (1u << 3u);
        OVERCURR_DETECT = curr & (1u << 4u);
        OVERCURR_DETECT_EN = curr & (1u << 5u);
    }

    /**
     * Set all of USB_PWR's bit fields.
     *
     * (read-write) Overrides for the power signals in the event that the VBUS
     * signals are not hooked up to GPIO. Set the value of the override and
     * then the override enable to switch over to the override value.
     */
    inline void set_USB_PWR(bool VBUS_EN, bool VBUS_EN_OVERRIDE_EN,
                            bool VBUS_DETECT, bool VBUS_DETECT_OVERRIDE_EN,
                            bool OVERCURR_DETECT,
                            bool OVERCURR_DETECT_EN) volatile
    {
        uint32_t curr = USB_PWR;

        curr &= ~(0b1u << 0u);
        curr |= (VBUS_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (VBUS_EN_OVERRIDE_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (VBUS_DETECT & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (VBUS_DETECT_OVERRIDE_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (OVERCURR_DETECT & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (OVERCURR_DETECT_EN & 0b1u) << 5u;

        USB_PWR = curr;
    }

    /**
     * Get USBPHY_DIRECT's DP_PULLUP_HISEL bit.
     *
     * Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline bool get_USBPHY_DIRECT_DP_PULLUP_HISEL() volatile
    {
        return USBPHY_DIRECT & (1u << 0u);
    }

    /**
     * Set USBPHY_DIRECT's DP_PULLUP_HISEL bit.
     *
     * Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline void set_USBPHY_DIRECT_DP_PULLUP_HISEL() volatile
    {
        USBPHY_DIRECT |= 1u << 0u;
    }

    /**
     * Clear USBPHY_DIRECT's DP_PULLUP_HISEL bit.
     *
     * Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline void clear_USBPHY_DIRECT_DP_PULLUP_HISEL() volatile
    {
        USBPHY_DIRECT &= ~(1u << 0u);
    }

    /**
     * Toggle USBPHY_DIRECT's DP_PULLUP_HISEL bit.
     *
     * Enable the second DP pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline void toggle_USBPHY_DIRECT_DP_PULLUP_HISEL() volatile
    {
        USBPHY_DIRECT ^= 1u << 0u;
    }

    /**
     * Get USBPHY_DIRECT's DP_PULLUP_EN bit.
     *
     * DP pull up enable
     */
    inline bool get_USBPHY_DIRECT_DP_PULLUP_EN() volatile
    {
        return USBPHY_DIRECT & (1u << 1u);
    }

    /**
     * Set USBPHY_DIRECT's DP_PULLUP_EN bit.
     *
     * DP pull up enable
     */
    inline void set_USBPHY_DIRECT_DP_PULLUP_EN() volatile
    {
        USBPHY_DIRECT |= 1u << 1u;
    }

    /**
     * Clear USBPHY_DIRECT's DP_PULLUP_EN bit.
     *
     * DP pull up enable
     */
    inline void clear_USBPHY_DIRECT_DP_PULLUP_EN() volatile
    {
        USBPHY_DIRECT &= ~(1u << 1u);
    }

    /**
     * Toggle USBPHY_DIRECT's DP_PULLUP_EN bit.
     *
     * DP pull up enable
     */
    inline void toggle_USBPHY_DIRECT_DP_PULLUP_EN() volatile
    {
        USBPHY_DIRECT ^= 1u << 1u;
    }

    /**
     * Get USBPHY_DIRECT's DP_PULLDN_EN bit.
     *
     * DP pull down enable
     */
    inline bool get_USBPHY_DIRECT_DP_PULLDN_EN() volatile
    {
        return USBPHY_DIRECT & (1u << 2u);
    }

    /**
     * Set USBPHY_DIRECT's DP_PULLDN_EN bit.
     *
     * DP pull down enable
     */
    inline void set_USBPHY_DIRECT_DP_PULLDN_EN() volatile
    {
        USBPHY_DIRECT |= 1u << 2u;
    }

    /**
     * Clear USBPHY_DIRECT's DP_PULLDN_EN bit.
     *
     * DP pull down enable
     */
    inline void clear_USBPHY_DIRECT_DP_PULLDN_EN() volatile
    {
        USBPHY_DIRECT &= ~(1u << 2u);
    }

    /**
     * Toggle USBPHY_DIRECT's DP_PULLDN_EN bit.
     *
     * DP pull down enable
     */
    inline void toggle_USBPHY_DIRECT_DP_PULLDN_EN() volatile
    {
        USBPHY_DIRECT ^= 1u << 2u;
    }

    /**
     * Get USBPHY_DIRECT's DM_PULLUP_HISEL bit.
     *
     * Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline bool get_USBPHY_DIRECT_DM_PULLUP_HISEL() volatile
    {
        return USBPHY_DIRECT & (1u << 4u);
    }

    /**
     * Set USBPHY_DIRECT's DM_PULLUP_HISEL bit.
     *
     * Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline void set_USBPHY_DIRECT_DM_PULLUP_HISEL() volatile
    {
        USBPHY_DIRECT |= 1u << 4u;
    }

    /**
     * Clear USBPHY_DIRECT's DM_PULLUP_HISEL bit.
     *
     * Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline void clear_USBPHY_DIRECT_DM_PULLUP_HISEL() volatile
    {
        USBPHY_DIRECT &= ~(1u << 4u);
    }

    /**
     * Toggle USBPHY_DIRECT's DM_PULLUP_HISEL bit.
     *
     * Enable the second DM pull up resistor. 0 - Pull = Rpu2; 1 - Pull = Rpu1
     * + Rpu2
     */
    inline void toggle_USBPHY_DIRECT_DM_PULLUP_HISEL() volatile
    {
        USBPHY_DIRECT ^= 1u << 4u;
    }

    /**
     * Get USBPHY_DIRECT's DM_PULLUP_EN bit.
     *
     * DM pull up enable
     */
    inline bool get_USBPHY_DIRECT_DM_PULLUP_EN() volatile
    {
        return USBPHY_DIRECT & (1u << 5u);
    }

    /**
     * Set USBPHY_DIRECT's DM_PULLUP_EN bit.
     *
     * DM pull up enable
     */
    inline void set_USBPHY_DIRECT_DM_PULLUP_EN() volatile
    {
        USBPHY_DIRECT |= 1u << 5u;
    }

    /**
     * Clear USBPHY_DIRECT's DM_PULLUP_EN bit.
     *
     * DM pull up enable
     */
    inline void clear_USBPHY_DIRECT_DM_PULLUP_EN() volatile
    {
        USBPHY_DIRECT &= ~(1u << 5u);
    }

    /**
     * Toggle USBPHY_DIRECT's DM_PULLUP_EN bit.
     *
     * DM pull up enable
     */
    inline void toggle_USBPHY_DIRECT_DM_PULLUP_EN() volatile
    {
        USBPHY_DIRECT ^= 1u << 5u;
    }

    /**
     * Get USBPHY_DIRECT's DM_PULLDN_EN bit.
     *
     * DM pull down enable
     */
    inline bool get_USBPHY_DIRECT_DM_PULLDN_EN() volatile
    {
        return USBPHY_DIRECT & (1u << 6u);
    }

    /**
     * Set USBPHY_DIRECT's DM_PULLDN_EN bit.
     *
     * DM pull down enable
     */
    inline void set_USBPHY_DIRECT_DM_PULLDN_EN() volatile
    {
        USBPHY_DIRECT |= 1u << 6u;
    }

    /**
     * Clear USBPHY_DIRECT's DM_PULLDN_EN bit.
     *
     * DM pull down enable
     */
    inline void clear_USBPHY_DIRECT_DM_PULLDN_EN() volatile
    {
        USBPHY_DIRECT &= ~(1u << 6u);
    }

    /**
     * Toggle USBPHY_DIRECT's DM_PULLDN_EN bit.
     *
     * DM pull down enable
     */
    inline void toggle_USBPHY_DIRECT_DM_PULLDN_EN() volatile
    {
        USBPHY_DIRECT ^= 1u << 6u;
    }

    /**
     * Get USBPHY_DIRECT's TX_DP_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM
     * in Hi-Z state; 1 - DPP/DPM driving\n If TX_DIFFMODE=0, OE for DPP only.
     * 0 - DPP in Hi-Z state; 1 - DPP driving
     */
    inline bool get_USBPHY_DIRECT_TX_DP_OE() volatile
    {
        return USBPHY_DIRECT & (1u << 8u);
    }

    /**
     * Set USBPHY_DIRECT's TX_DP_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM
     * in Hi-Z state; 1 - DPP/DPM driving\n If TX_DIFFMODE=0, OE for DPP only.
     * 0 - DPP in Hi-Z state; 1 - DPP driving
     */
    inline void set_USBPHY_DIRECT_TX_DP_OE() volatile
    {
        USBPHY_DIRECT |= 1u << 8u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_DP_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM
     * in Hi-Z state; 1 - DPP/DPM driving\n If TX_DIFFMODE=0, OE for DPP only.
     * 0 - DPP in Hi-Z state; 1 - DPP driving
     */
    inline void clear_USBPHY_DIRECT_TX_DP_OE() volatile
    {
        USBPHY_DIRECT &= ~(1u << 8u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_DP_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff pair. 0 - DPP/DPM
     * in Hi-Z state; 1 - DPP/DPM driving\n If TX_DIFFMODE=0, OE for DPP only.
     * 0 - DPP in Hi-Z state; 1 - DPP driving
     */
    inline void toggle_USBPHY_DIRECT_TX_DP_OE() volatile
    {
        USBPHY_DIRECT ^= 1u << 8u;
    }

    /**
     * Get USBPHY_DIRECT's TX_DM_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, Ignored.\n
     *                 If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z
     * state; 1 - DPM driving
     */
    inline bool get_USBPHY_DIRECT_TX_DM_OE() volatile
    {
        return USBPHY_DIRECT & (1u << 9u);
    }

    /**
     * Set USBPHY_DIRECT's TX_DM_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, Ignored.\n
     *                 If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z
     * state; 1 - DPM driving
     */
    inline void set_USBPHY_DIRECT_TX_DM_OE() volatile
    {
        USBPHY_DIRECT |= 1u << 9u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_DM_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, Ignored.\n
     *                 If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z
     * state; 1 - DPM driving
     */
    inline void clear_USBPHY_DIRECT_TX_DM_OE() volatile
    {
        USBPHY_DIRECT &= ~(1u << 9u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_DM_OE bit.
     *
     * Output enable. If TX_DIFFMODE=1, Ignored.\n
     *                 If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z
     * state; 1 - DPM driving
     */
    inline void toggle_USBPHY_DIRECT_TX_DM_OE() volatile
    {
        USBPHY_DIRECT ^= 1u << 9u;
    }

    /**
     * Get USBPHY_DIRECT's TX_DP bit.
     *
     * Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to
     * enable drive. DPP=TX_DP, DPM=~TX_DP\n If TX_DIFFMODE=0, Drives DPP only.
     * TX_DP_OE=1 to enable drive. DPP=TX_DP
     */
    inline bool get_USBPHY_DIRECT_TX_DP() volatile
    {
        return USBPHY_DIRECT & (1u << 10u);
    }

    /**
     * Set USBPHY_DIRECT's TX_DP bit.
     *
     * Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to
     * enable drive. DPP=TX_DP, DPM=~TX_DP\n If TX_DIFFMODE=0, Drives DPP only.
     * TX_DP_OE=1 to enable drive. DPP=TX_DP
     */
    inline void set_USBPHY_DIRECT_TX_DP() volatile
    {
        USBPHY_DIRECT |= 1u << 10u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_DP bit.
     *
     * Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to
     * enable drive. DPP=TX_DP, DPM=~TX_DP\n If TX_DIFFMODE=0, Drives DPP only.
     * TX_DP_OE=1 to enable drive. DPP=TX_DP
     */
    inline void clear_USBPHY_DIRECT_TX_DP() volatile
    {
        USBPHY_DIRECT &= ~(1u << 10u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_DP bit.
     *
     * Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff pair. TX_DP_OE=1 to
     * enable drive. DPP=TX_DP, DPM=~TX_DP\n If TX_DIFFMODE=0, Drives DPP only.
     * TX_DP_OE=1 to enable drive. DPP=TX_DP
     */
    inline void toggle_USBPHY_DIRECT_TX_DP() volatile
    {
        USBPHY_DIRECT ^= 1u << 10u;
    }

    /**
     * Get USBPHY_DIRECT's TX_DM bit.
     *
     * Output data. TX_DIFFMODE=1, Ignored\n
     *                 TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable
     * drive. DPM=TX_DM
     */
    inline bool get_USBPHY_DIRECT_TX_DM() volatile
    {
        return USBPHY_DIRECT & (1u << 11u);
    }

    /**
     * Set USBPHY_DIRECT's TX_DM bit.
     *
     * Output data. TX_DIFFMODE=1, Ignored\n
     *                 TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable
     * drive. DPM=TX_DM
     */
    inline void set_USBPHY_DIRECT_TX_DM() volatile
    {
        USBPHY_DIRECT |= 1u << 11u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_DM bit.
     *
     * Output data. TX_DIFFMODE=1, Ignored\n
     *                 TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable
     * drive. DPM=TX_DM
     */
    inline void clear_USBPHY_DIRECT_TX_DM() volatile
    {
        USBPHY_DIRECT &= ~(1u << 11u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_DM bit.
     *
     * Output data. TX_DIFFMODE=1, Ignored\n
     *                 TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable
     * drive. DPM=TX_DM
     */
    inline void toggle_USBPHY_DIRECT_TX_DM() volatile
    {
        USBPHY_DIRECT ^= 1u << 11u;
    }

    /**
     * Get USBPHY_DIRECT's RX_PD bit.
     *
     * RX power down override (if override enable is set). 1 = powered down.
     */
    inline bool get_USBPHY_DIRECT_RX_PD() volatile
    {
        return USBPHY_DIRECT & (1u << 12u);
    }

    /**
     * Set USBPHY_DIRECT's RX_PD bit.
     *
     * RX power down override (if override enable is set). 1 = powered down.
     */
    inline void set_USBPHY_DIRECT_RX_PD() volatile
    {
        USBPHY_DIRECT |= 1u << 12u;
    }

    /**
     * Clear USBPHY_DIRECT's RX_PD bit.
     *
     * RX power down override (if override enable is set). 1 = powered down.
     */
    inline void clear_USBPHY_DIRECT_RX_PD() volatile
    {
        USBPHY_DIRECT &= ~(1u << 12u);
    }

    /**
     * Toggle USBPHY_DIRECT's RX_PD bit.
     *
     * RX power down override (if override enable is set). 1 = powered down.
     */
    inline void toggle_USBPHY_DIRECT_RX_PD() volatile
    {
        USBPHY_DIRECT ^= 1u << 12u;
    }

    /**
     * Get USBPHY_DIRECT's TX_PD bit.
     *
     * TX power down override (if override enable is set). 1 = powered down.
     */
    inline bool get_USBPHY_DIRECT_TX_PD() volatile
    {
        return USBPHY_DIRECT & (1u << 13u);
    }

    /**
     * Set USBPHY_DIRECT's TX_PD bit.
     *
     * TX power down override (if override enable is set). 1 = powered down.
     */
    inline void set_USBPHY_DIRECT_TX_PD() volatile
    {
        USBPHY_DIRECT |= 1u << 13u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_PD bit.
     *
     * TX power down override (if override enable is set). 1 = powered down.
     */
    inline void clear_USBPHY_DIRECT_TX_PD() volatile
    {
        USBPHY_DIRECT &= ~(1u << 13u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_PD bit.
     *
     * TX power down override (if override enable is set). 1 = powered down.
     */
    inline void toggle_USBPHY_DIRECT_TX_PD() volatile
    {
        USBPHY_DIRECT ^= 1u << 13u;
    }

    /**
     * Get USBPHY_DIRECT's TX_FSSLEW bit.
     *
     * TX_FSSLEW=0: Low speed slew rate\n
     *                 TX_FSSLEW=1: Full speed slew rate
     */
    inline bool get_USBPHY_DIRECT_TX_FSSLEW() volatile
    {
        return USBPHY_DIRECT & (1u << 14u);
    }

    /**
     * Set USBPHY_DIRECT's TX_FSSLEW bit.
     *
     * TX_FSSLEW=0: Low speed slew rate\n
     *                 TX_FSSLEW=1: Full speed slew rate
     */
    inline void set_USBPHY_DIRECT_TX_FSSLEW() volatile
    {
        USBPHY_DIRECT |= 1u << 14u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_FSSLEW bit.
     *
     * TX_FSSLEW=0: Low speed slew rate\n
     *                 TX_FSSLEW=1: Full speed slew rate
     */
    inline void clear_USBPHY_DIRECT_TX_FSSLEW() volatile
    {
        USBPHY_DIRECT &= ~(1u << 14u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_FSSLEW bit.
     *
     * TX_FSSLEW=0: Low speed slew rate\n
     *                 TX_FSSLEW=1: Full speed slew rate
     */
    inline void toggle_USBPHY_DIRECT_TX_FSSLEW() volatile
    {
        USBPHY_DIRECT ^= 1u << 14u;
    }

    /**
     * Get USBPHY_DIRECT's TX_DIFFMODE bit.
     *
     * TX_DIFFMODE=0: Single ended mode\n
     *                 TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE
     * ignored)
     */
    inline bool get_USBPHY_DIRECT_TX_DIFFMODE() volatile
    {
        return USBPHY_DIRECT & (1u << 15u);
    }

    /**
     * Set USBPHY_DIRECT's TX_DIFFMODE bit.
     *
     * TX_DIFFMODE=0: Single ended mode\n
     *                 TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE
     * ignored)
     */
    inline void set_USBPHY_DIRECT_TX_DIFFMODE() volatile
    {
        USBPHY_DIRECT |= 1u << 15u;
    }

    /**
     * Clear USBPHY_DIRECT's TX_DIFFMODE bit.
     *
     * TX_DIFFMODE=0: Single ended mode\n
     *                 TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE
     * ignored)
     */
    inline void clear_USBPHY_DIRECT_TX_DIFFMODE() volatile
    {
        USBPHY_DIRECT &= ~(1u << 15u);
    }

    /**
     * Toggle USBPHY_DIRECT's TX_DIFFMODE bit.
     *
     * TX_DIFFMODE=0: Single ended mode\n
     *                 TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE
     * ignored)
     */
    inline void toggle_USBPHY_DIRECT_TX_DIFFMODE() volatile
    {
        USBPHY_DIRECT ^= 1u << 15u;
    }

    /**
     * Get USBPHY_DIRECT's RX_DD bit.
     *
     * Differential RX
     */
    inline bool get_USBPHY_DIRECT_RX_DD() volatile
    {
        return USBPHY_DIRECT & (1u << 16u);
    }

    /**
     * Get USBPHY_DIRECT's RX_DP bit.
     *
     * DPP pin state
     */
    inline bool get_USBPHY_DIRECT_RX_DP() volatile
    {
        return USBPHY_DIRECT & (1u << 17u);
    }

    /**
     * Get USBPHY_DIRECT's RX_DM bit.
     *
     * DPM pin state
     */
    inline bool get_USBPHY_DIRECT_RX_DM() volatile
    {
        return USBPHY_DIRECT & (1u << 18u);
    }

    /**
     * Get USBPHY_DIRECT's DP_OVCN bit.
     *
     * DP overcurrent
     */
    inline bool get_USBPHY_DIRECT_DP_OVCN() volatile
    {
        return USBPHY_DIRECT & (1u << 19u);
    }

    /**
     * Get USBPHY_DIRECT's DM_OVCN bit.
     *
     * DM overcurrent
     */
    inline bool get_USBPHY_DIRECT_DM_OVCN() volatile
    {
        return USBPHY_DIRECT & (1u << 20u);
    }

    /**
     * Get USBPHY_DIRECT's DP_OVV bit.
     *
     * DP over voltage
     */
    inline bool get_USBPHY_DIRECT_DP_OVV() volatile
    {
        return USBPHY_DIRECT & (1u << 21u);
    }

    /**
     * Get USBPHY_DIRECT's DM_OVV bit.
     *
     * DM over voltage
     */
    inline bool get_USBPHY_DIRECT_DM_OVV() volatile
    {
        return USBPHY_DIRECT & (1u << 22u);
    }

    /**
     * Get all of USBPHY_DIRECT's bit fields.
     *
     * (read-write) This register allows for direct control of the USB phy. Use
     * in conjunction with usbphy_direct_override register to enable each
     * override bit.
     */
    inline void get_USBPHY_DIRECT(bool &DP_PULLUP_HISEL, bool &DP_PULLUP_EN,
                                  bool &DP_PULLDN_EN, bool &DM_PULLUP_HISEL,
                                  bool &DM_PULLUP_EN, bool &DM_PULLDN_EN,
                                  bool &TX_DP_OE, bool &TX_DM_OE, bool &TX_DP,
                                  bool &TX_DM, bool &RX_PD, bool &TX_PD,
                                  bool &TX_FSSLEW, bool &TX_DIFFMODE,
                                  bool &RX_DD, bool &RX_DP, bool &RX_DM,
                                  bool &DP_OVCN, bool &DM_OVCN, bool &DP_OVV,
                                  bool &DM_OVV) volatile
    {
        uint32_t curr = USBPHY_DIRECT;

        DP_PULLUP_HISEL = curr & (1u << 0u);
        DP_PULLUP_EN = curr & (1u << 1u);
        DP_PULLDN_EN = curr & (1u << 2u);
        DM_PULLUP_HISEL = curr & (1u << 4u);
        DM_PULLUP_EN = curr & (1u << 5u);
        DM_PULLDN_EN = curr & (1u << 6u);
        TX_DP_OE = curr & (1u << 8u);
        TX_DM_OE = curr & (1u << 9u);
        TX_DP = curr & (1u << 10u);
        TX_DM = curr & (1u << 11u);
        RX_PD = curr & (1u << 12u);
        TX_PD = curr & (1u << 13u);
        TX_FSSLEW = curr & (1u << 14u);
        TX_DIFFMODE = curr & (1u << 15u);
        RX_DD = curr & (1u << 16u);
        RX_DP = curr & (1u << 17u);
        RX_DM = curr & (1u << 18u);
        DP_OVCN = curr & (1u << 19u);
        DM_OVCN = curr & (1u << 20u);
        DP_OVV = curr & (1u << 21u);
        DM_OVV = curr & (1u << 22u);
    }

    /**
     * Set all of USBPHY_DIRECT's bit fields.
     *
     * (read-write) This register allows for direct control of the USB phy. Use
     * in conjunction with usbphy_direct_override register to enable each
     * override bit.
     */
    inline void set_USBPHY_DIRECT(bool DP_PULLUP_HISEL, bool DP_PULLUP_EN,
                                  bool DP_PULLDN_EN, bool DM_PULLUP_HISEL,
                                  bool DM_PULLUP_EN, bool DM_PULLDN_EN,
                                  bool TX_DP_OE, bool TX_DM_OE, bool TX_DP,
                                  bool TX_DM, bool RX_PD, bool TX_PD,
                                  bool TX_FSSLEW, bool TX_DIFFMODE) volatile
    {
        uint32_t curr = USBPHY_DIRECT;

        curr &= ~(0b1u << 0u);
        curr |= (DP_PULLUP_HISEL & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (DP_PULLUP_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (DP_PULLDN_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 4u);
        curr |= (DM_PULLUP_HISEL & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (DM_PULLUP_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (DM_PULLDN_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 8u);
        curr |= (TX_DP_OE & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (TX_DM_OE & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (TX_DP & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (TX_DM & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (RX_PD & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (TX_PD & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (TX_FSSLEW & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (TX_DIFFMODE & 0b1u) << 15u;

        USBPHY_DIRECT = curr;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's DP_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline bool
    get_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 0u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's DP_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline void
    set_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 0u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's DP_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline void
    clear_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 0u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's DP_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline void
    toggle_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 0u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's DM_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline bool
    get_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 1u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's DM_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline void
    set_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 1u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's DM_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline void
    clear_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 1u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's DM_PULLUP_HISEL_OVERRIDE_EN bit.
     */
    inline void
    toggle_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 1u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's DP_PULLUP_EN_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 2u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's DP_PULLUP_EN_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 2u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's DP_PULLUP_EN_OVERRIDE_EN bit.
     */
    inline void
    clear_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 2u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's DP_PULLUP_EN_OVERRIDE_EN bit.
     */
    inline void
    toggle_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 2u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's DP_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 3u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's DP_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 3u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's DP_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline void
    clear_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 3u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's DP_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline void
    toggle_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 3u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's DM_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 4u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's DM_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 4u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's DM_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline void
    clear_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 4u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's DM_PULLDN_EN_OVERRIDE_EN bit.
     */
    inline void
    toggle_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 4u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_DP_OE_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 5u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_DP_OE_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 5u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_DP_OE_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 5u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_DP_OE_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 5u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_DM_OE_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 6u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_DM_OE_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 6u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_DM_OE_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 6u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_DM_OE_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 6u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_DP_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 7u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_DP_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 7u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_DP_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 7u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_DP_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 7u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_DM_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 8u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_DM_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 8u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_DM_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 8u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_DM_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 8u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's RX_PD_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 9u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's RX_PD_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 9u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's RX_PD_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 9u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's RX_PD_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 9u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_PD_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 10u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_PD_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 10u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_PD_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 10u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_PD_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 10u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_FSSLEW_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 11u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_FSSLEW_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 11u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_FSSLEW_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 11u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_FSSLEW_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 11u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's DM_PULLUP_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 12u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's DM_PULLUP_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 12u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's DM_PULLUP_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 12u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's DM_PULLUP_OVERRIDE_EN bit.
     */
    inline void toggle_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 12u;
    }

    /**
     * Get USBPHY_DIRECT_OVERRIDE's TX_DIFFMODE_OVERRIDE_EN bit.
     */
    inline bool get_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN() volatile
    {
        return USBPHY_DIRECT_OVERRIDE & (1u << 15u);
    }

    /**
     * Set USBPHY_DIRECT_OVERRIDE's TX_DIFFMODE_OVERRIDE_EN bit.
     */
    inline void set_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE |= 1u << 15u;
    }

    /**
     * Clear USBPHY_DIRECT_OVERRIDE's TX_DIFFMODE_OVERRIDE_EN bit.
     */
    inline void clear_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE &= ~(1u << 15u);
    }

    /**
     * Toggle USBPHY_DIRECT_OVERRIDE's TX_DIFFMODE_OVERRIDE_EN bit.
     */
    inline void
    toggle_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN() volatile
    {
        USBPHY_DIRECT_OVERRIDE ^= 1u << 15u;
    }

    /**
     * Get all of USBPHY_DIRECT_OVERRIDE's bit fields.
     *
     * (read-write) Override enable for each control in usbphy_direct
     */
    inline void get_USBPHY_DIRECT_OVERRIDE(
        bool &DP_PULLUP_HISEL_OVERRIDE_EN, bool &DM_PULLUP_HISEL_OVERRIDE_EN,
        bool &DP_PULLUP_EN_OVERRIDE_EN, bool &DP_PULLDN_EN_OVERRIDE_EN,
        bool &DM_PULLDN_EN_OVERRIDE_EN, bool &TX_DP_OE_OVERRIDE_EN,
        bool &TX_DM_OE_OVERRIDE_EN, bool &TX_DP_OVERRIDE_EN,
        bool &TX_DM_OVERRIDE_EN, bool &RX_PD_OVERRIDE_EN,
        bool &TX_PD_OVERRIDE_EN, bool &TX_FSSLEW_OVERRIDE_EN,
        bool &DM_PULLUP_OVERRIDE_EN, bool &TX_DIFFMODE_OVERRIDE_EN) volatile
    {
        uint32_t curr = USBPHY_DIRECT_OVERRIDE;

        DP_PULLUP_HISEL_OVERRIDE_EN = curr & (1u << 0u);
        DM_PULLUP_HISEL_OVERRIDE_EN = curr & (1u << 1u);
        DP_PULLUP_EN_OVERRIDE_EN = curr & (1u << 2u);
        DP_PULLDN_EN_OVERRIDE_EN = curr & (1u << 3u);
        DM_PULLDN_EN_OVERRIDE_EN = curr & (1u << 4u);
        TX_DP_OE_OVERRIDE_EN = curr & (1u << 5u);
        TX_DM_OE_OVERRIDE_EN = curr & (1u << 6u);
        TX_DP_OVERRIDE_EN = curr & (1u << 7u);
        TX_DM_OVERRIDE_EN = curr & (1u << 8u);
        RX_PD_OVERRIDE_EN = curr & (1u << 9u);
        TX_PD_OVERRIDE_EN = curr & (1u << 10u);
        TX_FSSLEW_OVERRIDE_EN = curr & (1u << 11u);
        DM_PULLUP_OVERRIDE_EN = curr & (1u << 12u);
        TX_DIFFMODE_OVERRIDE_EN = curr & (1u << 15u);
    }

    /**
     * Set all of USBPHY_DIRECT_OVERRIDE's bit fields.
     *
     * (read-write) Override enable for each control in usbphy_direct
     */
    inline void set_USBPHY_DIRECT_OVERRIDE(
        bool DP_PULLUP_HISEL_OVERRIDE_EN, bool DM_PULLUP_HISEL_OVERRIDE_EN,
        bool DP_PULLUP_EN_OVERRIDE_EN, bool DP_PULLDN_EN_OVERRIDE_EN,
        bool DM_PULLDN_EN_OVERRIDE_EN, bool TX_DP_OE_OVERRIDE_EN,
        bool TX_DM_OE_OVERRIDE_EN, bool TX_DP_OVERRIDE_EN,
        bool TX_DM_OVERRIDE_EN, bool RX_PD_OVERRIDE_EN, bool TX_PD_OVERRIDE_EN,
        bool TX_FSSLEW_OVERRIDE_EN, bool DM_PULLUP_OVERRIDE_EN,
        bool TX_DIFFMODE_OVERRIDE_EN) volatile
    {
        uint32_t curr = USBPHY_DIRECT_OVERRIDE;

        curr &= ~(0b1u << 0u);
        curr |= (DP_PULLUP_HISEL_OVERRIDE_EN & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (DM_PULLUP_HISEL_OVERRIDE_EN & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (DP_PULLUP_EN_OVERRIDE_EN & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (DP_PULLDN_EN_OVERRIDE_EN & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (DM_PULLDN_EN_OVERRIDE_EN & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (TX_DP_OE_OVERRIDE_EN & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (TX_DM_OE_OVERRIDE_EN & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (TX_DP_OVERRIDE_EN & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (TX_DM_OVERRIDE_EN & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (RX_PD_OVERRIDE_EN & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (TX_PD_OVERRIDE_EN & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (TX_FSSLEW_OVERRIDE_EN & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (DM_PULLUP_OVERRIDE_EN & 0b1u) << 12u;
        curr &= ~(0b1u << 15u);
        curr |= (TX_DIFFMODE_OVERRIDE_EN & 0b1u) << 15u;

        USBPHY_DIRECT_OVERRIDE = curr;
    }

    /**
     * Get USBPHY_TRIM's DP_PULLDN_TRIM field.
     *
     * Value to drive to USB PHY\n
     *                 DP pulldown resistor trim control\n
     *                 Experimental data suggests that the reset value will
     * work, but this register allows adjustment if required
     */
    inline uint8_t get_USBPHY_TRIM_DP_PULLDN_TRIM() volatile
    {
        return (USBPHY_TRIM >> 0u) & 0b11111u;
    }

    /**
     * Set USBPHY_TRIM's DP_PULLDN_TRIM field.
     *
     * Value to drive to USB PHY\n
     *                 DP pulldown resistor trim control\n
     *                 Experimental data suggests that the reset value will
     * work, but this register allows adjustment if required
     */
    inline void set_USBPHY_TRIM_DP_PULLDN_TRIM(uint8_t value) volatile
    {
        uint32_t curr = USBPHY_TRIM;

        curr &= ~(0b11111u << 0u);
        curr |= (value & 0b11111u) << 0u;

        USBPHY_TRIM = curr;
    }

    /**
     * Get USBPHY_TRIM's DM_PULLDN_TRIM field.
     *
     * Value to drive to USB PHY\n
     *                 DM pulldown resistor trim control\n
     *                 Experimental data suggests that the reset value will
     * work, but this register allows adjustment if required
     */
    inline uint8_t get_USBPHY_TRIM_DM_PULLDN_TRIM() volatile
    {
        return (USBPHY_TRIM >> 8u) & 0b11111u;
    }

    /**
     * Set USBPHY_TRIM's DM_PULLDN_TRIM field.
     *
     * Value to drive to USB PHY\n
     *                 DM pulldown resistor trim control\n
     *                 Experimental data suggests that the reset value will
     * work, but this register allows adjustment if required
     */
    inline void set_USBPHY_TRIM_DM_PULLDN_TRIM(uint8_t value) volatile
    {
        uint32_t curr = USBPHY_TRIM;

        curr &= ~(0b11111u << 8u);
        curr |= (value & 0b11111u) << 8u;

        USBPHY_TRIM = curr;
    }

    /**
     * Get all of USBPHY_TRIM's bit fields.
     *
     * (read-write) Used to adjust trim values of USB phy pull down resistors.
     */
    inline void get_USBPHY_TRIM(uint8_t &DP_PULLDN_TRIM,
                                uint8_t &DM_PULLDN_TRIM) volatile
    {
        uint32_t curr = USBPHY_TRIM;

        DP_PULLDN_TRIM = (curr >> 0u) & 0b11111u;
        DM_PULLDN_TRIM = (curr >> 8u) & 0b11111u;
    }

    /**
     * Set all of USBPHY_TRIM's bit fields.
     *
     * (read-write) Used to adjust trim values of USB phy pull down resistors.
     */
    inline void set_USBPHY_TRIM(uint8_t DP_PULLDN_TRIM,
                                uint8_t DM_PULLDN_TRIM) volatile
    {
        uint32_t curr = USBPHY_TRIM;

        curr &= ~(0b11111u << 0u);
        curr |= (DP_PULLDN_TRIM & 0b11111u) << 0u;
        curr &= ~(0b11111u << 8u);
        curr |= (DM_PULLDN_TRIM & 0b11111u) << 8u;

        USBPHY_TRIM = curr;
    }

    /**
     * Get INTR's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline bool get_INTR_HOST_CONN_DIS() volatile
    {
        return INTR & (1u << 0u);
    }

    /**
     * Get INTR's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline bool get_INTR_HOST_RESUME() volatile
    {
        return INTR & (1u << 1u);
    }

    /**
     * Get INTR's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline bool get_INTR_HOST_SOF() volatile
    {
        return INTR & (1u << 2u);
    }

    /**
     * Get INTR's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline bool get_INTR_TRANS_COMPLETE() volatile
    {
        return INTR & (1u << 3u);
    }

    /**
     * Get INTR's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline bool get_INTR_BUFF_STATUS() volatile
    {
        return INTR & (1u << 4u);
    }

    /**
     * Get INTR's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline bool get_INTR_ERROR_DATA_SEQ() volatile
    {
        return INTR & (1u << 5u);
    }

    /**
     * Get INTR's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline bool get_INTR_ERROR_RX_TIMEOUT() volatile
    {
        return INTR & (1u << 6u);
    }

    /**
     * Get INTR's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline bool get_INTR_ERROR_RX_OVERFLOW() volatile
    {
        return INTR & (1u << 7u);
    }

    /**
     * Get INTR's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline bool get_INTR_ERROR_BIT_STUFF() volatile
    {
        return INTR & (1u << 8u);
    }

    /**
     * Get INTR's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline bool get_INTR_ERROR_CRC() volatile
    {
        return INTR & (1u << 9u);
    }

    /**
     * Get INTR's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline bool get_INTR_STALL() volatile
    {
        return INTR & (1u << 10u);
    }

    /**
     * Get INTR's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline bool get_INTR_VBUS_DETECT() volatile
    {
        return INTR & (1u << 11u);
    }

    /**
     * Get INTR's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline bool get_INTR_BUS_RESET() volatile
    {
        return INTR & (1u << 12u);
    }

    /**
     * Get INTR's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline bool get_INTR_DEV_CONN_DIS() volatile
    {
        return INTR & (1u << 13u);
    }

    /**
     * Get INTR's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline bool get_INTR_DEV_SUSPEND() volatile
    {
        return INTR & (1u << 14u);
    }

    /**
     * Get INTR's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline bool get_INTR_DEV_RESUME_FROM_HOST() volatile
    {
        return INTR & (1u << 15u);
    }

    /**
     * Get INTR's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline bool get_INTR_SETUP_REQ() volatile
    {
        return INTR & (1u << 16u);
    }

    /**
     * Get INTR's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline bool get_INTR_DEV_SOF() volatile
    {
        return INTR & (1u << 17u);
    }

    /**
     * Get INTR's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline bool get_INTR_ABORT_DONE() volatile
    {
        return INTR & (1u << 18u);
    }

    /**
     * Get INTR's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline bool get_INTR_EP_STALL_NAK() volatile
    {
        return INTR & (1u << 19u);
    }

    /**
     * Get all of INTR's bit fields.
     *
     * (read-only) Raw Interrupts
     */
    inline void get_INTR(bool &HOST_CONN_DIS, bool &HOST_RESUME,
                         bool &HOST_SOF, bool &TRANS_COMPLETE,
                         bool &BUFF_STATUS, bool &ERROR_DATA_SEQ,
                         bool &ERROR_RX_TIMEOUT, bool &ERROR_RX_OVERFLOW,
                         bool &ERROR_BIT_STUFF, bool &ERROR_CRC, bool &STALL,
                         bool &VBUS_DETECT, bool &BUS_RESET,
                         bool &DEV_CONN_DIS, bool &DEV_SUSPEND,
                         bool &DEV_RESUME_FROM_HOST, bool &SETUP_REQ,
                         bool &DEV_SOF, bool &ABORT_DONE,
                         bool &EP_STALL_NAK) volatile
    {
        uint32_t curr = INTR;

        HOST_CONN_DIS = curr & (1u << 0u);
        HOST_RESUME = curr & (1u << 1u);
        HOST_SOF = curr & (1u << 2u);
        TRANS_COMPLETE = curr & (1u << 3u);
        BUFF_STATUS = curr & (1u << 4u);
        ERROR_DATA_SEQ = curr & (1u << 5u);
        ERROR_RX_TIMEOUT = curr & (1u << 6u);
        ERROR_RX_OVERFLOW = curr & (1u << 7u);
        ERROR_BIT_STUFF = curr & (1u << 8u);
        ERROR_CRC = curr & (1u << 9u);
        STALL = curr & (1u << 10u);
        VBUS_DETECT = curr & (1u << 11u);
        BUS_RESET = curr & (1u << 12u);
        DEV_CONN_DIS = curr & (1u << 13u);
        DEV_SUSPEND = curr & (1u << 14u);
        DEV_RESUME_FROM_HOST = curr & (1u << 15u);
        SETUP_REQ = curr & (1u << 16u);
        DEV_SOF = curr & (1u << 17u);
        ABORT_DONE = curr & (1u << 18u);
        EP_STALL_NAK = curr & (1u << 19u);
    }

    /**
     * Get INTE's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline bool get_INTE_HOST_CONN_DIS() volatile
    {
        return INTE & (1u << 0u);
    }

    /**
     * Set INTE's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline void set_INTE_HOST_CONN_DIS() volatile
    {
        INTE |= 1u << 0u;
    }

    /**
     * Clear INTE's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline void clear_INTE_HOST_CONN_DIS() volatile
    {
        INTE &= ~(1u << 0u);
    }

    /**
     * Toggle INTE's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline void toggle_INTE_HOST_CONN_DIS() volatile
    {
        INTE ^= 1u << 0u;
    }

    /**
     * Get INTE's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline bool get_INTE_HOST_RESUME() volatile
    {
        return INTE & (1u << 1u);
    }

    /**
     * Set INTE's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline void set_INTE_HOST_RESUME() volatile
    {
        INTE |= 1u << 1u;
    }

    /**
     * Clear INTE's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline void clear_INTE_HOST_RESUME() volatile
    {
        INTE &= ~(1u << 1u);
    }

    /**
     * Toggle INTE's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline void toggle_INTE_HOST_RESUME() volatile
    {
        INTE ^= 1u << 1u;
    }

    /**
     * Get INTE's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline bool get_INTE_HOST_SOF() volatile
    {
        return INTE & (1u << 2u);
    }

    /**
     * Set INTE's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline void set_INTE_HOST_SOF() volatile
    {
        INTE |= 1u << 2u;
    }

    /**
     * Clear INTE's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline void clear_INTE_HOST_SOF() volatile
    {
        INTE &= ~(1u << 2u);
    }

    /**
     * Toggle INTE's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline void toggle_INTE_HOST_SOF() volatile
    {
        INTE ^= 1u << 2u;
    }

    /**
     * Get INTE's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline bool get_INTE_TRANS_COMPLETE() volatile
    {
        return INTE & (1u << 3u);
    }

    /**
     * Set INTE's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline void set_INTE_TRANS_COMPLETE() volatile
    {
        INTE |= 1u << 3u;
    }

    /**
     * Clear INTE's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline void clear_INTE_TRANS_COMPLETE() volatile
    {
        INTE &= ~(1u << 3u);
    }

    /**
     * Toggle INTE's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline void toggle_INTE_TRANS_COMPLETE() volatile
    {
        INTE ^= 1u << 3u;
    }

    /**
     * Get INTE's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline bool get_INTE_BUFF_STATUS() volatile
    {
        return INTE & (1u << 4u);
    }

    /**
     * Set INTE's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline void set_INTE_BUFF_STATUS() volatile
    {
        INTE |= 1u << 4u;
    }

    /**
     * Clear INTE's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline void clear_INTE_BUFF_STATUS() volatile
    {
        INTE &= ~(1u << 4u);
    }

    /**
     * Toggle INTE's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline void toggle_INTE_BUFF_STATUS() volatile
    {
        INTE ^= 1u << 4u;
    }

    /**
     * Get INTE's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline bool get_INTE_ERROR_DATA_SEQ() volatile
    {
        return INTE & (1u << 5u);
    }

    /**
     * Set INTE's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline void set_INTE_ERROR_DATA_SEQ() volatile
    {
        INTE |= 1u << 5u;
    }

    /**
     * Clear INTE's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline void clear_INTE_ERROR_DATA_SEQ() volatile
    {
        INTE &= ~(1u << 5u);
    }

    /**
     * Toggle INTE's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline void toggle_INTE_ERROR_DATA_SEQ() volatile
    {
        INTE ^= 1u << 5u;
    }

    /**
     * Get INTE's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline bool get_INTE_ERROR_RX_TIMEOUT() volatile
    {
        return INTE & (1u << 6u);
    }

    /**
     * Set INTE's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline void set_INTE_ERROR_RX_TIMEOUT() volatile
    {
        INTE |= 1u << 6u;
    }

    /**
     * Clear INTE's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline void clear_INTE_ERROR_RX_TIMEOUT() volatile
    {
        INTE &= ~(1u << 6u);
    }

    /**
     * Toggle INTE's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline void toggle_INTE_ERROR_RX_TIMEOUT() volatile
    {
        INTE ^= 1u << 6u;
    }

    /**
     * Get INTE's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline bool get_INTE_ERROR_RX_OVERFLOW() volatile
    {
        return INTE & (1u << 7u);
    }

    /**
     * Set INTE's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline void set_INTE_ERROR_RX_OVERFLOW() volatile
    {
        INTE |= 1u << 7u;
    }

    /**
     * Clear INTE's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline void clear_INTE_ERROR_RX_OVERFLOW() volatile
    {
        INTE &= ~(1u << 7u);
    }

    /**
     * Toggle INTE's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline void toggle_INTE_ERROR_RX_OVERFLOW() volatile
    {
        INTE ^= 1u << 7u;
    }

    /**
     * Get INTE's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline bool get_INTE_ERROR_BIT_STUFF() volatile
    {
        return INTE & (1u << 8u);
    }

    /**
     * Set INTE's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline void set_INTE_ERROR_BIT_STUFF() volatile
    {
        INTE |= 1u << 8u;
    }

    /**
     * Clear INTE's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline void clear_INTE_ERROR_BIT_STUFF() volatile
    {
        INTE &= ~(1u << 8u);
    }

    /**
     * Toggle INTE's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline void toggle_INTE_ERROR_BIT_STUFF() volatile
    {
        INTE ^= 1u << 8u;
    }

    /**
     * Get INTE's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline bool get_INTE_ERROR_CRC() volatile
    {
        return INTE & (1u << 9u);
    }

    /**
     * Set INTE's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline void set_INTE_ERROR_CRC() volatile
    {
        INTE |= 1u << 9u;
    }

    /**
     * Clear INTE's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline void clear_INTE_ERROR_CRC() volatile
    {
        INTE &= ~(1u << 9u);
    }

    /**
     * Toggle INTE's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline void toggle_INTE_ERROR_CRC() volatile
    {
        INTE ^= 1u << 9u;
    }

    /**
     * Get INTE's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline bool get_INTE_STALL() volatile
    {
        return INTE & (1u << 10u);
    }

    /**
     * Set INTE's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline void set_INTE_STALL() volatile
    {
        INTE |= 1u << 10u;
    }

    /**
     * Clear INTE's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline void clear_INTE_STALL() volatile
    {
        INTE &= ~(1u << 10u);
    }

    /**
     * Toggle INTE's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline void toggle_INTE_STALL() volatile
    {
        INTE ^= 1u << 10u;
    }

    /**
     * Get INTE's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline bool get_INTE_VBUS_DETECT() volatile
    {
        return INTE & (1u << 11u);
    }

    /**
     * Set INTE's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline void set_INTE_VBUS_DETECT() volatile
    {
        INTE |= 1u << 11u;
    }

    /**
     * Clear INTE's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline void clear_INTE_VBUS_DETECT() volatile
    {
        INTE &= ~(1u << 11u);
    }

    /**
     * Toggle INTE's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline void toggle_INTE_VBUS_DETECT() volatile
    {
        INTE ^= 1u << 11u;
    }

    /**
     * Get INTE's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline bool get_INTE_BUS_RESET() volatile
    {
        return INTE & (1u << 12u);
    }

    /**
     * Set INTE's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline void set_INTE_BUS_RESET() volatile
    {
        INTE |= 1u << 12u;
    }

    /**
     * Clear INTE's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline void clear_INTE_BUS_RESET() volatile
    {
        INTE &= ~(1u << 12u);
    }

    /**
     * Toggle INTE's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline void toggle_INTE_BUS_RESET() volatile
    {
        INTE ^= 1u << 12u;
    }

    /**
     * Get INTE's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline bool get_INTE_DEV_CONN_DIS() volatile
    {
        return INTE & (1u << 13u);
    }

    /**
     * Set INTE's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline void set_INTE_DEV_CONN_DIS() volatile
    {
        INTE |= 1u << 13u;
    }

    /**
     * Clear INTE's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline void clear_INTE_DEV_CONN_DIS() volatile
    {
        INTE &= ~(1u << 13u);
    }

    /**
     * Toggle INTE's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline void toggle_INTE_DEV_CONN_DIS() volatile
    {
        INTE ^= 1u << 13u;
    }

    /**
     * Get INTE's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline bool get_INTE_DEV_SUSPEND() volatile
    {
        return INTE & (1u << 14u);
    }

    /**
     * Set INTE's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline void set_INTE_DEV_SUSPEND() volatile
    {
        INTE |= 1u << 14u;
    }

    /**
     * Clear INTE's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline void clear_INTE_DEV_SUSPEND() volatile
    {
        INTE &= ~(1u << 14u);
    }

    /**
     * Toggle INTE's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline void toggle_INTE_DEV_SUSPEND() volatile
    {
        INTE ^= 1u << 14u;
    }

    /**
     * Get INTE's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline bool get_INTE_DEV_RESUME_FROM_HOST() volatile
    {
        return INTE & (1u << 15u);
    }

    /**
     * Set INTE's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline void set_INTE_DEV_RESUME_FROM_HOST() volatile
    {
        INTE |= 1u << 15u;
    }

    /**
     * Clear INTE's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline void clear_INTE_DEV_RESUME_FROM_HOST() volatile
    {
        INTE &= ~(1u << 15u);
    }

    /**
     * Toggle INTE's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline void toggle_INTE_DEV_RESUME_FROM_HOST() volatile
    {
        INTE ^= 1u << 15u;
    }

    /**
     * Get INTE's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline bool get_INTE_SETUP_REQ() volatile
    {
        return INTE & (1u << 16u);
    }

    /**
     * Set INTE's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline void set_INTE_SETUP_REQ() volatile
    {
        INTE |= 1u << 16u;
    }

    /**
     * Clear INTE's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline void clear_INTE_SETUP_REQ() volatile
    {
        INTE &= ~(1u << 16u);
    }

    /**
     * Toggle INTE's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline void toggle_INTE_SETUP_REQ() volatile
    {
        INTE ^= 1u << 16u;
    }

    /**
     * Get INTE's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline bool get_INTE_DEV_SOF() volatile
    {
        return INTE & (1u << 17u);
    }

    /**
     * Set INTE's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline void set_INTE_DEV_SOF() volatile
    {
        INTE |= 1u << 17u;
    }

    /**
     * Clear INTE's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline void clear_INTE_DEV_SOF() volatile
    {
        INTE &= ~(1u << 17u);
    }

    /**
     * Toggle INTE's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline void toggle_INTE_DEV_SOF() volatile
    {
        INTE ^= 1u << 17u;
    }

    /**
     * Get INTE's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline bool get_INTE_ABORT_DONE() volatile
    {
        return INTE & (1u << 18u);
    }

    /**
     * Set INTE's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline void set_INTE_ABORT_DONE() volatile
    {
        INTE |= 1u << 18u;
    }

    /**
     * Clear INTE's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline void clear_INTE_ABORT_DONE() volatile
    {
        INTE &= ~(1u << 18u);
    }

    /**
     * Toggle INTE's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline void toggle_INTE_ABORT_DONE() volatile
    {
        INTE ^= 1u << 18u;
    }

    /**
     * Get INTE's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline bool get_INTE_EP_STALL_NAK() volatile
    {
        return INTE & (1u << 19u);
    }

    /**
     * Set INTE's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline void set_INTE_EP_STALL_NAK() volatile
    {
        INTE |= 1u << 19u;
    }

    /**
     * Clear INTE's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline void clear_INTE_EP_STALL_NAK() volatile
    {
        INTE &= ~(1u << 19u);
    }

    /**
     * Toggle INTE's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline void toggle_INTE_EP_STALL_NAK() volatile
    {
        INTE ^= 1u << 19u;
    }

    /**
     * Get all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void get_INTE(bool &HOST_CONN_DIS, bool &HOST_RESUME,
                         bool &HOST_SOF, bool &TRANS_COMPLETE,
                         bool &BUFF_STATUS, bool &ERROR_DATA_SEQ,
                         bool &ERROR_RX_TIMEOUT, bool &ERROR_RX_OVERFLOW,
                         bool &ERROR_BIT_STUFF, bool &ERROR_CRC, bool &STALL,
                         bool &VBUS_DETECT, bool &BUS_RESET,
                         bool &DEV_CONN_DIS, bool &DEV_SUSPEND,
                         bool &DEV_RESUME_FROM_HOST, bool &SETUP_REQ,
                         bool &DEV_SOF, bool &ABORT_DONE,
                         bool &EP_STALL_NAK) volatile
    {
        uint32_t curr = INTE;

        HOST_CONN_DIS = curr & (1u << 0u);
        HOST_RESUME = curr & (1u << 1u);
        HOST_SOF = curr & (1u << 2u);
        TRANS_COMPLETE = curr & (1u << 3u);
        BUFF_STATUS = curr & (1u << 4u);
        ERROR_DATA_SEQ = curr & (1u << 5u);
        ERROR_RX_TIMEOUT = curr & (1u << 6u);
        ERROR_RX_OVERFLOW = curr & (1u << 7u);
        ERROR_BIT_STUFF = curr & (1u << 8u);
        ERROR_CRC = curr & (1u << 9u);
        STALL = curr & (1u << 10u);
        VBUS_DETECT = curr & (1u << 11u);
        BUS_RESET = curr & (1u << 12u);
        DEV_CONN_DIS = curr & (1u << 13u);
        DEV_SUSPEND = curr & (1u << 14u);
        DEV_RESUME_FROM_HOST = curr & (1u << 15u);
        SETUP_REQ = curr & (1u << 16u);
        DEV_SOF = curr & (1u << 17u);
        ABORT_DONE = curr & (1u << 18u);
        EP_STALL_NAK = curr & (1u << 19u);
    }

    /**
     * Set all of INTE's bit fields.
     *
     * (read-write) Interrupt Enable
     */
    inline void set_INTE(bool HOST_CONN_DIS, bool HOST_RESUME, bool HOST_SOF,
                         bool TRANS_COMPLETE, bool BUFF_STATUS,
                         bool ERROR_DATA_SEQ, bool ERROR_RX_TIMEOUT,
                         bool ERROR_RX_OVERFLOW, bool ERROR_BIT_STUFF,
                         bool ERROR_CRC, bool STALL, bool VBUS_DETECT,
                         bool BUS_RESET, bool DEV_CONN_DIS, bool DEV_SUSPEND,
                         bool DEV_RESUME_FROM_HOST, bool SETUP_REQ,
                         bool DEV_SOF, bool ABORT_DONE,
                         bool EP_STALL_NAK) volatile
    {
        uint32_t curr = INTE;

        curr &= ~(0b1u << 0u);
        curr |= (HOST_CONN_DIS & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HOST_RESUME & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (HOST_SOF & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (TRANS_COMPLETE & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (BUFF_STATUS & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (ERROR_DATA_SEQ & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (ERROR_RX_TIMEOUT & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (ERROR_RX_OVERFLOW & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (ERROR_BIT_STUFF & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (ERROR_CRC & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (STALL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (VBUS_DETECT & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (BUS_RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (DEV_CONN_DIS & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (DEV_SUSPEND & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (DEV_RESUME_FROM_HOST & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (SETUP_REQ & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (DEV_SOF & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (ABORT_DONE & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (EP_STALL_NAK & 0b1u) << 19u;

        INTE = curr;
    }

    /**
     * Get INTF's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline bool get_INTF_HOST_CONN_DIS() volatile
    {
        return INTF & (1u << 0u);
    }

    /**
     * Set INTF's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline void set_INTF_HOST_CONN_DIS() volatile
    {
        INTF |= 1u << 0u;
    }

    /**
     * Clear INTF's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline void clear_INTF_HOST_CONN_DIS() volatile
    {
        INTF &= ~(1u << 0u);
    }

    /**
     * Toggle INTF's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline void toggle_INTF_HOST_CONN_DIS() volatile
    {
        INTF ^= 1u << 0u;
    }

    /**
     * Get INTF's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline bool get_INTF_HOST_RESUME() volatile
    {
        return INTF & (1u << 1u);
    }

    /**
     * Set INTF's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline void set_INTF_HOST_RESUME() volatile
    {
        INTF |= 1u << 1u;
    }

    /**
     * Clear INTF's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline void clear_INTF_HOST_RESUME() volatile
    {
        INTF &= ~(1u << 1u);
    }

    /**
     * Toggle INTF's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline void toggle_INTF_HOST_RESUME() volatile
    {
        INTF ^= 1u << 1u;
    }

    /**
     * Get INTF's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline bool get_INTF_HOST_SOF() volatile
    {
        return INTF & (1u << 2u);
    }

    /**
     * Set INTF's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline void set_INTF_HOST_SOF() volatile
    {
        INTF |= 1u << 2u;
    }

    /**
     * Clear INTF's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline void clear_INTF_HOST_SOF() volatile
    {
        INTF &= ~(1u << 2u);
    }

    /**
     * Toggle INTF's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline void toggle_INTF_HOST_SOF() volatile
    {
        INTF ^= 1u << 2u;
    }

    /**
     * Get INTF's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline bool get_INTF_TRANS_COMPLETE() volatile
    {
        return INTF & (1u << 3u);
    }

    /**
     * Set INTF's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline void set_INTF_TRANS_COMPLETE() volatile
    {
        INTF |= 1u << 3u;
    }

    /**
     * Clear INTF's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline void clear_INTF_TRANS_COMPLETE() volatile
    {
        INTF &= ~(1u << 3u);
    }

    /**
     * Toggle INTF's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline void toggle_INTF_TRANS_COMPLETE() volatile
    {
        INTF ^= 1u << 3u;
    }

    /**
     * Get INTF's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline bool get_INTF_BUFF_STATUS() volatile
    {
        return INTF & (1u << 4u);
    }

    /**
     * Set INTF's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline void set_INTF_BUFF_STATUS() volatile
    {
        INTF |= 1u << 4u;
    }

    /**
     * Clear INTF's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline void clear_INTF_BUFF_STATUS() volatile
    {
        INTF &= ~(1u << 4u);
    }

    /**
     * Toggle INTF's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline void toggle_INTF_BUFF_STATUS() volatile
    {
        INTF ^= 1u << 4u;
    }

    /**
     * Get INTF's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline bool get_INTF_ERROR_DATA_SEQ() volatile
    {
        return INTF & (1u << 5u);
    }

    /**
     * Set INTF's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline void set_INTF_ERROR_DATA_SEQ() volatile
    {
        INTF |= 1u << 5u;
    }

    /**
     * Clear INTF's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline void clear_INTF_ERROR_DATA_SEQ() volatile
    {
        INTF &= ~(1u << 5u);
    }

    /**
     * Toggle INTF's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline void toggle_INTF_ERROR_DATA_SEQ() volatile
    {
        INTF ^= 1u << 5u;
    }

    /**
     * Get INTF's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline bool get_INTF_ERROR_RX_TIMEOUT() volatile
    {
        return INTF & (1u << 6u);
    }

    /**
     * Set INTF's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline void set_INTF_ERROR_RX_TIMEOUT() volatile
    {
        INTF |= 1u << 6u;
    }

    /**
     * Clear INTF's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline void clear_INTF_ERROR_RX_TIMEOUT() volatile
    {
        INTF &= ~(1u << 6u);
    }

    /**
     * Toggle INTF's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline void toggle_INTF_ERROR_RX_TIMEOUT() volatile
    {
        INTF ^= 1u << 6u;
    }

    /**
     * Get INTF's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline bool get_INTF_ERROR_RX_OVERFLOW() volatile
    {
        return INTF & (1u << 7u);
    }

    /**
     * Set INTF's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline void set_INTF_ERROR_RX_OVERFLOW() volatile
    {
        INTF |= 1u << 7u;
    }

    /**
     * Clear INTF's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline void clear_INTF_ERROR_RX_OVERFLOW() volatile
    {
        INTF &= ~(1u << 7u);
    }

    /**
     * Toggle INTF's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline void toggle_INTF_ERROR_RX_OVERFLOW() volatile
    {
        INTF ^= 1u << 7u;
    }

    /**
     * Get INTF's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline bool get_INTF_ERROR_BIT_STUFF() volatile
    {
        return INTF & (1u << 8u);
    }

    /**
     * Set INTF's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline void set_INTF_ERROR_BIT_STUFF() volatile
    {
        INTF |= 1u << 8u;
    }

    /**
     * Clear INTF's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline void clear_INTF_ERROR_BIT_STUFF() volatile
    {
        INTF &= ~(1u << 8u);
    }

    /**
     * Toggle INTF's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline void toggle_INTF_ERROR_BIT_STUFF() volatile
    {
        INTF ^= 1u << 8u;
    }

    /**
     * Get INTF's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline bool get_INTF_ERROR_CRC() volatile
    {
        return INTF & (1u << 9u);
    }

    /**
     * Set INTF's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline void set_INTF_ERROR_CRC() volatile
    {
        INTF |= 1u << 9u;
    }

    /**
     * Clear INTF's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline void clear_INTF_ERROR_CRC() volatile
    {
        INTF &= ~(1u << 9u);
    }

    /**
     * Toggle INTF's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline void toggle_INTF_ERROR_CRC() volatile
    {
        INTF ^= 1u << 9u;
    }

    /**
     * Get INTF's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline bool get_INTF_STALL() volatile
    {
        return INTF & (1u << 10u);
    }

    /**
     * Set INTF's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline void set_INTF_STALL() volatile
    {
        INTF |= 1u << 10u;
    }

    /**
     * Clear INTF's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline void clear_INTF_STALL() volatile
    {
        INTF &= ~(1u << 10u);
    }

    /**
     * Toggle INTF's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline void toggle_INTF_STALL() volatile
    {
        INTF ^= 1u << 10u;
    }

    /**
     * Get INTF's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline bool get_INTF_VBUS_DETECT() volatile
    {
        return INTF & (1u << 11u);
    }

    /**
     * Set INTF's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline void set_INTF_VBUS_DETECT() volatile
    {
        INTF |= 1u << 11u;
    }

    /**
     * Clear INTF's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline void clear_INTF_VBUS_DETECT() volatile
    {
        INTF &= ~(1u << 11u);
    }

    /**
     * Toggle INTF's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline void toggle_INTF_VBUS_DETECT() volatile
    {
        INTF ^= 1u << 11u;
    }

    /**
     * Get INTF's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline bool get_INTF_BUS_RESET() volatile
    {
        return INTF & (1u << 12u);
    }

    /**
     * Set INTF's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline void set_INTF_BUS_RESET() volatile
    {
        INTF |= 1u << 12u;
    }

    /**
     * Clear INTF's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline void clear_INTF_BUS_RESET() volatile
    {
        INTF &= ~(1u << 12u);
    }

    /**
     * Toggle INTF's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline void toggle_INTF_BUS_RESET() volatile
    {
        INTF ^= 1u << 12u;
    }

    /**
     * Get INTF's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline bool get_INTF_DEV_CONN_DIS() volatile
    {
        return INTF & (1u << 13u);
    }

    /**
     * Set INTF's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline void set_INTF_DEV_CONN_DIS() volatile
    {
        INTF |= 1u << 13u;
    }

    /**
     * Clear INTF's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline void clear_INTF_DEV_CONN_DIS() volatile
    {
        INTF &= ~(1u << 13u);
    }

    /**
     * Toggle INTF's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline void toggle_INTF_DEV_CONN_DIS() volatile
    {
        INTF ^= 1u << 13u;
    }

    /**
     * Get INTF's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline bool get_INTF_DEV_SUSPEND() volatile
    {
        return INTF & (1u << 14u);
    }

    /**
     * Set INTF's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline void set_INTF_DEV_SUSPEND() volatile
    {
        INTF |= 1u << 14u;
    }

    /**
     * Clear INTF's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline void clear_INTF_DEV_SUSPEND() volatile
    {
        INTF &= ~(1u << 14u);
    }

    /**
     * Toggle INTF's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline void toggle_INTF_DEV_SUSPEND() volatile
    {
        INTF ^= 1u << 14u;
    }

    /**
     * Get INTF's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline bool get_INTF_DEV_RESUME_FROM_HOST() volatile
    {
        return INTF & (1u << 15u);
    }

    /**
     * Set INTF's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline void set_INTF_DEV_RESUME_FROM_HOST() volatile
    {
        INTF |= 1u << 15u;
    }

    /**
     * Clear INTF's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline void clear_INTF_DEV_RESUME_FROM_HOST() volatile
    {
        INTF &= ~(1u << 15u);
    }

    /**
     * Toggle INTF's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline void toggle_INTF_DEV_RESUME_FROM_HOST() volatile
    {
        INTF ^= 1u << 15u;
    }

    /**
     * Get INTF's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline bool get_INTF_SETUP_REQ() volatile
    {
        return INTF & (1u << 16u);
    }

    /**
     * Set INTF's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline void set_INTF_SETUP_REQ() volatile
    {
        INTF |= 1u << 16u;
    }

    /**
     * Clear INTF's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline void clear_INTF_SETUP_REQ() volatile
    {
        INTF &= ~(1u << 16u);
    }

    /**
     * Toggle INTF's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline void toggle_INTF_SETUP_REQ() volatile
    {
        INTF ^= 1u << 16u;
    }

    /**
     * Get INTF's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline bool get_INTF_DEV_SOF() volatile
    {
        return INTF & (1u << 17u);
    }

    /**
     * Set INTF's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline void set_INTF_DEV_SOF() volatile
    {
        INTF |= 1u << 17u;
    }

    /**
     * Clear INTF's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline void clear_INTF_DEV_SOF() volatile
    {
        INTF &= ~(1u << 17u);
    }

    /**
     * Toggle INTF's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline void toggle_INTF_DEV_SOF() volatile
    {
        INTF ^= 1u << 17u;
    }

    /**
     * Get INTF's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline bool get_INTF_ABORT_DONE() volatile
    {
        return INTF & (1u << 18u);
    }

    /**
     * Set INTF's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline void set_INTF_ABORT_DONE() volatile
    {
        INTF |= 1u << 18u;
    }

    /**
     * Clear INTF's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline void clear_INTF_ABORT_DONE() volatile
    {
        INTF &= ~(1u << 18u);
    }

    /**
     * Toggle INTF's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline void toggle_INTF_ABORT_DONE() volatile
    {
        INTF ^= 1u << 18u;
    }

    /**
     * Get INTF's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline bool get_INTF_EP_STALL_NAK() volatile
    {
        return INTF & (1u << 19u);
    }

    /**
     * Set INTF's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline void set_INTF_EP_STALL_NAK() volatile
    {
        INTF |= 1u << 19u;
    }

    /**
     * Clear INTF's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline void clear_INTF_EP_STALL_NAK() volatile
    {
        INTF &= ~(1u << 19u);
    }

    /**
     * Toggle INTF's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline void toggle_INTF_EP_STALL_NAK() volatile
    {
        INTF ^= 1u << 19u;
    }

    /**
     * Get all of INTF's bit fields.
     *
     * (read-write) Interrupt Force
     */
    inline void get_INTF(bool &HOST_CONN_DIS, bool &HOST_RESUME,
                         bool &HOST_SOF, bool &TRANS_COMPLETE,
                         bool &BUFF_STATUS, bool &ERROR_DATA_SEQ,
                         bool &ERROR_RX_TIMEOUT, bool &ERROR_RX_OVERFLOW,
                         bool &ERROR_BIT_STUFF, bool &ERROR_CRC, bool &STALL,
                         bool &VBUS_DETECT, bool &BUS_RESET,
                         bool &DEV_CONN_DIS, bool &DEV_SUSPEND,
                         bool &DEV_RESUME_FROM_HOST, bool &SETUP_REQ,
                         bool &DEV_SOF, bool &ABORT_DONE,
                         bool &EP_STALL_NAK) volatile
    {
        uint32_t curr = INTF;

        HOST_CONN_DIS = curr & (1u << 0u);
        HOST_RESUME = curr & (1u << 1u);
        HOST_SOF = curr & (1u << 2u);
        TRANS_COMPLETE = curr & (1u << 3u);
        BUFF_STATUS = curr & (1u << 4u);
        ERROR_DATA_SEQ = curr & (1u << 5u);
        ERROR_RX_TIMEOUT = curr & (1u << 6u);
        ERROR_RX_OVERFLOW = curr & (1u << 7u);
        ERROR_BIT_STUFF = curr & (1u << 8u);
        ERROR_CRC = curr & (1u << 9u);
        STALL = curr & (1u << 10u);
        VBUS_DETECT = curr & (1u << 11u);
        BUS_RESET = curr & (1u << 12u);
        DEV_CONN_DIS = curr & (1u << 13u);
        DEV_SUSPEND = curr & (1u << 14u);
        DEV_RESUME_FROM_HOST = curr & (1u << 15u);
        SETUP_REQ = curr & (1u << 16u);
        DEV_SOF = curr & (1u << 17u);
        ABORT_DONE = curr & (1u << 18u);
        EP_STALL_NAK = curr & (1u << 19u);
    }

    /**
     * Set all of INTF's bit fields.
     *
     * (read-write) Interrupt Force
     */
    inline void set_INTF(bool HOST_CONN_DIS, bool HOST_RESUME, bool HOST_SOF,
                         bool TRANS_COMPLETE, bool BUFF_STATUS,
                         bool ERROR_DATA_SEQ, bool ERROR_RX_TIMEOUT,
                         bool ERROR_RX_OVERFLOW, bool ERROR_BIT_STUFF,
                         bool ERROR_CRC, bool STALL, bool VBUS_DETECT,
                         bool BUS_RESET, bool DEV_CONN_DIS, bool DEV_SUSPEND,
                         bool DEV_RESUME_FROM_HOST, bool SETUP_REQ,
                         bool DEV_SOF, bool ABORT_DONE,
                         bool EP_STALL_NAK) volatile
    {
        uint32_t curr = INTF;

        curr &= ~(0b1u << 0u);
        curr |= (HOST_CONN_DIS & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (HOST_RESUME & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (HOST_SOF & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (TRANS_COMPLETE & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (BUFF_STATUS & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (ERROR_DATA_SEQ & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (ERROR_RX_TIMEOUT & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (ERROR_RX_OVERFLOW & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (ERROR_BIT_STUFF & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (ERROR_CRC & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (STALL & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (VBUS_DETECT & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (BUS_RESET & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (DEV_CONN_DIS & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (DEV_SUSPEND & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (DEV_RESUME_FROM_HOST & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (SETUP_REQ & 0b1u) << 16u;
        curr &= ~(0b1u << 17u);
        curr |= (DEV_SOF & 0b1u) << 17u;
        curr &= ~(0b1u << 18u);
        curr |= (ABORT_DONE & 0b1u) << 18u;
        curr &= ~(0b1u << 19u);
        curr |= (EP_STALL_NAK & 0b1u) << 19u;

        INTF = curr;
    }

    /**
     * Get INTS's HOST_CONN_DIS bit.
     *
     * Host: raised when a device is connected or disconnected (i.e. when
     * SIE_STATUS.SPEED changes). Cleared by writing to SIE_STATUS.SPEED
     */
    inline bool get_INTS_HOST_CONN_DIS() volatile
    {
        return INTS & (1u << 0u);
    }

    /**
     * Get INTS's HOST_RESUME bit.
     *
     * Host: raised when a device wakes up the host. Cleared by writing to
     * SIE_STATUS.RESUME
     */
    inline bool get_INTS_HOST_RESUME() volatile
    {
        return INTS & (1u << 1u);
    }

    /**
     * Get INTS's HOST_SOF bit.
     *
     * Host: raised every time the host sends a SOF (Start of Frame). Cleared
     * by reading SOF_RD
     */
    inline bool get_INTS_HOST_SOF() volatile
    {
        return INTS & (1u << 2u);
    }

    /**
     * Get INTS's TRANS_COMPLETE bit.
     *
     * Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear by writing to
     * this bit.
     */
    inline bool get_INTS_TRANS_COMPLETE() volatile
    {
        return INTS & (1u << 3u);
    }

    /**
     * Get INTS's BUFF_STATUS bit.
     *
     * Raised when any bit in BUFF_STATUS is set. Clear by clearing all bits in
     * BUFF_STATUS.
     */
    inline bool get_INTS_BUFF_STATUS() volatile
    {
        return INTS & (1u << 4u);
    }

    /**
     * Get INTS's ERROR_DATA_SEQ bit.
     *
     * Source: SIE_STATUS.DATA_SEQ_ERROR
     */
    inline bool get_INTS_ERROR_DATA_SEQ() volatile
    {
        return INTS & (1u << 5u);
    }

    /**
     * Get INTS's ERROR_RX_TIMEOUT bit.
     *
     * Source: SIE_STATUS.RX_TIMEOUT
     */
    inline bool get_INTS_ERROR_RX_TIMEOUT() volatile
    {
        return INTS & (1u << 6u);
    }

    /**
     * Get INTS's ERROR_RX_OVERFLOW bit.
     *
     * Source: SIE_STATUS.RX_OVERFLOW
     */
    inline bool get_INTS_ERROR_RX_OVERFLOW() volatile
    {
        return INTS & (1u << 7u);
    }

    /**
     * Get INTS's ERROR_BIT_STUFF bit.
     *
     * Source: SIE_STATUS.BIT_STUFF_ERROR
     */
    inline bool get_INTS_ERROR_BIT_STUFF() volatile
    {
        return INTS & (1u << 8u);
    }

    /**
     * Get INTS's ERROR_CRC bit.
     *
     * Source: SIE_STATUS.CRC_ERROR
     */
    inline bool get_INTS_ERROR_CRC() volatile
    {
        return INTS & (1u << 9u);
    }

    /**
     * Get INTS's STALL bit.
     *
     * Source: SIE_STATUS.STALL_REC
     */
    inline bool get_INTS_STALL() volatile
    {
        return INTS & (1u << 10u);
    }

    /**
     * Get INTS's VBUS_DETECT bit.
     *
     * Source: SIE_STATUS.VBUS_DETECTED
     */
    inline bool get_INTS_VBUS_DETECT() volatile
    {
        return INTS & (1u << 11u);
    }

    /**
     * Get INTS's BUS_RESET bit.
     *
     * Source: SIE_STATUS.BUS_RESET
     */
    inline bool get_INTS_BUS_RESET() volatile
    {
        return INTS & (1u << 12u);
    }

    /**
     * Get INTS's DEV_CONN_DIS bit.
     *
     * Set when the device connection state changes. Cleared by writing to
     * SIE_STATUS.CONNECTED
     */
    inline bool get_INTS_DEV_CONN_DIS() volatile
    {
        return INTS & (1u << 13u);
    }

    /**
     * Get INTS's DEV_SUSPEND bit.
     *
     * Set when the device suspend state changes. Cleared by writing to
     * SIE_STATUS.SUSPENDED
     */
    inline bool get_INTS_DEV_SUSPEND() volatile
    {
        return INTS & (1u << 14u);
    }

    /**
     * Get INTS's DEV_RESUME_FROM_HOST bit.
     *
     * Set when the device receives a resume from the host. Cleared by writing
     * to SIE_STATUS.RESUME
     */
    inline bool get_INTS_DEV_RESUME_FROM_HOST() volatile
    {
        return INTS & (1u << 15u);
    }

    /**
     * Get INTS's SETUP_REQ bit.
     *
     * Device. Source: SIE_STATUS.SETUP_REC
     */
    inline bool get_INTS_SETUP_REQ() volatile
    {
        return INTS & (1u << 16u);
    }

    /**
     * Get INTS's DEV_SOF bit.
     *
     * Set every time the device receives a SOF (Start of Frame) packet.
     * Cleared by reading SOF_RD
     */
    inline bool get_INTS_DEV_SOF() volatile
    {
        return INTS & (1u << 17u);
    }

    /**
     * Get INTS's ABORT_DONE bit.
     *
     * Raised when any bit in ABORT_DONE is set. Clear by clearing all bits in
     * ABORT_DONE.
     */
    inline bool get_INTS_ABORT_DONE() volatile
    {
        return INTS & (1u << 18u);
    }

    /**
     * Get INTS's EP_STALL_NAK bit.
     *
     * Raised when any bit in EP_STATUS_STALL_NAK is set. Clear by clearing all
     * bits in EP_STATUS_STALL_NAK.
     */
    inline bool get_INTS_EP_STALL_NAK() volatile
    {
        return INTS & (1u << 19u);
    }

    /**
     * Get all of INTS's bit fields.
     *
     * (read-only) Interrupt status after masking & forcing
     */
    inline void get_INTS(bool &HOST_CONN_DIS, bool &HOST_RESUME,
                         bool &HOST_SOF, bool &TRANS_COMPLETE,
                         bool &BUFF_STATUS, bool &ERROR_DATA_SEQ,
                         bool &ERROR_RX_TIMEOUT, bool &ERROR_RX_OVERFLOW,
                         bool &ERROR_BIT_STUFF, bool &ERROR_CRC, bool &STALL,
                         bool &VBUS_DETECT, bool &BUS_RESET,
                         bool &DEV_CONN_DIS, bool &DEV_SUSPEND,
                         bool &DEV_RESUME_FROM_HOST, bool &SETUP_REQ,
                         bool &DEV_SOF, bool &ABORT_DONE,
                         bool &EP_STALL_NAK) volatile
    {
        uint32_t curr = INTS;

        HOST_CONN_DIS = curr & (1u << 0u);
        HOST_RESUME = curr & (1u << 1u);
        HOST_SOF = curr & (1u << 2u);
        TRANS_COMPLETE = curr & (1u << 3u);
        BUFF_STATUS = curr & (1u << 4u);
        ERROR_DATA_SEQ = curr & (1u << 5u);
        ERROR_RX_TIMEOUT = curr & (1u << 6u);
        ERROR_RX_OVERFLOW = curr & (1u << 7u);
        ERROR_BIT_STUFF = curr & (1u << 8u);
        ERROR_CRC = curr & (1u << 9u);
        STALL = curr & (1u << 10u);
        VBUS_DETECT = curr & (1u << 11u);
        BUS_RESET = curr & (1u << 12u);
        DEV_CONN_DIS = curr & (1u << 13u);
        DEV_SUSPEND = curr & (1u << 14u);
        DEV_RESUME_FROM_HOST = curr & (1u << 15u);
        SETUP_REQ = curr & (1u << 16u);
        DEV_SOF = curr & (1u << 17u);
        ABORT_DONE = curr & (1u << 18u);
        EP_STALL_NAK = curr & (1u << 19u);
    }
};

static_assert(sizeof(usbctrl_regs) == usbctrl_regs::size);

static volatile usbctrl_regs *const USBCTRL_REGS =
    reinterpret_cast<usbctrl_regs *>(0x50110000);

}; // namespace RP2040
