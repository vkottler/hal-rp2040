/**
 * \file
 * \brief Generated by ifgen (3.1.7).
 */
#pragma once

#include "../ifgen/common.h"

namespace RP2040
{

struct [[gnu::packed]] psm
{
    /* Constant attributes. */
    static constexpr std::size_t size = 16; /*!< psm's size in bytes. */

    /* Fields. */
    uint32_t FRCE_ON; /*!< (read-write) Force block out of reset (i.e. power it
                         on) */
    uint32_t
        FRCE_OFF;   /*!< (read-write) Force into reset (i.e. power it off) */
    uint32_t WDSEL; /*!< (read-write) Set to 1 if this peripheral should be
                       reset when the watchdog fires. */
    const uint32_t DONE = {}; /*!< (read-only) Indicates the peripheral's
                                 registers are ready to access. */

    /* Methods. */

    /**
     * Get FRCE_ON's rosc bit.
     */
    inline bool get_FRCE_ON_rosc() volatile
    {
        return FRCE_ON & (1u << 0u);
    }

    /**
     * Set FRCE_ON's rosc bit.
     */
    inline void set_FRCE_ON_rosc() volatile
    {
        FRCE_ON |= 1u << 0u;
    }

    /**
     * Clear FRCE_ON's rosc bit.
     */
    inline void clear_FRCE_ON_rosc() volatile
    {
        FRCE_ON &= ~(1u << 0u);
    }

    /**
     * Toggle FRCE_ON's rosc bit.
     */
    inline void toggle_FRCE_ON_rosc() volatile
    {
        FRCE_ON ^= 1u << 0u;
    }

    /**
     * Get FRCE_ON's xosc bit.
     */
    inline bool get_FRCE_ON_xosc() volatile
    {
        return FRCE_ON & (1u << 1u);
    }

    /**
     * Set FRCE_ON's xosc bit.
     */
    inline void set_FRCE_ON_xosc() volatile
    {
        FRCE_ON |= 1u << 1u;
    }

    /**
     * Clear FRCE_ON's xosc bit.
     */
    inline void clear_FRCE_ON_xosc() volatile
    {
        FRCE_ON &= ~(1u << 1u);
    }

    /**
     * Toggle FRCE_ON's xosc bit.
     */
    inline void toggle_FRCE_ON_xosc() volatile
    {
        FRCE_ON ^= 1u << 1u;
    }

    /**
     * Get FRCE_ON's clocks bit.
     */
    inline bool get_FRCE_ON_clocks() volatile
    {
        return FRCE_ON & (1u << 2u);
    }

    /**
     * Set FRCE_ON's clocks bit.
     */
    inline void set_FRCE_ON_clocks() volatile
    {
        FRCE_ON |= 1u << 2u;
    }

    /**
     * Clear FRCE_ON's clocks bit.
     */
    inline void clear_FRCE_ON_clocks() volatile
    {
        FRCE_ON &= ~(1u << 2u);
    }

    /**
     * Toggle FRCE_ON's clocks bit.
     */
    inline void toggle_FRCE_ON_clocks() volatile
    {
        FRCE_ON ^= 1u << 2u;
    }

    /**
     * Get FRCE_ON's resets bit.
     */
    inline bool get_FRCE_ON_resets() volatile
    {
        return FRCE_ON & (1u << 3u);
    }

    /**
     * Set FRCE_ON's resets bit.
     */
    inline void set_FRCE_ON_resets() volatile
    {
        FRCE_ON |= 1u << 3u;
    }

    /**
     * Clear FRCE_ON's resets bit.
     */
    inline void clear_FRCE_ON_resets() volatile
    {
        FRCE_ON &= ~(1u << 3u);
    }

    /**
     * Toggle FRCE_ON's resets bit.
     */
    inline void toggle_FRCE_ON_resets() volatile
    {
        FRCE_ON ^= 1u << 3u;
    }

    /**
     * Get FRCE_ON's busfabric bit.
     */
    inline bool get_FRCE_ON_busfabric() volatile
    {
        return FRCE_ON & (1u << 4u);
    }

    /**
     * Set FRCE_ON's busfabric bit.
     */
    inline void set_FRCE_ON_busfabric() volatile
    {
        FRCE_ON |= 1u << 4u;
    }

    /**
     * Clear FRCE_ON's busfabric bit.
     */
    inline void clear_FRCE_ON_busfabric() volatile
    {
        FRCE_ON &= ~(1u << 4u);
    }

    /**
     * Toggle FRCE_ON's busfabric bit.
     */
    inline void toggle_FRCE_ON_busfabric() volatile
    {
        FRCE_ON ^= 1u << 4u;
    }

    /**
     * Get FRCE_ON's rom bit.
     */
    inline bool get_FRCE_ON_rom() volatile
    {
        return FRCE_ON & (1u << 5u);
    }

    /**
     * Set FRCE_ON's rom bit.
     */
    inline void set_FRCE_ON_rom() volatile
    {
        FRCE_ON |= 1u << 5u;
    }

    /**
     * Clear FRCE_ON's rom bit.
     */
    inline void clear_FRCE_ON_rom() volatile
    {
        FRCE_ON &= ~(1u << 5u);
    }

    /**
     * Toggle FRCE_ON's rom bit.
     */
    inline void toggle_FRCE_ON_rom() volatile
    {
        FRCE_ON ^= 1u << 5u;
    }

    /**
     * Get FRCE_ON's sram0 bit.
     */
    inline bool get_FRCE_ON_sram0() volatile
    {
        return FRCE_ON & (1u << 6u);
    }

    /**
     * Set FRCE_ON's sram0 bit.
     */
    inline void set_FRCE_ON_sram0() volatile
    {
        FRCE_ON |= 1u << 6u;
    }

    /**
     * Clear FRCE_ON's sram0 bit.
     */
    inline void clear_FRCE_ON_sram0() volatile
    {
        FRCE_ON &= ~(1u << 6u);
    }

    /**
     * Toggle FRCE_ON's sram0 bit.
     */
    inline void toggle_FRCE_ON_sram0() volatile
    {
        FRCE_ON ^= 1u << 6u;
    }

    /**
     * Get FRCE_ON's sram1 bit.
     */
    inline bool get_FRCE_ON_sram1() volatile
    {
        return FRCE_ON & (1u << 7u);
    }

    /**
     * Set FRCE_ON's sram1 bit.
     */
    inline void set_FRCE_ON_sram1() volatile
    {
        FRCE_ON |= 1u << 7u;
    }

    /**
     * Clear FRCE_ON's sram1 bit.
     */
    inline void clear_FRCE_ON_sram1() volatile
    {
        FRCE_ON &= ~(1u << 7u);
    }

    /**
     * Toggle FRCE_ON's sram1 bit.
     */
    inline void toggle_FRCE_ON_sram1() volatile
    {
        FRCE_ON ^= 1u << 7u;
    }

    /**
     * Get FRCE_ON's sram2 bit.
     */
    inline bool get_FRCE_ON_sram2() volatile
    {
        return FRCE_ON & (1u << 8u);
    }

    /**
     * Set FRCE_ON's sram2 bit.
     */
    inline void set_FRCE_ON_sram2() volatile
    {
        FRCE_ON |= 1u << 8u;
    }

    /**
     * Clear FRCE_ON's sram2 bit.
     */
    inline void clear_FRCE_ON_sram2() volatile
    {
        FRCE_ON &= ~(1u << 8u);
    }

    /**
     * Toggle FRCE_ON's sram2 bit.
     */
    inline void toggle_FRCE_ON_sram2() volatile
    {
        FRCE_ON ^= 1u << 8u;
    }

    /**
     * Get FRCE_ON's sram3 bit.
     */
    inline bool get_FRCE_ON_sram3() volatile
    {
        return FRCE_ON & (1u << 9u);
    }

    /**
     * Set FRCE_ON's sram3 bit.
     */
    inline void set_FRCE_ON_sram3() volatile
    {
        FRCE_ON |= 1u << 9u;
    }

    /**
     * Clear FRCE_ON's sram3 bit.
     */
    inline void clear_FRCE_ON_sram3() volatile
    {
        FRCE_ON &= ~(1u << 9u);
    }

    /**
     * Toggle FRCE_ON's sram3 bit.
     */
    inline void toggle_FRCE_ON_sram3() volatile
    {
        FRCE_ON ^= 1u << 9u;
    }

    /**
     * Get FRCE_ON's sram4 bit.
     */
    inline bool get_FRCE_ON_sram4() volatile
    {
        return FRCE_ON & (1u << 10u);
    }

    /**
     * Set FRCE_ON's sram4 bit.
     */
    inline void set_FRCE_ON_sram4() volatile
    {
        FRCE_ON |= 1u << 10u;
    }

    /**
     * Clear FRCE_ON's sram4 bit.
     */
    inline void clear_FRCE_ON_sram4() volatile
    {
        FRCE_ON &= ~(1u << 10u);
    }

    /**
     * Toggle FRCE_ON's sram4 bit.
     */
    inline void toggle_FRCE_ON_sram4() volatile
    {
        FRCE_ON ^= 1u << 10u;
    }

    /**
     * Get FRCE_ON's sram5 bit.
     */
    inline bool get_FRCE_ON_sram5() volatile
    {
        return FRCE_ON & (1u << 11u);
    }

    /**
     * Set FRCE_ON's sram5 bit.
     */
    inline void set_FRCE_ON_sram5() volatile
    {
        FRCE_ON |= 1u << 11u;
    }

    /**
     * Clear FRCE_ON's sram5 bit.
     */
    inline void clear_FRCE_ON_sram5() volatile
    {
        FRCE_ON &= ~(1u << 11u);
    }

    /**
     * Toggle FRCE_ON's sram5 bit.
     */
    inline void toggle_FRCE_ON_sram5() volatile
    {
        FRCE_ON ^= 1u << 11u;
    }

    /**
     * Get FRCE_ON's xip bit.
     */
    inline bool get_FRCE_ON_xip() volatile
    {
        return FRCE_ON & (1u << 12u);
    }

    /**
     * Set FRCE_ON's xip bit.
     */
    inline void set_FRCE_ON_xip() volatile
    {
        FRCE_ON |= 1u << 12u;
    }

    /**
     * Clear FRCE_ON's xip bit.
     */
    inline void clear_FRCE_ON_xip() volatile
    {
        FRCE_ON &= ~(1u << 12u);
    }

    /**
     * Toggle FRCE_ON's xip bit.
     */
    inline void toggle_FRCE_ON_xip() volatile
    {
        FRCE_ON ^= 1u << 12u;
    }

    /**
     * Get FRCE_ON's vreg_and_chip_reset bit.
     */
    inline bool get_FRCE_ON_vreg_and_chip_reset() volatile
    {
        return FRCE_ON & (1u << 13u);
    }

    /**
     * Set FRCE_ON's vreg_and_chip_reset bit.
     */
    inline void set_FRCE_ON_vreg_and_chip_reset() volatile
    {
        FRCE_ON |= 1u << 13u;
    }

    /**
     * Clear FRCE_ON's vreg_and_chip_reset bit.
     */
    inline void clear_FRCE_ON_vreg_and_chip_reset() volatile
    {
        FRCE_ON &= ~(1u << 13u);
    }

    /**
     * Toggle FRCE_ON's vreg_and_chip_reset bit.
     */
    inline void toggle_FRCE_ON_vreg_and_chip_reset() volatile
    {
        FRCE_ON ^= 1u << 13u;
    }

    /**
     * Get FRCE_ON's sio bit.
     */
    inline bool get_FRCE_ON_sio() volatile
    {
        return FRCE_ON & (1u << 14u);
    }

    /**
     * Set FRCE_ON's sio bit.
     */
    inline void set_FRCE_ON_sio() volatile
    {
        FRCE_ON |= 1u << 14u;
    }

    /**
     * Clear FRCE_ON's sio bit.
     */
    inline void clear_FRCE_ON_sio() volatile
    {
        FRCE_ON &= ~(1u << 14u);
    }

    /**
     * Toggle FRCE_ON's sio bit.
     */
    inline void toggle_FRCE_ON_sio() volatile
    {
        FRCE_ON ^= 1u << 14u;
    }

    /**
     * Get FRCE_ON's proc0 bit.
     */
    inline bool get_FRCE_ON_proc0() volatile
    {
        return FRCE_ON & (1u << 15u);
    }

    /**
     * Set FRCE_ON's proc0 bit.
     */
    inline void set_FRCE_ON_proc0() volatile
    {
        FRCE_ON |= 1u << 15u;
    }

    /**
     * Clear FRCE_ON's proc0 bit.
     */
    inline void clear_FRCE_ON_proc0() volatile
    {
        FRCE_ON &= ~(1u << 15u);
    }

    /**
     * Toggle FRCE_ON's proc0 bit.
     */
    inline void toggle_FRCE_ON_proc0() volatile
    {
        FRCE_ON ^= 1u << 15u;
    }

    /**
     * Get FRCE_ON's proc1 bit.
     */
    inline bool get_FRCE_ON_proc1() volatile
    {
        return FRCE_ON & (1u << 16u);
    }

    /**
     * Set FRCE_ON's proc1 bit.
     */
    inline void set_FRCE_ON_proc1() volatile
    {
        FRCE_ON |= 1u << 16u;
    }

    /**
     * Clear FRCE_ON's proc1 bit.
     */
    inline void clear_FRCE_ON_proc1() volatile
    {
        FRCE_ON &= ~(1u << 16u);
    }

    /**
     * Toggle FRCE_ON's proc1 bit.
     */
    inline void toggle_FRCE_ON_proc1() volatile
    {
        FRCE_ON ^= 1u << 16u;
    }

    /**
     * Get all of FRCE_ON's bit fields.
     *
     * (read-write) Force block out of reset (i.e. power it on)
     */
    inline void get_FRCE_ON(bool &rosc, bool &xosc, bool &clocks, bool &resets,
                            bool &busfabric, bool &rom, bool &sram0,
                            bool &sram1, bool &sram2, bool &sram3, bool &sram4,
                            bool &sram5, bool &xip, bool &vreg_and_chip_reset,
                            bool &sio, bool &proc0, bool &proc1) volatile
    {
        uint32_t curr = FRCE_ON;

        rosc = curr & (1u << 0u);
        xosc = curr & (1u << 1u);
        clocks = curr & (1u << 2u);
        resets = curr & (1u << 3u);
        busfabric = curr & (1u << 4u);
        rom = curr & (1u << 5u);
        sram0 = curr & (1u << 6u);
        sram1 = curr & (1u << 7u);
        sram2 = curr & (1u << 8u);
        sram3 = curr & (1u << 9u);
        sram4 = curr & (1u << 10u);
        sram5 = curr & (1u << 11u);
        xip = curr & (1u << 12u);
        vreg_and_chip_reset = curr & (1u << 13u);
        sio = curr & (1u << 14u);
        proc0 = curr & (1u << 15u);
        proc1 = curr & (1u << 16u);
    }

    /**
     * Set all of FRCE_ON's bit fields.
     *
     * (read-write) Force block out of reset (i.e. power it on)
     */
    inline void set_FRCE_ON(bool rosc, bool xosc, bool clocks, bool resets,
                            bool busfabric, bool rom, bool sram0, bool sram1,
                            bool sram2, bool sram3, bool sram4, bool sram5,
                            bool xip, bool vreg_and_chip_reset, bool sio,
                            bool proc0, bool proc1) volatile
    {
        uint32_t curr = FRCE_ON;

        curr &= ~(0b1u << 0u);
        curr |= (rosc & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (xosc & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clocks & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (resets & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (busfabric & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (rom & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (sram0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (sram1 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (sram2 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (sram3 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (sram4 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (sram5 & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (xip & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (vreg_and_chip_reset & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (sio & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (proc0 & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (proc1 & 0b1u) << 16u;

        FRCE_ON = curr;
    }

    /**
     * Get FRCE_OFF's rosc bit.
     */
    inline bool get_FRCE_OFF_rosc() volatile
    {
        return FRCE_OFF & (1u << 0u);
    }

    /**
     * Set FRCE_OFF's rosc bit.
     */
    inline void set_FRCE_OFF_rosc() volatile
    {
        FRCE_OFF |= 1u << 0u;
    }

    /**
     * Clear FRCE_OFF's rosc bit.
     */
    inline void clear_FRCE_OFF_rosc() volatile
    {
        FRCE_OFF &= ~(1u << 0u);
    }

    /**
     * Toggle FRCE_OFF's rosc bit.
     */
    inline void toggle_FRCE_OFF_rosc() volatile
    {
        FRCE_OFF ^= 1u << 0u;
    }

    /**
     * Get FRCE_OFF's xosc bit.
     */
    inline bool get_FRCE_OFF_xosc() volatile
    {
        return FRCE_OFF & (1u << 1u);
    }

    /**
     * Set FRCE_OFF's xosc bit.
     */
    inline void set_FRCE_OFF_xosc() volatile
    {
        FRCE_OFF |= 1u << 1u;
    }

    /**
     * Clear FRCE_OFF's xosc bit.
     */
    inline void clear_FRCE_OFF_xosc() volatile
    {
        FRCE_OFF &= ~(1u << 1u);
    }

    /**
     * Toggle FRCE_OFF's xosc bit.
     */
    inline void toggle_FRCE_OFF_xosc() volatile
    {
        FRCE_OFF ^= 1u << 1u;
    }

    /**
     * Get FRCE_OFF's clocks bit.
     */
    inline bool get_FRCE_OFF_clocks() volatile
    {
        return FRCE_OFF & (1u << 2u);
    }

    /**
     * Set FRCE_OFF's clocks bit.
     */
    inline void set_FRCE_OFF_clocks() volatile
    {
        FRCE_OFF |= 1u << 2u;
    }

    /**
     * Clear FRCE_OFF's clocks bit.
     */
    inline void clear_FRCE_OFF_clocks() volatile
    {
        FRCE_OFF &= ~(1u << 2u);
    }

    /**
     * Toggle FRCE_OFF's clocks bit.
     */
    inline void toggle_FRCE_OFF_clocks() volatile
    {
        FRCE_OFF ^= 1u << 2u;
    }

    /**
     * Get FRCE_OFF's resets bit.
     */
    inline bool get_FRCE_OFF_resets() volatile
    {
        return FRCE_OFF & (1u << 3u);
    }

    /**
     * Set FRCE_OFF's resets bit.
     */
    inline void set_FRCE_OFF_resets() volatile
    {
        FRCE_OFF |= 1u << 3u;
    }

    /**
     * Clear FRCE_OFF's resets bit.
     */
    inline void clear_FRCE_OFF_resets() volatile
    {
        FRCE_OFF &= ~(1u << 3u);
    }

    /**
     * Toggle FRCE_OFF's resets bit.
     */
    inline void toggle_FRCE_OFF_resets() volatile
    {
        FRCE_OFF ^= 1u << 3u;
    }

    /**
     * Get FRCE_OFF's busfabric bit.
     */
    inline bool get_FRCE_OFF_busfabric() volatile
    {
        return FRCE_OFF & (1u << 4u);
    }

    /**
     * Set FRCE_OFF's busfabric bit.
     */
    inline void set_FRCE_OFF_busfabric() volatile
    {
        FRCE_OFF |= 1u << 4u;
    }

    /**
     * Clear FRCE_OFF's busfabric bit.
     */
    inline void clear_FRCE_OFF_busfabric() volatile
    {
        FRCE_OFF &= ~(1u << 4u);
    }

    /**
     * Toggle FRCE_OFF's busfabric bit.
     */
    inline void toggle_FRCE_OFF_busfabric() volatile
    {
        FRCE_OFF ^= 1u << 4u;
    }

    /**
     * Get FRCE_OFF's rom bit.
     */
    inline bool get_FRCE_OFF_rom() volatile
    {
        return FRCE_OFF & (1u << 5u);
    }

    /**
     * Set FRCE_OFF's rom bit.
     */
    inline void set_FRCE_OFF_rom() volatile
    {
        FRCE_OFF |= 1u << 5u;
    }

    /**
     * Clear FRCE_OFF's rom bit.
     */
    inline void clear_FRCE_OFF_rom() volatile
    {
        FRCE_OFF &= ~(1u << 5u);
    }

    /**
     * Toggle FRCE_OFF's rom bit.
     */
    inline void toggle_FRCE_OFF_rom() volatile
    {
        FRCE_OFF ^= 1u << 5u;
    }

    /**
     * Get FRCE_OFF's sram0 bit.
     */
    inline bool get_FRCE_OFF_sram0() volatile
    {
        return FRCE_OFF & (1u << 6u);
    }

    /**
     * Set FRCE_OFF's sram0 bit.
     */
    inline void set_FRCE_OFF_sram0() volatile
    {
        FRCE_OFF |= 1u << 6u;
    }

    /**
     * Clear FRCE_OFF's sram0 bit.
     */
    inline void clear_FRCE_OFF_sram0() volatile
    {
        FRCE_OFF &= ~(1u << 6u);
    }

    /**
     * Toggle FRCE_OFF's sram0 bit.
     */
    inline void toggle_FRCE_OFF_sram0() volatile
    {
        FRCE_OFF ^= 1u << 6u;
    }

    /**
     * Get FRCE_OFF's sram1 bit.
     */
    inline bool get_FRCE_OFF_sram1() volatile
    {
        return FRCE_OFF & (1u << 7u);
    }

    /**
     * Set FRCE_OFF's sram1 bit.
     */
    inline void set_FRCE_OFF_sram1() volatile
    {
        FRCE_OFF |= 1u << 7u;
    }

    /**
     * Clear FRCE_OFF's sram1 bit.
     */
    inline void clear_FRCE_OFF_sram1() volatile
    {
        FRCE_OFF &= ~(1u << 7u);
    }

    /**
     * Toggle FRCE_OFF's sram1 bit.
     */
    inline void toggle_FRCE_OFF_sram1() volatile
    {
        FRCE_OFF ^= 1u << 7u;
    }

    /**
     * Get FRCE_OFF's sram2 bit.
     */
    inline bool get_FRCE_OFF_sram2() volatile
    {
        return FRCE_OFF & (1u << 8u);
    }

    /**
     * Set FRCE_OFF's sram2 bit.
     */
    inline void set_FRCE_OFF_sram2() volatile
    {
        FRCE_OFF |= 1u << 8u;
    }

    /**
     * Clear FRCE_OFF's sram2 bit.
     */
    inline void clear_FRCE_OFF_sram2() volatile
    {
        FRCE_OFF &= ~(1u << 8u);
    }

    /**
     * Toggle FRCE_OFF's sram2 bit.
     */
    inline void toggle_FRCE_OFF_sram2() volatile
    {
        FRCE_OFF ^= 1u << 8u;
    }

    /**
     * Get FRCE_OFF's sram3 bit.
     */
    inline bool get_FRCE_OFF_sram3() volatile
    {
        return FRCE_OFF & (1u << 9u);
    }

    /**
     * Set FRCE_OFF's sram3 bit.
     */
    inline void set_FRCE_OFF_sram3() volatile
    {
        FRCE_OFF |= 1u << 9u;
    }

    /**
     * Clear FRCE_OFF's sram3 bit.
     */
    inline void clear_FRCE_OFF_sram3() volatile
    {
        FRCE_OFF &= ~(1u << 9u);
    }

    /**
     * Toggle FRCE_OFF's sram3 bit.
     */
    inline void toggle_FRCE_OFF_sram3() volatile
    {
        FRCE_OFF ^= 1u << 9u;
    }

    /**
     * Get FRCE_OFF's sram4 bit.
     */
    inline bool get_FRCE_OFF_sram4() volatile
    {
        return FRCE_OFF & (1u << 10u);
    }

    /**
     * Set FRCE_OFF's sram4 bit.
     */
    inline void set_FRCE_OFF_sram4() volatile
    {
        FRCE_OFF |= 1u << 10u;
    }

    /**
     * Clear FRCE_OFF's sram4 bit.
     */
    inline void clear_FRCE_OFF_sram4() volatile
    {
        FRCE_OFF &= ~(1u << 10u);
    }

    /**
     * Toggle FRCE_OFF's sram4 bit.
     */
    inline void toggle_FRCE_OFF_sram4() volatile
    {
        FRCE_OFF ^= 1u << 10u;
    }

    /**
     * Get FRCE_OFF's sram5 bit.
     */
    inline bool get_FRCE_OFF_sram5() volatile
    {
        return FRCE_OFF & (1u << 11u);
    }

    /**
     * Set FRCE_OFF's sram5 bit.
     */
    inline void set_FRCE_OFF_sram5() volatile
    {
        FRCE_OFF |= 1u << 11u;
    }

    /**
     * Clear FRCE_OFF's sram5 bit.
     */
    inline void clear_FRCE_OFF_sram5() volatile
    {
        FRCE_OFF &= ~(1u << 11u);
    }

    /**
     * Toggle FRCE_OFF's sram5 bit.
     */
    inline void toggle_FRCE_OFF_sram5() volatile
    {
        FRCE_OFF ^= 1u << 11u;
    }

    /**
     * Get FRCE_OFF's xip bit.
     */
    inline bool get_FRCE_OFF_xip() volatile
    {
        return FRCE_OFF & (1u << 12u);
    }

    /**
     * Set FRCE_OFF's xip bit.
     */
    inline void set_FRCE_OFF_xip() volatile
    {
        FRCE_OFF |= 1u << 12u;
    }

    /**
     * Clear FRCE_OFF's xip bit.
     */
    inline void clear_FRCE_OFF_xip() volatile
    {
        FRCE_OFF &= ~(1u << 12u);
    }

    /**
     * Toggle FRCE_OFF's xip bit.
     */
    inline void toggle_FRCE_OFF_xip() volatile
    {
        FRCE_OFF ^= 1u << 12u;
    }

    /**
     * Get FRCE_OFF's vreg_and_chip_reset bit.
     */
    inline bool get_FRCE_OFF_vreg_and_chip_reset() volatile
    {
        return FRCE_OFF & (1u << 13u);
    }

    /**
     * Set FRCE_OFF's vreg_and_chip_reset bit.
     */
    inline void set_FRCE_OFF_vreg_and_chip_reset() volatile
    {
        FRCE_OFF |= 1u << 13u;
    }

    /**
     * Clear FRCE_OFF's vreg_and_chip_reset bit.
     */
    inline void clear_FRCE_OFF_vreg_and_chip_reset() volatile
    {
        FRCE_OFF &= ~(1u << 13u);
    }

    /**
     * Toggle FRCE_OFF's vreg_and_chip_reset bit.
     */
    inline void toggle_FRCE_OFF_vreg_and_chip_reset() volatile
    {
        FRCE_OFF ^= 1u << 13u;
    }

    /**
     * Get FRCE_OFF's sio bit.
     */
    inline bool get_FRCE_OFF_sio() volatile
    {
        return FRCE_OFF & (1u << 14u);
    }

    /**
     * Set FRCE_OFF's sio bit.
     */
    inline void set_FRCE_OFF_sio() volatile
    {
        FRCE_OFF |= 1u << 14u;
    }

    /**
     * Clear FRCE_OFF's sio bit.
     */
    inline void clear_FRCE_OFF_sio() volatile
    {
        FRCE_OFF &= ~(1u << 14u);
    }

    /**
     * Toggle FRCE_OFF's sio bit.
     */
    inline void toggle_FRCE_OFF_sio() volatile
    {
        FRCE_OFF ^= 1u << 14u;
    }

    /**
     * Get FRCE_OFF's proc0 bit.
     */
    inline bool get_FRCE_OFF_proc0() volatile
    {
        return FRCE_OFF & (1u << 15u);
    }

    /**
     * Set FRCE_OFF's proc0 bit.
     */
    inline void set_FRCE_OFF_proc0() volatile
    {
        FRCE_OFF |= 1u << 15u;
    }

    /**
     * Clear FRCE_OFF's proc0 bit.
     */
    inline void clear_FRCE_OFF_proc0() volatile
    {
        FRCE_OFF &= ~(1u << 15u);
    }

    /**
     * Toggle FRCE_OFF's proc0 bit.
     */
    inline void toggle_FRCE_OFF_proc0() volatile
    {
        FRCE_OFF ^= 1u << 15u;
    }

    /**
     * Get FRCE_OFF's proc1 bit.
     */
    inline bool get_FRCE_OFF_proc1() volatile
    {
        return FRCE_OFF & (1u << 16u);
    }

    /**
     * Set FRCE_OFF's proc1 bit.
     */
    inline void set_FRCE_OFF_proc1() volatile
    {
        FRCE_OFF |= 1u << 16u;
    }

    /**
     * Clear FRCE_OFF's proc1 bit.
     */
    inline void clear_FRCE_OFF_proc1() volatile
    {
        FRCE_OFF &= ~(1u << 16u);
    }

    /**
     * Toggle FRCE_OFF's proc1 bit.
     */
    inline void toggle_FRCE_OFF_proc1() volatile
    {
        FRCE_OFF ^= 1u << 16u;
    }

    /**
     * Get all of FRCE_OFF's bit fields.
     *
     * (read-write) Force into reset (i.e. power it off)
     */
    inline void get_FRCE_OFF(bool &rosc, bool &xosc, bool &clocks,
                             bool &resets, bool &busfabric, bool &rom,
                             bool &sram0, bool &sram1, bool &sram2,
                             bool &sram3, bool &sram4, bool &sram5, bool &xip,
                             bool &vreg_and_chip_reset, bool &sio, bool &proc0,
                             bool &proc1) volatile
    {
        uint32_t curr = FRCE_OFF;

        rosc = curr & (1u << 0u);
        xosc = curr & (1u << 1u);
        clocks = curr & (1u << 2u);
        resets = curr & (1u << 3u);
        busfabric = curr & (1u << 4u);
        rom = curr & (1u << 5u);
        sram0 = curr & (1u << 6u);
        sram1 = curr & (1u << 7u);
        sram2 = curr & (1u << 8u);
        sram3 = curr & (1u << 9u);
        sram4 = curr & (1u << 10u);
        sram5 = curr & (1u << 11u);
        xip = curr & (1u << 12u);
        vreg_and_chip_reset = curr & (1u << 13u);
        sio = curr & (1u << 14u);
        proc0 = curr & (1u << 15u);
        proc1 = curr & (1u << 16u);
    }

    /**
     * Set all of FRCE_OFF's bit fields.
     *
     * (read-write) Force into reset (i.e. power it off)
     */
    inline void set_FRCE_OFF(bool rosc, bool xosc, bool clocks, bool resets,
                             bool busfabric, bool rom, bool sram0, bool sram1,
                             bool sram2, bool sram3, bool sram4, bool sram5,
                             bool xip, bool vreg_and_chip_reset, bool sio,
                             bool proc0, bool proc1) volatile
    {
        uint32_t curr = FRCE_OFF;

        curr &= ~(0b1u << 0u);
        curr |= (rosc & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (xosc & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clocks & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (resets & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (busfabric & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (rom & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (sram0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (sram1 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (sram2 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (sram3 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (sram4 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (sram5 & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (xip & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (vreg_and_chip_reset & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (sio & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (proc0 & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (proc1 & 0b1u) << 16u;

        FRCE_OFF = curr;
    }

    /**
     * Get WDSEL's rosc bit.
     */
    inline bool get_WDSEL_rosc() volatile
    {
        return WDSEL & (1u << 0u);
    }

    /**
     * Set WDSEL's rosc bit.
     */
    inline void set_WDSEL_rosc() volatile
    {
        WDSEL |= 1u << 0u;
    }

    /**
     * Clear WDSEL's rosc bit.
     */
    inline void clear_WDSEL_rosc() volatile
    {
        WDSEL &= ~(1u << 0u);
    }

    /**
     * Toggle WDSEL's rosc bit.
     */
    inline void toggle_WDSEL_rosc() volatile
    {
        WDSEL ^= 1u << 0u;
    }

    /**
     * Get WDSEL's xosc bit.
     */
    inline bool get_WDSEL_xosc() volatile
    {
        return WDSEL & (1u << 1u);
    }

    /**
     * Set WDSEL's xosc bit.
     */
    inline void set_WDSEL_xosc() volatile
    {
        WDSEL |= 1u << 1u;
    }

    /**
     * Clear WDSEL's xosc bit.
     */
    inline void clear_WDSEL_xosc() volatile
    {
        WDSEL &= ~(1u << 1u);
    }

    /**
     * Toggle WDSEL's xosc bit.
     */
    inline void toggle_WDSEL_xosc() volatile
    {
        WDSEL ^= 1u << 1u;
    }

    /**
     * Get WDSEL's clocks bit.
     */
    inline bool get_WDSEL_clocks() volatile
    {
        return WDSEL & (1u << 2u);
    }

    /**
     * Set WDSEL's clocks bit.
     */
    inline void set_WDSEL_clocks() volatile
    {
        WDSEL |= 1u << 2u;
    }

    /**
     * Clear WDSEL's clocks bit.
     */
    inline void clear_WDSEL_clocks() volatile
    {
        WDSEL &= ~(1u << 2u);
    }

    /**
     * Toggle WDSEL's clocks bit.
     */
    inline void toggle_WDSEL_clocks() volatile
    {
        WDSEL ^= 1u << 2u;
    }

    /**
     * Get WDSEL's resets bit.
     */
    inline bool get_WDSEL_resets() volatile
    {
        return WDSEL & (1u << 3u);
    }

    /**
     * Set WDSEL's resets bit.
     */
    inline void set_WDSEL_resets() volatile
    {
        WDSEL |= 1u << 3u;
    }

    /**
     * Clear WDSEL's resets bit.
     */
    inline void clear_WDSEL_resets() volatile
    {
        WDSEL &= ~(1u << 3u);
    }

    /**
     * Toggle WDSEL's resets bit.
     */
    inline void toggle_WDSEL_resets() volatile
    {
        WDSEL ^= 1u << 3u;
    }

    /**
     * Get WDSEL's busfabric bit.
     */
    inline bool get_WDSEL_busfabric() volatile
    {
        return WDSEL & (1u << 4u);
    }

    /**
     * Set WDSEL's busfabric bit.
     */
    inline void set_WDSEL_busfabric() volatile
    {
        WDSEL |= 1u << 4u;
    }

    /**
     * Clear WDSEL's busfabric bit.
     */
    inline void clear_WDSEL_busfabric() volatile
    {
        WDSEL &= ~(1u << 4u);
    }

    /**
     * Toggle WDSEL's busfabric bit.
     */
    inline void toggle_WDSEL_busfabric() volatile
    {
        WDSEL ^= 1u << 4u;
    }

    /**
     * Get WDSEL's rom bit.
     */
    inline bool get_WDSEL_rom() volatile
    {
        return WDSEL & (1u << 5u);
    }

    /**
     * Set WDSEL's rom bit.
     */
    inline void set_WDSEL_rom() volatile
    {
        WDSEL |= 1u << 5u;
    }

    /**
     * Clear WDSEL's rom bit.
     */
    inline void clear_WDSEL_rom() volatile
    {
        WDSEL &= ~(1u << 5u);
    }

    /**
     * Toggle WDSEL's rom bit.
     */
    inline void toggle_WDSEL_rom() volatile
    {
        WDSEL ^= 1u << 5u;
    }

    /**
     * Get WDSEL's sram0 bit.
     */
    inline bool get_WDSEL_sram0() volatile
    {
        return WDSEL & (1u << 6u);
    }

    /**
     * Set WDSEL's sram0 bit.
     */
    inline void set_WDSEL_sram0() volatile
    {
        WDSEL |= 1u << 6u;
    }

    /**
     * Clear WDSEL's sram0 bit.
     */
    inline void clear_WDSEL_sram0() volatile
    {
        WDSEL &= ~(1u << 6u);
    }

    /**
     * Toggle WDSEL's sram0 bit.
     */
    inline void toggle_WDSEL_sram0() volatile
    {
        WDSEL ^= 1u << 6u;
    }

    /**
     * Get WDSEL's sram1 bit.
     */
    inline bool get_WDSEL_sram1() volatile
    {
        return WDSEL & (1u << 7u);
    }

    /**
     * Set WDSEL's sram1 bit.
     */
    inline void set_WDSEL_sram1() volatile
    {
        WDSEL |= 1u << 7u;
    }

    /**
     * Clear WDSEL's sram1 bit.
     */
    inline void clear_WDSEL_sram1() volatile
    {
        WDSEL &= ~(1u << 7u);
    }

    /**
     * Toggle WDSEL's sram1 bit.
     */
    inline void toggle_WDSEL_sram1() volatile
    {
        WDSEL ^= 1u << 7u;
    }

    /**
     * Get WDSEL's sram2 bit.
     */
    inline bool get_WDSEL_sram2() volatile
    {
        return WDSEL & (1u << 8u);
    }

    /**
     * Set WDSEL's sram2 bit.
     */
    inline void set_WDSEL_sram2() volatile
    {
        WDSEL |= 1u << 8u;
    }

    /**
     * Clear WDSEL's sram2 bit.
     */
    inline void clear_WDSEL_sram2() volatile
    {
        WDSEL &= ~(1u << 8u);
    }

    /**
     * Toggle WDSEL's sram2 bit.
     */
    inline void toggle_WDSEL_sram2() volatile
    {
        WDSEL ^= 1u << 8u;
    }

    /**
     * Get WDSEL's sram3 bit.
     */
    inline bool get_WDSEL_sram3() volatile
    {
        return WDSEL & (1u << 9u);
    }

    /**
     * Set WDSEL's sram3 bit.
     */
    inline void set_WDSEL_sram3() volatile
    {
        WDSEL |= 1u << 9u;
    }

    /**
     * Clear WDSEL's sram3 bit.
     */
    inline void clear_WDSEL_sram3() volatile
    {
        WDSEL &= ~(1u << 9u);
    }

    /**
     * Toggle WDSEL's sram3 bit.
     */
    inline void toggle_WDSEL_sram3() volatile
    {
        WDSEL ^= 1u << 9u;
    }

    /**
     * Get WDSEL's sram4 bit.
     */
    inline bool get_WDSEL_sram4() volatile
    {
        return WDSEL & (1u << 10u);
    }

    /**
     * Set WDSEL's sram4 bit.
     */
    inline void set_WDSEL_sram4() volatile
    {
        WDSEL |= 1u << 10u;
    }

    /**
     * Clear WDSEL's sram4 bit.
     */
    inline void clear_WDSEL_sram4() volatile
    {
        WDSEL &= ~(1u << 10u);
    }

    /**
     * Toggle WDSEL's sram4 bit.
     */
    inline void toggle_WDSEL_sram4() volatile
    {
        WDSEL ^= 1u << 10u;
    }

    /**
     * Get WDSEL's sram5 bit.
     */
    inline bool get_WDSEL_sram5() volatile
    {
        return WDSEL & (1u << 11u);
    }

    /**
     * Set WDSEL's sram5 bit.
     */
    inline void set_WDSEL_sram5() volatile
    {
        WDSEL |= 1u << 11u;
    }

    /**
     * Clear WDSEL's sram5 bit.
     */
    inline void clear_WDSEL_sram5() volatile
    {
        WDSEL &= ~(1u << 11u);
    }

    /**
     * Toggle WDSEL's sram5 bit.
     */
    inline void toggle_WDSEL_sram5() volatile
    {
        WDSEL ^= 1u << 11u;
    }

    /**
     * Get WDSEL's xip bit.
     */
    inline bool get_WDSEL_xip() volatile
    {
        return WDSEL & (1u << 12u);
    }

    /**
     * Set WDSEL's xip bit.
     */
    inline void set_WDSEL_xip() volatile
    {
        WDSEL |= 1u << 12u;
    }

    /**
     * Clear WDSEL's xip bit.
     */
    inline void clear_WDSEL_xip() volatile
    {
        WDSEL &= ~(1u << 12u);
    }

    /**
     * Toggle WDSEL's xip bit.
     */
    inline void toggle_WDSEL_xip() volatile
    {
        WDSEL ^= 1u << 12u;
    }

    /**
     * Get WDSEL's vreg_and_chip_reset bit.
     */
    inline bool get_WDSEL_vreg_and_chip_reset() volatile
    {
        return WDSEL & (1u << 13u);
    }

    /**
     * Set WDSEL's vreg_and_chip_reset bit.
     */
    inline void set_WDSEL_vreg_and_chip_reset() volatile
    {
        WDSEL |= 1u << 13u;
    }

    /**
     * Clear WDSEL's vreg_and_chip_reset bit.
     */
    inline void clear_WDSEL_vreg_and_chip_reset() volatile
    {
        WDSEL &= ~(1u << 13u);
    }

    /**
     * Toggle WDSEL's vreg_and_chip_reset bit.
     */
    inline void toggle_WDSEL_vreg_and_chip_reset() volatile
    {
        WDSEL ^= 1u << 13u;
    }

    /**
     * Get WDSEL's sio bit.
     */
    inline bool get_WDSEL_sio() volatile
    {
        return WDSEL & (1u << 14u);
    }

    /**
     * Set WDSEL's sio bit.
     */
    inline void set_WDSEL_sio() volatile
    {
        WDSEL |= 1u << 14u;
    }

    /**
     * Clear WDSEL's sio bit.
     */
    inline void clear_WDSEL_sio() volatile
    {
        WDSEL &= ~(1u << 14u);
    }

    /**
     * Toggle WDSEL's sio bit.
     */
    inline void toggle_WDSEL_sio() volatile
    {
        WDSEL ^= 1u << 14u;
    }

    /**
     * Get WDSEL's proc0 bit.
     */
    inline bool get_WDSEL_proc0() volatile
    {
        return WDSEL & (1u << 15u);
    }

    /**
     * Set WDSEL's proc0 bit.
     */
    inline void set_WDSEL_proc0() volatile
    {
        WDSEL |= 1u << 15u;
    }

    /**
     * Clear WDSEL's proc0 bit.
     */
    inline void clear_WDSEL_proc0() volatile
    {
        WDSEL &= ~(1u << 15u);
    }

    /**
     * Toggle WDSEL's proc0 bit.
     */
    inline void toggle_WDSEL_proc0() volatile
    {
        WDSEL ^= 1u << 15u;
    }

    /**
     * Get WDSEL's proc1 bit.
     */
    inline bool get_WDSEL_proc1() volatile
    {
        return WDSEL & (1u << 16u);
    }

    /**
     * Set WDSEL's proc1 bit.
     */
    inline void set_WDSEL_proc1() volatile
    {
        WDSEL |= 1u << 16u;
    }

    /**
     * Clear WDSEL's proc1 bit.
     */
    inline void clear_WDSEL_proc1() volatile
    {
        WDSEL &= ~(1u << 16u);
    }

    /**
     * Toggle WDSEL's proc1 bit.
     */
    inline void toggle_WDSEL_proc1() volatile
    {
        WDSEL ^= 1u << 16u;
    }

    /**
     * Get all of WDSEL's bit fields.
     *
     * (read-write) Set to 1 if this peripheral should be reset when the
     * watchdog fires.
     */
    inline void get_WDSEL(bool &rosc, bool &xosc, bool &clocks, bool &resets,
                          bool &busfabric, bool &rom, bool &sram0, bool &sram1,
                          bool &sram2, bool &sram3, bool &sram4, bool &sram5,
                          bool &xip, bool &vreg_and_chip_reset, bool &sio,
                          bool &proc0, bool &proc1) volatile
    {
        uint32_t curr = WDSEL;

        rosc = curr & (1u << 0u);
        xosc = curr & (1u << 1u);
        clocks = curr & (1u << 2u);
        resets = curr & (1u << 3u);
        busfabric = curr & (1u << 4u);
        rom = curr & (1u << 5u);
        sram0 = curr & (1u << 6u);
        sram1 = curr & (1u << 7u);
        sram2 = curr & (1u << 8u);
        sram3 = curr & (1u << 9u);
        sram4 = curr & (1u << 10u);
        sram5 = curr & (1u << 11u);
        xip = curr & (1u << 12u);
        vreg_and_chip_reset = curr & (1u << 13u);
        sio = curr & (1u << 14u);
        proc0 = curr & (1u << 15u);
        proc1 = curr & (1u << 16u);
    }

    /**
     * Set all of WDSEL's bit fields.
     *
     * (read-write) Set to 1 if this peripheral should be reset when the
     * watchdog fires.
     */
    inline void set_WDSEL(bool rosc, bool xosc, bool clocks, bool resets,
                          bool busfabric, bool rom, bool sram0, bool sram1,
                          bool sram2, bool sram3, bool sram4, bool sram5,
                          bool xip, bool vreg_and_chip_reset, bool sio,
                          bool proc0, bool proc1) volatile
    {
        uint32_t curr = WDSEL;

        curr &= ~(0b1u << 0u);
        curr |= (rosc & 0b1u) << 0u;
        curr &= ~(0b1u << 1u);
        curr |= (xosc & 0b1u) << 1u;
        curr &= ~(0b1u << 2u);
        curr |= (clocks & 0b1u) << 2u;
        curr &= ~(0b1u << 3u);
        curr |= (resets & 0b1u) << 3u;
        curr &= ~(0b1u << 4u);
        curr |= (busfabric & 0b1u) << 4u;
        curr &= ~(0b1u << 5u);
        curr |= (rom & 0b1u) << 5u;
        curr &= ~(0b1u << 6u);
        curr |= (sram0 & 0b1u) << 6u;
        curr &= ~(0b1u << 7u);
        curr |= (sram1 & 0b1u) << 7u;
        curr &= ~(0b1u << 8u);
        curr |= (sram2 & 0b1u) << 8u;
        curr &= ~(0b1u << 9u);
        curr |= (sram3 & 0b1u) << 9u;
        curr &= ~(0b1u << 10u);
        curr |= (sram4 & 0b1u) << 10u;
        curr &= ~(0b1u << 11u);
        curr |= (sram5 & 0b1u) << 11u;
        curr &= ~(0b1u << 12u);
        curr |= (xip & 0b1u) << 12u;
        curr &= ~(0b1u << 13u);
        curr |= (vreg_and_chip_reset & 0b1u) << 13u;
        curr &= ~(0b1u << 14u);
        curr |= (sio & 0b1u) << 14u;
        curr &= ~(0b1u << 15u);
        curr |= (proc0 & 0b1u) << 15u;
        curr &= ~(0b1u << 16u);
        curr |= (proc1 & 0b1u) << 16u;

        WDSEL = curr;
    }

    /**
     * Get DONE's rosc bit.
     */
    inline bool get_DONE_rosc() volatile
    {
        return DONE & (1u << 0u);
    }

    /**
     * Get DONE's xosc bit.
     */
    inline bool get_DONE_xosc() volatile
    {
        return DONE & (1u << 1u);
    }

    /**
     * Get DONE's clocks bit.
     */
    inline bool get_DONE_clocks() volatile
    {
        return DONE & (1u << 2u);
    }

    /**
     * Get DONE's resets bit.
     */
    inline bool get_DONE_resets() volatile
    {
        return DONE & (1u << 3u);
    }

    /**
     * Get DONE's busfabric bit.
     */
    inline bool get_DONE_busfabric() volatile
    {
        return DONE & (1u << 4u);
    }

    /**
     * Get DONE's rom bit.
     */
    inline bool get_DONE_rom() volatile
    {
        return DONE & (1u << 5u);
    }

    /**
     * Get DONE's sram0 bit.
     */
    inline bool get_DONE_sram0() volatile
    {
        return DONE & (1u << 6u);
    }

    /**
     * Get DONE's sram1 bit.
     */
    inline bool get_DONE_sram1() volatile
    {
        return DONE & (1u << 7u);
    }

    /**
     * Get DONE's sram2 bit.
     */
    inline bool get_DONE_sram2() volatile
    {
        return DONE & (1u << 8u);
    }

    /**
     * Get DONE's sram3 bit.
     */
    inline bool get_DONE_sram3() volatile
    {
        return DONE & (1u << 9u);
    }

    /**
     * Get DONE's sram4 bit.
     */
    inline bool get_DONE_sram4() volatile
    {
        return DONE & (1u << 10u);
    }

    /**
     * Get DONE's sram5 bit.
     */
    inline bool get_DONE_sram5() volatile
    {
        return DONE & (1u << 11u);
    }

    /**
     * Get DONE's xip bit.
     */
    inline bool get_DONE_xip() volatile
    {
        return DONE & (1u << 12u);
    }

    /**
     * Get DONE's vreg_and_chip_reset bit.
     */
    inline bool get_DONE_vreg_and_chip_reset() volatile
    {
        return DONE & (1u << 13u);
    }

    /**
     * Get DONE's sio bit.
     */
    inline bool get_DONE_sio() volatile
    {
        return DONE & (1u << 14u);
    }

    /**
     * Get DONE's proc0 bit.
     */
    inline bool get_DONE_proc0() volatile
    {
        return DONE & (1u << 15u);
    }

    /**
     * Get DONE's proc1 bit.
     */
    inline bool get_DONE_proc1() volatile
    {
        return DONE & (1u << 16u);
    }

    /**
     * Get all of DONE's bit fields.
     *
     * (read-only) Indicates the peripheral's registers are ready to access.
     */
    inline void get_DONE(bool &rosc, bool &xosc, bool &clocks, bool &resets,
                         bool &busfabric, bool &rom, bool &sram0, bool &sram1,
                         bool &sram2, bool &sram3, bool &sram4, bool &sram5,
                         bool &xip, bool &vreg_and_chip_reset, bool &sio,
                         bool &proc0, bool &proc1) volatile
    {
        uint32_t curr = DONE;

        rosc = curr & (1u << 0u);
        xosc = curr & (1u << 1u);
        clocks = curr & (1u << 2u);
        resets = curr & (1u << 3u);
        busfabric = curr & (1u << 4u);
        rom = curr & (1u << 5u);
        sram0 = curr & (1u << 6u);
        sram1 = curr & (1u << 7u);
        sram2 = curr & (1u << 8u);
        sram3 = curr & (1u << 9u);
        sram4 = curr & (1u << 10u);
        sram5 = curr & (1u << 11u);
        xip = curr & (1u << 12u);
        vreg_and_chip_reset = curr & (1u << 13u);
        sio = curr & (1u << 14u);
        proc0 = curr & (1u << 15u);
        proc1 = curr & (1u << 16u);
    }
};

static_assert(sizeof(psm) == psm::size);

static volatile psm *const PSM = reinterpret_cast<psm *>(0x40010000);

}; // namespace RP2040
